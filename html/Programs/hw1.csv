"r04921104","0","0.08","104368","@c8d0a1a352d1b78dbc87ece025cb6cfc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();

        try {
            br = new BufferedReader(new FileReader(args[0]));

            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[][] pairlist = new int[info.size() - 1][2];
        for (int i = 0; i < info.size() - 1; i++) {
            pairlist[i][0] = Integer.parseInt(info.get(i + 1)[0]);
            pairlist[i][1] = Integer.parseInt(info.get(i + 1)[1]);
            //System.out.println(pairlist[i][0]+ "" "" +pairlist[i][1]);
        }

        boolean[][] openloc = new boolean[size][size];
        //System.out.print(openloc[8]);

        UF uf = new UF(size * size);

        search:
        {
            for (int i = 0; i < pairlist.length; i++) {
                openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1)] = true;
                //System.out.println((pairlist[i][0]-1) +"" ""+ (pairlist[i][1]-1));

                try {
                    if (openloc[(pairlist[i][0] - 1) - 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) - 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1) + 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) + 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) - 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) + 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) + 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }

                for (int frc = 0; frc < size; frc++) {
                    if (openloc[0][frc]) {
                        for (int lrc = 0; lrc < size; lrc++) {
                            if (openloc[size - 1][lrc]) {
                                if (uf.connected(frc, (size - 1) * size + lrc)) {
                                    System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                                    break search;
                                }
                            }
                        }
                    }
                }

            }
            System.out.println(-1);
        }

    }

}

@c8d0a1a352d1b78dbc87ece025cb6cfc@"
"r04921104","5","1.39","163200","@48e115ec0dee30bcf52b8cc26b96443e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();

        try {
            br = new BufferedReader(new FileReader(args[0]));

            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[][] pairlist = new int[info.size() - 1][2];
        for (int i = 0; i < info.size() - 1; i++) {
            pairlist[i][0] = Integer.parseInt(info.get(i + 1)[0]);
            pairlist[i][1] = Integer.parseInt(info.get(i + 1)[1]);
            //System.out.println(pairlist[i][0]+ "" "" +pairlist[i][1]);
        }

        boolean[][] openloc = new boolean[size][size];
        //System.out.print(openloc[8]);

        UF uf = new UF(size * size);

        search:
        {
            for (int i = 0; i < pairlist.length; i++) {
                openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1)] = true;
                //System.out.println((pairlist[i][0]-1) +"" ""+ (pairlist[i][1]-1));

                try {
                    if (openloc[(pairlist[i][0] - 1) - 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) - 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1) + 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) + 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) - 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) + 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) + 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }

                for (int frc = 0; frc < size; frc++) {
                    if (openloc[0][frc]) {
                        for (int lrc = 0; lrc < size; lrc++) {
                            if (openloc[size - 1][lrc]) {
                                if (uf.connected(frc, (size - 1) * size + lrc)) {
                                    System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                                    break search;
                                }
                            }
                        }
                    }
                }

            }
        }

    }

}

@48e115ec0dee30bcf52b8cc26b96443e@"
"r04921104","0","0.91","105552","@d57c7c441dcb42127b6fed39207844a3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import edu.princeton.cs.algs4.UF;

public class Percolation {

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();

        try {
            br = new BufferedReader(new FileReader(args[0]));

            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[][] pairlist = new int[info.size() - 1][2];
        for (int i = 0; i < info.size() - 1; i++) {
            pairlist[i][0] = Integer.parseInt(info.get(i + 1)[0]);
            pairlist[i][1] = Integer.parseInt(info.get(i + 1)[1]);
            //System.out.println(pairlist[i][0]+ "" "" +pairlist[i][1]);
        }

        boolean[][] openloc = new boolean[size][size];
        //System.out.print(openloc[8]);

        UF uf = new UF(size * size);

        search:
        {
            for (int i = 0; i < pairlist.length; i++) {
                openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1)] = true;
                //System.out.println((pairlist[i][0]-1) +"" ""+ (pairlist[i][1]-1));

                try {
                    if (openloc[(pairlist[i][0] - 1) - 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) - 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1) + 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) + 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) - 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) + 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) + 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }

                for (int frc = 0; frc < size; frc++) {
                    if (openloc[0][frc]) {
                        for (int lrc = 0; lrc < size; lrc++) {
                            if (openloc[size - 1][lrc]) {
                                if (uf.connected(frc, (size - 1) * size + lrc)) {
                                    System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                                    break search;
                                }
                            }
                        }
                    }
                }

            }
        }

    }

}

@d57c7c441dcb42127b6fed39207844a3@"
"r04447001","9","0.91","121968","@6fca57fbe92ed7f481f76f788feecad4@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author jerry
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){;
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF UF = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        while((data = br.readLine()) != null){
        String[] data2 = data.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0){
            UF.union((x2*N+y2), N*N);// for the top row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }
        }
         else if(x2 == (N-1)){
            UF.union((x2*N+y2), N*N+1);// for the buttom row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }
        }       
         else{
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                
           }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }         
         }
        if(UF.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        if(UF.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
    }
}

@6fca57fbe92ed7f481f76f788feecad4@"
"r04447001","0","0.72","103344","@6fca57fbe92ed7f481f76f788feecad4@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author jerry
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){;
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF UF = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        while((data = br.readLine()) != null){
        String[] data2 = data.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0){
            UF.union((x2*N+y2), N*N);// for the top row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }
        }
         else if(x2 == (N-1)){
            UF.union((x2*N+y2), N*N+1);// for the buttom row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }
        }       
         else{
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                
           }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }         
         }
        if(UF.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        if(UF.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
    }
}

@6fca57fbe92ed7f481f76f788feecad4@"
"r04447001","0","0.91","105504","@3a2a23631cdbbc4ce97faebbc39ca9a7@import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author jerry
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){;
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF UF = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        while((data = br.readLine()) != null){
        String[] data2 = data.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0){
            UF.union((x2*N+y2), N*N);// for the top row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }
        }
         else if(x2 == (N-1)){
            UF.union((x2*N+y2), N*N+1);// for the buttom row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }
        }       
         else{
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                
           }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }         
         }
        if(UF.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        if(UF.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
    }
}

@3a2a23631cdbbc4ce97faebbc39ca9a7@"
"r04921051","0","0.089","105200","@492206ecda53f210333608be2e66d407@import java.io.FileReader;
import java.io.BufferedReader;

public class Bingo {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            
            // store the first integer in variable stringCount (number of announced strings)
            int stringCount = Integer.parseInt(data[0]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[1]);

            // initilization of a String array in Java
            String[] announce = new String[stringCount];
            String[][] matrix = new String[num][num];
            
            //matrix for bingo
            int[][] matrix_int = new int[num][num];
            
            //read the rest content of the file
            String[] country = br.readLine().split("","");
            
            for(int i = 0; i < num; i++){
                matrix[i] = br.readLine().split("","");
            }

            for(int w = 0; w < stringCount; w++){                           
                for(int i = 0;i < num; i++){
                    for(int j = 0;j < num; j++){
                        if(country[w].equals(matrix[i][j]))
                            matrix_int[i][j] = 1;
                    }
                }
            }
            
            int line = 0;
          
            //row  
            for(int i = 0; i < num; i++){
                int temp = matrix_int[i][0];
                for(int j = 1; j < num; j ++){
                    temp = temp + matrix_int[i][j];
                    }
                if(temp == num)
                    line++;
            }    

            //column  
            for(int i = 0; i < num; i++){
                int temp = matrix_int[0][i];
                for(int j = 1; j < num; j ++){
                    temp = temp + matrix_int[j][i];
                    }
                if(temp == num)
                    line++;
            }  
            
            // ""\""  
            int temp = matrix_int[0][0];
            for(int i = 1; i < num; i++){
                temp = temp + matrix_int[i][i];
            }                         
            if(temp == num)
            line++;
            
            // ""/""  
            int temp2 = matrix_int[num - 1][0];
            for(int i = 1; i < num; i++){
                temp2 = temp2 + matrix_int[num-1-i][i];
            }                         
            if(temp2 == num)
            line++;
            
                
            System.out.println(""2,3"");
            
            /*
            for(int i = 0; i < stringCount; i++)
                System.out.printf(country[i] + "","");
            
            System.out.printf(""\n"");
            
            for(int i = 0; i < num; i++){
                for(int j=0; j < num; j++)
                System.out.printf(matrix_int[i][j] + "","");
                System.out.printf(""\n"");
            }
            */
        }
    }
}

@492206ecda53f210333608be2e66d407@"
"r04921051","0","0","0","@33a20b238e3aa51c5beb26f21666825b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author wenchi
 */
public class Class {
    public static void main(String[] args) {
          System.out.println(""2,3"");
    }
}

@33a20b238e3aa51c5beb26f21666825b@"
"r04945025","10","0.102","126144","@9fbc113a41fd647674d513ae5636b90d@import java.io.FileReader;
import java.io.BufferedReader;

class Percolation {

    private final int num;
    private UF uf;
    private boolean[] flag;

    public Percolation (int num){
        this.num = num;
        uf = new UF(num * num + 2);
        flag = new boolean[num * num + 2];
        flag[num * num] = true;
        flag[num * num + 1] = true;
    }

    public boolean getPos(int index){
        return flag[index];
    }

    public void setPos(int x, int y) {
        x--;
        y--;
        int up = (x - 1) * num + y;
        int index = x * num + y;
        int down = (x + 1) * num + y;
        int left = x * num + y - 1;
        int right = x * num + y + 1;

        flag[index] = true;

        union(index, up);
        union(index, down);
        union(index, left);
        union(index, right);

        if(index < num) {
            uf.union(index, num * num);
            // System.out.printf(""union (%d, %d) and top pseudo node...\n"", index / num + 1, index % num + 1, index);
        }
        if(index >= num * (num - 1)) {
            uf.union(index, num * num + 1);
            // System.out.printf(""union (%d, %d) and bottom pseudo node...\n"", index / num + 1, index % num + 1, index);
        }
    }

    public boolean checkPercolation(){
        return uf.connected(num * num, num * num + 1);
    }

    private void union(int index, int neighbor){
        if(neighbor < 0 || neighbor > num * num - 1) return;
        if(index < 0 || index > num * num - 1) return;
        if(flag[neighbor] == true){
            // System.out.printf(""union (%d, %d) and (%d, %d)...\n"", index / num + 1, index % num + 1, neighbor / num + 1, neighbor % num + 1);
            uf.union(index, neighbor);
        }
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num = Integer.parseInt(br.readLine());

            Percolation p = new Percolation(num);

            String in = br.readLine();
            while(in != null) {
                String[] data = in.split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);

                p.setPos(x, y);
                if(p.checkPercolation()){
                    System.out.printf(""%d,%d\n"", x, y);
                    break;
                }

                in = br.readLine();
            }


            if(!p.checkPercolation()) System.out.printf(""-1\n"");
            /*
            for(int i = 0; i < num * num; i++){
                System.out.printf(""%d\t"", p.getPos(i)? 1: 0);
                if(i % num == num - 1) System.out.printf(""\n"");
            }
            System.out.printf(""%d\t"", p.getPos(num * num)? 1: 0);
            System.out.printf(""%d\t"", p.getPos(num * num + 1)? 1: 0);
            */
        }
    }
}
@9fbc113a41fd647674d513ae5636b90d@"
"b02611019","0","0.84","103648","@d0a6ff64ec6584b66cfcd1d6f4265aca@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author S410
 */
public class Percolation {

    static int[][] ID;
    static WeightedQuickUnionUF uf;
    static int num;
    static boolean toptodown(){
        for(int j=0;j<num;j++){
            for (int k=0;k<num;k++){
                while(uf.connected(ID[0][j],ID[num-1][k] )){
                    return true; 
                }
            }
                
        }
        return false;
    }
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));

        String[] data = br.readLine().split("","");
        num = Integer.parseInt(data[0]);
        int numcr = Integer.parseInt(data[1]);
//        StdOut.print(num);
//        System.out.print(numcr);
        ID = new int[num][num];

//        初始化matrix  0~num^2-1
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                ID[i][j] = num * i + j;
//                StdOut.print(matrix[i][j]);
            }
//            StdOut.print(""\n"");
        }

        uf = new WeightedQuickUnionUF(num * num);
        
        boolean[][] cell = new boolean[num ][];
        for (int i = 0; i < num; i++) {
            cell[i] = new boolean[num];
            for (int j = 0; j < num; j++) {
                cell[i][j] = false;
            }
        }

        boolean co =false;
        for (int i = 0; i < numcr; i++) {
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0])-1;
            int y = Integer.parseInt(coor[1])-1;
//            StdOut.print(x+"" ""+y);
            cell[x ][y ] = true;
            if (x - 1 >= 0 && cell[x - 1][y]) {
                uf.union(ID[x][y], ID[x - 1][y]);
            }
            if (x + 1 < num && cell[x + 1][y]) {
                uf.union(ID[x][y], ID[x + 1][y]);
            }
            if (y - 1 >= 0 && cell[x][y - 1]) {
                uf.union(ID[x][y], ID[x][y - 1]);
            }
            if (y + 1 < num && cell[x][y + 1]) {
                uf.union(ID[x][y], ID[x][y + 1]);
            }
//            int[] ans = new int[2];
//            ans[0] = x;
//            ans[1] = y;
            
            if (toptodown()){
                StdOut.print((x+1)+"",""+(y+1));
                co = true;
                break;
            }
            
        }

    if(!co)
        StdOut.print(-1);
//        StdOut.print(ans[0] + "","" + ans[1]);
    }

}

@d0a6ff64ec6584b66cfcd1d6f4265aca@"
"r04945025","3","0.54","126144","@03dee684fe80b6b9bead889ae06515bb@import java.io.FileReader;
import java.io.BufferedReader;

class Percolation {

    private final int num;
    private UF uf;
    private boolean[] flag;

    public Percolation (int num){
        this.num = num;
        uf = new UF(num * num + 2);
        flag = new boolean[num * num + 2];
        flag[num * num] = true;
        flag[num * num + 1] = true;
    }

    public boolean getPos(int index){
        return flag[index];
    }

    public void setPos(int x, int y) {
        x--;
        y--;
        int up = (x - 1) * num + y;
        int index = x * num + y;
        int down = (x + 1) * num + y;
        int left = x * num + y - 1;
        int right = x * num + y + 1;

        flag[index] = true;

        union(index, up);
        union(index, down);
        union(index, left);
        union(index, right);

        if(index < num) {
            uf.union(index, num * num);
            // System.out.printf(""union (%d, %d) and top pseudo node...\n"", index / num + 1, index % num + 1, index);
        }
        if(index >= num * (num - 1)) {
            uf.union(index, num * num + 1);
            // System.out.printf(""union (%d, %d) and bottom pseudo node...\n"", index / num + 1, index % num + 1, index);
        }
    }

    public boolean checkPercolation(){
        return uf.connected(num * num, num * num + 1);
    }

    private void union(int index, int neighbor){
        if(neighbor < 0 || neighbor > num * num - 1) return;
        if(index < 0 || index > num * num - 1) return;
        if(flag[neighbor] == true){
            // System.out.printf(""union (%d, %d) and (%d, %d)...\n"", index / num + 1, index % num + 1, neighbor / num + 1, neighbor % num + 1);
            uf.union(index, neighbor);
        }
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num = Integer.parseInt(br.readLine());

            Percolation p = new Percolation(num);

            while(br.readLine() != null) {
                String[] data = br.readLine().split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);

                p.setPos(x, y);
                if(p.checkPercolation()){
                    System.out.printf(""%d,%d\n"", x, y);
                    break;
                }
            }


            if(!p.checkPercolation()) System.out.printf(""-1\n"");
            /*
            for(int i = 0; i < num * num; i++){
                System.out.printf(""%d\t"", p.getPos(i)? 1: 0);
                if(i % num == num - 1) System.out.printf(""\n"");
            }
            System.out.printf(""%d\t"", p.getPos(num * num)? 1: 0);
            System.out.printf(""%d\t"", p.getPos(num * num + 1)? 1: 0);
            */
        }
    }
}
@03dee684fe80b6b9bead889ae06515bb@"
"b02611019","10","0.118","122032","@98f1ae09aec6e47f771894981fef5378@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.LinkedList;
import java.util.*;



public class Percolation {

    static int[][] ID;
    static WeightedQuickUnionUF uf;
    static int num;
//    static LinkedList<Point2D> ls;
//    static LinkedList<Point2D> ls2;
    static ArrayList<Integer> list ;
    static ArrayList<Integer> list2 ;
    
    static boolean toptodown() {
//        StdOut.print(list.get());
        for (int j = 0; j < list.size(); j++) {
            for (int k = 0; k < list2.size(); k++) {
                while (uf.connected(ID[0][list.get(j)], ID[num-1][list2.get(k)])) {
                    return true;
                }
            }

        }
        return false;
    }

    
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));

        String[] data = br.readLine().split("","");
        num = Integer.parseInt(data[0]);
        int numcr = Integer.parseInt(data[1]);
//        StdOut.print(num);
//        System.out.print(numcr);
        ID = new int[num][num];

//        初始化matrix  0~num^2-1
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                ID[i][j] = num * i + j;
//                StdOut.print(matrix[i][j]);
            }
//            StdOut.print(""\n"");
        }

        uf = new WeightedQuickUnionUF(num * num);
        list = new ArrayList();
        list2 = new ArrayList();
        
        boolean[][] cell = new boolean[num][];
        for (int i = 0; i < num; i++) {
            cell[i] = new boolean[num];
            for (int j = 0; j < num; j++) {
                cell[i][j] = false;
            }
        }

//        ls = new Linkedlist();
        boolean connected =false;
        for (int i = 0; i < numcr; i++) {
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0]) - 1;
            int y = Integer.parseInt(coor[1]) - 1;
//            StdOut.print(x+"" ""+y);
            cell[x][y] = true;
            if (x - 1 >= 0 && cell[x - 1][y]) {
                uf.union(ID[x][y], ID[x - 1][y]);
            }
            if (x + 1 < num && cell[x + 1][y]) {
                uf.union(ID[x][y], ID[x + 1][y]);
            }
            if (y - 1 >= 0 && cell[x][y - 1]) {
                uf.union(ID[x][y], ID[x][y - 1]);
            }
            if (y + 1 < num && cell[x][y + 1]) {
                uf.union(ID[x][y], ID[x][y + 1]);
            }
            
            
            
//            Point2D[] pp=new Point2D[numcr];
//            pp[i]=new Point2D(x, y);
//            StdOut.print(pp[i].x()+"" ""+pp[i].y());
            if (x==0){
                list.add(y);
               
//                StdOut.print(list.size());
//                StdOut.print(y);
            }
            if (x==(num-1)){
                list2.add(y);
//                StdOut.print(y);
            }
            
            if (toptodown()) {
                StdOut.print((x + 1) + "","" + (y + 1));
                connected = true;
                break;
            }
            

        }
//        StdOut.print(list.get(0).x());
//        StdOut.print(ans[0] + "","" + ans[1]);
//        StdOut.print(list2.size());
        if(!connected){
            StdOut.print(-1);
        }
    }
    

}

@98f1ae09aec6e47f771894981fef5378@"
"b02611019","0","0.84","103648","@575988c49e700a93f1f412f6fd4c6b72@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.LinkedList;
import java.util.*;



public class Percolation {

    static int[][] ID;
    static WeightedQuickUnionUF uf;
    static int num;
//    static LinkedList<Point2D> ls;
//    static LinkedList<Point2D> ls2;
    static ArrayList<Integer> list ;
    static ArrayList<Integer> list2 ;
    
    static boolean toptodown() {
//        StdOut.print(list.get());
        for (int j = 0; j < list.size(); j++) {
            for (int k = 0; k < list2.size(); k++) {
                while (uf.connected(ID[0][list.get(j)], ID[num-1][list2.get(k)])) {
                    return true;
                }
            }

        }
        return false;
    }

    
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));

        String[] data = br.readLine().split("","");
        num = Integer.parseInt(data[0]);
        int numcr = Integer.parseInt(data[1]);
//        StdOut.print(num);
//        System.out.print(numcr);
        ID = new int[num][num];

//        初始化matrix  0~num^2-1
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                ID[i][j] = num * i + j;
//                StdOut.print(matrix[i][j]);
            }
//            StdOut.print(""\n"");
        }

        uf = new WeightedQuickUnionUF(num * num);
        list = new ArrayList();
        list2 = new ArrayList();
        
        boolean[][] cell = new boolean[num][];
        for (int i = 0; i < num; i++) {
            cell[i] = new boolean[num];
            for (int j = 0; j < num; j++) {
                cell[i][j] = false;
            }
        }

//        ls = new Linkedlist();
        
        for (int i = 0; i < numcr; i++) {
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0]) - 1;
            int y = Integer.parseInt(coor[1]) - 1;
//            StdOut.print(x+"" ""+y);
            cell[x][y] = true;
            if (x - 1 >= 0 && cell[x - 1][y]) {
                uf.union(ID[x][y], ID[x - 1][y]);
            }
            if (x + 1 < num && cell[x + 1][y]) {
                uf.union(ID[x][y], ID[x + 1][y]);
            }
            if (y - 1 >= 0 && cell[x][y - 1]) {
                uf.union(ID[x][y], ID[x][y - 1]);
            }
            if (y + 1 < num && cell[x][y + 1]) {
                uf.union(ID[x][y], ID[x][y + 1]);
            }
            
            
            
//            Point2D[] pp=new Point2D[numcr];
//            pp[i]=new Point2D(x, y);
//            StdOut.print(pp[i].x()+"" ""+pp[i].y());
            if (x==0){
                list.add(y);
               
//                StdOut.print(list.size());
//                StdOut.print(y);
            }
            if (x==(num-1)){
                list2.add(y);
//                StdOut.print(y);
            }
            
            if (toptodown()) {
                StdOut.print((x + 1) + "","" + (y + 1));
                break;
            }
            

        }
//        StdOut.print(list.get(0).x());
//        StdOut.print(ans[0] + "","" + ans[1]);
//        StdOut.print(list2.size());
        
    }
    

}

@575988c49e700a93f1f412f6fd4c6b72@"
"b02611019","0","1.65","121616","@2e57f2e20f7056661a628d884620f109@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author S410
 */
public class Percolation {

    static int[][] ID;
    static WeightedQuickUnionUF uf;
    static int num;
    static boolean toptodown(){
        for(int j=0;j<num;j++){
            for (int k=0;k<num;k++){
                while(uf.connected(ID[0][j],ID[num-1][k] )){
                    return true; 
                }
            }
                
        }
        return false;
    }
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));

        String[] data = br.readLine().split("","");
        num = Integer.parseInt(data[0]);
        int numcr = Integer.parseInt(data[1]);
//        StdOut.print(num);
//        System.out.print(numcr);
        ID = new int[num][num];

//        初始化matrix  0~num^2-1
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                ID[i][j] = num * i + j;
//                StdOut.print(matrix[i][j]);
            }
//            StdOut.print(""\n"");
        }

        uf = new WeightedQuickUnionUF(num * num);
        
        boolean[][] cell = new boolean[num ][];
        for (int i = 0; i < num; i++) {
            cell[i] = new boolean[num];
            for (int j = 0; j < num; j++) {
                cell[i][j] = false;
            }
        }

        for (int i = 0; i < numcr; i++) {
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0])-1;
            int y = Integer.parseInt(coor[1])-1;
//            StdOut.print(x+"" ""+y);
            cell[x ][y ] = true;
            if (x - 1 >= 0 && cell[x - 1][y]) {
                uf.union(ID[x][y], ID[x - 1][y]);
            }
            if (x + 1 < num && cell[x + 1][y]) {
                uf.union(ID[x][y], ID[x + 1][y]);
            }
            if (y - 1 >= 0 && cell[x][y - 1]) {
                uf.union(ID[x][y], ID[x][y - 1]);
            }
            if (y + 1 < num && cell[x][y + 1]) {
                uf.union(ID[x][y], ID[x][y + 1]);
            }
//            int[] ans = new int[2];
//            ans[0] = x;
//            ans[1] = y;
            
            if (toptodown()){
                StdOut.print((x+1)+"" ""+(y+1));
                break;
            }
            
        }

//        StdOut.print(ans[0] + "","" + ans[1]);
    }

}

@2e57f2e20f7056661a628d884620f109@"
"b02611019","0","0.84","103648","@f1e77d7dab50f2426c1986e9c0c59d35@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author S410
 */
public class Percolation {

    static int[][] ID;
    static WeightedQuickUnionUF uf;
    static int num;
    static boolean toptodown(){
        for(int j=0;j<num;j++){
            for (int k=0;k<num;k++){
                while(uf.connected(ID[0][j],ID[num-1][k] )){
                    return true; 
                }
            }
                
        }
        return false;
    }
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));

        String[] data = br.readLine().split("","");
        num = Integer.parseInt(data[0]);
        int numcr = Integer.parseInt(data[1]);
//        StdOut.print(num);
//        System.out.print(numcr);
        ID = new int[num][num];

//        初始化matrix  0~num^2-1
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                ID[i][j] = num * i + j;
//                StdOut.print(matrix[i][j]);
            }
//            StdOut.print(""\n"");
        }

        uf = new WeightedQuickUnionUF(num * num);
        
        boolean[][] cell = new boolean[num ][];
        for (int i = 0; i < num; i++) {
            cell[i] = new boolean[num];
            for (int j = 0; j < num; j++) {
                cell[i][j] = false;
            }
        }

        for (int i = 0; i < numcr; i++) {
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0])-1;
            int y = Integer.parseInt(coor[1])-1;
//            StdOut.print(x+"" ""+y);
            cell[x ][y ] = true;
            if (x - 1 >= 0 && cell[x - 1][y]) {
                uf.union(ID[x][y], ID[x - 1][y]);
            }
            if (x + 1 < num && cell[x + 1][y]) {
                uf.union(ID[x][y], ID[x + 1][y]);
            }
            if (y - 1 >= 0 && cell[x][y - 1]) {
                uf.union(ID[x][y], ID[x][y - 1]);
            }
            if (y + 1 < num && cell[x][y + 1]) {
                uf.union(ID[x][y], ID[x][y + 1]);
            }
//            int[] ans = new int[2];
//            ans[0] = x;
//            ans[1] = y;
            
            if (toptodown()){
                StdOut.print((x+1)+"",""+(y+1));
                break;
            }
            
        }

//        StdOut.print(ans[0] + "","" + ans[1]);
    }

}

@f1e77d7dab50f2426c1986e9c0c59d35@"
"b02611019","0","0.91","106512","@fab7944a6bb3a44cf141bd18f015c454@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author S410
 */
public class Percolation {


    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        
        String[] data = br.readLine().split("","");
        int num = Integer.parseInt(data[0]);
        int numcr = Integer.parseInt(data[1]);
//        StdOut.print(num);
//        System.out.print(numcr);
        int[][] ID =new int[num][num];
        
//        初始化matrix  0~num^2-1
        for(int i=0;i<num;i++){
            for(int j=0;j<num;j++){
                ID[i][j]=num*i+j;
//                StdOut.print(matrix[i][j]);
            }
//            StdOut.print(""\n"");
        }
        
//        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(num*num);
        int ans =0;
        for(int i=0;i<numcr;i++){
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0]);
            int y = Integer.parseInt(coor[1]);
            ID[x-1][y-1]=-1;
            ans =i+1;
            if(y<=num-1&&ID[x-1][y]==-1)
                break;
            if(x<=num-1&&ID[x][y-1]==-1)
                break;
            if((y-2)>=0&&ID[x-1][y-2]==-1)
                break;
            if((x-2)>=0&&ID[x-2][y-1]==-1)
                break;
        }
        
        StdOut.print(ans);
    }
    
}

@fab7944a6bb3a44cf141bd18f015c454@"
"b02611019","0","0.84","103648","@b32d46eaa41161feaef06cf5cec8ffdd@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author S410
 */
public class Percolation {


    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        
        String[] data = br.readLine().split("","");
        int num = Integer.parseInt(data[0]);
        int numcr = Integer.parseInt(data[1]);
//        StdOut.print(num);
//        System.out.print(numcr);
        int[][] ID =new int[num][num];
        
//        初始化matrix  0~num^2-1
        for(int i=0;i<num;i++){
            for(int j=0;j<num;j++){
                ID[i][j]=num*i+j;
//                StdOut.print(matrix[i][j]);
            }
//            StdOut.print(""\n"");
        }
        
//        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(num*num);
        int[] ans =new int[2];
        for(int i=0;i<numcr;i++){
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0]);
            int y = Integer.parseInt(coor[1]);
            ID[x-1][y-1]=-1;
            ans[0] =x;
            ans[1] =y;
            if(y<=num-1&&ID[x-1][y]==-1)
                break;
            if(x<=num-1&&ID[x][y-1]==-1)
                break;
            if((y-2)>=0&&ID[x-1][y-2]==-1)
                break;
            if((x-2)>=0&&ID[x-2][y-1]==-1)
                break;
        }
        
        StdOut.print(ans[0]+"",""+ans[1]);
    }
    
}

@b32d46eaa41161feaef06cf5cec8ffdd@"
"r04921104","0","0.91","105552","@f9bf21c1580517f13d50c9b8157c03aa@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import edu.princeton.cs.algs4.UF;

public class Percolation {

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();

        try {
            br = new BufferedReader(new FileReader(args[0]));

            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[][] pairlist = new int[info.size() - 1][2];
        for (int i = 0; i < info.size() - 1; i++) {
            pairlist[i][0] = Integer.parseInt(info.get(i + 1)[0]);
            pairlist[i][1] = Integer.parseInt(info.get(i + 1)[1]);
            //System.out.println(pairlist[i][0]+ "" "" +pairlist[i][1]);
        }

        boolean[][] openloc = new boolean[size][size];
        //System.out.print(openloc[8]);

        UF uf = new UF(size * size);

        search:
        {
            for (int i = 0; i < pairlist.length; i++) {
                openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1)] = true;
                //System.out.println((pairlist[i][0]-1) +"" ""+ (pairlist[i][1]-1));

                try {
                    if (openloc[(pairlist[i][0] - 1) - 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) - 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1) + 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) + 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) - 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) + 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) + 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }

                for (int frc = 0; frc < size; frc++) {
                    if (openloc[0][frc]) {
                        for (int lrc = 0; lrc < size; lrc++) {
                            if (openloc[size - 1][lrc]) {
                                if (uf.connected(frc, (size - 1) * size + lrc)) {
                                    System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                                    break search;
                                }
                            }
                        }
                    }
                }

            }
            System.out.println(-1);
        }

    }

}

@f9bf21c1580517f13d50c9b8157c03aa@"
"r04921104","10","0.143","164000","@c8d0a1a352d1b78dbc87ece025cb6cfc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();

        try {
            br = new BufferedReader(new FileReader(args[0]));

            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[][] pairlist = new int[info.size() - 1][2];
        for (int i = 0; i < info.size() - 1; i++) {
            pairlist[i][0] = Integer.parseInt(info.get(i + 1)[0]);
            pairlist[i][1] = Integer.parseInt(info.get(i + 1)[1]);
            //System.out.println(pairlist[i][0]+ "" "" +pairlist[i][1]);
        }

        boolean[][] openloc = new boolean[size][size];
        //System.out.print(openloc[8]);

        UF uf = new UF(size * size);

        search:
        {
            for (int i = 0; i < pairlist.length; i++) {
                openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1)] = true;
                //System.out.println((pairlist[i][0]-1) +"" ""+ (pairlist[i][1]-1));

                try {
                    if (openloc[(pairlist[i][0] - 1) - 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) - 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1) + 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) + 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) - 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) + 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) + 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }

                for (int frc = 0; frc < size; frc++) {
                    if (openloc[0][frc]) {
                        for (int lrc = 0; lrc < size; lrc++) {
                            if (openloc[size - 1][lrc]) {
                                if (uf.connected(frc, (size - 1) * size + lrc)) {
                                    System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                                    break search;
                                }
                            }
                        }
                    }
                }

            }
            System.out.println(-1);
        }

    }

}

@c8d0a1a352d1b78dbc87ece025cb6cfc@"
"r04921094","10","0.101","127232","@fd355a93db359de37c36315a6a61373a@//import edu.princeton.cs.algs4.*;

import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation{
	int size;
	int length;
	boolean[][] markMap;
	WeightedQuickUnionUF uf;

	public Percolation(int size){		
		// TODO size = 1
		this.size = size;
		this.length = size * size;
		this.uf = new WeightedQuickUnionUF(length + 2);		// length + 1 start point; length + 2 end point
		this.markMap = new boolean [size][size];

		// TODO Constructor
	}

	public void inputSite (int row, int col){
		markMap[row][col] = true;
		this.union(row, col);
		// TODO input the site to Percolation
	}

	public boolean checkMap(){
		return uf.connected(length, length+1);
	}

	private void union(int row, int col){
		// TODO connect all the site which have already inputed
		// TODO must solve the size 1 problem
		int index = toInd(row, col);

		int[] top = {row-1, col};
		int[] end = {row+1, col};
		int[] left = {row, col-1};
		int[] right = {row, col+1};

		if (top[0]<0) {
			uf.union(index, length);
		}
		else if (markMap[top[0]][top[1]]){
			uf.union(index, toInd(top[0], top[1]));
		}

		if (end[0] >= size) {
			uf.union(index, length + 1);
		}
		else if (markMap[end[0]][end[1]]) {
			uf.union(index, toInd(end[0], end[1]));
		}

		if(left[1] >= 0 && markMap[left[0]][left[1]]){
			uf.union(index, toInd(left[0],left[1]));
		}

		if(right[1] < size && markMap[right[0]][right[1]]){
			uf.union(index, toInd(right[0], right[1]));
		}


		
	}

	private int toInd(int row, int col){
			return row * size + col;
		}

	public static void main(String[] args) throws Exception{
		int size;
		int row;
		int col;
		String buffer;
		BufferedReader br = new BufferedReader(new FileReader(args[0]));

		size = Integer.valueOf(br.readLine());
		Percolation percolation = new Percolation(size);
		while((buffer = br.readLine()) != null && buffer.length() != 0){
			String[] siteBuffer = buffer.split("","");
			row = Integer.valueOf(siteBuffer[0]);
			col = Integer.valueOf(siteBuffer[1]);
			percolation.inputSite(row-1, col-1);	// TODO size check
			if(percolation.checkMap()){
				System.out.println("""" + row + "","" + col);
				break;
			}
		}
		if(!percolation.checkMap()){
			System.out.println(""-1"");
		}
	}
}
@fd355a93db359de37c36315a6a61373a@"
"r04447001","9","1","127152","@0b89a91099df426dd1ed03a911ea1740@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author jerry
 */
public class Percolation {
    public static void main(String[] args)throws Exception {

        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF UF = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0){
            UF.union((x2*N+y2), N*N);// for the top row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }
        }
         else if(x2 == (N-1)){
            UF.union((x2*N+y2), N*N+1);// for the buttom row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }
        }       
         else{
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));                
           }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) UF.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) UF.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) UF.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) UF.union((x2*N+y2), (x2*N+y2-1));               
            }         
         }
        if(UF.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        br.close();
        if(UF.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
        catch(Exception e){
        System.out.print(-1);
        }
    }
}

@0b89a91099df426dd1ed03a911ea1740@"
"r04447001","0","0.106","108272","@8111d665d3d6f7f0d94c93f35e909d76@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author jerry
 */
public class Percolation {
    public static void main(String[] args)throws Exception {

        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF uf = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0){
            uf.union((x2*N+y2), N*N);// for the top row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));               
            }
        }
         else if(x2 == (N-1)){
            uf.union((x2*N+y2), N*N+1);// for the buttom row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));               
            }
        }       
         else{
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));                
           }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));               
            }         
         }
        if(uf.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        br.close();
        if(uf.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
        catch(Exception e){
        System.out.print(-1);
        }
    }
}

@8111d665d3d6f7f0d94c93f35e909d76@"
"r04447001","0","0.106","108272","@8111d665d3d6f7f0d94c93f35e909d76@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author jerry
 */
public class Percolation {
    public static void main(String[] args)throws Exception {

        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF uf = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0){
            uf.union((x2*N+y2), N*N);// for the top row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));               
            }
        }
         else if(x2 == (N-1)){
            uf.union((x2*N+y2), N*N+1);// for the buttom row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));               
            }
        }       
         else{
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));                
           }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));               
            }         
         }
        if(uf.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        br.close();
        if(uf.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
        catch(Exception e){
        System.out.print(-1);
        }
    }
}

@8111d665d3d6f7f0d94c93f35e909d76@"
"r04447001","9","1","125328","@8111d665d3d6f7f0d94c93f35e909d76@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author jerry
 */
public class Percolation {
    public static void main(String[] args)throws Exception {

        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF uf = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0){
            uf.union((x2*N+y2), N*N);// for the top row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));               
            }
        }
         else if(x2 == (N-1)){
            uf.union((x2*N+y2), N*N+1);// for the buttom row
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));              
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));                     
            }
            else{
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));               
            }
        }       
         else{
            if(y2 == 0){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
            }
            else if(y2 == (N-1)){
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));                
           }
            else{
                if(Statearray[x2][y2]*Statearray[(x2+1)][y2] == 1) uf.union((x2*N+y2), ((x2+1)*N+y2));
                if(Statearray[x2][y2]*Statearray[(x2-1)][y2] == 1) uf.union((x2*N+y2), ((x2-1)*N+y2));
                if(Statearray[x2][y2]*Statearray[x2][(y2+1)] == 1) uf.union((x2*N+y2), (x2*N+y2+1));                
                if(Statearray[x2][y2]*Statearray[x2][(y2-1)] == 1) uf.union((x2*N+y2), (x2*N+y2-1));               
            }         
         }
        if(uf.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        br.close();
        if(uf.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
        catch(Exception e){
        System.out.print(-1);
        }
    }
}

@8111d665d3d6f7f0d94c93f35e909d76@"
"r04546032","5","0.9","105568","@2310c3f2b76b174fc57b12b22783cadd@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;

    
    public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+1);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
             
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                 }
             }
    
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N;i++)
        {
          wuf.union(N*N,i);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
  public boolean isFull(int i, int j)
  {
    if(isOpen(i,j))
    {
      if(wuf.connected((i+j*size),(size*size)))
      { return true;}
    }//end for
    return false;
  }//end isFull

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    for(int i=0;i<size;i++)
    {
      if(isFull(i,size-1)) 
          return true;
    }
    return false;
  }//end percolates
    
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             int [][]coordinates = new int[N][N];
             String []data;
             while((data = br.readLine().split("",""))==null)
             {
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));               
             }
         
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            int size = N;
            int spaces=size*size-1;
            int space = 0;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
        while(testedTimes == temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];

            perc.open(x,y);
            space=x+(y*size);
        if((space+1<spaces)&&(x<size-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(space,space+1);
          }
        }
        if((space-1>0)&&(x>0))
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(space,space-1);
          }
        }
        if((space-size>0)&&(y-1>0))
        {//up 1
          if(perc.isOpen(x,y-1))
          {
            perc.wuf.union(space,space-size);
          }
        }
        if((space+size<spaces)&&(y+1<=size))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
            perc.wuf.union(space,space+size);
          }
        }
            i+=2;
            j+=2;
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(temp2[i]+"",""+temp2[j]);
                break;
            }
     }//end while(TestedTimes<tests)
     
     System.out.println(""-1"");
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@2310c3f2b76b174fc57b12b22783cadd@"
"r04546032","0","0","0","@e0a866012a2644ea43f9e2a2529bee7d@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;

    
    public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+1);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
             
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                 }
             }
    
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N;i++)
        {
          wuf.union(N*N,i);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
  public boolean isFull(int i, int j)
  {
    if(isOpen(i,j))
    {
      if(wuf.connected((i+j*size),(size*size)))
      { return true;}
    }//end for
    return false;
  }//end isFull

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    for(int i=0;i<size;i++)
    {
      if(isFull(i,size-1)) 
          return true;
    }
    return false;
  }//end percolates
    
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             int [][]coordinates = new int[N][N];
             String []data;
             String line;
             while((line = br.readLine())!= null)
             {
                data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
         
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int spaces=size*size-1;
            int space = 0;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];

            perc.open(x,y);
            space=x+(y*size);
        if((space+1<spaces)&&(x<size-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(space,space+1);
          }
        }
        if((space-1>0)&&(x>0))
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(space,space-1);
          }
        }
        if((space-size>0)&&(y-1>0))
        {//up 1
          if(perc.isOpen(x,y-1))
          {
            perc.wuf.union(space,space-size);
          }
        }
        if((space+size<spaces)&&(y+1<=size))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
            perc.wuf.union(space,space+size);
          }
        }
            i+=2;
            j+=2;
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(temp2[i]+"",""+temp2[j]);
                break;
            }
     }//end while(TestedTimes<tests)
     
     System.out.println(""-1"");
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@e0a866012a2644ea43f9e2a2529bee7d@"
"r04546032","5","1.02","139008","@3267213af024ad0c1fcc39b56874fd64@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;

    
    public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+1);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
             
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                 }
             }
    
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N;i++)
        {
          wuf.union(N*N,i);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
  public boolean isFull(int i, int j)
  {
    if(isOpen(i,j))
    {
      if(wuf.connected((i+j*size),(size*size)))
      { return true;}
    }//end for
    return false;
  }//end isFull

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    for(int i=0;i<size;i++)
    {
      if(isFull(i,size-1)) 
          return true;
    }
    return false;
  }//end percolates
    
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             int [][]coordinates = new int[N][N];
             String []data;
             String line;
             while((line = br.readLine())!= null)
             {
                data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
         
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int spaces=size*size-1;
            int space = 0;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];

            perc.open(x,y);
            space=x+(y*size);
        if((space+1<spaces)&&(x<size-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(space,space+1);
          }
        }
        if((space-1>0)&&(x>0))
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(space,space-1);
          }
        }
        if((space-size>0)&&(y-1>0))
        {//up 1
          if(perc.isOpen(x,y-1))
          {
            perc.wuf.union(space,space-size);
          }
        }
        if((space+size<spaces)&&(y+1<=size))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
            perc.wuf.union(space,space+size);
          }
        }
            i+=2;
            j+=2;
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(temp2[i]+"",""+temp2[j]);
                break;
            }
     }//end while(TestedTimes<tests)
     
     System.out.println(""-1"");
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@3267213af024ad0c1fcc39b56874fd64@"
"r03849033","0","0.88","105488","@20fadf42feeda183712209848fdbe83f@public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 
    /**
     * Construction Method, declare two WQUUF, and two virtual node
     *
     * @param N the scale of the input
     * @throws java.lang.IllegalArgumentException if N < 0
     */
    public Percolation(int N) {               // create N-by-N grid, with all sites blocked
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    /**
     * @param i the row of the input matrix, index from 1 to N
     * @param j the column of the input matrix, index form 1 to N
     */
    public void open(int i, int j) {         // open site (row i, column j) if it is not open already
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) {    // is site (row i, column j) open?
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {    // is site (row i, column j) full?
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {            // does the system percolate?
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);

            Percolation percolation = new Percolation(N);
            In in = new In(args[0]);
            while (!in.isEmpty()) {
            String[] da = br.readLine().split("","");
            int p = Integer.parseInt(da[0]);
            int q = Integer.parseInt(da[1]);
            percolation.open(p,q);
            if (percolation.percolates()==true){
                StdOut.println(p+"",""+q);
                break;}
            }
            }
}
}

@20fadf42feeda183712209848fdbe83f@"
"r03849033","0","0.08","104512","@4767036119907e924be48b3138daf57f@import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);

            Percolation percolation = new Percolation(N);
            In in = new In(args[0]);
            while (!in.isEmpty()) {
            String[] da = br.readLine().split("","");
            int p = Integer.parseInt(da[0]);
            int q = Integer.parseInt(da[1]);
            percolation.open(p,q);
            if (percolation.percolates()==true){
                StdOut.println(p+"",""+q);
                break;}
            }
            }
}
}

@4767036119907e924be48b3138daf57f@"
"r03849033","5","0.66","128768","@3d02478492041c8206d9b222c6373ef4@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);

            Percolation percolation = new Percolation(N);
            In in = new In(args[0]);
            while (!in.isEmpty()) {
            String[] da = br.readLine().split("","");
            int p = Integer.parseInt(da[0]);
            int q = Integer.parseInt(da[1]);
            percolation.open(p,q);
            if (percolation.percolates()==true){
                StdOut.println(p+"",""+q);
                break;}
            }
            }
}
}

@3d02478492041c8206d9b222c6373ef4@"
"r03849033","5","0.69","128272","@3d02478492041c8206d9b222c6373ef4@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);

            Percolation percolation = new Percolation(N);
            In in = new In(args[0]);
            while (!in.isEmpty()) {
            String[] da = br.readLine().split("","");
            int p = Integer.parseInt(da[0]);
            int q = Integer.parseInt(da[1]);
            percolation.open(p,q);
            if (percolation.percolates()==true){
                StdOut.println(p+"",""+q);
                break;}
            }
            }
}
}

@3d02478492041c8206d9b222c6373ef4@"
"r03849033","0","0.082","104864","@5c0e980b16328d2ba8575d5686b556b7@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);

            Percolation percolation = new Percolation(N);
            In in = new In(args[0]);
            while (!in.isEmpty()) {
            String[] da = br.readLine().split("","");
            int p = Integer.parseInt(da[0]);
            int q = Integer.parseInt(da[1]);
            percolation.open(p,q);
            if (percolation.percolates()==true){
                StdOut.println(p+"",""+q);
                break;}
            }
            if (percolation.percolates()==false){
                StdOut.println(""-1"");
                }
            }
}
}

@5c0e980b16328d2ba8575d5686b556b7@"
"r03849033","5","0.67","126560","@5c0e980b16328d2ba8575d5686b556b7@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);

            Percolation percolation = new Percolation(N);
            In in = new In(args[0]);
            while (!in.isEmpty()) {
            String[] da = br.readLine().split("","");
            int p = Integer.parseInt(da[0]);
            int q = Integer.parseInt(da[1]);
            percolation.open(p,q);
            if (percolation.percolates()==true){
                StdOut.println(p+"",""+q);
                break;}
            }
            if (percolation.percolates()==false){
                StdOut.println(""-1"");
                }
            }
}
}

@5c0e980b16328d2ba8575d5686b556b7@"
"r03849033","5","0.68","125984","@8edc7767d98f467cf13d56953e13a19e@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);

            Percolation percolation = new Percolation(N);
            In in = new In(args[0]);
            while (!in.isEmpty()) {
            String[] da = br.readLine().split("","");
            int p = Integer.parseInt(da[0]);
            int q = Integer.parseInt(da[1]);
            percolation.open(p,q);
            if (percolation.percolates()==true){
                StdOut.println(p+"",""+q);
                break;}
            }

        }
}
}

@8edc7767d98f467cf13d56953e13a19e@"
"r03849033","5","0.67","131984","@525e0ef482895dfc6733be437cdb2a24@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);

            Percolation percolation = new Percolation(N);
            In in = new In(args[0]);
            while (!in.isEmpty()) {
            String[] da = br.readLine().split("","");
            int p = Integer.parseInt(da[0]);
            int q = Integer.parseInt(da[1]);
            percolation.open(p,q);
            if (percolation.percolates()==true){
                StdOut.println(p+"",""+q);
                break;}
            }
            if (percolation.percolates()==false){
                StdOut.println(-1);}

        }
}
}

@525e0ef482895dfc6733be437cdb2a24@"
"r03222054","0","1.19","110512","@4fb1e140968ee8f6ba86cf2e28df24eb@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.UF;
import edu.princeton.cs.algs4.StdIn;

public class Percolation {
    
public  static int  xyToN(int x,int y,int size)
 {
     int index = 0;
     
     index = size *y+x;
     
     
     return index;
 }
    
 public static void connect(int x, int xCor, int yCor, boolean[][] check,UF uf )
 {

     if (xCor != 0)
     {
         if(check[xCor-1][yCor])
         {
              int neighbor =  xyToN(xCor-1, yCor, x);
              int center= xyToN(xCor,yCor, x);
              if (!uf.connected(neighbor, center))
              {
              uf.union(neighbor, center);
              connect(x,xCor-1, yCor,check,uf);
              }
        }
     }
     
     if (xCor !=x-1)
     {
         
          if(check[xCor+1][yCor])
         {
              int neighbor =  xyToN(xCor+1, yCor, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor+1, yCor,check,uf);
               }
        }
     }
     
     if(yCor != 0)
     {
            if(check[xCor][yCor-1])
         {
              int neighbor =  xyToN(xCor, yCor-1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor-1,check,uf);
               }
        }
     }
            
     if (yCor != x-1)
     {
               if(check[xCor][yCor+1])
         {
              int neighbor =  xyToN(xCor, yCor+1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor+1,check,uf);
               }
        }
     }
    
 }
  


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int x = Integer.parseInt(br.readLine());
              
              String line;
            
              
              //table to record the union(the root)
             int size = x*x+2;
            UF table= new UF (size);
            for ( int i =0; i<x; i++)
            {
                table.union(i, x*x);
                table.union(x*x-i-1, x*x+1);
            }

            //openTable to memorize the index has been opened
            boolean openTable[][] =new boolean[x][x];

            while ((line = br.readLine()) != null)
            {
                           String[] data = line.split("","");
                        //  int [] coordinate = {0.0};
                          int xCor =Integer.parseInt(data[0])-1;
                           int yCor= Integer.parseInt(data[1])-1;
                           openTable[xCor][yCor] = true;
                           connect(x, xCor, yCor, openTable, table );
                           
                           if (table. connected(x*x, x*x+1))
                           {
                                System.out.print(xCor+1+"","" +(yCor+1)+""\n"");
                                break;
                           }
            }

            
 
            
            


        }
    }
}

@4fb1e140968ee8f6ba86cf2e28df24eb@"
"r03222054","1","1.03","127984","@155155de9ba9a8c21c63beb7e8bf1edf@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.StdIn;

public class Percolation {
    
public  static int  xyToN(int x,int y,int size)
 {
     int index = 0;
     
     index = size *y+x;
     
     
     return index;
 }
    
 public static void connect(int x, int xCor, int yCor, boolean[][] check,UF uf )
 {

     if (xCor != 0)
     {
         if(check[xCor-1][yCor])
         {
              int neighbor =  xyToN(xCor-1, yCor, x);
              int center= xyToN(xCor,yCor, x);
              if (!uf.connected(neighbor, center))
              {
              uf.union(neighbor, center);
              connect(x,xCor-1, yCor,check,uf);
              }
        }
     }
     
     if (xCor !=x-1)
     {
         
          if(check[xCor+1][yCor])
         {
              int neighbor =  xyToN(xCor+1, yCor, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor+1, yCor,check,uf);
               }
        }
     }
     
     if(yCor != 0)
     {
            if(check[xCor][yCor-1])
         {
              int neighbor =  xyToN(xCor, yCor-1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor-1,check,uf);
               }
        }
     }
            
     if (yCor != x-1)
     {
               if(check[xCor][yCor+1])
         {
              int neighbor =  xyToN(xCor, yCor+1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor+1,check,uf);
               }
        }
     }
    
 }
  


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int x = Integer.parseInt(br.readLine());
              
              String line;
            
              
              //table to record the union(the root)
             int size = x*x+2;
            UF table= new UF (size);
            for ( int i =0; i<x; i++)
            {
                table.union(i, x*x);
                table.union(x*x-i-1, x*x+1);
            }

            //openTable to memorize the index has been opened
            boolean openTable[][] =new boolean[x][x];

            while ((line = br.readLine()) != null)
            {
                           String[] data = line.split("","");
                        //  int [] coordinate = {0.0};
                          int xCor =Integer.parseInt(data[0])-1;
                           int yCor= Integer.parseInt(data[1])-1;
                           openTable[xCor][yCor] = true;
                           connect(x, xCor, yCor, openTable, table );
                           
                           if (table. connected(x*x, x*x+1))
                           {
                                System.out.print(xCor+1+"","" +(yCor+1)+""\n"");
                                break;
                           }
            }

            
 
            
            


        }
    }
}

@155155de9ba9a8c21c63beb7e8bf1edf@"
"r03222054","0","0.81","104704","@6ced4cdb577243e435e8f3102fdcbd51@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.UF;
import edu.princeton.cs.algs4.StdIn;

public class Percolation {
    
public  static int  xyToN(int x,int y,int size)
 {
     int index = 0;
     
     index = size *y+x;
     
     
     return index;
 }
    
 public static void connect(int x, int xCor, int yCor, boolean[][] check,UF uf )
 {

     if (xCor != 0)
     {
         if(check[xCor-1][yCor])
         {
              int neighbor =  xyToN(xCor-1, yCor, x);
              int center= xyToN(xCor,yCor, x);
              if (!uf.connected(neighbor, center))
              {
              uf.union(neighbor, center);
              connect(x,xCor-1, yCor,check,uf);
              }
        }
     }
     
     if (xCor !=x-1)
     {
         
          if(check[xCor+1][yCor])
         {
              int neighbor =  xyToN(xCor+1, yCor, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor+1, yCor,check,uf);
               }
        }
     }
     
     if(yCor != 0)
     {
            if(check[xCor][yCor-1])
         {
              int neighbor =  xyToN(xCor, yCor-1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor-1,check,uf);
               }
        }
     }
            
     if (yCor != x-1)
     {
               if(check[xCor][yCor+1])
         {
              int neighbor =  xyToN(xCor, yCor+1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor+1,check,uf);
               }
        }
     }

    
 }
  


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int x = Integer.parseInt(br.readLine());
              
              String line;
            
              
              //table to record the union(the root)
             int size = x*x+2;
            UF table= new UF (size);
//            for ( int i =0; i<x; i++)
//            {
//                table.union(i, x*x);
//                table.union(x*x-i-1, x*x+1);
//            }

            //openTable to memorize the index has been opened
            boolean openTable[][] =new boolean[x][x];

            while ((line = br.readLine()) != null)
            {
                           String[] data = line.split("","");
                        //  int [] coordinate = {0.0};
                          int xCor =Integer.parseInt(data[0])-1;
                           int yCor= Integer.parseInt(data[1])-1;
                           openTable[xCor][yCor] = true;
                           if(xCor ==0)
                           {
                               table.union(yCor, size-2);
                           }
                           
                            if(xCor ==x-1)
                           {
                               table.union(yCor+x*(x-1), size-1);
                           }
                           
                           connect(x, xCor, yCor, openTable, table );
                           
                           if (table. connected(x*x, x*x+1))
                           {
                                System.out.print(xCor+1+"","" +(yCor+1)+""\n"");
                                break;
                           }
            }

            
 
            
            


        }
    }
}

@6ced4cdb577243e435e8f3102fdcbd51@"
"r03222054","0","0.81","104704","@de19763a6954f6af501bde9a28cd012f@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.StdIn;

public class Percolation {
    
public  static int  xyToN(int x,int y,int size)
 {
     int index = 0;
     
     index = size *y+x;
     
     
     return index;
 }
    
 public static void connect(int x, int xCor, int yCor, boolean[][] check,UF uf )
 {

     if (xCor != 0)
     {
         if(check[xCor-1][yCor])
         {
              int neighbor =  xyToN(xCor-1, yCor, x);
              int center= xyToN(xCor,yCor, x);
              if (!uf.connected(neighbor, center))
              {
              uf.union(neighbor, center);
              connect(x,xCor-1, yCor,check,uf);
              }
        }
     }
     
     if (xCor !=x-1)
     {
         
          if(check[xCor+1][yCor])
         {
              int neighbor =  xyToN(xCor+1, yCor, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor+1, yCor,check,uf);
               }
        }
     }
     
     if(yCor != 0)
     {
            if(check[xCor][yCor-1])
         {
              int neighbor =  xyToN(xCor, yCor-1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor-1,check,uf);
               }
        }
     }
            
     if (yCor != x-1)
     {
               if(check[xCor][yCor+1])
         {
              int neighbor =  xyToN(xCor, yCor+1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor+1,check,uf);
               }
        }
     }

    
 }
  


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int x = Integer.parseInt(br.readLine());
              
              String line;
            
              
              //table to record the union(the root)
             int size = x*x+2;
            UF table= new UF (size);
//            for ( int i =0; i<x; i++)
//            {
//                table.union(i, x*x);
//                table.union(x*x-i-1, x*x+1);
//            }

            //openTable to memorize the index has been opened
            boolean openTable[][] =new boolean[x][x];

            while ((line = br.readLine()) != null)
            {
                           String[] data = line.split("","");
                        //  int [] coordinate = {0.0};
                          int xCor =Integer.parseInt(data[0])-1;
                           int yCor= Integer.parseInt(data[1])-1;
                           openTable[xCor][yCor] = true;
                           if(xCor ==0)
                           {
                               table.union(yCor, size-2);
                           }
                           
                            if(xCor ==x-1)
                           {
                               table.union(yCor+x*(x-1), size-1);
                           }
                           
                           connect(x, xCor, yCor, openTable, table );
                           
                           if (table. connected(x*x, x*x+1))
                           {
                                System.out.print(xCor+1+"","" +(yCor+1)+""\n"");
                                break;
                           }
            }

            
 
            
            


        }
    }
}

@de19763a6954f6af501bde9a28cd012f@"
"r03222054","3","1.04","122304","@de19763a6954f6af501bde9a28cd012f@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.StdIn;

public class Percolation {
    
public  static int  xyToN(int x,int y,int size)
 {
     int index = 0;
     
     index = size *y+x;
     
     
     return index;
 }
    
 public static void connect(int x, int xCor, int yCor, boolean[][] check,UF uf )
 {

     if (xCor != 0)
     {
         if(check[xCor-1][yCor])
         {
              int neighbor =  xyToN(xCor-1, yCor, x);
              int center= xyToN(xCor,yCor, x);
              if (!uf.connected(neighbor, center))
              {
              uf.union(neighbor, center);
              connect(x,xCor-1, yCor,check,uf);
              }
        }
     }
     
     if (xCor !=x-1)
     {
         
          if(check[xCor+1][yCor])
         {
              int neighbor =  xyToN(xCor+1, yCor, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor+1, yCor,check,uf);
               }
        }
     }
     
     if(yCor != 0)
     {
            if(check[xCor][yCor-1])
         {
              int neighbor =  xyToN(xCor, yCor-1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor-1,check,uf);
               }
        }
     }
            
     if (yCor != x-1)
     {
               if(check[xCor][yCor+1])
         {
              int neighbor =  xyToN(xCor, yCor+1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor+1,check,uf);
               }
        }
     }

    
 }
  


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int x = Integer.parseInt(br.readLine());
              
              String line;
            
              
              //table to record the union(the root)
             int size = x*x+2;
            UF table= new UF (size);
//            for ( int i =0; i<x; i++)
//            {
//                table.union(i, x*x);
//                table.union(x*x-i-1, x*x+1);
//            }

            //openTable to memorize the index has been opened
            boolean openTable[][] =new boolean[x][x];

            while ((line = br.readLine()) != null)
            {
                           String[] data = line.split("","");
                        //  int [] coordinate = {0.0};
                          int xCor =Integer.parseInt(data[0])-1;
                           int yCor= Integer.parseInt(data[1])-1;
                           openTable[xCor][yCor] = true;
                           if(xCor ==0)
                           {
                               table.union(yCor, size-2);
                           }
                           
                            if(xCor ==x-1)
                           {
                               table.union(yCor+x*(x-1), size-1);
                           }
                           
                           connect(x, xCor, yCor, openTable, table );
                           
                           if (table. connected(x*x, x*x+1))
                           {
                                System.out.print(xCor+1+"","" +(yCor+1)+""\n"");
                                break;
                           }
            }

            
 
            
            


        }
    }
}

@de19763a6954f6af501bde9a28cd012f@"
"r04447001","0","0.81","104704","@4414d1f7ce17db0ace34d6e573e2b2a5@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author jerry
 */
public class Percolation {
    public static void main(String[] args)throws Exception {

        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF uf = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0) uf.union((x2*N+y2), N*N);
        if(x2 == (N-1)) uf.union((x2*N+y2), N*N+1);
        if(checkbound(x2+1,N) && Statearray[(x2+1)][y2] == 1) uf.union(x2*N+y2, (x2+1)*N+y2);
        if(checkbound(y2+1,N) && Statearray[x2][(y2+1)] == 1) uf.union(x2*N+y2, x2*N+y2+1);
        if(checkbound(x2-1,N) && Statearray[(x2-1)][y2] == 1) uf.union(x2*N+y2, (x2-1)*N+y2);
        if(checkbound(y2-1,N) && Statearray[x2][(y2-1)] == 1) uf.union(x2*N+y2, x2*N+y2-1);
        
        if(uf.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        br.close();
        if(uf.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
        catch(Exception e){
        System.out.print(-1);
        }
    }
    public static boolean checkbound(int P,int Q){
    boolean result = true;
    if(P < 0 || P > (Q-1)) result = false;
    return result;
    }
}

@4414d1f7ce17db0ace34d6e573e2b2a5@"
"r04447001","0","0.81","104704","@8f6eb63b1422992bb4b8654c31087d01@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author jerry
 */
public class Percolation {
    public static void main(String[] args)throws Exception {

        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF uf = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0) uf.union((x2*N+y2), N*N);
        if(x2 == (N-1)) uf.union((x2*N+y2), N*N+1);
        if(checkbound(x2+1,N) && Statearray[(x2+1)][y2] == 1) uf.union(x2*N+y2, (x2+1)*N+y2);
        if(checkbound(y2+1,N) && Statearray[x2][(y2+1)] == 1) uf.union(x2*N+y2, x2*N+y2+1);
        if(checkbound(x2-1,N) && Statearray[(x2-1)][y2] == 1) uf.union(x2*N+y2, (x2-1)*N+y2);
        if(checkbound(y2-1,N) && Statearray[x2][(y2-1)] == 1) uf.union(x2*N+y2, x2*N+y2-1);
        
        if(uf.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        br.close();
        if(uf.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
        catch(Exception e){
        System.out.print(-1);
        }
    }
    public static boolean checkbound(int P,int Q){
    boolean result = true;
    if(P < 0 || P > (Q-1)) result = false;
    return result;
    }
}

@8f6eb63b1422992bb4b8654c31087d01@"
"r04447001","0","0.81","104704","@4414d1f7ce17db0ace34d6e573e2b2a5@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author jerry
 */
public class Percolation {
    public static void main(String[] args)throws Exception {

        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF uf = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0) uf.union((x2*N+y2), N*N);
        if(x2 == (N-1)) uf.union((x2*N+y2), N*N+1);
        if(checkbound(x2+1,N) && Statearray[(x2+1)][y2] == 1) uf.union(x2*N+y2, (x2+1)*N+y2);
        if(checkbound(y2+1,N) && Statearray[x2][(y2+1)] == 1) uf.union(x2*N+y2, x2*N+y2+1);
        if(checkbound(x2-1,N) && Statearray[(x2-1)][y2] == 1) uf.union(x2*N+y2, (x2-1)*N+y2);
        if(checkbound(y2-1,N) && Statearray[x2][(y2-1)] == 1) uf.union(x2*N+y2, x2*N+y2-1);
        
        if(uf.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        br.close();
        if(uf.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
        catch(Exception e){
        System.out.print(-1);
        }
    }
    public static boolean checkbound(int P,int Q){
    boolean result = true;
    if(P < 0 || P > (Q-1)) result = false;
    return result;
    }
}

@4414d1f7ce17db0ace34d6e573e2b2a5@"
"r04447001","10","0.107","121888","@8f6eb63b1422992bb4b8654c31087d01@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author jerry
 */
public class Percolation {
    public static void main(String[] args)throws Exception {

        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        int N = Integer.parseInt(data);
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        UF uf = new UF(N*N+2);//create new UF, 2 digits for top and bottum cluster
        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 1; // open this site
        if(x2 == 0) uf.union((x2*N+y2), N*N);
        if(x2 == (N-1)) uf.union((x2*N+y2), N*N+1);
        if(checkbound(x2+1,N) && Statearray[(x2+1)][y2] == 1) uf.union(x2*N+y2, (x2+1)*N+y2);
        if(checkbound(y2+1,N) && Statearray[x2][(y2+1)] == 1) uf.union(x2*N+y2, x2*N+y2+1);
        if(checkbound(x2-1,N) && Statearray[(x2-1)][y2] == 1) uf.union(x2*N+y2, (x2-1)*N+y2);
        if(checkbound(y2-1,N) && Statearray[x2][(y2-1)] == 1) uf.union(x2*N+y2, x2*N+y2-1);
        
        if(uf.connected(N*N, (N*N+1))) {
        System.out.print(x+"",""+y);
        break;
        }
        }
        br.close();
        if(uf.connected(N*N, (N*N+1))){}
        else{System.out.print(-1);}
        }
        catch(Exception e){
        System.out.print(-1);
        }
    }
    public static boolean checkbound(int P,int Q){
    boolean result = true;
    if(P < 0 || P > (Q-1)) result = false;
    return result;
    }
}

@8f6eb63b1422992bb4b8654c31087d01@"
"r04942099","9","1.11","153584","@84793b0d0107ad6f4d87d1dc3e7cde2d@import java.io.FileReader;
import java.io.BufferedReader;



public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String data = br.readLine();

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            
           
            //System.out.println(size);  //N by N grid
            //System.out.println(num);  //print出file.txt內的行數
            
            int identity =0;
            int[] line = new int[size*size+2];
            int[] lineopen = new int[size*size+2];

            for (int i = 0; i < size*size+2; ++i) {
                    lineopen[i]=0;
                    line[i] = identity;
                    ++identity;
            }
            lineopen[0] = 0;  //upper pseudo node
            lineopen[size*size+1] = 1; // lower pseudo node
            int percolation = 0;
            UF wei = new UF(size*size+2);
            int test=0;
            for(int i = 0;i<num;i++){
                test = (match[i][0]-1)*size+match[i][1];
                lineopen[test]=1;
                
                if(test-size<1){
                    wei.union(line[test], line[0]);
                }
                else{
                    if(lineopen[test-size]==1) wei.union(line[test], line[test-size]);
                }
                
                if(test+size>size*size){
                    wei.union(line[test], line[size*size+1]);
                }
                else{
                    if(lineopen[test+size]==1) wei.union(line[test], line[test+size]);
                }
                
                if(test%size!=1){
                    if(lineopen[test-1]==1) wei.union(line[test], line[test-1]);
                }
                
                if(test%size!=0){
                    if(lineopen[test+1]==1) wei.union(line[test], line[test+1]);
                }
                
               
                
                if(wei.connected(line[0], line[size*size+1])==true){
                    System.out.println(match[i][0]+"",""+match[i][1]);
                    percolation = 1;
                    break;
                }
                
            }
           

          if(percolation==0){
              System.out.println(-1);
          }


        }

    }
}

@84793b0d0107ad6f4d87d1dc3e7cde2d@"
"r04942099","0","0.81","104704","@fb59ae97d8bf4dad68a4287f8ff3ed39@import java.io.FileReader;
import java.io.BufferedReader;



public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String data = br.readLine();

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            
           
            //System.out.println(size);  //N by N grid
            //System.out.println(num);  //print出file.txt內的行數
            
            int identity =0;
            int[] line = new int[size*size+2];
            int[] lineopen = new int[size*size+2];

            for (int i = 0; i < size*size+2; ++i) {
                    lineopen[i]=0;
                    line[i] = identity;
                    ++identity;
            }
            lineopen[0] = 0;  //upper pseudo node
            lineopen[size*size+1] = 1; // lower pseudo node
            int percolation = 0;
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size*size+2);
            int test=0;
            for(int i = 0;i<num;i++){
                test = (match[i][0]-1)*size+match[i][1];
                lineopen[test]=1;
                
                if(test-size<1){
                    wei.union(line[test], line[0]);
                }
                else{
                    if(lineopen[test-size]==1) wei.union(line[test], line[test-size]);
                }
                
                if(test+size>size*size){
                    wei.union(line[test], line[size*size+1]);
                }
                else{
                    if(lineopen[test+size]==1) wei.union(line[test], line[test+size]);
                }
                
                if(test%size!=1){
                    if(lineopen[test-1]==1) wei.union(line[test], line[test-1]);
                }
                
                if(test%size!=0){
                    if(lineopen[test+1]==1) wei.union(line[test], line[test+1]);
                }
                
               
                
                if(wei.connected(line[0], line[size*size+1])==true){
                    System.out.println(match[i][0]+"",""+match[i][1]);
                    percolation = 1;
                    break;
                }
                
            }
           

          if(percolation==0){
              System.out.println(-1);
          }


        }

    }
}

@fb59ae97d8bf4dad68a4287f8ff3ed39@"
"r03222054","5","1.1","119328","@e8b80fe9b642ba6179243eabd1bc9e52@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.StdIn;

public class Percolation {
    
public  static int  xyToN(int x,int y,int size)
 {
     int index = 0;
     
     index = size *x+y;
     
     
     return index;
 }
    
 public static void connect(int x, int xCor, int yCor, boolean[][] check,UF uf )
 {

     if (xCor != 0)
     {
         if(check[xCor-1][yCor])
         {
              int neighbor =  xyToN(xCor-1, yCor, x);
              int center= xyToN(xCor,yCor, x);
              if (!uf.connected(neighbor, center))
              {
              uf.union(neighbor, center);
              connect(x,xCor-1, yCor,check,uf);
              }
        }
     }
     
     if (xCor !=x-1)
     {
         
          if(check[xCor+1][yCor])
         {
              int neighbor =  xyToN(xCor+1, yCor, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor+1, yCor,check,uf);
               }
        }
     }
     
     if(yCor != 0)
     {
            if(check[xCor][yCor-1])
         {
              int neighbor =  xyToN(xCor, yCor-1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor-1,check,uf);
               }
        }
     }
            
     if (yCor != x-1)
     {
               if(check[xCor][yCor+1])
         {
              int neighbor =  xyToN(xCor, yCor+1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor+1,check,uf);
               }
        }
     }

    
 }
  


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int x = Integer.parseInt(br.readLine());
              
              String line;
            
              
              //table to record the union(the root)
             int size = x*x+2;
            UF table= new UF (size);
            boolean openTable[][] =new boolean[x][x];

            while ((line = br.readLine()) != null)
            {
                           String[] data = line.split("","");
                        //  int [] coordinate = {0.0};
                          int xCor =Integer.parseInt(data[0])-1;
                           int yCor= Integer.parseInt(data[1])-1;
                           openTable[xCor][yCor] = true;
                           if(xCor ==0)
                           {
                               table.union(yCor, size-2);
                           }
                           
                            if(xCor ==x-1)
                           {
                               table.union(yCor+x*(x-1), size-1);
                           }
                           
                           connect(x, xCor, yCor, openTable, table );
                          
                           
                           
                           if (table. connected(x*x, x*x+1))
                           {
                                System.out.print(xCor+1+"","" +(yCor+1)+""\n"");
                                break;
                           }
            }

            
// 
//            for( int i=0; i<x*x+2; i++)
//                System.out.print(table.find(i)+""\n"");
            
            


        }
    }
}

@e8b80fe9b642ba6179243eabd1bc9e52@"
"r04942099","9","1.22","152624","@97115e498db6949f5aafc8776880d3c2@import java.io.FileReader;
import java.io.BufferedReader;



public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String data = br.readLine();

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            
           
            //System.out.println(size);  //N by N grid
            //System.out.println(num);  //print出file.txt內的行數
            
            int identity =0;
            int[] line = new int[size*size+2];
            int[] lineopen = new int[size*size+2];

            for (int i = 0; i < size*size+2; ++i) {
                    lineopen[i]=0;
                    line[i] = identity;
                    ++identity;
            }
            lineopen[0] = 0;  //upper pseudo node
            lineopen[size*size+1] = 1; // lower pseudo node
            int percolation = 0;
            QuickFindUF wei = new QuickFindUF(size*size+2);
            int test=0;
            for(int i = 0;i<num;i++){
                test = (match[i][0]-1)*size+match[i][1];
                lineopen[test]=1;
                
                if(test-size<1){
                    wei.union(line[test], line[0]);
                }
                else{
                    if(lineopen[test-size]==1) wei.union(line[test], line[test-size]);
                }
                
                if(test+size>size*size){
                    wei.union(line[test], line[size*size+1]);
                }
                else{
                    if(lineopen[test+size]==1) wei.union(line[test], line[test+size]);
                }
                
                if(test%size!=1){
                    if(lineopen[test-1]==1) wei.union(line[test], line[test-1]);
                }
                
                if(test%size!=0){
                    if(lineopen[test+1]==1) wei.union(line[test], line[test+1]);
                }
                
               
                
                if(wei.connected(line[0], line[size*size+1])==true){
                    System.out.println(match[i][0]+"",""+match[i][1]);
                    percolation = 1;
                    break;
                }
                
            }
           

          if(percolation==0){
              System.out.println(-1);
          }


        }

    }
}

@97115e498db6949f5aafc8776880d3c2@"
"r04942099","10","0.211","164400","@2e04c1551c750894250db2a593ad77be@import java.io.FileReader;
import java.io.BufferedReader;



public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String data = br.readLine();

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            
           
            //System.out.println(size);  //N by N grid
            //System.out.println(num);  //print出file.txt內的行數
            
            int identity =0;
            int[] line = new int[size*size+2];
            int[] lineopen = new int[size*size+2];

            for (int i = 0; i < size*size+2; ++i) {
                    lineopen[i]=0;
                    line[i] = identity;
                    ++identity;
            }
            lineopen[0] = 0;  //upper pseudo node
            lineopen[size*size+1] = 1; // lower pseudo node
            int percolation = 0;
            QuickFindUF wei = new QuickFindUF(size*size+2);
            int test=0;
            for(int i = 0;i<num;i++){
                test = (match[i][0]-1)*size+match[i][1];
                lineopen[test]=1;
                
                if(test-size<1){
                    wei.union(line[test], line[0]);
                }
                else{
                    if(lineopen[test-size]==1) wei.union(line[test], line[test-size]);
                }
                
                if(test+size>size*size){
                    wei.union(line[test], line[size*size+1]);
                }
                else{
                    if(lineopen[test+size]==1) wei.union(line[test], line[test+size]);
                }
                
                if(test%size!=1){
                    if(lineopen[test-1]==1) wei.union(line[test], line[test-1]);
                }
                
                if(test%size!=0){
                    if(lineopen[test+1]==1) wei.union(line[test], line[test+1]);
                }
                
               
                
                if(wei.connected(line[0], line[size*size+1])==true){
                    System.out.println(match[i][0]+"",""+match[i][1]);
                    percolation = 1;
                    break;
                }
                
            }
           

          if(percolation==0){
              System.out.println(""-1"");
          }


        }

    }
}

@2e04c1551c750894250db2a593ad77be@"
"r03222054","0","0.74","103920","@aa155c5f13011884750659af73a3a538@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.UF;
import edu.princeton.cs.algs4.StdIn;

public class Percolation {
    
public  static int  xyToN(int x,int y,int size)
 {
     int index = 0;
     index = size *x+y;
     return index;
 }
    
 public static void connect(int x, int xCor, int yCor, boolean[][] check,UF uf )
 {

     if (xCor != 0)
     {
         if(check[xCor-1][yCor])
         {
              int neighbor =  xyToN(xCor-1, yCor, x);
              int center= xyToN(xCor,yCor, x);
              if (!uf.connected(neighbor, center))
              {
              uf.union(neighbor, center);
              connect(x,xCor-1, yCor,check,uf);
              }
        }
     }
     
     if (xCor !=x-1)
     {
         
          if(check[xCor+1][yCor])
         {
              int neighbor =  xyToN(xCor+1, yCor, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor+1, yCor,check,uf);
               }
        }
     }
     
     if(yCor != 0)
     {
            if(check[xCor][yCor-1])
         {
              int neighbor =  xyToN(xCor, yCor-1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor-1,check,uf);
               }
        }
     }
            
     if (yCor != x-1)
     {
               if(check[xCor][yCor+1])
         {
              int neighbor =  xyToN(xCor, yCor+1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor+1,check,uf);
               }
        }
     }

    
 }
  


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int x = Integer.parseInt(br.readLine());
              
              String line;
            
              
              //table to record the union(the root)
             int size = x*x+2;
            UF table= new UF (size);
            boolean openTable[][] =new boolean[x][x];

            while ((line = br.readLine()) != null)
            {
                           String[] data = line.split("","");
                        //  int [] coordinate = {0.0};
                          int xCor =Integer.parseInt(data[0])-1;
                           int yCor= Integer.parseInt(data[1])-1;
                           openTable[xCor][yCor] = true;
                           if(xCor ==0)
                           {
                               table.union(yCor, size-2);
                           }
                           
                            if(xCor ==x-1)
                           {
                               table.union(yCor+x*(x-1), size-1);
                           }
                           
                           connect(x, xCor, yCor, openTable, table );
                       
                           if (table. connected(x*x, x*x+1))
                           {
                                System.out.print(xCor+1+"","" +(yCor+1)+""\n"");
                                break;
                           }
            }
                  if (table. connected(x*x, x*x+1))
                           {
                               System.out.print(""-1"");
                           }   


        }
                          
    }
}

@aa155c5f13011884750659af73a3a538@"
"r03222054","0","1.1","126176","@7e3fd9dbadb62a8d984b8a158efa7851@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.StdIn;

public class Percolation {
    
public  static int  xyToN(int x,int y,int size)
 {
     int index = 0;
     index = size *x+y;
     return index;
 }
    
 public static void connect(int x, int xCor, int yCor, boolean[][] check,UF uf )
 {

     if (xCor != 0)
     {
         if(check[xCor-1][yCor])
         {
              int neighbor =  xyToN(xCor-1, yCor, x);
              int center= xyToN(xCor,yCor, x);
              if (!uf.connected(neighbor, center))
              {
              uf.union(neighbor, center);
              connect(x,xCor-1, yCor,check,uf);
              }
        }
     }
     
     if (xCor !=x-1)
     {
         
          if(check[xCor+1][yCor])
         {
              int neighbor =  xyToN(xCor+1, yCor, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor+1, yCor,check,uf);
               }
        }
     }
     
     if(yCor != 0)
     {
            if(check[xCor][yCor-1])
         {
              int neighbor =  xyToN(xCor, yCor-1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor-1,check,uf);
               }
        }
     }
            
     if (yCor != x-1)
     {
               if(check[xCor][yCor+1])
         {
              int neighbor =  xyToN(xCor, yCor+1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor+1,check,uf);
               }
        }
     }

    
 }
  


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int x = Integer.parseInt(br.readLine());
              
              String line;
            
              
              //table to record the union(the root)
             int size = x*x+2;
            UF table= new UF (size);
            boolean openTable[][] =new boolean[x][x];

            while ((line = br.readLine()) != null)
            {
                           String[] data = line.split("","");
                        //  int [] coordinate = {0.0};
                          int xCor =Integer.parseInt(data[0])-1;
                           int yCor= Integer.parseInt(data[1])-1;
                           openTable[xCor][yCor] = true;
                           if(xCor ==0)
                           {
                               table.union(yCor, size-2);
                           }
                           
                            if(xCor ==x-1)
                           {
                               table.union(yCor+x*(x-1), size-1);
                           }
                           
                           connect(x, xCor, yCor, openTable, table );
                       
                           if (table. connected(x*x, x*x+1))
                           {
                                System.out.print(xCor+1+"","" +(yCor+1)+""\n"");
                                break;
                           }
            }
                  if (table. connected(x*x, x*x+1))
                           {
                               System.out.print(""-1"");
                           }   


        }
                          
    }
}

@7e3fd9dbadb62a8d984b8a158efa7851@"
"r03222054","10","0.107","120720","@aff8c17841fc116f409f5698e3d35015@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;
//import edu.princeton.cs.algs4.StdIn;

public class Percolation {
    
public  static int  xyToN(int x,int y,int size)
 {
     int index = 0;
     index = size *x+y;
     return index;
 }
    
 public static void connect(int x, int xCor, int yCor, boolean[][] check,UF uf )
 {

     if (xCor != 0)
     {
         if(check[xCor-1][yCor])
         {
              int neighbor =  xyToN(xCor-1, yCor, x);
              int center= xyToN(xCor,yCor, x);
              if (!uf.connected(neighbor, center))
              {
              uf.union(neighbor, center);
              connect(x,xCor-1, yCor,check,uf);
              }
        }
     }
     
     if (xCor !=x-1)
     {
         
          if(check[xCor+1][yCor])
         {
              int neighbor =  xyToN(xCor+1, yCor, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor+1, yCor,check,uf);
               }
        }
     }
     
     if(yCor != 0)
     {
            if(check[xCor][yCor-1])
         {
              int neighbor =  xyToN(xCor, yCor-1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor-1,check,uf);
               }
        }
     }
            
     if (yCor != x-1)
     {
               if(check[xCor][yCor+1])
         {
              int neighbor =  xyToN(xCor, yCor+1, x);
              int center= xyToN(xCor,yCor, x);
               if (!uf.connected(neighbor, center))
               {
              uf.union(neighbor, center);
              connect(x,xCor, yCor+1,check,uf);
               }
        }
     }

    
 }
  


    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int x = Integer.parseInt(br.readLine());
              
              String line;
            
              
              //table to record the union(the root)
             int size = x*x+2;
            UF table= new UF (size);
            boolean openTable[][] =new boolean[x][x];

            while ((line = br.readLine()) != null)
            {
                           String[] data = line.split("","");
                        //  int [] coordinate = {0.0};
                          int xCor =Integer.parseInt(data[0])-1;
                           int yCor= Integer.parseInt(data[1])-1;
                           openTable[xCor][yCor] = true;
                           if(xCor ==0)
                           {
                               table.union(yCor, size-2);
                           }
                           
                            if(xCor ==x-1)
                           {
                               table.union(yCor+x*(x-1), size-1);
                           }
                           
                           connect(x, xCor, yCor, openTable, table );
                       
                           if (table. connected(x*x, x*x+1))
                           {
                                System.out.print(xCor+1+"","" +(yCor+1)+""\n"");
                                break;
                           }
            }
                  if (!table. connected(x*x, x*x+1))
                           {
                               System.out.print(""-1"");
                           }   


        }
                          
    }
}

@aff8c17841fc116f409f5698e3d35015@"
"r04921051","5","1.06","124208","@36fdc59cf28df205e39ef2374883506a@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String data = br.readLine();
            
            // store the first integer in variable stringCount (number of announced strings)
            int dimension = Integer.parseInt(data);
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            UF uf = new UF(dimension*dimension+2);
            //unuion the top to uf[dimension*dimension]
            for(int i = 0; i < dimension; i++){
                uf.union(i, dimension*dimension);
            }            
            //unuion the buttom to uf[dimension*dimension+1]
            for(int i = 0; i < dimension; i++){
                uf.union(dimension*(dimension-1) + i, dimension*dimension+1);
            }      
            
            int x,y;

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                
                matrix[x][y] = 1;     
                
                //up
                if((x-1 >= 0) && (matrix[x-1][y]==1))
                   uf.union(dimension*x + y, dimension*(x-1) + y); 
                
                //down
                if((x+1 < dimension) && (matrix[x+1][y]==1))
                   uf.union(dimension*x + y, dimension*(x+1) + y);
                
                //left
                if((y-1 >= 0) && (matrix[x][y-1]==1))
                   uf.union(dimension*x + y, dimension*x + y-1);
                
                //up
                if((y+1 < dimension) && (matrix[x][y+1]==1))
                   uf.union(dimension*x + y, dimension*x + y+1); 
                
                if(uf.connected(dimension*dimension,dimension*dimension+1)){
                    System.out.printf(""%d,%d"",x+1,y+1);
                    break;
                }
                
            }
          
            //print(dimension,matrix);
            
                }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@36fdc59cf28df205e39ef2374883506a@"
"b03611023","0","0.078","102096","@c3e88f2b5da61c264a4f6dc2ac3c4671@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
        

   
    
    
   
    
    

   
    
    
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
            
            
            String[] N = br.readLine().split("","");
            // n*n matrix
            String buffer ;
            String gg = """";
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            
            int[][] matrix = new int[n+2][n+2];
            
            UF uf = new UF(n*n+2);
            //top id = n*n bottom id = n*n+1
            
            

            int i = 0;
            int j = 0;
           String[] data;
           buffer = br.readLine();
           while(buffer!=null){
           gg = gg.concat(buffer);
           i++;
           buffer = br.readLine();
           }
           
           String ngg =  gg.replaceAll("","", """");        
            //System.out.println(ngg);
            int L = ngg.length();
            int[] Data = new int[L];
            for(j = 0;j<L;j++){
             Data[j] = Integer.parseInt(ngg.substring(j, j+1));
            // System.out.print(Data[j]);
            }
            for(j = 0; j<L ; j+=2){
                int a = Data[j];
                int b =Data[j+1];
                matrix[a][b] = 1;
            if(a == 1){
                uf.union(n*n, b-1);
                //System.out.print(uf.find((a-1)*n+b-1));
            }    
            if(a == n){
            uf.union(n*n+1, (a-1)*n+b-1);
            //System.out.print(uf.find((a-1)*n+b-1));
            }
           if(a<n+1 && b<n+1 && matrix[a][b+1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b);
           }  
           if(a<n+1 && b<n+1 && matrix[a][b-1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b-2);
           } 
           if(a<n+1 && b<n+1 && matrix[a+1][b] == 1){
           uf.union((a-1)*n+b-1, a*n+b-1);
           } 
           if(a<n+1 && b<n+1 && matrix[a-1][b] == 1){
           uf.union((a-1)*n+b-1, (a-2)*n+b-1);
           } 
            if(uf.connected(n*n, n*n+1)){
            System.out.print(a);
            System.out.print("","");
            System.out.print(b);
            break;            
            }
            }
            if(!uf.connected(n*n, n*n+1)){
            System.out.print(-1);
            }
            
            
           
          
            
            
           /* buffer = br.readLine();
            while (buffer != null) {
                data = buffer.split("","");
                i++;
              for (String printStr : data) {                 
                    System.out.print(printStr);         捲                                                       
                }
                buffer = br.readLine();       
            }*/
        
        
        
           
           
              
              
            
                
            }
            
                      
    }   
}

@c3e88f2b5da61c264a4f6dc2ac3c4671@"
"r03849033","3","0.57","126448","@c0295930b9c9bb3307c4fd75caafe06e@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            for (int i = 0; i < N * N; i++){
                if (br.readLine() == null ){
                    break;        
                }        
                String[] da = br.readLine().split("","");
                int p = Integer.parseInt(da[0]);
                int q = Integer.parseInt(da[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }               
            }
            if (percolation.percolates()==false){
                StdOut.println(""-1"");
            }            
        }
    }
}

@c0295930b9c9bb3307c4fd75caafe06e@"
"r04921051","10","0.106","122560","@40f054a1218621c1481bb95789e15096@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String data = br.readLine();
            
            // store the first integer in variable stringCount (number of announced strings)
            int dimension = Integer.parseInt(data);
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            UF uf = new UF(dimension*dimension+2);
            //unuion the top to uf[dimension*dimension]
            for(int i = 0; i < dimension; i++){
                uf.union(i, dimension*dimension);
            }            
            //unuion the buttom to uf[dimension*dimension+1]
            for(int i = 0; i < dimension; i++){
                uf.union(dimension*(dimension-1) + i, dimension*dimension+1);
            }      
            
            int x,y;
            
            int flag = 0;

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                
                matrix[x][y] = 1;     
                
                //up
                if((x-1 >= 0) && (matrix[x-1][y]==1))
                   uf.union(dimension*x + y, dimension*(x-1) + y); 
                
                //down
                if((x+1 < dimension) && (matrix[x+1][y]==1))
                   uf.union(dimension*x + y, dimension*(x+1) + y);
                
                //left
                if((y-1 >= 0) && (matrix[x][y-1]==1))
                   uf.union(dimension*x + y, dimension*x + y-1);
                
                //up
                if((y+1 < dimension) && (matrix[x][y+1]==1))
                   uf.union(dimension*x + y, dimension*x + y+1); 
                
                if(uf.connected(dimension*dimension,dimension*dimension+1)){
                    System.out.printf(""%d,%d"",x+1,y+1);
                    flag = 1;
                    break;
                }
                
            }
        
            if (flag == 0){
                System.out.printf(""%d"",-1);
            }
            //print(dimension,matrix);
            
                }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@40f054a1218621c1481bb95789e15096@"
"b03611023","7","0.64","105680","@c3e88f2b5da61c264a4f6dc2ac3c4671@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
        

   
    
    
   
    
    

   
    
    
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
            
            
            String[] N = br.readLine().split("","");
            // n*n matrix
            String buffer ;
            String gg = """";
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            
            int[][] matrix = new int[n+2][n+2];
            
            UF uf = new UF(n*n+2);
            //top id = n*n bottom id = n*n+1
            
            

            int i = 0;
            int j = 0;
           String[] data;
           buffer = br.readLine();
           while(buffer!=null){
           gg = gg.concat(buffer);
           i++;
           buffer = br.readLine();
           }
           
           String ngg =  gg.replaceAll("","", """");        
            //System.out.println(ngg);
            int L = ngg.length();
            int[] Data = new int[L];
            for(j = 0;j<L;j++){
             Data[j] = Integer.parseInt(ngg.substring(j, j+1));
            // System.out.print(Data[j]);
            }
            for(j = 0; j<L ; j+=2){
                int a = Data[j];
                int b =Data[j+1];
                matrix[a][b] = 1;
            if(a == 1){
                uf.union(n*n, b-1);
                //System.out.print(uf.find((a-1)*n+b-1));
            }    
            if(a == n){
            uf.union(n*n+1, (a-1)*n+b-1);
            //System.out.print(uf.find((a-1)*n+b-1));
            }
           if(a<n+1 && b<n+1 && matrix[a][b+1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b);
           }  
           if(a<n+1 && b<n+1 && matrix[a][b-1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b-2);
           } 
           if(a<n+1 && b<n+1 && matrix[a+1][b] == 1){
           uf.union((a-1)*n+b-1, a*n+b-1);
           } 
           if(a<n+1 && b<n+1 && matrix[a-1][b] == 1){
           uf.union((a-1)*n+b-1, (a-2)*n+b-1);
           } 
            if(uf.connected(n*n, n*n+1)){
            System.out.print(a);
            System.out.print("","");
            System.out.print(b);
            break;            
            }
            }
            if(!uf.connected(n*n, n*n+1)){
            System.out.print(-1);
            }
            
            
           
          
            
            
           /* buffer = br.readLine();
            while (buffer != null) {
                data = buffer.split("","");
                i++;
              for (String printStr : data) {                 
                    System.out.print(printStr);         捲                                                       
                }
                buffer = br.readLine();       
            }*/
        
        
        
           
           
              
              
            
                
            }
            
                      
    }   
}

@c3e88f2b5da61c264a4f6dc2ac3c4671@"
"b03611023","7","0.67","105728","@c3e88f2b5da61c264a4f6dc2ac3c4671@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
        

   
    
    
   
    
    

   
    
    
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
            
            
            String[] N = br.readLine().split("","");
            // n*n matrix
            String buffer ;
            String gg = """";
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            
            int[][] matrix = new int[n+2][n+2];
            
            UF uf = new UF(n*n+2);
            //top id = n*n bottom id = n*n+1
            
            

            int i = 0;
            int j = 0;
           String[] data;
           buffer = br.readLine();
           while(buffer!=null){
           gg = gg.concat(buffer);
           i++;
           buffer = br.readLine();
           }
           
           String ngg =  gg.replaceAll("","", """");        
            //System.out.println(ngg);
            int L = ngg.length();
            int[] Data = new int[L];
            for(j = 0;j<L;j++){
             Data[j] = Integer.parseInt(ngg.substring(j, j+1));
            // System.out.print(Data[j]);
            }
            for(j = 0; j<L ; j+=2){
                int a = Data[j];
                int b =Data[j+1];
                matrix[a][b] = 1;
            if(a == 1){
                uf.union(n*n, b-1);
                //System.out.print(uf.find((a-1)*n+b-1));
            }    
            if(a == n){
            uf.union(n*n+1, (a-1)*n+b-1);
            //System.out.print(uf.find((a-1)*n+b-1));
            }
           if(a<n+1 && b<n+1 && matrix[a][b+1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b);
           }  
           if(a<n+1 && b<n+1 && matrix[a][b-1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b-2);
           } 
           if(a<n+1 && b<n+1 && matrix[a+1][b] == 1){
           uf.union((a-1)*n+b-1, a*n+b-1);
           } 
           if(a<n+1 && b<n+1 && matrix[a-1][b] == 1){
           uf.union((a-1)*n+b-1, (a-2)*n+b-1);
           } 
            if(uf.connected(n*n, n*n+1)){
            System.out.print(a);
            System.out.print("","");
            System.out.print(b);
            break;            
            }
            }
            if(!uf.connected(n*n, n*n+1)){
            System.out.print(-1);
            }
            
            
           
          
            
            
           /* buffer = br.readLine();
            while (buffer != null) {
                data = buffer.split("","");
                i++;
              for (String printStr : data) {                 
                    System.out.print(printStr);         捲                                                       
                }
                buffer = br.readLine();       
            }*/
        
        
        
           
           
              
              
            
                
            }
            
                      
    }   
}

@c3e88f2b5da61c264a4f6dc2ac3c4671@"
"r03849033","5","0.7","132048","@b691a4a8294be2cdeb5eeb202d63834d@

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            In in = new In(args[0]);
            while (!in.isEmpty()) {
                String[] da = br.readLine().split("","");
                int p = Integer.parseInt(da[0]);
                int q = Integer.parseInt(da[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }               
            }
            if (percolation.percolates()==false){
                StdOut.println(""-1"");
            }            
        }
    }
}

@b691a4a8294be2cdeb5eeb202d63834d@"
"r04546014","0","0.7","132048","@4daa03c453a599a890507a17789dcd60@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import edu.princeton.cs.algs4.UF;
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Jayden
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.valueOf(br.readLine());
            //檔案中第一個數告知為幾乘幾的矩陣
            int z=num*num;
            UF uf = new UF(z + 2);
            //此class用來儲存所對應的cc，而+2是為了讓第一個row和最後一個row多一個總結，如此判斷次數不用那麼多(和講義一樣的方法)
            byte[][] matrix = new byte[num][num];
            //定義出主要的matrix
            String[] announce = new String[2];
            int a = 0, b = 0,c=0;
            while (uf.find(z) != uf.find(z + 1)) {
                announce = br.readLine().split("","");
                if (announce[0].isEmpty()) {
                    c=1;
                    break;
                } 
                else {
                    a = Integer.valueOf(announce[0]);
                    b = Integer.valueOf(announce[1]);
                    matrix[a - 1][b - 1] = 1;
                    //翻轉成白色
                    if (a == 1) {
                        uf.union(b - 1, z);
                        if (matrix[a][b - 1] == 1) {
                            uf.union(b - 1, num + b - 1);
                            //連結他下面的數
                        }
                    } else if (a == num) {
                        uf.union(((num - 1) * num + b - 1), z + 1);
                        if (matrix[a - 2][b - 1] == 1) {
                            uf.union((num - 1) * num + b - 1, (num - 2) * num + b - 1);
                            //連結他上面的數
                        }
                    } else {
                        if (matrix[a - 2][b - 1] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 2) * num + b - 1);
                            //連結上面的數
                        }
                        if (matrix[a][b - 1] == 1) {
                            uf.union((a - 1) * num + b - 1, a * num + b - 1);
                            //連結下面的數
                        }
                    }
                    if (b == 1) {
                        if (matrix[a - 1][b] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                            //連結後面的數
                        }
                    } else if (b == num) {
                        if (matrix[a - 1][b - 2] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                            //連結前面的數
                        }
                    } else {
                        if (matrix[a - 1][b] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                        }
                        if (matrix[a - 1][b - 2] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                        }
                    }
                }

            }
            if(c==0){

            System.out.println(a + "","" + b);
            }
            else{
                System.out.println(-1);
            }
        }
    }

}

@4daa03c453a599a890507a17789dcd60@"
"r04546014","4","0.44","122192","@e1ea3f5b3bcdf12ef0ceb7cb36cfff25@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Jayden
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.valueOf(br.readLine());
            //檔案中第一個數告知為幾乘幾的矩陣
            int z=num*num;
            UF uf = new UF(z + 2);
            //此class用來儲存所對應的cc，而+2是為了讓第一個row和最後一個row多一個總結，如此判斷次數不用那麼多(和講義一樣的方法)
            byte[][] matrix = new byte[num][num];
            //定義出主要的matrix
            String[] announce = new String[2];
            int a = 0, b = 0,c=0;
            while (uf.find(z) != uf.find(z + 1)) {
                announce = br.readLine().split("","");
                if (announce[0].isEmpty()) {
                    c=1;
                    break;
                } 
                else {
                    a = Integer.valueOf(announce[0]);
                    b = Integer.valueOf(announce[1]);
                    matrix[a - 1][b - 1] = 1;
                    //翻轉成白色
                    if (a == 1) {
                        uf.union(b - 1, z);
                        if (matrix[a][b - 1] == 1) {
                            uf.union(b - 1, num + b - 1);
                            //連結他下面的數
                        }
                    } else if (a == num) {
                        uf.union(((num - 1) * num + b - 1), z + 1);
                        if (matrix[a - 2][b - 1] == 1) {
                            uf.union((num - 1) * num + b - 1, (num - 2) * num + b - 1);
                            //連結他上面的數
                        }
                    } else {
                        if (matrix[a - 2][b - 1] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 2) * num + b - 1);
                            //連結上面的數
                        }
                        if (matrix[a][b - 1] == 1) {
                            uf.union((a - 1) * num + b - 1, a * num + b - 1);
                            //連結下面的數
                        }
                    }
                    if (b == 1) {
                        if (matrix[a - 1][b] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                            //連結後面的數
                        }
                    } else if (b == num) {
                        if (matrix[a - 1][b - 2] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                            //連結前面的數
                        }
                    } else {
                        if (matrix[a - 1][b] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                        }
                        if (matrix[a - 1][b - 2] == 1) {
                            uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                        }
                    }
                }

            }
            if(c==0){

            System.out.println(a + "","" + b);
            }
            else{
                System.out.println(-1);
            }
        }
    }

}

@e1ea3f5b3bcdf12ef0ceb7cb36cfff25@"
"r04546032","0","1.05","141328","@fe6220e645ba32ceed4558d264881669@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    int [][]grid;
    public int size;
    int space = 0;
    int coordinates[];

    
    public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+2);//initializes the WQUUF data structure.
        this.grid = new int[N][N];
        coordinates = new int[spaces+2];
            int count = 0;
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = count;
                     count++;
                 }
             }
        for(int i = 0; i < spaces+2;i++)
        {
            coordinates[i] = i;
        }
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N+2;i++)
        {
          wuf.union(i,i);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(grid[i][j]!=-1)
        {
          this.grid[i][j]=-1;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
      if(grid[i][j] != -1)
      {
          return false;
      }
      return true;
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */


  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    if(wuf.connected(coordinates[size*size], coordinates[size*size+1]) == true)
    {
          return true;
    }
    return false;
  }//end percolates
    
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
             while((line = br.readLine())!= null)
             {
                data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
           //先upper virtual的相連
            for(int a = 0; a < N;a++)
            {
                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
            }
            //lower virtual connect
             for(int b = N*(N-1); b < N*N-1;b++)
            {
                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
            }
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
            int X =temp2[i+2];
            int Y = temp2[j+2];
//            perc.open(x,y);
//            perc.open(X, Y);
            
         
            perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
          
            
            i+=2;
            j+=2;
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(temp2[i]+"",""+temp2[j]);
                break;
            }
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@fe6220e645ba32ceed4558d264881669@"
"r04546014","9","0.92","125568","@81a557c279970c4979eca7c76870443e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Jayden
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.valueOf(br.readLine());
            //檔案中第一個數告知為幾乘幾的矩陣
            int z = num * num;
            UF uf = new UF(z + 2);
            //此class用來儲存所對應的cc，而+2是為了讓第一個row和最後一個row多一個總結，如此判斷次數不用那麼多(和講義一樣的方法)
            byte[][] matrix = new byte[num][num];
            //定義出主要的matrix
            String[] announce = new String[2];
            int a = 0, b = 0;
            while (uf.find(z) != uf.find(z + 1) && br.ready() == true) {
                announce = br.readLine().split("","");
                a = Integer.valueOf(announce[0]);
                b = Integer.valueOf(announce[1]);
                matrix[a - 1][b - 1] = 1;
                //翻轉成白色
                if (a == 1) {
                    uf.union(b - 1, z);
                    if (matrix[a][b - 1] == 1) {
                        uf.union(b - 1, num + b - 1);
                        //連結他下面的數
                    }
                } else if (a == num) {
                    uf.union(((num - 1) * num + b - 1), z + 1);
                    if (matrix[a - 2][b - 1] == 1) {
                        uf.union((num - 1) * num + b - 1, (num - 2) * num + b - 1);
                        //連結他上面的數
                    }
                } else {
                    if (matrix[a - 2][b - 1] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 2) * num + b - 1);
                        //連結上面的數
                    }
                    if (matrix[a][b - 1] == 1) {
                        uf.union((a - 1) * num + b - 1, a * num + b - 1);
                        //連結下面的數
                    }
                }
                if (b == 1) {
                    if (matrix[a - 1][b] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                        //連結後面的數
                    }
                } else if (b == num) {
                    if (matrix[a - 1][b - 2] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                        //連結前面的數
                    }
                } else {
                    if (matrix[a - 1][b] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                    }
                    if (matrix[a - 1][b - 2] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                    }
                }
            }

            if (uf.find(z) == uf.find(z + 1)) {

                System.out.println(a + "","" + b);
            } else {
                System.out.println(-1);
            }
        }
    }

}

@81a557c279970c4979eca7c76870443e@"
"r04546014","0","0.81","104208","@6d386abc23eb7c7d7a241dbb066ec1d0@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Jayden
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.valueOf(br.readLine());
            //檔案中第一個數告知為幾乘幾的矩陣            
            int z = num * num;
            UF uf = new UF(z + 2);
            //此class用來儲存所對應的cc，而+2是為了讓第一個row和最後一個row多一個總結，如此判斷次數不用那麼多(和講義一樣的方法)
            byte[][] matrix = new byte[num][num];
            //定義出主要的matrix
            String[] announce = new String[2];
            int a = 0, b = 0;
            if(num==1&&br.ready()==true){
                System.out.println(1+"",""+1);
                System.exit(0);
            }            
            while (uf.find(z) != uf.find(z + 1) && br.ready() == true) {
                announce = br.readLine().split("","");
                a = Integer.valueOf(announce[0]);
                b = Integer.valueOf(announce[1]);
                matrix[a - 1][b - 1] = 1;
                //翻轉成白色
                if (a == 1) {
                    uf.union(b - 1, z);
                    if (matrix[a][b - 1] == 1) {
                        uf.union(b - 1, num + b - 1);
                        //連結他下面的數
                    }
                } else if (a == num) {
                    uf.union(((num - 1) * num + b - 1), z + 1);
                    if (matrix[a - 2][b - 1] == 1) {
                        uf.union((num - 1) * num + b - 1, (num - 2) * num + b - 1);
                        //連結他上面的數
                    }
                } else {
                    if (matrix[a - 2][b - 1] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 2) * num + b - 1);
                        //連結上面的數
                    }
                    if (matrix[a][b - 1] == 1) {
                        uf.union((a - 1) * num + b - 1, a * num + b - 1);
                        //連結下面的數
                    }
                }
                if (b == 1) {
                    if (matrix[a - 1][b] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                        //連結後面的數
                    }
                } else if (b == num) {
                    if (matrix[a - 1][b - 2] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                        //連結前面的數
                    }
                } else {
                    if (matrix[a - 1][b] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                    }
                    if (matrix[a - 1][b - 2] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                    }
                }
            }

            if (uf.find(z) == uf.find(z + 1)) {
                System.out.println(a + "","" + b);
            } else {
                System.out.println(-1);
            }
        }
    }

@6d386abc23eb7c7d7a241dbb066ec1d0@"
"r04546014","10","0.104","125408","@761146dce334c26138a24f2eaba071d1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Jayden
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int num = Integer.valueOf(br.readLine());
            //檔案中第一個數告知為幾乘幾的矩陣            
            int z = num * num;
            UF uf = new UF(z + 2);
            //此class用來儲存所對應的cc，而+2是為了讓第一個row和最後一個row多一個總結，如此判斷次數不用那麼多(和講義一樣的方法)
            byte[][] matrix = new byte[num][num];
            //定義出主要的matrix
            String[] announce = new String[2];
            int a = 0, b = 0;
            if(num==1&&br.ready()==true){
                System.out.println(1+"",""+1);
                System.exit(0);
            }            
            while (uf.find(z) != uf.find(z + 1) && br.ready() == true) {
                announce = br.readLine().split("","");
                a = Integer.valueOf(announce[0]);
                b = Integer.valueOf(announce[1]);
                matrix[a - 1][b - 1] = 1;
                //翻轉成白色
                if (a == 1) {
                    uf.union(b - 1, z);
                    if (matrix[a][b - 1] == 1) {
                        uf.union(b - 1, num + b - 1);
                        //連結他下面的數
                    }
                } else if (a == num) {
                    uf.union(((num - 1) * num + b - 1), z + 1);
                    if (matrix[a - 2][b - 1] == 1) {
                        uf.union((num - 1) * num + b - 1, (num - 2) * num + b - 1);
                        //連結他上面的數
                    }
                } else {
                    if (matrix[a - 2][b - 1] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 2) * num + b - 1);
                        //連結上面的數
                    }
                    if (matrix[a][b - 1] == 1) {
                        uf.union((a - 1) * num + b - 1, a * num + b - 1);
                        //連結下面的數
                    }
                }
                if (b == 1) {
                    if (matrix[a - 1][b] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                        //連結後面的數
                    }
                } else if (b == num) {
                    if (matrix[a - 1][b - 2] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                        //連結前面的數
                    }
                } else {
                    if (matrix[a - 1][b] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b);
                    }
                    if (matrix[a - 1][b - 2] == 1) {
                        uf.union((a - 1) * num + b - 1, (a - 1) * num + b - 2);
                    }
                }
            }

            if (uf.find(z) == uf.find(z + 1)) {
                System.out.println(a + "","" + b);
            } else {
                System.out.println(-1);
            }
        }
    }

}

@761146dce334c26138a24f2eaba071d1@"
"r04546032","1","1.05","139584","@15ca2d7e7017f900992d4c48bb55ba59@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    int [][]grid;
    public int size;
    int space = 0;
    int coordinates[];

    
    public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+2);//initializes the WQUUF data structure.
        this.grid = new int[N][N];
        coordinates = new int[spaces+2];
            int count = 0;
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = count;
                     count++;
                 }
             }
        for(int i = 0; i < spaces+2;i++)
        {
            coordinates[i] = i;
        }
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N+2;i++)
        {
          wuf.union(coordinates[i],coordinates[i]);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {
        if(grid[i][j]!=-1)
        {
          this.grid[i][j]=-1;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
      if(grid[i][j] != -1)
      {
          return false;
      }
      return true;
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */


  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    if(wuf.connected(coordinates[size*size], coordinates[size*size+1]) == true)
    {
          return true;
    }
    return false;
  }//end percolates
    
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
             while((line = br.readLine())!= null)
             {
                data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
           //先upper virtual的相連
            for(int a = 0; a < N;a++)
            {
                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
            }
            //lower virtual connect
             for(int b = N*(N-1); b < N*N-1;b++)
            {
                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
            }
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
            int X =temp2[i+2];
            int Y = temp2[j+2];
//            perc.open(x,y);
//            perc.open(X, Y);
            
         
            perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
          
            
            i+=2;
            j+=2;
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+"",""+j);
                break;
            }
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@15ca2d7e7017f900992d4c48bb55ba59@"
"r04921104","10","0.113","159216","@ecd0f6ee9c63a63777f7f6169597a450@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();

        try {
            br = new BufferedReader(new FileReader(args[0]));

            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[][] pairlist = new int[info.size() - 1][2];
        for (int i = 0; i < info.size() - 1; i++) {
            pairlist[i][0] = Integer.parseInt(info.get(i + 1)[0]);
            pairlist[i][1] = Integer.parseInt(info.get(i + 1)[1]);
            //System.out.println(pairlist[i][0]+ "" "" +pairlist[i][1]);
        }

        boolean[][] openloc = new boolean[size][size];
        //System.out.print(openloc[8]);

        UF uf = new UF(size * size + 2);
        for (int k = 0; k < size; k++) {
            uf.union(k, size * size);                //top row connect to visual top point
            uf.union(size * (size - 1) + k, size * size + 1);//bottom row connect to visual bottom point
        }

        search:
        {
            for (int i = 0; i < pairlist.length; i++) {
                openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1)] = true;
                //System.out.println((pairlist[i][0]-1) +"" ""+ (pairlist[i][1]-1));

                try {
                    if (openloc[(pairlist[i][0] - 1) - 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) - 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1) + 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) + 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) - 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) + 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) + 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }

                if (uf.connected(size * size, size * size + 1)) {
                    System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                    break search;
                }

                /*
                 for (int frc = 0; frc < size; frc++) {
                 if (openloc[0][frc]) {
                 for (int lrc = 0; lrc < size; lrc++) {
                 if (openloc[size - 1][lrc]) {
                 if (uf.connected(frc, (size - 1) * size + lrc)) {
                 System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                 break search;
                 }
                 }
                 }
                 }
                 }
                 */
            }
            System.out.println(-1);
        }

    }

}

@ecd0f6ee9c63a63777f7f6169597a450@"
"r04546032","1","0.19","105520","@836e8bd51847610eb9050a55aa63ea33@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    int [][]grid;
    public int size;
    int space = 0;
    int coordinates[];

    
    public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+2);//initializes the WQUUF data structure.
        this.grid = new int[N][N];
        coordinates = new int[spaces+2];
            int count = 0;
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = count;
                     count++;
                 }
             }
        for(int i = 0; i < spaces+2;i++)
        {
            coordinates[i] = i;
        }
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N+2;i++)
        {
          wuf.union(coordinates[i],coordinates[i]);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {
        if(grid[i][j]!=-1)
        {
          this.grid[i][j]=-1;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
      if(grid[i][j] != -1)
      {
          return false;
      }
      return true;
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */


  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    if(wuf.connected(coordinates[size*size], coordinates[size*size+1]) == true)
    {
          return true;
    }
    return false;
  }//end percolates
    
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
            int spaces=N*N-1;
            int space = 0;
             while((line = br.readLine())!= null)
             {
                data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
//           //先upper virtual的相連
//            for(int a = 0; a < N;a++)
//            {
//                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
//            }
//            //lower virtual connect
//             for(int b = N*(N-1); b < N*N-1;b++)
//            {
//                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
//            }
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
            int X =temp2[i+2];
            int Y = temp2[j+2];
//            perc.open(x,y);
//            perc.open(X, Y);
            
         
            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
        if((space+1<spaces)&&(x<size-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(space,space+1);
          }
        }
        if((space-1>0)&&(x>0))
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(space,space-1);
          }
        }
        if((space-size>0)&&(y-1>0))
        {//up 1
          if(perc.isOpen(x,y-1))
          {
            perc.wuf.union(space,space-size);
          }
        }
        if((space+size<spaces)&&(y+1<=size))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
            perc.wuf.union(space,space+size);
          }
        }
          
            
            
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+1+"",""+j);
                break;
            }
            i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@836e8bd51847610eb9050a55aa63ea33@"
"r04546032","1","0.18","101152","@fba33a70a10e502c3075ef608afe55a0@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    int [][]grid;
    public int size;
    int space = 0;
    int coordinates[];

    
    public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+2);//initializes the WQUUF data structure.
        this.grid = new int[N][N];
        coordinates = new int[spaces+2];
            int count = 0;
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = count;
                     count++;
                 }
             }
        for(int i = 0; i < spaces+2;i++)
        {
            coordinates[i] = i;
        }
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N+2;i++)
        {
          wuf.union(coordinates[i],coordinates[i]);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {
        if(grid[i][j]!=-1)
        {
          this.grid[i][j]=-1;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
      if(grid[i][j] != -1)
      {
          return false;
      }
      return true;
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */


  
  public boolean isFull(int i, int j)
  {
    if(isOpen(i,j))
    {
      if(wuf.connected((i+j*size),(size*size)))
      { return true;}
    }//end for
    return false;
  }//end isFull

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    for(int i=0;i<size;i++)
    {
      if(isFull(i,size-1)) 
          return true;
    }
    return false;
  }//end percolates
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
            int spaces=N*N-1;
            int space = 0;
             while((line = br.readLine())!= null)
             {
                data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
//           //先upper virtual的相連
//            for(int a = 0; a < N;a++)
//            {
//                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
//            }
//            //lower virtual connect
//             for(int b = N*(N-1); b < N*N-1;b++)
//            {
//                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
//            }
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
            int X =temp2[i+2];
            int Y = temp2[j+2];
//            perc.open(x,y);
//            perc.open(X, Y);
            
         
            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
        if((space+1<spaces)&&(x<size-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(space,space+1);
          }
        }
        if((space-1>0)&&(x>0))
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(space,space-1);
          }
        }
        if((space-size>0)&&(y-1>0))
        {//up 1
          if(perc.isOpen(x,y-1))
          {
            perc.wuf.union(space,space-size);
          }
        }
        if((space+size<spaces)&&(y+1<=size))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
            perc.wuf.union(space,space+size);
          }
        }
          
            
            
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+1+"",""+j);
                break;
            }
            i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@fba33a70a10e502c3075ef608afe55a0@"
"r04546032","0","0","0","@fcf6a1c2a10dd406a7f44d8f2fe4ca76@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;
    int coordinates[];

    
     public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+1);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
             
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                 }
             }
    
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N;i++)
        {
          wuf.union(N*N,i);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
  public boolean isFull(int i, int j)
  {
    if(isOpen(i,j))
    {
      if(wuf.connected((i+j*size),(size*size)))
      { return true;}
    }//end for
    return false;
  }//end isFull

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    for(int i=0;i<size;i++)
    {
      if(isFull(i,size-1)) 
          return true;
    }
    return false;
  }//end percolates
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
            int spaces=N*N-1;
            int space = 0;
             while((line = br.readLine())!= null)
             {
                data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
//           //先upper virtual的相連
//            for(int a = 0; a < N;a++)
//            {
//                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
//            }
//            //lower virtual connect
//             for(int b = N*(N-1); b < N*N-1;b++)
//            {
//                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
//            }
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
            int X =temp2[i+2];
            int Y = temp2[j+2];
//            perc.open(x,y);
//            perc.open(X, Y);
            
         
            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
        if((space+1<spaces)&&(x<size-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(space,space+1);
          }
        }
        if((space-1>0)&&(x>0))
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(space,space-1);
          }
        }
        if((space-size>0)&&(y-1>0))
        {//up 1
          if(perc.isOpen(x,y-1))
          {
            perc.wuf.union(space,space-size);
          }
        }
        if((space+size<spaces)&&(y+1<=size))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
            perc.wuf.union(space,space+size);
          }
        }
          
            
            
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+1+"",""+j);
                break;
            }
            i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@fcf6a1c2a10dd406a7f44d8f2fe4ca76@"
"r04546032","5","1.07","149008","@9689378b71f2c1f201821e870807056a@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;
    int coordinates[];

    
     public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+1);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
             
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                 }
             }
    
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N;i++)
        {
          wuf.union(N*N,i);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
  public boolean isFull(int i, int j)
  {
    if(isOpen(i,j))
    {
      if(wuf.connected((i+j*size),(size*size)))
      { return true;}
    }//end for
    return false;
  }//end isFull

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    for(int i=0;i<size;i++)
    {
      if(isFull(i,size-1)) 
          return true;
    }
    return false;
  }//end percolates
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
            int spaces=N*N-1;
            int space = 0;
             while((line = br.readLine())!= null)
             {
               data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
//           //先upper virtual的相連
//            for(int a = 0; a < N;a++)
//            {
//                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
//            }
//            //lower virtual connect
//             for(int b = N*(N-1); b < N*N-1;b++)
//            {
//                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
//            }
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
            perc.open(x,y);
//            perc.open(X, Y);
            space=x+(y*size);
         
            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
        if((space+1<spaces)&&(x<size-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(space,space+1);
          }
        }
        if((space-1>0)&&(x>0))
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(space,space-1);
          }
        }
        if((space-size>0)&&(y-1>0))
        {//up 1
          if(perc.isOpen(x,y-1))
          {
            perc.wuf.union(space,space-size);
          }
        }
        if((space+size<spaces)&&(y+1<=size))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
            perc.wuf.union(space,space+size);
          }
        }
          
            
            
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+1+"",""+j);
                break;
            }
            i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@9689378b71f2c1f201821e870807056a@"
"r04546032","0","1.08","147904","@d72c64bc99edfbc13d422c31da494c6d@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;
    int coordinates[];
    int [][]  Grid;

    
     public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        coordinates = new int[N*N-1]; 
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                     Grid[i][j] = count;
                     count++;
                 }
             }
    for(int i = 0; i < N*N-1;i++)
    {
        coordinates[i] = i;
    }
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N*N;i++)
        {
          wuf.union(i,i);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
          opensites+=1;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
  public boolean isFull(int i, int j)
  {
    if(isOpen(i,j))
    {
      if(wuf.connected((i+j*size),(size*size)))
      { return true;}
    }//end for
    return false;
  }//end isFull

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    for(int i=0;i<size;i++)
    {
      if(isFull(i,size-1)) 
          return true;
    }
    return false;
  }//end percolates
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
            int spaces=N*N-1;
            int space = 0;
             while((line = br.readLine())!= null)
             {
               data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
//           //先upper virtual的相連
//            for(int a = 0; a < N;a++)
//            {
//                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
//            }
//            //lower virtual connect
//             for(int b = N*(N-1); b < N*N-1;b++)
//            {
//                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
//            }
        while(testedTimes > temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
            perc.open(x,y);
//            perc.open(X, Y);
       
         
            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
        if(perc.Grid[x][y]%N!=(N-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x+1][y]]);
          }
        }
        if(perc.Grid[x][y]%N!=0)
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x-1][y]]);
          }
        }
        if(perc.Grid[x][y]>=N)
        {//up 1
          if(perc.isOpen(x,y-1))
          {
             perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y+1]]);
          }
        }
        if(perc.Grid[x][y]<N*(N-1))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
              perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y-1]]);
          }
        }
          
            
            
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+1+"",""+j);
                break;
            }
            i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@d72c64bc99edfbc13d422c31da494c6d@"
"b03611023","0","0.081","104768","@a994063771cab792d2ddd7311030d536@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
      
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            // n*n matrix
            String buffer ;
            String gg = """";
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            
            int[][] matrix = new int[n+2][n+2];
            
            UF uf = new UF(n*n+2);
            //top id = n*n bottom id = n*n+1
            
            

            int i = 0;
            int j = 0;
           String[] data;
           buffer = br.readLine();
           while(buffer!=null){
           gg = gg.concat(buffer);
           gg = gg.concat("","");
           i++;
           buffer = br.readLine();
           }
           // System.out.println(gg);
           String[] ngg =  gg.split("","");    
           /*for(j = 0;j<i*2;j++){
            System.out.println(ngg[j]);
           }*/
            int[] Data = new int[2*i];
            for(j = 0;j<2*i;j++){
             Data[j] = Integer.parseInt(ngg[j]);
            // System.out.print(Data[j]);
            }
            for(j = 0; j<2*i ; j+=2){
                int a = Data[j];
                int b =Data[j+1];
                matrix[a][b] = 1;
            if(a == 1){
                uf.union(n*n, b-1);
                //System.out.print(uf.find((a-1)*n+b-1));
            }    
            if(a == n){
            uf.union(n*n+1, (a-1)*n+b-1);
            //System.out.print(uf.find((a-1)*n+b-1));
            }
           if(a<n+1 && b<n+1 && matrix[a][b+1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b);
           }  
           if(a<n+1 && b<n+1 && matrix[a][b-1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b-2);
           } 
           if(a<n+1 && b<n+1 && matrix[a+1][b] == 1){
           uf.union((a-1)*n+b-1, a*n+b-1);
           } 
           if(a<n+1 && b<n+1 && matrix[a-1][b] == 1){
           uf.union((a-1)*n+b-1, (a-2)*n+b-1);
           } 
            if(uf.connected(n*n, n*n+1)){
            System.out.print(a);
            System.out.print("","");
            System.out.print(b);
            break;            
            }
            }
            if(!uf.connected(n*n, n*n+1)){
            System.out.print(-1);
            }
            
            
           
          
            
            
           /* buffer = br.readLine();
            while (buffer != null) {
                data = buffer.split("","");
                i++;
              for (String printStr : data) {                 
                    System.out.print(printStr);         捲                                                       
                }
                buffer = br.readLine();       
            }*/
        
        
        
           
           
              
              
            
                
            }
            
                      
    }   
}

@a994063771cab792d2ddd7311030d536@"
"b03611023","0","0.081","104768","@a994063771cab792d2ddd7311030d536@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
      
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            // n*n matrix
            String buffer ;
            String gg = """";
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            
            int[][] matrix = new int[n+2][n+2];
            
            UF uf = new UF(n*n+2);
            //top id = n*n bottom id = n*n+1
            
            

            int i = 0;
            int j = 0;
           String[] data;
           buffer = br.readLine();
           while(buffer!=null){
           gg = gg.concat(buffer);
           gg = gg.concat("","");
           i++;
           buffer = br.readLine();
           }
           // System.out.println(gg);
           String[] ngg =  gg.split("","");    
           /*for(j = 0;j<i*2;j++){
            System.out.println(ngg[j]);
           }*/
            int[] Data = new int[2*i];
            for(j = 0;j<2*i;j++){
             Data[j] = Integer.parseInt(ngg[j]);
            // System.out.print(Data[j]);
            }
            for(j = 0; j<2*i ; j+=2){
                int a = Data[j];
                int b =Data[j+1];
                matrix[a][b] = 1;
            if(a == 1){
                uf.union(n*n, b-1);
                //System.out.print(uf.find((a-1)*n+b-1));
            }    
            if(a == n){
            uf.union(n*n+1, (a-1)*n+b-1);
            //System.out.print(uf.find((a-1)*n+b-1));
            }
           if(a<n+1 && b<n+1 && matrix[a][b+1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b);
           }  
           if(a<n+1 && b<n+1 && matrix[a][b-1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b-2);
           } 
           if(a<n+1 && b<n+1 && matrix[a+1][b] == 1){
           uf.union((a-1)*n+b-1, a*n+b-1);
           } 
           if(a<n+1 && b<n+1 && matrix[a-1][b] == 1){
           uf.union((a-1)*n+b-1, (a-2)*n+b-1);
           } 
            if(uf.connected(n*n, n*n+1)){
            System.out.print(a);
            System.out.print("","");
            System.out.print(b);
            break;            
            }
            }
            if(!uf.connected(n*n, n*n+1)){
            System.out.print(-1);
            }
            
            
           
          
            
            
           /* buffer = br.readLine();
            while (buffer != null) {
                data = buffer.split("","");
                i++;
              for (String printStr : data) {                 
                    System.out.print(printStr);         捲                                                       
                }
                buffer = br.readLine();       
            }*/
        
        
        
           
           
              
              
            
                
            }
            
                      
    }   
}

@a994063771cab792d2ddd7311030d536@"
"b03611023","10","0.154","157952","@a994063771cab792d2ddd7311030d536@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
      
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            // n*n matrix
            String buffer ;
            String gg = """";
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            
            int[][] matrix = new int[n+2][n+2];
            
            UF uf = new UF(n*n+2);
            //top id = n*n bottom id = n*n+1
            
            

            int i = 0;
            int j = 0;
           String[] data;
           buffer = br.readLine();
           while(buffer!=null){
           gg = gg.concat(buffer);
           gg = gg.concat("","");
           i++;
           buffer = br.readLine();
           }
           // System.out.println(gg);
           String[] ngg =  gg.split("","");    
           /*for(j = 0;j<i*2;j++){
            System.out.println(ngg[j]);
           }*/
            int[] Data = new int[2*i];
            for(j = 0;j<2*i;j++){
             Data[j] = Integer.parseInt(ngg[j]);
            // System.out.print(Data[j]);
            }
            for(j = 0; j<2*i ; j+=2){
                int a = Data[j];
                int b =Data[j+1];
                matrix[a][b] = 1;
            if(a == 1){
                uf.union(n*n, b-1);
                //System.out.print(uf.find((a-1)*n+b-1));
            }    
            if(a == n){
            uf.union(n*n+1, (a-1)*n+b-1);
            //System.out.print(uf.find((a-1)*n+b-1));
            }
           if(a<n+1 && b<n+1 && matrix[a][b+1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b);
           }  
           if(a<n+1 && b<n+1 && matrix[a][b-1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b-2);
           } 
           if(a<n+1 && b<n+1 && matrix[a+1][b] == 1){
           uf.union((a-1)*n+b-1, a*n+b-1);
           } 
           if(a<n+1 && b<n+1 && matrix[a-1][b] == 1){
           uf.union((a-1)*n+b-1, (a-2)*n+b-1);
           } 
            if(uf.connected(n*n, n*n+1)){
            System.out.print(a);
            System.out.print("","");
            System.out.print(b);
            break;            
            }
            }
            if(!uf.connected(n*n, n*n+1)){
            System.out.print(-1);
            }
            
            
           
          
            
            
           /* buffer = br.readLine();
            while (buffer != null) {
                data = buffer.split("","");
                i++;
              for (String printStr : data) {                 
                    System.out.print(printStr);         捲                                                       
                }
                buffer = br.readLine();       
            }*/
        
        
        
           
           
              
              
            
                
            }
            
                      
    }   
}

@a994063771cab792d2ddd7311030d536@"
"r03849033","4","0.53","121584","@a140af72af14910ebae0c215fdd11ecb@

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            String[] da ;
            while ( (da = br.readLine().split("","") )!=null) {                 
         
                int p = Integer.parseInt(da[0]);
                int q = Integer.parseInt(da[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }    
            }
            if (br.readLine() == null){
                StdOut.println(""-1"");
            }
          
        }
    }
}

@a140af72af14910ebae0c215fdd11ecb@"
"r03849033","0","0.081","104768","@a15dd876edf40b8a5ce73791deaa9ede@

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            for (int i = 0; i < N*N; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }    
            }
            if (br.readLine() == null){
                StdOut.println(""-1"");
            }
          
        }
    }
}

@a15dd876edf40b8a5ce73791deaa9ede@"
"r03849033","0","0.081","104768","@4e2bc84fd6527f1273d43ead80bd32ed@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            for (int i = 0; i < N*N; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }    
            }
            if (br.readLine() == null){
                StdOut.println(""-1"");
            }
          
        }
    }
}

@4e2bc84fd6527f1273d43ead80bd32ed@"
"r03849033","9","1.07","127376","@4e2bc84fd6527f1273d43ead80bd32ed@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            for (int i = 0; i < N*N; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }    
            }
            if (br.readLine() == null){
                StdOut.println(""-1"");
            }
          
        }
    }
}

@4e2bc84fd6527f1273d43ead80bd32ed@"
"r03849033","9","1.03","127872","@a15dd876edf40b8a5ce73791deaa9ede@

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            for (int i = 0; i < N*N; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }    
            }
            if (br.readLine() == null){
                StdOut.println(""-1"");
            }
          
        }
    }
}

@a15dd876edf40b8a5ce73791deaa9ede@"
"r03849033","0","0.081","104768","@aeebe2855c97fac2c97ad1a4c9bdf102@

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            for (int i = 0; i < N*N; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }    
            }
            if (percolation.percolates()==false){
                StdOut.println(""-1"");
            }
          
        }
    }
}

@aeebe2855c97fac2c97ad1a4c9bdf102@"
"r03849033","0","0.081","104768","@aeebe2855c97fac2c97ad1a4c9bdf102@

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            for (int i = 0; i < N*N; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }    
            }
            if (percolation.percolates()==false){
                StdOut.println(""-1"");
            }
          
        }
    }
}

@aeebe2855c97fac2c97ad1a4c9bdf102@"
"r03849033","10","0.105","126672","@aeebe2855c97fac2c97ad1a4c9bdf102@

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {          
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }
 
    public void open(int i, int j) {     
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
    }
    
    
    public boolean isOpen(int i, int j) { 
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {   
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {        
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int N = Integer.parseInt(data[0]);
            Percolation percolation = new Percolation(N);
            for (int i = 0; i < N*N; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                percolation.open(p, q);
                if (percolation.percolates()==true){
                    StdOut.println(p+"",""+q);
                    break;
                }    
            }
            if (percolation.percolates()==false){
                StdOut.println(""-1"");
            }
          
        }
    }
}

@aeebe2855c97fac2c97ad1a4c9bdf102@"
"r03723070","0","0.105","126672","@b25d2165a099a0b1d894ee3a3819fcdd@mport java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       int size = Integer.parseInt(br.readLine());//read txt   
       UF uf = new UF(size*size+2);
       for(int i=1; i<=size; i++){
           uf.union(0,i);
           uf.union(size*size+1,size*size+1-i);
       }
       //for 2>1
       int [][] sitedata =new int [size+2][size+2] ;
       //data0 for null, if not null go
       String data0 = br.readLine();
       // the result
       boolean result = false;
       while( data0 != null){
               String [] data = data0.split("","");
               int x = Integer.parseInt(data[0]);
               int y = Integer.parseInt(data[1]);
               sitedata[x][y]=1;
               //data0 for count, if the next is null, data0 is for while()
               //x is not on the top, (i, j) => (i-1)N+j
               if(x!=1 && sitedata[x-1][y]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x-2)*size+y);
               if(x!=size && sitedata[x+1][y]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x)*size+y);
               if(y!=1 && sitedata[x][y-1]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x-1)*size+y-1);
               if(y!=size && sitedata[x][y+1]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x-1)*size+y+1);     
               
               if(uf.connected(0,size*size+1)){
                    System.out.printf(""%d,%d\n"",x,y);
                    result = true;
                    break;
               }
               data0 = br.readLine();
       }
       if(result != true)
           System.out.printf(""-1\n"");
    }
}

       
       
       
@b25d2165a099a0b1d894ee3a3819fcdd@"
"r03723070","0","0.081","104768","@5571d98be9ced852079f54d1ceb094bf@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       int size = Integer.parseInt(br.readLine());//read txt   
       UF uf = new UF(size*size+2);
       for(int i=1; i<=size; i++){
           uf.union(0,i);
           uf.union(size*size+1,size*size+1-i);
       }
       //for 2>1
       int [][] sitedata =new int [size+2][size+2] ;
       //data0 for null, if not null go
       String data0 = br.readLine();
       // the result
       boolean result = false;
       while( data0 != null){
               String [] data = data0.split("","");
               int x = Integer.parseInt(data[0]);
               int y = Integer.parseInt(data[1]);
               sitedata[x][y]=1;
               //data0 for count, if the next is null, data0 is for while()
               //x is not on the top, (i, j) => (i-1)N+j
               if(x!=1 && sitedata[x-1][y]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x-2)*size+y);
               if(x!=size && sitedata[x+1][y]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x)*size+y);
               if(y!=1 && sitedata[x][y-1]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x-1)*size+y-1);
               if(y!=size && sitedata[x][y+1]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x-1)*size+y+1);     
               
               if(uf.connected(0,size*size+1)){
                    System.out.printf(""%d,%d\n"",x,y);
                    result = true;
                    break;
               }
               data0 = br.readLine();
       }
       if(result != true)
           System.out.printf(""-1\n"");
    }
}

       
       
       
       
       
       
       
      
@5571d98be9ced852079f54d1ceb094bf@"
"r03723070","0","0.93","104496","@01625dad25072b00300498897aa08174@errr
@01625dad25072b00300498897aa08174@"
"r03723070","10","0.109","123728","@5571d98be9ced852079f54d1ceb094bf@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       int size = Integer.parseInt(br.readLine());//read txt   
       UF uf = new UF(size*size+2);
       for(int i=1; i<=size; i++){
           uf.union(0,i);
           uf.union(size*size+1,size*size+1-i);
       }
       //for 2>1
       int [][] sitedata =new int [size+2][size+2] ;
       //data0 for null, if not null go
       String data0 = br.readLine();
       // the result
       boolean result = false;
       while( data0 != null){
               String [] data = data0.split("","");
               int x = Integer.parseInt(data[0]);
               int y = Integer.parseInt(data[1]);
               sitedata[x][y]=1;
               //data0 for count, if the next is null, data0 is for while()
               //x is not on the top, (i, j) => (i-1)N+j
               if(x!=1 && sitedata[x-1][y]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x-2)*size+y);
               if(x!=size && sitedata[x+1][y]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x)*size+y);
               if(y!=1 && sitedata[x][y-1]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x-1)*size+y-1);
               if(y!=size && sitedata[x][y+1]==1) //2>1 dim
                   uf.union((x-1)*size+y,(x-1)*size+y+1);     
               
               if(uf.connected(0,size*size+1)){
                    System.out.printf(""%d,%d\n"",x,y);
                    result = true;
                    break;
               }
               data0 = br.readLine();
       }
       if(result != true)
           System.out.printf(""-1\n"");
    }
}

       
       
       
       
       
       
       
      
@5571d98be9ced852079f54d1ceb094bf@"
"r04631041","0","0.081","104768","@6e672cc707f22bf2fc1505a6b06bfc33@import java.io.FileReader;
import java.io.BufferedReader;

public class HW1 {
//---------------------------Object from text book----------------------------//    
    private static int[] idd;
    public static void construct(int N,int n){
        idd=new int[N+2*n+2];
        for (int i=0 ; i<N+2*n+2 ; i++)
            idd[i]=i;
        for (int i=1 ; i<=n ; i++){
            union(i,0);
            union(N+2*n+1-i,N+2*n+2-1);
            }
    }
//    private static int root(int i){
//    while(i!=idd[i]){
//        //idd[i]=idd[idd[i]];
//        i=idd[i];
//    }
//    return i;
//    }
    public static boolean connected(int p, int q){
        return idd[p]==idd[q];
    }
    public static void union(int p, int q){
        int pid=idd[p];
        int qid=idd[q];
        for(int i=0 ; i<idd.length ; i++)
            if(idd[i]==pid) idd[i]=qid;
    }
    
 //---------------------------------------------------------------------------//
    public static void check_union(int[][] m,int n,int x_axis,int y_axis){
       int nx=x_axis-1;
       int ny=y_axis-1;
       if(x_axis==1) 
           union(y_axis+n,y_axis);
       if(x_axis==n)
           union(nx*n+ny+n+1,nx*n+ny+2*n+1);
       if(m[x_axis+1][y_axis]==1)
          union(n*(nx+1)+ny+n+1,nx*n+ny+n+1);
       if (m[x_axis-1][y_axis]==1)
          union(n*(nx-1)+ny+n+1,nx*n+ny+n+1);  
       if (m[x_axis][y_axis+1]==1)
          union(nx*n+ny+1+n+1,nx*n+ny+n+1);
       if (m[x_axis][y_axis-1]==1)
           union(nx*n+ny-1+n+1,nx*n+ny+n+1); 
        }
    public static boolean percolation(int N,int n){
    if (idd[0]==idd[N+2*n+1])
        return(true);
    else
        return(false);
    }
    public static void main(String[] args) throws Exception  {
//----------------Read the first line and store the matrix size---------------//
        try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
        String FirstLine=br.readLine();
        int size=Integer.parseInt(FirstLine);
//----------------Set the matrix and initialized to be zero-------------------//
        int[][] matrix=new int[size+2][size+2];
        for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=0;
//---------------------Initializing the number to id--------------------------//
        int Number=size*size;
        construct(Number,size);
//----------------------------------------------------------------------------//
        String str=null;
        while((str=br.readLine())!=null){
        String[] data=str.split("","");
        int x_coordinate=Integer.parseInt(data[0]);
        int y_coordinate=Integer.parseInt(data[1]);
        matrix[x_coordinate][y_coordinate]=1;
        check_union(matrix,size,x_coordinate,y_coordinate);
        if (percolation(Number,size)==true){
            System.out.println(x_coordinate+"",""+y_coordinate);
            break;
        }
        }
        
        if ((str=br.readLine())==null && percolation(Number,size)==false)
            System.out.println(""-1"");
          
        
        }
        
        }
    }
    
@6e672cc707f22bf2fc1505a6b06bfc33@"
"r04631041","0","0.081","104768","@f01e6cc064ee7ba3d5f96f1b32f72a29@import java.io.FileReader;
import java.io.BufferedReader;

public class Hwpercolation {
//---------------------------Object from text book----------------------------//    
    private static int[] idd;
    public static void construct(int N,int n){
        idd=new int[N+2*n+2];
        for (int i=0 ; i<N+2*n+2 ; i++)
            idd[i]=i;
        for (int i=1 ; i<=n ; i++){
            union(i,0);
            union(N+2*n+1-i,N+2*n+2-1);
            }
    }
//    private static int root(int i){
//    while(i!=idd[i]){
//        //idd[i]=idd[idd[i]];
//        i=idd[i];
//    }
//    return i;
//    }
    public static boolean connected(int p, int q){
        return idd[p]==idd[q];
    }
    public static void union(int p, int q){
        int pid=idd[p];
        int qid=idd[q];
        for(int i=0 ; i<idd.length ; i++)
            if(idd[i]==pid) idd[i]=qid;
    }
    
 //---------------------------------------------------------------------------//
    public static void check_union(int[][] m,int n,int x_axis,int y_axis){
       int nx=x_axis-1;
       int ny=y_axis-1;
       if(x_axis==1) 
           union(y_axis+n,y_axis);
       if(x_axis==n)
           union(nx*n+ny+n+1,nx*n+ny+2*n+1);
       if(m[x_axis+1][y_axis]==1)
          union(n*(nx+1)+ny+n+1,nx*n+ny+n+1);
       if (m[x_axis-1][y_axis]==1)
          union(n*(nx-1)+ny+n+1,nx*n+ny+n+1);  
       if (m[x_axis][y_axis+1]==1)
          union(nx*n+ny+1+n+1,nx*n+ny+n+1);
       if (m[x_axis][y_axis-1]==1)
           union(nx*n+ny-1+n+1,nx*n+ny+n+1); 
        }
    public static boolean percolation(int N,int n){
    if (idd[0]==idd[N+2*n+1])
        return(true);
    else
        return(false);
    }
    public static void main(String[] args) throws Exception  {
//----------------Read the first line and store the matrix size---------------//
        try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
        String FirstLine=br.readLine();
        int size=Integer.parseInt(FirstLine);
//----------------Set the matrix and initialized to be zero-------------------//
        int[][] matrix=new int[size+2][size+2];
        for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=0;
//---------------------Initializing the number to id--------------------------//
        int Number=size*size;
        construct(Number,size);
//----------------------------------------------------------------------------//
        String str=null;
        while((str=br.readLine())!=null){
        String[] data=str.split("","");
        int x_coordinate=Integer.parseInt(data[0]);
        int y_coordinate=Integer.parseInt(data[1]);
        matrix[x_coordinate][y_coordinate]=1;
        check_union(matrix,size,x_coordinate,y_coordinate);
        if (percolation(Number,size)==true){
            System.out.println(x_coordinate+"",""+y_coordinate);
            break;
        }
        }
        
        if ((str=br.readLine())==null && percolation(Number,size)==false)
            System.out.println(""-1"");
          
        
        }
        
        }
    }
    
@f01e6cc064ee7ba3d5f96f1b32f72a29@"
"r04631041","10","0.111","124672","@fa2c2424004d5f797104be867289f18a@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
//---------------------------Object from text book----------------------------//    
    private static int[] idd;
    public static void construct(int N,int n){
        idd=new int[N+2*n+2];
        for (int i=0 ; i<N+2*n+2 ; i++)
            idd[i]=i;
        for (int i=1 ; i<=n ; i++){
            union(i,0);
            union(N+2*n+1-i,N+2*n+2-1);
            }
    }
//    private static int root(int i){
//    while(i!=idd[i]){
//        //idd[i]=idd[idd[i]];
//        i=idd[i];
//    }
//    return i;
//    }
    public static boolean connected(int p, int q){
        return idd[p]==idd[q];
    }
    public static void union(int p, int q){
        int pid=idd[p];
        int qid=idd[q];
        for(int i=0 ; i<idd.length ; i++)
            if(idd[i]==pid) idd[i]=qid;
    }
    
 //---------------------------------------------------------------------------//
    public static void check_union(int[][] m,int n,int x_axis,int y_axis){
       int nx=x_axis-1;
       int ny=y_axis-1;
       if(x_axis==1) 
           union(y_axis+n,y_axis);
       if(x_axis==n)
           union(nx*n+ny+n+1,nx*n+ny+2*n+1);
       if(m[x_axis+1][y_axis]==1)
          union(n*(nx+1)+ny+n+1,nx*n+ny+n+1);
       if (m[x_axis-1][y_axis]==1)
          union(n*(nx-1)+ny+n+1,nx*n+ny+n+1);  
       if (m[x_axis][y_axis+1]==1)
          union(nx*n+ny+1+n+1,nx*n+ny+n+1);
       if (m[x_axis][y_axis-1]==1)
           union(nx*n+ny-1+n+1,nx*n+ny+n+1); 
        }
    public static boolean percolation(int N,int n){
    if (idd[0]==idd[N+2*n+1])
        return(true);
    else
        return(false);
    }
    public static void main(String[] args) throws Exception  {
//----------------Read the first line and store the matrix size---------------//
        try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
        String FirstLine=br.readLine();
        int size=Integer.parseInt(FirstLine);
//----------------Set the matrix and initialized to be zero-------------------//
        int[][] matrix=new int[size+2][size+2];
        for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=0;
//---------------------Initializing the number to id--------------------------//
        int Number=size*size;
        construct(Number,size);
//----------------------------------------------------------------------------//
        String str=null;
        while((str=br.readLine())!=null){
        String[] data=str.split("","");
        int x_coordinate=Integer.parseInt(data[0]);
        int y_coordinate=Integer.parseInt(data[1]);
        matrix[x_coordinate][y_coordinate]=1;
        check_union(matrix,size,x_coordinate,y_coordinate);
        if (percolation(Number,size)==true){
            System.out.println(x_coordinate+"",""+y_coordinate);
            break;
        }
        }
        
        if ((str=br.readLine())==null && percolation(Number,size)==false)
            System.out.println(""-1"");
          
        
        }
        
        }
    }
    

@fa2c2424004d5f797104be867289f18a@"
"r04546032","0","0.081","104768","@cdaa6b883cca1afecece132da410db59@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;
    int coordinates[];
    int Grid[][];
    
    public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        Grid = new int[N][N];
        coordinates = new int[spaces+2];
            int count = 0;
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     Grid[i][j] = count;
                     grid[i][j]= false;
                     count++;
                 }
             }
        for(int i = 0; i < spaces+2;i++)
        {
            coordinates[i] = i;
        }
        opensites=0;//intializes open sites to 0.
        for(int i=0;i<N+2;i++)
        {
          wuf.union(coordinates[i],coordinates[i]);
        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {
        if(grid[i][j]==false)
        {
          this.grid[i][j]=true;
    
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
      return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */


  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */
  public boolean percolates()
  {
    if(wuf.connected(coordinates[size*size], coordinates[size*size+1]) == true)
    {
          return true;
    }
    return false;
  }//end percolates
    
    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
             while((line = br.readLine())!= null)
             {
                data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
           //先upper virtual的相連
            for(int a = 0; a < N;a++)
            {
                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
            }
            //lower virtual connect
             for(int b = N*(N-1); b < N*N-1;b++)
            {
                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
            }
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
            perc.open(x,y);
//            perc.open(x,y);
//            perc.open(X, Y);
            
         
             if(perc.Grid[x][y]%N!=(N-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x+1][y]]);
          }
        }
        if(perc.Grid[x][y]%N!=0)
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x-1][y]]);
          }
        }
        if(perc.Grid[x][y]>=N)
        {//up 1
          if(perc.isOpen(x,y-1))
          {
             perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y-1]]);
          }
        }
        if(perc.Grid[x][y]<N*(N-1))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
              perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y+1]]);
          }
        }
           
          
            
           
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+1+"",""+j);
                break;
            }
             i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
@cdaa6b883cca1afecece132da410db59@"
"r04546032","0","0","0","@8a5717cc4f4f6749d13fc408aebc99a8@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;
    int coordinates[];
    int [][]  Grid;

    
     public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        coordinates = new int[spaces+2]; //加入上下virtual 
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                     Grid[i][j] = count;
                     count++;
                 }
             }
    for(int i = 0; i < N*N+2;i++)
    {
        coordinates[i] = i;
    }
//        opensites=0;//intializes open sites to 0.
//        for(int i=0;i<N+2;i++)
//        {
//          wuf.union(coordinates[i],coordinates[i]);
//        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
    public boolean percolates()
  {
    if(wuf.connected(coordinates[size*size], coordinates[size*size+1]) == true)
    {
          return true;
    }
    return false;
  }//end percolates

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */

    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
             int spaces=N*N-1;
          
             while((line = br.readLine())!= null)
             {
               data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
           //先upper virtual的相連
            for(int a = 0; a < N;a++)
            {
                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
            }
            //lower virtual connect
             for(int b = N*(N-1); b < N*N-1;b++)
            {
                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
            }
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
            perc.open(x,y);
//            perc.open(X, Y);
       
         
            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
        if(perc.Grid[x][y]%N!=(N-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x+1][y]]);
          }
        }
        if(perc.Grid[x][y]%N!=0)
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x-1][y]]);
          }
        }
        if(perc.Grid[x][y]>=N)
        {//up 1
          if(perc.isOpen(x,y-1))
          {
             perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y-1]]);
          }
        }
        if(perc.Grid[x][y]<N*(N-1))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
              perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y+1]]);
          }
        }
          
            
            
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+1+"",""+j);
                break;
            }
            i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@8a5717cc4f4f6749d13fc408aebc99a8@"
"r04546032","0","0","0","@8a5717cc4f4f6749d13fc408aebc99a8@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;
    int coordinates[];
    int [][]  Grid;

    
     public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        coordinates = new int[spaces+2]; //加入上下virtual 
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                     Grid[i][j] = count;
                     count++;
                 }
             }
    for(int i = 0; i < N*N+2;i++)
    {
        coordinates[i] = i;
    }
//        opensites=0;//intializes open sites to 0.
//        for(int i=0;i<N+2;i++)
//        {
//          wuf.union(coordinates[i],coordinates[i]);
//        }// end for that connects all top sites
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
    public boolean percolates()
  {
    if(wuf.connected(coordinates[size*size], coordinates[size*size+1]) == true)
    {
          return true;
    }
    return false;
  }//end percolates

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */

    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
             int spaces=N*N-1;
          
             while((line = br.readLine())!= null)
             {
               data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
           //先upper virtual的相連
            for(int a = 0; a < N;a++)
            {
                perc.wuf.union(perc.coordinates[N*N], perc.coordinates[a]);
            }
            //lower virtual connect
             for(int b = N*(N-1); b < N*N-1;b++)
            {
                perc.wuf.union(perc.coordinates[N*N+1], perc.coordinates[b]);    
            }
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
            perc.open(x,y);
//            perc.open(X, Y);
       
         
            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
        if(perc.Grid[x][y]%N!=(N-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x+1][y]]);
          }
        }
        if(perc.Grid[x][y]%N!=0)
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x-1][y]]);
          }
        }
        if(perc.Grid[x][y]>=N)
        {//up 1
          if(perc.isOpen(x,y-1))
          {
             perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y-1]]);
          }
        }
        if(perc.Grid[x][y]<N*(N-1))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
              perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y+1]]);
          }
        }
          
            
            
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+1+"",""+j);
                break;
            }
            i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@8a5717cc4f4f6749d13fc408aebc99a8@"
"r04546032","0","0.87","147264","@ed70a1a150191ce3a948b4e6c681466b@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;
    int coordinates[];
    int [][]  Grid;

    
     public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        coordinates = new int[spaces+2]; //加入上下virtual 
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                     Grid[i][j] = count;
                     count++;
                 }
             }
    for(int i = 0; i < N*N+2;i++)
    {
        coordinates[i] = i;
    }
            //先upper virtual的相連
            for(int a = 0; a < N;a++)
            {
                wuf.union(coordinates[N*N], coordinates[a]);
            }
            //lower virtual connect
             for(int b = N*(N-1); b < N*N-1;b++)
            {
                wuf.union(coordinates[N*N+1], coordinates[b]);    
            }
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
    public boolean percolates()
  {
    if(wuf.connected(coordinates[size*size], coordinates[size*size+1]) == true)
    {
          return true;
    }
    return false;
  }//end percolates

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */

    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
             int spaces=N*N-1;
          
             while((line = br.readLine())!= null)
             {
               data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
      
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
            perc.open(x,y);
//            perc.open(X, Y);
       
         
            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
        if(perc.Grid[x][y]%N!=(N-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x+1][y]]);
          }
        }
        if(perc.Grid[x][y]%N!=0)
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x-1][y]]);
          }
        }
        if(perc.Grid[x][y]>=N)
        {//up 1
          if(perc.isOpen(x,y-1))
          {
             perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y-1]]);
          }
        }
        if(perc.Grid[x][y]<N*(N-1))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
              perc.wuf.union(perc.coordinates[perc.Grid[x][y]],perc.coordinates[perc.Grid[x][y+1]]);
          }
        }
          
            
            
            testedTimes++;
            if(perc.percolates()== true )
            {
                System.out.println(i+1+"",""+j);
                break;
            }
            i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@ed70a1a150191ce3a948b4e6c681466b@"
"r04546032","0","0.081","104768","@ad1bb15be6a2cc513cd6471c5d04d065@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;


public class Percolation 
{
    WeightedQuickUnionUF wuf;
    int opensites;
    boolean [][]grid;
    public int size;
    int space = 0;
   // int coordinates[];
    int [][]  Grid;

    
     public Percolation(int N)
    { 
        int spaces= N*N;
        wuf = new WeightedQuickUnionUF(spaces+2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
      //  coordinates = new int[spaces+2]; //加入上下virtual 
             for(int i = 0; i < N ; i++)
             {
                 for(int j = 0; j <N;j++)
                 {
                     grid[i][j] = false;
                     Grid[i][j] = count;
                     count++;
                 }
             }
//    for(int i = 0; i < N*N+2;i++)
//    {
//        coordinates[i] = i;
//    }
            //先upper virtual的相連
            for(int a = 0; a < N;a++)
            {
                wuf.union(N*N, a);
            }
            //lower virtual connect
             for(int b = N*(N-1); b <= N*N-1;b++)
            {
                wuf.union(N*N+1, b);    
            }
  }// end constructor;
    
    public void open(int i, int j)
    {

        if(!(this.grid[i][j]))
        {
          this.grid[i][j]=true;
        }
  }//end open
  public boolean isOpen(int i, int j)
  {
    return grid[i][j];
  }//end isOpen

  /* 
   * takes to ints as X and Y coordinates and 
   * returns true if that space is full and false
   * if not
   */
    public boolean percolates()
  {
    if(wuf.connected(size*size, size*size+1))
    {
          return true;
    }
    return false;
  }//end percolates

  /* 
   * checks if any space on the bottom is full returns true 
   * if there is one false other wise
   */

    
    public static void main(String[] args) throws Exception{
        
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) 
         {
             String number = br.readLine();
             int N = Integer.parseInt(number);
             ArrayList<Integer>temp = new ArrayList<>();
             String []data;
             String line;
             int spaces=N*N-1;
          
             while((line = br.readLine())!= null)
             {
               data=line.split("","");
               temp.add(Integer.parseInt(data[0]));
               temp.add(Integer.parseInt(data[1]));
               
             }
            
            Integer [] temp2 = temp.toArray(new Integer[temp.size()]);
            for(int i = 0; i < temp.size();i++)
            {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
           // Percolation perc = new Percolation(size);
            int i = 0; int j = 1;
  
        Percolation perc = new Percolation(size);
      
        while(testedTimes != temp2.length/2)
        {
            int x=temp2[i];
            int y=temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
            perc.open(x,y);
//            perc.open(X, Y);
       
         
            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
           
        if(perc.Grid[x][y]%N!=(N-1))
        {//right 1
          if(perc.isOpen(x+1,y))
          {
            perc.wuf.union(perc.Grid[x][y],perc.Grid[x+1][y]);
          }
        }
        if(perc.Grid[x][y]%N!=0)
        {//left 1
          if(perc.isOpen(x-1,y))
          {
            perc.wuf.union(perc.Grid[x][y],perc.Grid[x-1][y]);
          }
        }
        if(perc.Grid[x][y]>=N)
        {//up 1
          if(perc.isOpen(x,y-1))
          {
             perc.wuf.union(perc.Grid[x][y],perc.Grid[x][y-1]);
          }
        }
        if(perc.Grid[x][y]<N*(N-1))
        {//down 1
          if((perc.isOpen(x,y+1)))
          {
              perc.wuf.union(perc.Grid[x][y],perc.Grid[x][y+1]);
          }
        }
          
            
            
            testedTimes++;
            if(perc.percolates() )
            {
                System.out.println((i+2)+"",""+(j+2));
                break;
            }
            i+=2;
            j+=2;
     }//end while(TestedTimes<tests)
     if(testedTimes == temp2.length/2)
     {System.out.println(""-1"");}
      
    //end while(TestedTimes<tests)
    }           
  }
         
}
     


@ad1bb15be6a2cc513cd6471c5d04d065@"
"r04546032","0","0.95","105584","@9d412d70f413b7fa6e1cad9b05ed1a91@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 1);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
            }
        }

        opensites = 0;//intializes open sites to 0.
        for (int i = 0; i < N; i++) {
            wuf.union(N * N, i);
        }// end for that connects all top sites
    }// end constructor;

    public void open(int i, int j) {

        if (!(this.grid[i][j])) {
            this.grid[i][j] = true;
            opensites += 1;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return grid[i][j];
    }//end isOpen

    /* 
     * takes to ints as X and Y coordinates and 
     * returns true if that space is full and false
     * if not
     */
    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected((i + j * size), (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates() {
        for (int i = 0; i < size; i++) {
            if (isFull(i, size - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            int[][] coordinates = new int[N][N];
            String[] data;
            while ((data = br.readLine().split("","")) == null) {
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));
            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            int size = N;
            int spaces = size * size - 1;
            int space = 0;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            while (testedTimes == temp2.length / 2) {
                int x = temp2[i];
                int y = temp2[j];

                perc.open(x, y);
                space = x + (y * size);
                if ((space + 1 < spaces) && (x < size - 1)) {//right 1
                    if (perc.isOpen(x + 1, y)) {
                        perc.wuf.union(space, space + 1);
                    }
                }
                if ((space - 1 > 0) && (x > 0)) {//left 1
                    if (perc.isOpen(x - 1, y)) {
                        perc.wuf.union(space, space - 1);
                    }
                }
                if ((space - size > 0) && (y - 1 > 0)) {//up 1
                    if (perc.isOpen(x, y - 1)) {
                        perc.wuf.union(space, space - size);
                    }
                }
                if ((space + size < spaces) && (y + 1 <= size)) {//down 1
                    if ((perc.isOpen(x, y + 1))) {
                        perc.wuf.union(space, space + size);
                    }
                }
                testedTimes++;
                if (perc.percolates()) {
                    System.out.println((i + 1) + "","" + (j));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)

            if (testedTimes == temp2.length / 2) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@9d412d70f413b7fa6e1cad9b05ed1a91@"
"r04546032","1","1.03","147824","@cfe0dcb67b5a0447f05c647b097facf8@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    // int coordinates[];
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        //  coordinates = new int[spaces+2]; //加入上下virtual 
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }
//    for(int i = 0; i < N*N+2;i++)
//    {
//        coordinates[i] = i;
//    }
        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
        for (int b = N * (N - 1); b <= N * N - 1; b++) {
            wuf.union(N * N + 1, b);
        }
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;
            int spaces = N * N - 1;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);

            while (testedTimes != temp2.length / 2) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if ((x>=0)&&(x<size-1)) {//right 1
                    if (perc.isOpen(x + 1, y) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                    }
                }
                if (x>1) {//left 1
                    
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        
                    }
                }
                if (y>0) {//up 1
                 
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    
                }
                if (y<size-1) {//down 1
                    if ((perc.isOpen(x, y + 1)) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((i + 1) + "","" + (j));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == temp2.length / 2) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@cfe0dcb67b5a0447f05c647b097facf8@"
"r04546032","0","0.081","104768","@21b6dd662b4b5780fde99dacc0d89377@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    // int coordinates[];
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        //  coordinates = new int[spaces+2]; //加入上下virtual 
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }
//    for(int i = 0; i < N*N+2;i++)
//    {
//        coordinates[i] = i;
//    }
        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
            wuf.union(N * N + 1, b);
        }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);

            while (testedTimes != temp2.length / 2) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if ((x>=0)&&(x<size-1)) {//right 1
                    if (perc.isOpen(x + 1, y) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                    }
                }
                if (x>0) {//left 1
                    
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        
                    }
                }
                if (y>0) {//up 1
                 
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    
                }
                if (y<size-1) {//down 1
                    if ((perc.isOpen(x, y + 1)) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((i + 1) + "","" + (j));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == temp2.length / 2) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@21b6dd662b4b5780fde99dacc0d89377@"
"r04546032","0","0.081","104768","@9eb805364d29baedf2effc33530e25bc@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    // int coordinates[];
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        //  coordinates = new int[spaces+2]; //加入上下virtual 
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }
//    for(int i = 0; i < N*N+2;i++)
//    {
//        coordinates[i] = i;
//    }
        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
            wuf.union(N * N + 1, b);
        }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);

            while (testedTimes != temp2.length / 2) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if ((x>=0)&&(x<size-1)) {//right 1
                    if (perc.isOpen(x + 1, y) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                    }
                }
                if (x>0) {//left 1
                    
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        
                    }
                }
                if (y>0) {//up 1
                 
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    
                }
                if (y<size-1) {//down 1
                    if ((perc.isOpen(x, y + 1)) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((i + 1) + "","" + (j));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == temp2.length / 2) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@9eb805364d29baedf2effc33530e25bc@"
"r04546032","1","1.09","149472","@9eb805364d29baedf2effc33530e25bc@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    // int coordinates[];
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        //  coordinates = new int[spaces+2]; //加入上下virtual 
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }
//    for(int i = 0; i < N*N+2;i++)
//    {
//        coordinates[i] = i;
//    }
        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
            wuf.union(N * N + 1, b);
        }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);

            while (testedTimes != temp2.length / 2) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if ((x>=0)&&(x<size-1)) {//right 1
                    if (perc.isOpen(x + 1, y) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                    }
                }
                if (x>0) {//left 1
                    
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        
                    }
                }
                if (y>0) {//up 1
                 
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    
                }
                if (y<size-1) {//down 1
                    if ((perc.isOpen(x, y + 1)) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((i + 1) + "","" + (j));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == temp2.length / 2) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@9eb805364d29baedf2effc33530e25bc@"
"r04546032","3","1.09","149376","@7c87b5bc6f27f0a5199e7152d6146cba@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    // int coordinates[];
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        //  coordinates = new int[spaces+2]; //加入上下virtual 
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }
//    for(int i = 0; i < N*N+2;i++)
//    {
//        coordinates[i] = i;
//    }
        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
            wuf.union(N * N + 1, b);
        }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);

            while (testedTimes != temp2.length / 2) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if ((x>=0)&&(x<size-1)) {//right 1
                    if (perc.isOpen(x + 1, y) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                    }
                }
                if (x>0) {//left 1
                    
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);                       
                    }
                }
                if (y>0) {//up 1
                 
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    
                }
                if (y<size-1) {//down 1
                    if ((perc.isOpen(x, y + 1)) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y+1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == temp2.length / 2) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@7c87b5bc6f27f0a5199e7152d6146cba@"
"r04546032","0","0.081","104768","@94d2b5de8ffe8c03d038f3834ccbb7b1@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    // int coordinates[];
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        //  coordinates = new int[spaces+2]; //加入上下virtual 
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }
//    for(int i = 0; i < N*N+2;i++)
//    {
//        coordinates[i] = i;
//    }
        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
            wuf.union(N * N + 1, b);
        }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);

            while (testedTimes > temp2.length / 2) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if ((x>=0)&&(x<size-1)) {//right 1
                    if (perc.isOpen(x + 1, y) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                    }
                }
                if (x>0) {//left 1
                    
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);                       
                    }
                }
                if (y>0) {//up 1
                 
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    
                }
                if (y<size-1) {//down 1
                    if ((perc.isOpen(x, y + 1)) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y+1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2+1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@94d2b5de8ffe8c03d038f3834ccbb7b1@"
"r04546032","0","1.06","141472","@bee03ec8618cbf295013670f557ad6df@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    // int coordinates[];
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];
        //  coordinates = new int[spaces+2]; //加入上下virtual 
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }
//    for(int i = 0; i < N*N+2;i++)
//    {
//        coordinates[i] = i;
//    }
        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
            wuf.union(N * N + 1, b);
        }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);

            while (testedTimes > temp2.length / 2) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

            //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if ((x>=0)&&(x<size-1)) {//right 1
                    if (perc.isOpen(x + 1, y) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                    }
                }
                if (x>0) {//left 1
                    
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);                       
                    }
                }
                if (y>0) {//up 1
                 
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    
                }
                if (y<size-1) {//down 1
                    if ((perc.isOpen(x, y + 1)) == true) {
                        perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y+1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2+1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@bee03ec8618cbf295013670f557ad6df@"
"r04945021","7","1.02","126464","@afefe6e2a1bbbf9909312f22b0cc182d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int Num = Integer.parseInt(data[0]);
            boolean[][] matrix = new boolean[Num][Num];
            for(int i=0;i<Num;i++){
                           Arrays.fill(matrix[i], false); 
            }
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(Num * Num + 2);
            String line;
            int top = 0;
            int bottom = Num * Num + 1;
            while ((line = br.readLine()) != null) {
                String[] dataOpen = line.split("","");
                int row = Integer.parseInt(dataOpen[0]);
                int col = Integer.parseInt(dataOpen[1]);
                //open
                matrix[row - 1][col - 1] = true;
               //如果上或下有open就和虛擬的2點union
                //Num*(row-1)是id
                if (row == 1) {
                    uf.union((Num * (row - 1) + col), top);
                }
                if (row == Num) {
                    uf.union((Num * (row - 1) + col), bottom);
                }
               //確認點周圍有沒有打開，如果有就union在一起
                //跟上接
                if (row > 1 && (matrix[row - 2][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 2) + col));
                }
                //跟下接
                if (row < Num && (matrix[row][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * row + col));
                }
                //跟左接
                if (col > 1 && (matrix[row - 1][col - 2] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col - 2));
                }
                //跟右接
                if (col < Num && (matrix[row - 1][col] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col));
                }
                if (uf.connected(top, bottom) == true) {
                    System.out.printf(""%d,%d\n"", row, col);
                    break;
                }
            }
            if (uf.connected(top, bottom) == false) {
                System.out.printf(""-1"");
            }
        }

    }
}

@afefe6e2a1bbbf9909312f22b0cc182d@"
"r04546032","3","1.08","148288","@ec398e547ff9ae09ac9dda86b735cfeb@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (coordinates[perc.Grid[x][y]] % N != (N - 1)) {//right 1
                    if (x == N - 1) {
                        if (perc.isOpen(x, y + 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                        }
                    } else {
                        if (perc.isOpen(x + 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] % N != 0) {//left 1
                    if (x == 0) {
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    } else {
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] > (N - 1)) {//up 1
                    if (y == 0) {
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        }
                    } else {
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] < N * (N - 1)) {//down 1
                    if (y == N - 1) {
                        if ((perc.isOpen(x + 1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                        }
                    } else {
                        if ((perc.isOpen(x, y + 1)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                        }
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@ec398e547ff9ae09ac9dda86b735cfeb@"
"b02611023","0","0","0","@99d3826fdcca10c0f194362a75aa1182@import java.io.*;

public class Percolation {

	public static int[] check;

	public static int num;

	public static void main(String[] args) throws Exception{
		try(BufferedReader br = new BufferedReader(new FileReader(""input.txt""))){

			num = Integer.parseInt(br.readLine());

			String line;

			String[] lines = new String[2];

			int count;

			check = new int[num * num + 2];
			check[num*num] = num * num;
			check[num*num+1] = num * num + 1;

			int root_1 = 0;

			int[][] matrix = new int[num+2][num+2];

			for(int i = 0; i < num * num; i ++){
				line = br.readLine();
				if(num == 1){
					System.out.println(line);
				}
				if(line == null){
					break;
				}

				lines = line.split("","");
				int row = Integer.parseInt(lines[0]);
				int col = Integer.parseInt(lines[1]);
				matrix[row][col] = 1;
				count = col - 1 + num * (row - 1);
				check[count] = count;

				if(row == 1){
					//check[count] = check[num*num];
					union(check[count],check[num*num]);
				}
				else if(row == num){
					//check[count] = check[num*num+1];
					union(check[count],check[num*num+1]);
				}
				else{
					//�U
					if(matrix[row][col] - matrix[row+1][col] == 0){
						//check[row*num+col-1] = check[count];
						union(check[row*num+col-1],check[count]);
					}
					//�k
					if(matrix[row][col] - matrix[row][col+1] == 0){
						//check[(row-1)*num+col] = check[count];
						union(check[(row-1)*num+col],check[count]);
					}
					//��
					if(matrix[row][col] - matrix[row][col-1] == 0){
						//check[count] = check[(row-1)*num+col-2];
						union(check[count],check[(row-1)*num+col-2]);
					}
					//�W
					if(matrix[row][col] - matrix[row-1][col] == 0){
						//check[count] = check[(row-2)*num+col-1];
						union(check[count],check[(row-2)*num+col-1]);
					}
				}
				root_1 = root(check[num*num+1]);

				if(root_1 == check[num*num]){
					System.out.println(row + "","" + col);
					//System.out.println(root_1);
					break;
				}
				//System.out.println(check[count]);
			}
			/*for(int k = 0;k<num*num+2;k++){
				System.out.println(check[k]);
			}*/
			if(root_1 != check[num*num]){
				//System.out.println(check[num*num]);
				System.out.println(""-1"");
			}
		}
	}

	public static int root(int i){
		while(i != check[i]){
			i = check[i];
		}
		return i;
	}

	public static void union(int p, int q){
		int i = root(p);
		int j = root(q);
		check[i] = j;
	}
}

@99d3826fdcca10c0f194362a75aa1182@"
"b02611023","6","1.01","142512","@b68e8c09200c1086c19a164a32d6f6b6@import java.io.*;

public class Percolation {

	public static int[] check;

	public static int num;

	public static void main(String[] args) throws Exception{
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

			num = Integer.parseInt(br.readLine());

			String line;

			String[] lines = new String[2];

			int count;

			check = new int[num * num + 2];
			check[num*num] = num * num;
			check[num*num+1] = num * num + 1;

			int root_1 = 0;

			int[][] matrix = new int[num+2][num+2];

			for(int i = 0; i < num * num; i ++){
				line = br.readLine();
				if(num == 1){
					System.out.println(line);
				}
				if(line == null){
					break;
				}

				lines = line.split("","");
				int row = Integer.parseInt(lines[0]);
				int col = Integer.parseInt(lines[1]);
				matrix[row][col] = 1;
				count = col - 1 + num * (row - 1);
				check[count] = count;

				if(row == 1){
					//check[count] = check[num*num];
					union(check[count],check[num*num]);
				}
				else if(row == num){
					//check[count] = check[num*num+1];
					union(check[count],check[num*num+1]);
				}
				else{
					//�U
					if(matrix[row][col] - matrix[row+1][col] == 0){
						//check[row*num+col-1] = check[count];
						union(check[row*num+col-1],check[count]);
					}
					//�k
					if(matrix[row][col] - matrix[row][col+1] == 0){
						//check[(row-1)*num+col] = check[count];
						union(check[(row-1)*num+col],check[count]);
					}
					//��
					if(matrix[row][col] - matrix[row][col-1] == 0){
						//check[count] = check[(row-1)*num+col-2];
						union(check[count],check[(row-1)*num+col-2]);
					}
					//�W
					if(matrix[row][col] - matrix[row-1][col] == 0){
						//check[count] = check[(row-2)*num+col-1];
						union(check[count],check[(row-2)*num+col-1]);
					}
				}
				root_1 = root(check[num*num+1]);

				if(root_1 == check[num*num]){
					System.out.println(row + "","" + col);
					//System.out.println(root_1);
					break;
				}
				//System.out.println(check[count]);
			}
			/*for(int k = 0;k<num*num+2;k++){
				System.out.println(check[k]);
			}*/
			if(root_1 != check[num*num]){
				//System.out.println(check[num*num]);
				System.out.println(""-1"");
			}
		}
	}

	public static int root(int i){
		while(i != check[i]){
			i = check[i];
		}
		return i;
	}

	public static void union(int p, int q){
		int i = root(p);
		int j = root(q);
		check[i] = j;
	}
}

@b68e8c09200c1086c19a164a32d6f6b6@"
"r04546032","0","1.01","142512","@0c718394794d9561f0e26eb2cccfcfed@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (coordinates[perc.Grid[x][y]] % N != (N - 1)) {//right 1
                    if (x == N - 1) {
                        if (perc.isOpen(x, y + 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] % N != 0) {//left 1
                    if (x == 0) {
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] > (N - 1)) {//up 1
                    if (y == 0) {
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        }
                    } else {
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] < N * (N - 1)) {//down 1
                    if (y == N - 1) {
                        if ((perc.isOpen(x + 1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                        }
                    } else {
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}
@0c718394794d9561f0e26eb2cccfcfed@"
"r04546032","0","1.01","142512","@86b4a13f089a323d38fce40c90c4bfb1@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (coordinates[perc.Grid[x][y]] % N != (N - 1)) {//right 1
                    if (x == N - 1) {
                        if (perc.isOpen(x, y + 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] % N != 0) {//left 1
                    if (x == 0) {
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] > (N - 1)) {//up 1
                    if (y == 0) {
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        }
                    } else {
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] < N * (N - 1)) {//down 1
                    if (y == N - 1) {
                        if ((perc.isOpen(x + 1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                        }
                    } else {
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@86b4a13f089a323d38fce40c90c4bfb1@"
"r04546032","0","1.01","142512","@86b4a13f089a323d38fce40c90c4bfb1@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (coordinates[perc.Grid[x][y]] % N != (N - 1)) {//right 1
                    if (x == N - 1) {
                        if (perc.isOpen(x, y + 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] % N != 0) {//left 1
                    if (x == 0) {
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] > (N - 1)) {//up 1
                    if (y == 0) {
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        }
                    } else {
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] < N * (N - 1)) {//down 1
                    if (y == N - 1) {
                        if ((perc.isOpen(x + 1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                        }
                    } else {
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@86b4a13f089a323d38fce40c90c4bfb1@"
"r04546032","0","1.01","142512","@860ad58dd7b7c94309d2d024c3e3c03a@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (coordinates[perc.Grid[x][y]] % N != (N - 1)) {//right 1
                    if (x == N - 1) {
                        if (perc.isOpen(x, y + 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] % N != 0) {//left 1
                    if (x == 0) {
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] > (N - 1)) {//up 1
                    if (y == 0) {
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        }
                    } else {
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] < N * (N - 1)) {//down 1
                    if (y == N - 1) {
                        if ((perc.isOpen(x + 1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                        }
                    } else {
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}
@860ad58dd7b7c94309d2d024c3e3c03a@"
"r04546032","3","1.08","141440","@86b4a13f089a323d38fce40c90c4bfb1@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (coordinates[perc.Grid[x][y]] % N != (N - 1)) {//right 1
                    if (x == N - 1) {
                        if (perc.isOpen(x, y + 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y + 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] % N != 0) {//left 1
                    if (x == 0) {
                        if (perc.isOpen(x, y - 1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y - 1]);
                        }
                    } else {
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] > (N - 1)) {//up 1
                    if (y == 0) {
                        if (perc.isOpen(x - 1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x - 1][y]);
                        }
                    } else {
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                }
                if (coordinates[perc.Grid[x][y]] < N * (N - 1)) {//down 1
                    if (y == N - 1) {
                        if ((perc.isOpen(x + 1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x + 1][y]);
                        }
                    } else {
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    }
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@86b4a13f089a323d38fce40c90c4bfb1@"
"r04546032","0","0","0","@5426cf4672052c3151e20dbc9a1692cf@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (y<size-1) {//right 1
                  
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                
                if (y> 0) {//left 1
                   
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                
                if (x>0) {//up 1
                   
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                
                if (x<size-1) {//down 1
                  
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@5426cf4672052c3151e20dbc9a1692cf@"
"r04546032","3","1.1","145712","@1a22cc5ce9c59fed8315242ee911aed2@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
    /*    for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }*/
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (y<size-1) {//right 1
                  
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                
                if (y> 0) {//left 1
                   
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                
                if (x>0) {//up 1
                   
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                
                if (x<size-1) {//down 1
                  
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    
                }

                testedTimes++;
                if (perc.percolates(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@1a22cc5ce9c59fed8315242ee911aed2@"
"r04945021","0","1.01","142512","@e9545fdec00fc0945ebd0f6d6af3afbc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int Num = Integer.parseInt(data[0]);
            boolean[][] matrix = new boolean[Num][Num];
            for(int i=0;i<Num;i++){
                           Arrays.fill(matrix[i], false); 
            }
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(Num * Num + 2);
            String line;
            int nopercolation=-1;
            int top = 0;
            int bottom = Num * Num + 1;
            while ((line = br.readLine()) != null) {
                String[] dataOpen = line.split("","");
                int row = Integer.parseInt(dataOpen[0]);
                int col = Integer.parseInt(dataOpen[1]);
                //open
                matrix[row - 1][col - 1] = true;
               //如果上或下有open就和虛擬的2點union
                //Num*(row-1)是id
                if (row == 1) {
                    uf.union((Num * (row - 1) + col), top);
                }
                if (row == Num) {
                    uf.union((Num * (row - 1) + col), bottom);
                }
               //確認點周圍有沒有打開，如果有就union在一起
                //跟上接
                if (row > 1 && (matrix[row - 2][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 2) + col));
                }
                //跟下接
                if (row < Num && (matrix[row][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * row + col));
                }
                //跟左接
                if (col > 1 && (matrix[row - 1][col - 2] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col - 2));
                }
                //跟右接
                if (col < Num && (matrix[row - 1][col] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col));
                }
                if (uf.connected(top, bottom) == true) {
                    System.out.printf(""%d,%d\n"", row, col);
                    break;
                }
            }
            if (uf.connected(top, bottom) == false) {
                System.out.printf(""%d\n"",nopercolation);
            }
        }

    }
}

@e9545fdec00fc0945ebd0f6d6af3afbc@"
"r04945021","8","1.11","128384","@e9545fdec00fc0945ebd0f6d6af3afbc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int Num = Integer.parseInt(data[0]);
            boolean[][] matrix = new boolean[Num][Num];
            for(int i=0;i<Num;i++){
                           Arrays.fill(matrix[i], false); 
            }
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(Num * Num + 2);
            String line;
            int nopercolation=-1;
            int top = 0;
            int bottom = Num * Num + 1;
            while ((line = br.readLine()) != null) {
                String[] dataOpen = line.split("","");
                int row = Integer.parseInt(dataOpen[0]);
                int col = Integer.parseInt(dataOpen[1]);
                //open
                matrix[row - 1][col - 1] = true;
               //如果上或下有open就和虛擬的2點union
                //Num*(row-1)是id
                if (row == 1) {
                    uf.union((Num * (row - 1) + col), top);
                }
                if (row == Num) {
                    uf.union((Num * (row - 1) + col), bottom);
                }
               //確認點周圍有沒有打開，如果有就union在一起
                //跟上接
                if (row > 1 && (matrix[row - 2][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 2) + col));
                }
                //跟下接
                if (row < Num && (matrix[row][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * row + col));
                }
                //跟左接
                if (col > 1 && (matrix[row - 1][col - 2] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col - 2));
                }
                //跟右接
                if (col < Num && (matrix[row - 1][col] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col));
                }
                if (uf.connected(top, bottom) == true) {
                    System.out.printf(""%d,%d\n"", row, col);
                    break;
                }
            }
            if (uf.connected(top, bottom) == false) {
                System.out.printf(""%d\n"",nopercolation);
            }
        }

    }
}

@e9545fdec00fc0945ebd0f6d6af3afbc@"
"b03611041","0","1.1","145712","@dabdcd374ae91e7f15b67e4145273e3a@/**
 * Created by Sunny on 3/4/16.
 */
import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            int num=Integer.parseInt(br.readLine());
            boolean matrix[][]=new boolean [num+2][num+2];
            int id[][]=new int [num][num];
            int inputNum[]=new int[2];
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(num*num+1);

            //init
            for(int i=0;i<num+2;i++){
                for(int j=0;j<num+2;j++){
                    matrix[i][j]=false;
                }
            }

            String test;
            boolean flag=false;

            while((test=br.readLine())!=null&&flag==false){
                String[] input=test.split("","");
                inputNum[0]=Integer.parseInt(input[0]);
                inputNum[1]=Integer.parseInt(input[1]);
                matrix[inputNum[0]][inputNum[1]]=true;
                int currentId=(inputNum[0]-1)*num+(inputNum[1]-1)+1;

                //check neighbor site is connected
                for(int i=-1;i<2;i++){
                    int j=0;
                    if(i==0 && j==0)continue;
                    else if(matrix[inputNum[0]+i][inputNum[1]+j]==true){
                        if(!uf.connected(currentId,(inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1))
                            uf.union((inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1,currentId);
                    }
                }

                for(int j=-1;j<2;j++){
                    int i=0;
                    if(i==0 && j==0)continue;
                    else if(matrix[inputNum[0]+i][inputNum[1]+j]==true){
                        if(!uf.connected(currentId,(inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1))
                            uf.union((inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1,currentId);
                    }
                }


                for(int i=1;i<=num;i++){
                    for(int j=num*(num-1)+1;j<=num*num;j++){
                        if(uf.connected(i,j)){
                            System.out.printf(""%d,%d"",inputNum[0],inputNum[1]);
                            flag=true;
                            break;
                        }
                    }
                    if(flag==true)break;
                }

//                for(int i=0;i<num*num+1;i++){
//                    System.out.printf(""%s "",uf.find(i));
//                }
//               c
//                System.out.printf(""\n"");

//                    System.out.printf(""%b\n"",percolation.ifNeighbor(current,tempP));
//                    if(matrix[inputNum[0]-1][inputNum[1]-1])

            }
            if(flag==false)
                System.out.printf(""%d"",-1);

        }
    }

//    boolean ifNeighbor(int[] current,int[] neighbor){
//
//        if(((Math.abs(current[0]-neighbor[0]))==0 && Math.abs(current[1]-neighbor[1])==1) || (Math.abs(current[0]-neighbor[0])==1 && Math.abs(current[1]-neighbor[1])==0))
//            return true;
//        else
//            return false;
//    }

}


@dabdcd374ae91e7f15b67e4145273e3a@"
"b03611041","0","1.01","142512","@b2c6622a9fffba7175ff9cce7748aa18@/**
 * Created by Sunny on 3/4/16.
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            int num=Integer.parseInt(br.readLine());
            boolean matrix[][]=new boolean [num+2][num+2];
            int id[][]=new int [num][num];
            int inputNum[]=new int[2];
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(num*num+1);

            //init
            for(int i=0;i<num+2;i++){
                for(int j=0;j<num+2;j++){
                    matrix[i][j]=false;
                }
            }

            String test;
            boolean flag=false;

            while((test=br.readLine())!=null&&flag==false){
                String[] input=test.split("","");
                inputNum[0]=Integer.parseInt(input[0]);
                inputNum[1]=Integer.parseInt(input[1]);
                matrix[inputNum[0]][inputNum[1]]=true;
                int currentId=(inputNum[0]-1)*num+(inputNum[1]-1)+1;

                //check neighbor site is connected
                for(int i=-1;i<2;i++){
                    int j=0;
                    if(i==0 && j==0)continue;
                    else if(matrix[inputNum[0]+i][inputNum[1]+j]==true){
                        if(!uf.connected(currentId,(inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1))
                            uf.union((inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1,currentId);
                    }
                }

                for(int j=-1;j<2;j++){
                    int i=0;
                    if(i==0 && j==0)continue;
                    else if(matrix[inputNum[0]+i][inputNum[1]+j]==true){
                        if(!uf.connected(currentId,(inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1))
                            uf.union((inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1,currentId);
                    }
                }


                for(int i=1;i<=num;i++){
                    for(int j=num*(num-1)+1;j<=num*num;j++){
                        if(uf.connected(i,j)){
                            System.out.printf(""%d,%d"",inputNum[0],inputNum[1]);
                            flag=true;
                            break;
                        }
                    }
                    if(flag==true)break;
                }

//                for(int i=0;i<num*num+1;i++){
//                    System.out.printf(""%s "",uf.find(i));
//                }
//               c
//                System.out.printf(""\n"");

//                    System.out.printf(""%b\n"",percolation.ifNeighbor(current,tempP));
//                    if(matrix[inputNum[0]-1][inputNum[1]-1])

            }
            if(flag==false)
                System.out.printf(""%d"",-1);

        }
    }

//    boolean ifNeighbor(int[] current,int[] neighbor){
//
//        if(((Math.abs(current[0]-neighbor[0]))==0 && Math.abs(current[1]-neighbor[1])==1) || (Math.abs(current[0]-neighbor[0])==1 && Math.abs(current[1]-neighbor[1])==0))
//            return true;
//        else
//            return false;
//    }

}


@b2c6622a9fffba7175ff9cce7748aa18@"
"b03611041","0","1.01","142512","@4d20ce98f521c93f9adaf8e271b46b20@/**
 * Created by Sunny on 3/4/16.
 */
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            int num=Integer.parseInt(br.readLine());
            boolean matrix[][]=new boolean [num+2][num+2];
            int id[][]=new int [num][num];
            int inputNum[]=new int[2];
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(num*num+1);

            //init
            for(int i=0;i<num+2;i++){
                for(int j=0;j<num+2;j++){
                    matrix[i][j]=false;
                }
            }

            String test;
            boolean flag=false;

            while((test=br.readLine())!=null&&flag==false){
                String[] input=test.split("","");
                inputNum[0]=Integer.parseInt(input[0]);
                inputNum[1]=Integer.parseInt(input[1]);
                matrix[inputNum[0]][inputNum[1]]=true;
                int currentId=(inputNum[0]-1)*num+(inputNum[1]-1)+1;

                //check neighbor site is connected
                for(int i=-1;i<2;i++){
                    int j=0;
                    if(i==0 && j==0)continue;
                    else if(matrix[inputNum[0]+i][inputNum[1]+j]==true){
                        if(!uf.connected(currentId,(inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1))
                            uf.union((inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1,currentId);
                    }
                }

                for(int j=-1;j<2;j++){
                    int i=0;
                    if(i==0 && j==0)continue;
                    else if(matrix[inputNum[0]+i][inputNum[1]+j]==true){
                        if(!uf.connected(currentId,(inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1))
                            uf.union((inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1,currentId);
                    }
                }


                for(int i=1;i<=num;i++){
                    for(int j=num*(num-1)+1;j<=num*num;j++){
                        if(uf.connected(i,j)){
                            System.out.printf(""%d,%d"",inputNum[0],inputNum[1]);
                            flag=true;
                            break;
                        }
                    }
                    if(flag==true)break;
                }

//                for(int i=0;i<num*num+1;i++){
//                    System.out.printf(""%s "",uf.find(i));
//                }
//               c
//                System.out.printf(""\n"");

//                    System.out.printf(""%b\n"",percolation.ifNeighbor(current,tempP));
//                    if(matrix[inputNum[0]-1][inputNum[1]-1])

            }
            if(flag==false)
                System.out.printf(""%d"",-1);

        }
    }

//    boolean ifNeighbor(int[] current,int[] neighbor){
//
//        if(((Math.abs(current[0]-neighbor[0]))==0 && Math.abs(current[1]-neighbor[1])==1) || (Math.abs(current[0]-neighbor[0])==1 && Math.abs(current[1]-neighbor[1])==0))
//            return true;
//        else
//            return false;
//    }

}


@4d20ce98f521c93f9adaf8e271b46b20@"
"r04546032","0","1.01","142512","@92ae381660a49e97ed8e23f9da7c1549@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
        for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates
    
    public boolean connect(int N)
    {
       return  wuf.connected(N*N, N*N+1);
    }
   

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (y<size-1) {//right 1
                  
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                
                if (y> 0) {//left 1
                   
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                
                if (x>0) {//up 1
                   
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                
                if (x<size-1) {//down 1
                  
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    
                }

                testedTimes++;
                
                
                                            
                if (perc.connect(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 2)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@92ae381660a49e97ed8e23f9da7c1549@"
"r04546032","0","1.01","142512","@92ae381660a49e97ed8e23f9da7c1549@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
        for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates
    
    public boolean connect(int N)
    {
       return  wuf.connected(N*N, N*N+1);
    }
   

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (y<size-1) {//right 1
                  
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                
                if (y> 0) {//left 1
                   
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                
                if (x>0) {//up 1
                   
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                
                if (x<size-1) {//down 1
                  
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    
                }

                testedTimes++;
                
                
                                            
                if (perc.connect(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 2)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@92ae381660a49e97ed8e23f9da7c1549@"
"b03611041","10","0.194","119840","@fc49798109abe5f83de64145558b4a70@/**
 * Created by Sunny on 3/4/16.
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            int num=Integer.parseInt(br.readLine());
            boolean matrix[][]=new boolean [num+2][num+2];
            int id[][]=new int [num][num];
            int inputNum[]=new int[2];
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(num*num+1);

            //init
            for(int i=0;i<num+2;i++){
                for(int j=0;j<num+2;j++){
                    matrix[i][j]=false;
                }
            }

            String test;
            boolean flag=false;

            while((test=br.readLine())!=null&&flag==false){
                String[] input=test.split("","");
                inputNum[0]=Integer.parseInt(input[0]);
                inputNum[1]=Integer.parseInt(input[1]);
                matrix[inputNum[0]][inputNum[1]]=true;
                int currentId=(inputNum[0]-1)*num+(inputNum[1]-1)+1;

                //check neighbor site is connected
                for(int i=-1;i<2;i++){
                    int j=0;
                    if(i==0 && j==0)continue;
                    else if(matrix[inputNum[0]+i][inputNum[1]+j]==true){
                        if(!uf.connected(currentId,(inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1))
                            uf.union((inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1,currentId);
                    }
                }

                for(int j=-1;j<2;j++){
                    int i=0;
                    if(i==0 && j==0)continue;
                    else if(matrix[inputNum[0]+i][inputNum[1]+j]==true){
                        if(!uf.connected(currentId,(inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1))
                            uf.union((inputNum[0]-1+i)*num+(inputNum[1]-1+j)+1,currentId);
                    }
                }


                for(int i=1;i<=num;i++){
                    for(int j=num*(num-1)+1;j<=num*num;j++){
                        if(uf.connected(i,j)){
                            System.out.printf(""%d,%d"",inputNum[0],inputNum[1]);
                            flag=true;
                            break;
                        }
                    }
                    if(flag==true)break;
                }

//                for(int i=0;i<num*num+1;i++){
//                    System.out.printf(""%s "",uf.find(i));
//                }
//               c
//                System.out.printf(""\n"");

//                    System.out.printf(""%b\n"",percolation.ifNeighbor(current,tempP));
//                    if(matrix[inputNum[0]-1][inputNum[1]-1])

            }
            if(flag==false)
                System.out.printf(""%d"",-1);

        }
    }

//    boolean ifNeighbor(int[] current,int[] neighbor){
//
//        if(((Math.abs(current[0]-neighbor[0]))==0 && Math.abs(current[1]-neighbor[1])==1) || (Math.abs(current[0]-neighbor[0])==1 && Math.abs(current[1]-neighbor[1])==0))
//            return true;
//        else
//            return false;
//    }

}


@fc49798109abe5f83de64145558b4a70@"
"r04546032","0","1.01","142512","@92ae381660a49e97ed8e23f9da7c1549@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
        for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates
    
    public boolean connect(int N)
    {
       return  wuf.connected(N*N, N*N+1);
    }
   

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (y<size-1) {//right 1
                  
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                
                if (y> 0) {//left 1
                   
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                
                if (x>0) {//up 1
                   
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                
                if (x<size-1) {//down 1
                  
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    
                }

                testedTimes++;
                
                
                                            
                if (perc.connect(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 2)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}

@92ae381660a49e97ed8e23f9da7c1549@"
"r04546032","5","1.05","142736","@70e325a256230369d283c4bb2549e6f3@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    int opensites;
    boolean[][] grid;
    public int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
        for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates
    
    public boolean connect(int N)
    {
       return  wuf.connected(N*N, N*N+1);
    }
   

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (y<size-1) {//right 1
                  
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                
                if (y> 0) {//left 1
                   
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                
                if (x>0) {//up 1
                   
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                
                if (x<size-1) {//down 1
                  
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    
                }

                testedTimes++;
                
                
                                            
                if (perc.connect(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 2)) {
                System.out.println(""-1"");
            }

            //end while(TestedTimes<tests)
        }
    }

}
@70e325a256230369d283c4bb2549e6f3@"
"r04945021","8","1.07","127312","@71beb05cedad5f31786b7b1f6c551f57@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int Num = Integer.parseInt(data[0]);
            boolean[][] matrix = new boolean[Num][Num];
            for(int i=0;i<Num;i++){
                           Arrays.fill(matrix[i], false); 
            }
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(Num * Num + 2);
            String line;
            int nopercolation=-1;
            int top = 0;
            int bottom = Num * Num + 1;
            while (((line = br.readLine()) != null)&& !("""".equals(line))) {
                String[] dataOpen = line.split("","");
                int row = Integer.parseInt(dataOpen[0]);
                int col = Integer.parseInt(dataOpen[1]);
                //open
                matrix[row - 1][col - 1] = true;
               //如果上或下有open就和虛擬的2點union
                //Num*(row-1)是id
                if (row == 1) {
                    uf.union((Num * (row - 1) + col), top);
                }
                if (row == Num) {
                    uf.union((Num * (row - 1) + col), bottom);
                }
               //確認點周圍有沒有打開，如果有就union在一起
                //跟上接
                if (row > 1 && (matrix[row - 2][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 2) + col));
                }
                //跟下接
                if (row < Num && (matrix[row][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * row + col));
                }
                //跟左接
                if (col > 1 && (matrix[row - 1][col - 2] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col - 2));
                }
                //跟右接
                if (col < Num && (matrix[row - 1][col] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col));
                }
                if (uf.connected(top, bottom) == true) {
                    System.out.printf(""%d,%d\n"", row, col);
                    break;
                }
            }
            if (uf.connected(top, bottom) == false) {
                System.out.printf(""%d\n"",nopercolation);
            }
        }

    }
}

@71beb05cedad5f31786b7b1f6c551f57@"
"r04546032","0","1.01","142512","@f1af2a28f969c4cfaefc4a971b1f7365@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    boolean[][] grid;
    private int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
        for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates
    
    public boolean connect(int N)
    {
       return  wuf.connected(N*N, N*N+1);
    }
   

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (y<size-1) {//right 1
                  
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                
                if (y> 0) {//left 1
                   
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                
                if (x>0) {//up 1
                   
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                
                if (x<size-1) {//down 1
                  
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    
                }

                testedTimes++;
                
                
                                            
                if (perc.connect(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1) ) 
            {
                if(perc.connect(N)==false)
                {System.out.println(""-1"");}
            }

            //end while(TestedTimes<tests)
        }
    }

}

@f1af2a28f969c4cfaefc4a971b1f7365@"
"r04546032","10","0.109","141616","@a8e3955d79929b1964cad33f8f54e420@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
import java.util.ArrayList;

public class Percolation {

    WeightedQuickUnionUF wuf;
    boolean[][] grid;
    private int size;
    int space = 0;
    int[][] Grid;

    public Percolation(int N) {
        int spaces = N * N;
        wuf = new WeightedQuickUnionUF(spaces + 2);//initializes the WQUUF data structure.
        this.grid = new boolean[N][N];
        int count = 0;
        Grid = new int[N][N];

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                grid[i][j] = false;
                Grid[i][j] = count;
                count++;
            }
        }

        //先upper virtual的相連
        for (int a = 0; a < N; a++) {
            wuf.union(N * N, a);
        }
        //lower virtual connect
        for (int b = N * (N - 1); b <= N * N - 1; b++) {
         wuf.union(N * N + 1, b);
         }
    }// end constructor;

    public void open(int i, int j) {

        if (this.grid[i][j] == false) {
            this.grid[i][j] = true;
        }
    }//end open

    public boolean isOpen(int i, int j) {
        return this.grid[i][j];
    }//end isOpen

    public boolean isFull(int i, int j) {
        if (isOpen(i, j)) {
            if (wuf.connected(Grid[i][j], (size * size))) {
                return true;
            }
        }//end for
        return false;
    }//end isFull

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public boolean percolates(int N) {
        for (int i = 0; i < N; i++) {
            if (isFull(i, N - 1)) {
                return true;
            }
        }
        return false;
    }//end percolates
    
    public boolean connect(int N)
    {
       return  wuf.connected(N*N, N*N+1);
    }
   

    /* 
     * checks if any space on the bottom is full returns true 
     * if there is one false other wise
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String number = br.readLine();
            int N = Integer.parseInt(number);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));

            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);
            for (int i = 0; i < temp.size(); i++) {
                temp2[i]--;
            }
            int size = N;
            int testedTimes = 1;
            // Percolation perc = new Percolation(size);
            int i = 0;
            int j = 1;

            Percolation perc = new Percolation(size);
            int coordinates[] = new int[size * size + 1];
            for (int a = 0; a < size * size + 1; a++) {
                coordinates[a] = a;
            }

            while (testedTimes != (temp2.length / 2 + 1)) {
                int x = temp2[i];
                int y = temp2[j];
//            int X =temp2[i+2];
//            int Y = temp2[j+2];
                perc.open(x, y);
//            perc.open(X, Y);

                //perc.wuf.union(perc.coordinates[perc.grid[x][y]], perc.coordinates[perc.grid[X][Y]]);
                if (y<size-1) {//right 1
                  
                        if (perc.isOpen(x , y+1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y+1]);
                        }
                    }
                
                if (y> 0) {//left 1
                   
                        if (perc.isOpen(x , y-1) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x][y-1]);
                        }
                    }
                
                if (x>0) {//up 1
                   
                        if (perc.isOpen(x-1, y) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x-1][y]);
                        }
                    }
                
                if (x<size-1) {//down 1
                  
                        if ((perc.isOpen(x+1, y)) == true) {
                            perc.wuf.union(perc.Grid[x][y], perc.Grid[x+1][y]);
                        }
                    
                }

                testedTimes++;
                
                
                                            
                if (perc.connect(N)) {
                    System.out.println((x + 1) + "","" + (y + 1));
                    break;
                }
                i += 2;
                j += 2;
            }//end while(TestedTimes<tests)
            if (testedTimes == (temp2.length / 2 + 1) ) 
            {
                if(perc.connect(N)==false)
                {System.out.println(""-1"");}
            }

            //end while(TestedTimes<tests)
        }
    }

}

@a8e3955d79929b1964cad33f8f54e420@"
"r04945021","8","1.12","128160","@28cf1d925ca848c4002b04ec54b74b93@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int Num = Integer.parseInt(data[0]);
            boolean[][] matrix = new boolean[Num][Num];
            for(int i=0;i<Num;i++){
                           Arrays.fill(matrix[i], false); 
            }
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(Num * Num + 2);
            String line;
            int nopercolation=-1;
            int top = 0;
            int bottom = Num * Num + 1;
            while ((line = br.readLine()) != null) {
                if ("""".equals(line)){
                    continue;
                }
                String[] dataOpen = line.split("","");
                int row = Integer.parseInt(dataOpen[0]);
                int col = Integer.parseInt(dataOpen[1]);
                //open
                matrix[row - 1][col - 1] = true;
               //如果上或下有open就和虛擬的2點union
                //Num*(row-1)是id
                if (row == 1) {
                    uf.union((Num * (row - 1) + col), top);
                }
                if (row == Num) {
                    uf.union((Num * (row - 1) + col), bottom);
                }
               //確認點周圍有沒有打開，如果有就union在一起
                //跟上接
                if (row > 1 && (matrix[row - 2][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 2) + col));
                }
                //跟下接
                if (row < Num && (matrix[row][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * row + col));
                }
                //跟左接
                if (col > 1 && (matrix[row - 1][col - 2] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col - 2));
                }
                //跟右接
                if (col < Num && (matrix[row - 1][col] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col));
                }
                if (uf.connected(top, bottom) == true) {
                    System.out.printf(""%d,%d\n"", row, col);
                    break;
                }
            }
            if (uf.connected(top, bottom) == false) {
                System.out.printf(""%d\n"",nopercolation);
            }
        }

    }
}

@28cf1d925ca848c4002b04ec54b74b93@"
"r04945021","10","0.11","127744","@e885983f2280e8afc6292f5a432bd4a8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int Num = Integer.parseInt(data[0]);
            boolean[][] matrix = new boolean[Num][Num];
            for(int i=0;i<Num;i++){
                           Arrays.fill(matrix[i], false); 
            }
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(Num * Num + 2);
            String line;
            int nopercolation=-1;
            int top = 0;
            int bottom = Num * Num + 1;
            while ((line = br.readLine()) != null) {
                if ("""".equals(line)){
                    continue;
                }
                String[] dataOpen = line.split("","");
                int row = Integer.parseInt(dataOpen[0]);
                int col = Integer.parseInt(dataOpen[1]);
                //open
                matrix[row - 1][col - 1] = true;
               //如果上或下有open就和虛擬的2點union
                //Num*(row-1)是id
                if (row == 1) {
                    uf.union((Num * (row - 1) + col), top);
                }
                if (row == Num) {
                    uf.union((Num * (row - 1) + col), bottom);
                }
               //確認點周圍有沒有打開，如果有就union在一起
                //跟上接
                if (row > 1 && (matrix[row - 2][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 2) + col));
                }
                //跟下接
                if (row < Num && (matrix[row][col - 1] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * row + col));
                }
                //跟左接
                if (col > 1 && (matrix[row - 1][col - 2] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col - 1));
                }
                //跟右接
                if (col < Num && (matrix[row - 1][col] == true)) {
                    uf.union((Num * (row - 1) + col), (Num * (row - 1) + col+1));
                }
                if (uf.connected(top, bottom) == true) {
                    System.out.printf(""%d,%d\n"", row, col);
                    break;
                }
            }
            if (uf.connected(top, bottom) == false) {
                System.out.printf(""%d\n"",nopercolation);
            }
        }

    }
}

@e885983f2280e8afc6292f5a432bd4a8@"
"b02611023","0","0","0","@dbd7a16cb31ace88c58752cdb42e3ada@import java.io.*;

public class Percolation {

	public static int[] check;

	public static int num;

	public static void main(String[] args) throws Exception{
		try(BufferedReader br = new BufferedReader(new FileReader(""input.txt""))){

			num = Integer.parseInt(br.readLine());

			String line;

			String[] lines = new String[2];

			int count;

			check = new int[num * num + 2];
			check[num*num] = num * num;
			check[num*num+1] = num * num + 1;

			int root_1 = 0;

			int[][] matrix = new int[num+2][num+2];

			for(int i = 0; i < num * num; i ++){
				line = br.readLine();
				if(num == 1){
					System.out.println(line);
				}
				if(line == null){
					break;
				}

				lines = line.split("","");
				int row = Integer.parseInt(lines[0]);
				int col = Integer.parseInt(lines[1]);
				matrix[row][col] = 1;
				count = col - 1 + num * (row - 1);
				check[count] = count;

				if(row == 1){
					//check[count] = check[num*num];
					union(check[count],check[num*num]);
				}
				if(row == num){
					//check[count] = check[num*num+1];
					union(check[count],check[num*num+1]);
				}
				//�U
				if(matrix[row][col] - matrix[row+1][col] == 0){
					//check[row*num+col-1] = check[count];
					union(check[row*num+col-1],check[count]);
				}
				//�k
				if(matrix[row][col] - matrix[row][col+1] == 0){
					//check[(row-1)*num+col] = check[count];
					union(check[(row-1)*num+col],check[count]);
				}
				//��
				if(matrix[row][col] - matrix[row][col-1] == 0){
					//check[count] = check[(row-1)*num+col-2];
					union(check[count],check[(row-1)*num+col-2]);
				}
				//�W
				if(matrix[row][col] - matrix[row-1][col] == 0){
					//check[count] = check[(row-2)*num+col-1];
					union(check[count],check[(row-2)*num+col-1]);
				}

				root_1 = root(check[num*num+1]);

				if(root_1 == check[num*num]){
					System.out.println(row + "","" + col);
					//System.out.println(root_1);
					break;
				}
				//System.out.println(check[count]);
			}
			/*for(int k = 0;k<num*num+2;k++){
				System.out.println(check[k]);
			}*/
			if(root_1 != check[num*num]){
				//System.out.println(check[num*num]);
				System.out.println(""-1"");
			}
		}
	}

	public static int root(int i){
		while(i != check[i]){
			i = check[i];
		}
		return i;
	}

	public static void union(int p, int q){
		int i = root(p);
		int j = root(q);
		check[i] = j;
	}
}

@dbd7a16cb31ace88c58752cdb42e3ada@"
"b02611023","8","1.14","145888","@c958acffbe5af91e10bfe072f77c1a10@import java.io.*;

public class Percolation {

	public static int[] check;

	public static int num;

	public static void main(String[] args) throws Exception{
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

			num = Integer.parseInt(br.readLine());

			String line;

			String[] lines = new String[2];

			int count;

			check = new int[num * num + 2];
			check[num*num] = num * num;
			check[num*num+1] = num * num + 1;

			int root_1 = 0;

			int[][] matrix = new int[num+2][num+2];

			for(int i = 0; i < num * num; i ++){
				line = br.readLine();
				if(num == 1){
					System.out.println(line);
				}
				if(line == null){
					break;
				}

				lines = line.split("","");
				int row = Integer.parseInt(lines[0]);
				int col = Integer.parseInt(lines[1]);
				matrix[row][col] = 1;
				count = col - 1 + num * (row - 1);
				check[count] = count;

				if(row == 1){
					//check[count] = check[num*num];
					union(check[count],check[num*num]);
				}
				if(row == num){
					//check[count] = check[num*num+1];
					union(check[count],check[num*num+1]);
				}
				//�U
				if(matrix[row][col] - matrix[row+1][col] == 0){
					//check[row*num+col-1] = check[count];
					union(check[row*num+col-1],check[count]);
				}
				//�k
				if(matrix[row][col] - matrix[row][col+1] == 0){
					//check[(row-1)*num+col] = check[count];
					union(check[(row-1)*num+col],check[count]);
				}
				//��
				if(matrix[row][col] - matrix[row][col-1] == 0){
					//check[count] = check[(row-1)*num+col-2];
					union(check[count],check[(row-1)*num+col-2]);
				}
				//�W
				if(matrix[row][col] - matrix[row-1][col] == 0){
					//check[count] = check[(row-2)*num+col-1];
					union(check[count],check[(row-2)*num+col-1]);
				}

				root_1 = root(check[num*num+1]);

				if(root_1 == check[num*num]){
					System.out.println(row + "","" + col);
					//System.out.println(root_1);
					break;
				}
				//System.out.println(check[count]);
			}
			/*for(int k = 0;k<num*num+2;k++){
				System.out.println(check[k]);
			}*/
			if(root_1 != check[num*num]){
				//System.out.println(check[num*num]);
				System.out.println(""-1"");
			}
		}
	}

	public static int root(int i){
		while(i != check[i]){
			i = check[i];
		}
		return i;
	}

	public static void union(int p, int q){
		int i = root(p);
		int j = root(q);
		check[i] = j;
	}
}

@c958acffbe5af91e10bfe072f77c1a10@"
"b02611023","8","1.14","138144","@c958acffbe5af91e10bfe072f77c1a10@import java.io.*;

public class Percolation {

	public static int[] check;

	public static int num;

	public static void main(String[] args) throws Exception{
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

			num = Integer.parseInt(br.readLine());

			String line;

			String[] lines = new String[2];

			int count;

			check = new int[num * num + 2];
			check[num*num] = num * num;
			check[num*num+1] = num * num + 1;

			int root_1 = 0;

			int[][] matrix = new int[num+2][num+2];

			for(int i = 0; i < num * num; i ++){
				line = br.readLine();
				if(num == 1){
					System.out.println(line);
				}
				if(line == null){
					break;
				}

				lines = line.split("","");
				int row = Integer.parseInt(lines[0]);
				int col = Integer.parseInt(lines[1]);
				matrix[row][col] = 1;
				count = col - 1 + num * (row - 1);
				check[count] = count;

				if(row == 1){
					//check[count] = check[num*num];
					union(check[count],check[num*num]);
				}
				if(row == num){
					//check[count] = check[num*num+1];
					union(check[count],check[num*num+1]);
				}
				//�U
				if(matrix[row][col] - matrix[row+1][col] == 0){
					//check[row*num+col-1] = check[count];
					union(check[row*num+col-1],check[count]);
				}
				//�k
				if(matrix[row][col] - matrix[row][col+1] == 0){
					//check[(row-1)*num+col] = check[count];
					union(check[(row-1)*num+col],check[count]);
				}
				//��
				if(matrix[row][col] - matrix[row][col-1] == 0){
					//check[count] = check[(row-1)*num+col-2];
					union(check[count],check[(row-1)*num+col-2]);
				}
				//�W
				if(matrix[row][col] - matrix[row-1][col] == 0){
					//check[count] = check[(row-2)*num+col-1];
					union(check[count],check[(row-2)*num+col-1]);
				}

				root_1 = root(check[num*num+1]);

				if(root_1 == check[num*num]){
					System.out.println(row + "","" + col);
					//System.out.println(root_1);
					break;
				}
				//System.out.println(check[count]);
			}
			/*for(int k = 0;k<num*num+2;k++){
				System.out.println(check[k]);
			}*/
			if(root_1 != check[num*num]){
				//System.out.println(check[num*num]);
				System.out.println(""-1"");
			}
		}
	}

	public static int root(int i){
		while(i != check[i]){
			i = check[i];
		}
		return i;
	}

	public static void union(int p, int q){
		int i = root(p);
		int j = root(q);
		check[i] = j;
	}
}

@c958acffbe5af91e10bfe072f77c1a10@"
"b02611023","8","1.04","122928","@716aadfd9785ee8d500f320fd1161188@import java.io.*;

public class Percolation {

	public static int[] check;

	public static int num;

	public static void main(String[] args) throws Exception{
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

			num = Integer.parseInt(br.readLine());

			String line;

			String[] lines = new String[2];

			int count;

			check = new int[num * num + 2];
			check[num*num] = num * num;
			check[num*num+1] = num * num + 1;

			int root_1 = 0;

			int root_2 = 0;

			int[][] matrix = new int[num+2][num+2];

			for(int i = 0; i < num * num; i ++){
				line = br.readLine();
				if(num == 1){
					System.out.println(line);
				}
				if(line == null){
					break;
				}

				lines = line.split("","");
				int row = Integer.parseInt(lines[0]);
				int col = Integer.parseInt(lines[1]);
				matrix[row][col] = 1;
				count = col - 1 + num * (row - 1);
				check[count] = count;

				if(row == 1){
					union(check[count],check[num*num]);
				}
				if(row == num){
					union(check[count],check[num*num+1]);
				}
				//�U
				if(matrix[row][col] - matrix[row+1][col] == 0){
					union(check[row*num+col-1],check[count]);
				}
				//�k
				if(matrix[row][col] - matrix[row][col+1] == 0){
					union(check[(row-1)*num+col],check[count]);
				}
				//��
				if(matrix[row][col] - matrix[row][col-1] == 0){
					union(check[count],check[(row-1)*num+col-2]);
				}
				//�W
				if(matrix[row][col] - matrix[row-1][col] == 0){
					union(check[count],check[(row-2)*num+col-1]);
				}

				root_1 = root(check[num*num+1]);

				root_2 = root(check[num*num]);

				if(root_1 == root_2){
					System.out.println(row + "","" + col);
					break;
				}
			}
			if(root_1 != check[num*num]){
				System.out.println(""-1"");
			}
		}
	}

	public static int root(int i){
		while(i != check[i]){
			i = check[i];
		}
		return i;
	}

	public static void union(int p, int q){
		int i = root(p);
		int j = root(q);
		check[i] = j;
	}
}

@716aadfd9785ee8d500f320fd1161188@"
"b02611023","9","1.07","125952","@902b5c463891ed544d781656efd6250e@import java.io.*;

public class Percolation {

	public static int[] check;

	public static int num;

	public static void main(String[] args) throws Exception{
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

			num = Integer.parseInt(br.readLine());

			String line;

			String[] lines = new String[2];

			int count;

			check = new int[num * num + 2];
			check[num*num] = num * num;
			check[num*num+1] = num * num + 1;

			int root_1 = 0;

			int root_2 = 0;

			int[][] matrix = new int[num+2][num+2];

			for(int i = 0; i < num * num; i ++){
				line = br.readLine();
				if(num == 1){
					System.out.println(line);
				}
				if(line == null){
					break;
				}

				lines = line.split("","");
				int row = Integer.parseInt(lines[0]);
				int col = Integer.parseInt(lines[1]);
				matrix[row][col] = 1;
				count = col - 1 + num * (row - 1);
				check[count] = count;

				if(row == 1){
					union(check[count],check[num*num]);
				}
				if(row == num){
					union(check[count],check[num*num+1]);
				}
				//�U
				if(matrix[row][col] - matrix[row+1][col] == 0){
					union(check[row*num+col-1],check[count]);
				}
				//�k
				if(matrix[row][col] - matrix[row][col+1] == 0){
					union(check[(row-1)*num+col],check[count]);
				}
				//��
				if(matrix[row][col] - matrix[row][col-1] == 0){
					union(check[count],check[(row-1)*num+col-2]);
				}
				//�W
				if(matrix[row][col] - matrix[row-1][col] == 0){
					union(check[count],check[(row-2)*num+col-1]);
				}

				root_1 = root(check[num*num+1]);

				root_2 = root(check[num*num]);

				if(root_1 == root_2){
					System.out.println(row + "","" + col);
					break;
				}
			}
			if(root_1 != root_2){
				System.out.println(""-1"");
			}
		}
	}

	public static int root(int i){
		while(i != check[i]){
			i = check[i];
		}
		return i;
	}

	public static void union(int p, int q){
		int i = root(p);
		int j = root(q);
		check[i] = j;
	}
}

@902b5c463891ed544d781656efd6250e@"
"b02611023","9","0.87","124240","@336a8044f958740c14f55d04e23e523f@import java.io.*;

public class Percolation {

	public static int[] check;

	public static int num;

	public static void main(String[] args) throws Exception{
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

			num = Integer.parseInt(br.readLine());

			String line;

			String[] lines = new String[2];

			int count;

			check = new int[num * num + 2];
			check[num*num] = num * num;
			check[num*num+1] = num * num + 1;

			int root_1 = 0;

			int root_2 = 0;

			int[][] matrix = new int[num+2][num+2];

			for(int i = 0; i < num * num; i ++){
				line = br.readLine();
				if(num == 1){
					System.out.println(line);
				}
				if(line == null){
					break;
				}

				lines = line.split("","");
				int row = Integer.parseInt(lines[0]);
				int col = Integer.parseInt(lines[1]);

				if(row > num || row < 0 || col > num || col <0){
					continue;
				}

				matrix[row][col] = 1;
				count = col - 1 + num * (row - 1);
				check[count] = count;

				if(row == 1){
					union(check[count],check[num*num]);
				}
				if(row == num){
					union(check[count],check[num*num+1]);
				}
				//�U
				if(matrix[row][col] - matrix[row+1][col] == 0){
					union(check[row*num+col-1],check[count]);
				}
				//�k
				if(matrix[row][col] - matrix[row][col+1] == 0){
					union(check[(row-1)*num+col],check[count]);
				}
				//��
				if(matrix[row][col] - matrix[row][col-1] == 0){
					union(check[count],check[(row-1)*num+col-2]);
				}
				//�W
				if(matrix[row][col] - matrix[row-1][col] == 0){
					union(check[count],check[(row-2)*num+col-1]);
				}

				root_1 = root(check[num*num+1]);

				root_2 = root(check[num*num]);

				if(root_1 == root_2){
					System.out.println(row + "","" + col);
					break;
				}
			}
			if(root_1 != root_2){
				System.out.println(""-1"");
			}
		}
	}

	public static int root(int i){
		while(i != check[i]){
			i = check[i];
		}
		return i;
	}

	public static void union(int p, int q){
		int i = root(p);
		int j = root(q);
		check[i] = j;
	}
}

@336a8044f958740c14f55d04e23e523f@"
"b02611023","10","0.104","120224","@f733e449c4e6d4b992bc59c5d8ecd80e@import java.io.*;

public class Percolation {

	public static int[] check;

	public static int num;

	public static void main(String[] args) throws Exception{
		try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

			num = Integer.parseInt(br.readLine());

			String line;

			String[] lines = new String[2];

			int count;

			check = new int[num * num + 2];
			check[num*num] = num * num;
			check[num*num+1] = num * num + 1;

			int root_1 = 0;

			int root_2 = 0;

			int[][] matrix = new int[num+2][num+2];

			for(int i = 0; i < num * num; i ++){
				line = br.readLine();
				if(num == 1){
					System.out.println(line);
					break;
				}
				if(line == null){
					break;
				}

				lines = line.split("","");
				int row = Integer.parseInt(lines[0]);
				int col = Integer.parseInt(lines[1]);

				if(row > num || row < 0 || col > num || col < 0){
					continue;
				}

				matrix[row][col] = 1;
				count = col - 1 + num * (row - 1);
				check[count] = count;

				if(row == 1){
					union(check[count],check[num*num]);
				}
				if(row == num){
					union(check[count],check[num*num+1]);
				}
				//�U
				if(matrix[row][col] - matrix[row+1][col] == 0){
					union(check[row*num+col-1],check[count]);
				}
				//�k
				if(matrix[row][col] - matrix[row][col+1] == 0){
					union(check[(row-1)*num+col],check[count]);
				}
				//��
				if(matrix[row][col] - matrix[row][col-1] == 0){
					union(check[count],check[(row-1)*num+col-2]);
				}
				//�W
				if(matrix[row][col] - matrix[row-1][col] == 0){
					union(check[count],check[(row-2)*num+col-1]);
				}

				root_1 = root(check[num*num+1]);

				root_2 = root(check[num*num]);

				if(root_1 == root_2){
					System.out.println(row + "","" + col);
					break;
				}
			}
			if(root_1 != root_2){
				System.out.println(""-1"");
			}
		}
	}

	public static int root(int i){
		while(i != check[i]){
			i = check[i];
		}
		return i;
	}

	public static void union(int p, int q){
		int i = root(p);
		int j = root(q);
		check[i] = j;
	}
}
@f733e449c4e6d4b992bc59c5d8ecd80e@"
"r04228002","6","1.73","154432","@e3f1a8f249bf5fbc2bc45203d1c752e4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            
            String[] row1 = br.readLine().split("","");
            int SizeNum = Integer.parseInt(row1[0]);
            //System.out.println(SizeNum);
            
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(SizeNum*SizeNum+2);
            Point SupperTop = new Point(SizeNum*SizeNum,SizeNum*SizeNum+1,SizeNum*SizeNum+1);
            Point SupperBottom = new Point(SizeNum*SizeNum+1,SizeNum*SizeNum+1,SizeNum*SizeNum+1);
                    
            ArrayList<Point> PointList = new ArrayList<Point>();
            for (int i = 0; i< i+1;i++){
                String[] row;
                try{
                    row = br.readLine().split("","");
                }
                catch(Exception e){
                    break;
                }
                //String[] row = br.readLine().split("","");
                int x = Integer.parseInt(row[0]);
                int y = Integer.parseInt(row[1]);
                
                Point p1 = new Point(i,x,y);
                
                if (x == 1){
                    uf.union(i, SupperTop.ID); 
                }
                if (x == SizeNum){
                    uf.union(i, SupperBottom.ID);
                }
                PointList.add(p1);
                
                int x1 = x-1;
                int x2 = x+1;
                int y1 = y-1;
                int y2 = y+1;
                
                
                for (int j=0;j < PointList.size();j++){
                    Point a = PointList.get(j);
                    int xx = a.XCOOR; 
                    int yy = a.XCOOR;
                    if (xx == x1 & yy == y){
                    uf.union(i, a.ID);
                }
                    if (xx == x2 & yy == y){
                    uf.union(i, a.ID);
                } 
                    if (xx == x & yy == y1){
                    uf.union(i, a.ID);
                } 
                    if (xx == x & yy == y2){
                    uf.union(i, a.ID);
                }
                }
                
                boolean result = uf.connected(SupperTop.ID,SupperBottom.ID);
                //System.out.println(result);
                if (result == true){
                    String out = row[0] + "","" + row[1];
                    System.out.println(out);
                    break;
                    }
                
            }
            boolean result = uf.connected(SupperTop.ID,SupperBottom.ID);
            if (result == false){
                System.out.println(""-1"");
            }
           
        }
    }
    
}

class Point{
    public int XCOOR;
    public int YCOOR;
    public int ID;
    public Point(int id,int x,int y){
        int XCOOR;
        XCOOR=x;
        this.XCOOR=x;
        int YCOOR;
        YCOOR=y;
        this.YCOOR=y;
        int ID;
        ID=id;
        this.ID=id;
        
    
    }
    public int getX(){
        return XCOOR;      
    }
    public int getY(){
        return YCOOR;
    }
    public int getID(){
        return ID;
    }
    
}

@e3f1a8f249bf5fbc2bc45203d1c752e4@"
"r04921028","0","0.87","124240","@5d1bbbb2e976e48023b1cb4613006a18@public class Percolation {
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
                  
//===============================================================================

            String buf1[] = br.readLine().split("","");
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            int count2 = 1;
            while (br.ready())
            {
//            System.out.println(count2);
            String buf2[] = br.readLine().split("","");
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
            int p = M[Mx[count2-1]-1][My[count2-1]-1];
            int q = M[Mx[count2]-1][My[count2]-1];
//            System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
            StdOut.println(Mx[count2] + "","" + My[count2]);
             break;
            }
            count2++;
            }
        }
        
    }
    
    
}
@5d1bbbb2e976e48023b1cb4613006a18@"
"r04921028","4","2.18","134128","@5d9968f6092072ebd6ca4141011adae7@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */



public class Percolation {
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
                  
//===============================================================================

            String buf1[] = br.readLine().split("","");
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            int count2 = 1;
            while (br.ready())
            {
//            System.out.println(count2);
            String buf2[] = br.readLine().split("","");
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
            int p = M[Mx[count2-1]-1][My[count2-1]-1];
            int q = M[Mx[count2]-1][My[count2]-1];
//            System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
            StdOut.println(Mx[count2] + "","" + My[count2]);
             break;
            }
            count2++;
            }
        }
        
    }
    
    
}

@5d9968f6092072ebd6ca4141011adae7@"
"r04921028","9","2.3","139104","@b625c432c7c8598905f88fd2bd46973c@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */



public class Percolation {
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
                  
//===============================================================================

            String buf1[] = br.readLine().split("","");
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            int count2 = 1;
            while (br.ready())
            {
//            System.out.println(count2);
            String buf2[] = br.readLine().split("","");
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
//          System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
            StdOut.println(Mx[count2] + "","" + My[count2]);
             break;
            }
            
            count2++;
            }
            if(!uf.connected(0,(n*n)+1))
            {    
            StdOut.println(""-1"");
            }
        }
        
    }
    
    
}
@b625c432c7c8598905f88fd2bd46973c@"
"r04921028","9","2.52","137008","@8f94bbdf47ecdade5bd343915822fc76@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */



public class Percolation {
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
//===============================================================================

            String buf1[] = br.readLine().split("","");
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            int count2 = 1;
            while (br.ready())
            {
//            System.out.println(count2);
            String buf2[] = br.readLine().split("","");
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
//          System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
                if (uf.connected(0,(n*n)+1))
                {
                StdOut.println(Mx[count2] + "","" + My[count2]);
                 break;
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
//            StdOut.println(Mx[count2] + "","" + My[count2]);
             break;
            }
            
            count2++;
            }
            if(!uf.connected(0,(n*n)+1))
            {    
            StdOut.println(""-1"");
            }
        }
        
    }
}
@8f94bbdf47ecdade5bd343915822fc76@"
"b03611011","1","0.4","100864","@e87df74f110c1f134fab01fccc5f7746@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], tep[], count[];
    private static int num, recount, tf = 0;
    private static int number[] = new int[1];

    private static int v = 1;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        if (p < num || p > num * (num - 1)) {
            id[p] = 1;
            if (p >= num * (num)) {
                id[p] = id.length;
            }
        } else {
            quotient = p % num;
            switch (quotient) {
                case 1: {
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p] = id[p + 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p] = id[p + num];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0) {
                        v++;
                        id[p] = v;
                    }
                    break;
                }
                case 0:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p - 1] > 0) {
                        id[p] = id[p - 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p - 1] <= 0 && id[p + num] <= 0) {
                        v++;
                        id[p] = v;
                    }
                    break;
                default:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p] = id[p + 1];
                        tep[recount] = id[p];
                    }
                    if (id[p - 1] > 0) {
                        id[p] = id[p - 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0 && id[p - 1] <= 0) {
                        v++;
                        id[p] = v;
                    }
            }
        }
        for (int i = 0; i < num; i++) {
            if (id[2 * num + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }

        if (tf == 1) {
            for (int k = 1; k < id.length - 1; k++) {
                if (id[k] == tep[recount]) {
                    id[k] = id[p - num];
                }
            }
        }
    }

    public int getnumber() {
        return number[0];
    }

    public static void point(int x, int y) {
        number[0] = 0;
        number[0] = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            num = Integer.parseInt(data[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            tep = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
                tep[i] = 0;
            }
            id[0] = 1;
            int j = 1;
            recount = 0;
            count = new int[2];
            number[0] = 0;
            while (j >= 0) {
                String[] data1 = br.readLine().split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                union(number[0]);
                if (tf == -1) {
                    System.out.println(count[0]+"",""+count[1]);
                    break;
                }
                j++;
            }

        }
    }
}

@e87df74f110c1f134fab01fccc5f7746@"
"b03611011","1","0.47","105232","@e87df74f110c1f134fab01fccc5f7746@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], tep[], count[];
    private static int num, recount, tf = 0;
    private static int number[] = new int[1];

    private static int v = 1;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        if (p < num || p > num * (num - 1)) {
            id[p] = 1;
            if (p >= num * (num)) {
                id[p] = id.length;
            }
        } else {
            quotient = p % num;
            switch (quotient) {
                case 1: {
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p] = id[p + 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p] = id[p + num];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0) {
                        v++;
                        id[p] = v;
                    }
                    break;
                }
                case 0:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p - 1] > 0) {
                        id[p] = id[p - 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p - 1] <= 0 && id[p + num] <= 0) {
                        v++;
                        id[p] = v;
                    }
                    break;
                default:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p] = id[p + 1];
                        tep[recount] = id[p];
                    }
                    if (id[p - 1] > 0) {
                        id[p] = id[p - 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0 && id[p - 1] <= 0) {
                        v++;
                        id[p] = v;
                    }
            }
        }
        for (int i = 0; i < num; i++) {
            if (id[2 * num + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }

        if (tf == 1) {
            for (int k = 1; k < id.length - 1; k++) {
                if (id[k] == tep[recount]) {
                    id[k] = id[p - num];
                }
            }
        }
    }

    public int getnumber() {
        return number[0];
    }

    public static void point(int x, int y) {
        number[0] = 0;
        number[0] = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            num = Integer.parseInt(data[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            tep = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
                tep[i] = 0;
            }
            id[0] = 1;
            int j = 1;
            recount = 0;
            count = new int[2];
            number[0] = 0;
            while (j >= 0) {
                String[] data1 = br.readLine().split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                union(number[0]);
                if (tf == -1) {
                    System.out.println(count[0]+"",""+count[1]);
                    break;
                }
                j++;
            }

        }
    }
}

@e87df74f110c1f134fab01fccc5f7746@"
"r04921028","4","2.57","138800","@42f666afcb02a5903a91eb3f41483486@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */



public class Percolation {
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
//===============================================================================
            
            String buf1[] = br.readLine().split("","");
            if(br.ready()){
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            }
            int count2 = 1;
            
            while (br.ready())
            {
//            System.out.println(count2);
            String buf2[] = br.readLine().split("","");
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
//          System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
                if (uf.connected(0,(n*n)+1))
                {
                StdOut.println(Mx[count2] + "","" + My[count2]);
                 break;
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
//            StdOut.println(Mx[count2] + "","" + My[count2]);
             break;
            }
            
            count2++;
            }
            if(n==1&&Mx[0]==1){
                StdOut.println(""1,1"");
            }
            if(n==1&&Mx[0]!=1){
                StdOut.println(""-1"");
            }
        }
        
    }
}
@42f666afcb02a5903a91eb3f41483486@"
"r04921028","4","2.53","141888","@64972d9e0bb21b3b8367325dd89b8f14@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */



public class Percolation {
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
//===============================================================================

            String buf1[] = br.readLine().split("","");
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            int count2 = 1;
            while (br.ready())
            {
//            System.out.println(count2);
            String buf2[] = br.readLine().split("","");
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
//          System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
                if (uf.connected(0,(n*n)+1))
                {
                StdOut.println(Mx[count2] + "","" + My[count2]);
                 break;
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
//            StdOut.println(Mx[count2] + "","" + My[count2]);

             break;
            }
            
            count2++;
            }
        }
        
    }
}
@64972d9e0bb21b3b8367325dd89b8f14@"
"r04921028","9","2.55","133552","@8f94bbdf47ecdade5bd343915822fc76@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */



public class Percolation {
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
//===============================================================================

            String buf1[] = br.readLine().split("","");
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            int count2 = 1;
            while (br.ready())
            {
//            System.out.println(count2);
            String buf2[] = br.readLine().split("","");
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
//          System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
                if (uf.connected(0,(n*n)+1))
                {
                StdOut.println(Mx[count2] + "","" + My[count2]);
                 break;
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
//            StdOut.println(Mx[count2] + "","" + My[count2]);
             break;
            }
            
            count2++;
            }
            if(!uf.connected(0,(n*n)+1))
            {    
            StdOut.println(""-1"");
            }
        }
        
    }
}
@8f94bbdf47ecdade5bd343915822fc76@"
"b03611011","1","0.39","104736","@faa52a019d611580154fb93aafbb138f@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], tep[], count[];
    private static int num, recount, tf = 0;
    private static int number[] = new int[1];

    private static int v = 1;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        if (p < num || p > num * (num - 1)) {
            id[p] = 1;
            if (p < num && id[p + num] != 0) {
                id[p + num] = id[p];
            }
            if (p >= num * (num)) {
                id[p] = id.length;
            }
        } else {
            quotient = p % num;
            switch (quotient) {
                case 1: {
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p] = id[p + 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p] = id[p + num];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0) {
                        v++;
                        id[p] = v;
                    }
                    break;
                }
                case 0:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p - 1] > 0) {
                        id[p] = id[p - 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p - 1] <= 0 && id[p + num] <= 0) {
                        v++;
                        id[p] = v;
                    }
                    break;
                default:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p] = id[p + 1];
                        tep[recount] = id[p];
                    }
                    if (id[p - 1] > 0) {
                        id[p] = id[p - 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0 && id[p - 1] <= 0) {
                        v++;
                        id[p] = v;
                    }
            }
        }
        for (int i = 0; i < num; i++) {
            if (id[2 * num + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }

        if (tf == 1) {
            for (int i = 0; i < 2; i++) {
                for (int k = 1; k < id.length - 1; k++) {
                    if (id[k] == tep[recount]) {
                        id[k] = id[p - num];
                    }
                }
            }
        }
    }

    public int getnumber() {
        return number[0];
    }

    public static void point(int x, int y) {
        number[0] = 0;
        number[0] = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            num = Integer.parseInt(data[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            tep = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
                tep[i] = 0;
            }
            id[0] = 1;
            int j = 1;
            recount = 0;
            count = new int[2];
            number[0] = 0;
            while (j >= 0) {
                String[] data1 = br.readLine().split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                union(number[0]);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
                j++;
            }

        }
    }
}

@faa52a019d611580154fb93aafbb138f@"
"b03611035","0","0","0","@5a0c7bc2ecb3462425e8abb8b0a12fc7@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""input.dat""))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         br.read();
         //建立UF物件，名為gg
         UFF gg=new UFF(order*order);
               
         //MARK
         br.mark(1234);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UFF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }
             
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",y,x);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

private static class UFF {
    private int[] id;     // id[i] = parent of i
    private int[] opcl;
    private byte[] rank;  // rank[i] = rank of subtree rooted at i (cannot be more than 31)
    private int count;    // number of components

    /**
     * Initializes an empty union-find data structure with <tt>N</tt>
     * isolated components <tt>0</tt> through <tt>N-1</tt>
     * @throws java.lang.IllegalArgumentException if <tt>N &lt; 0</tt>
     * @param N the number of sites
     */
    public UFF(int N) {
        if (N < 0) throw new IllegalArgumentException();
        count = N;
        id = new int[N];
        opcl = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
            opcl[i]=i;
            rank[i] = 0;
        }
    }

    /**
     * Returns the component identifier for the component containing site <tt>p</tt>.
     * @param p the integer representing one object
     * @return the component identifier for the component containing site <tt>p</tt>
     * @throws java.lang.IndexOutOfBoundsException unless <tt>0 &le; p &lt; N</tt>
     */
    public int find(int p) {
        if (p < 0 || p >= id.length) throw new IndexOutOfBoundsException();
        while (p != id[p]) {
            id[p] = id[id[p]];    // path compression by halving
            p = id[p];
        }
        return p;
    }

    /**
     * Returns the number of components.
     * @return the number of components (between <tt>1</tt> and <tt>N</tt>)
     */
    public int count() {
        return count;
    }
  
    /**
     * Are the two sites <tt>p</tt> and <tt>q</tt> in the same component?
     * @param p the integer representing one site
     * @param q the integer representing the other site
     * @return true if the two sites <tt>p</tt> and <tt>q</tt> are in the same component; false otherwise
     * @throws java.lang.IndexOutOfBoundsException unless
     *      both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
     */
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

  
    /**
     * Merges the component containing site <tt>p</tt> with the 
     * the component containing site <tt>q</tt>.
     * @param p the integer representing one site
     * @param q the integer representing the other site
     * @throws java.lang.IndexOutOfBoundsException unless
     *      both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
     */
    public void union(int p, int q) {
        int i = find(p);
        int j = find(q);
        if (i == j) return;

        // make root of smaller rank point to root of larger rank
        if      (rank[i] < rank[j]) id[i] = j;
        else if (rank[i] > rank[j]) id[j] = i;
        else {
            id[j] = i;
            rank[i]++;
        }
        count--;
    }
   
    /**
     * Reads in a an integer <tt>N</tt> and a sequence of pairs of integers
     * (between <tt>0</tt> and <tt>N-1</tt>) from standard input, where each integer
     * in the pair represents some site;
     * if the sites are in different components, merge the two components
     * and print the pair to standard output.
    public static void main(String[] args) {
        int N = StdIn.readInt();
        UFF uf = new UFF(N);
        while (!StdIn.isEmpty()) {
            int p = StdIn.readInt();
            int q = StdIn.readInt();
            if (uf.connected(p, q)) continue;
            uf.union(p, q);
            StdOut.println(p + "" "" + q);
        }
        StdOut.println(uf.count() + "" components"");
    }*/
}}
@5a0c7bc2ecb3462425e8abb8b0a12fc7@"
"b03611035","0","0","0","@6c2269af243cb76c9b12cc474add71d6@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""input.dat""))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UFF gg=new UFF(order*order);
               
         //MARK
         br.mark(1234);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UFF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }
             
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",y,x);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

private static class UFF {
    private int[] id;     // id[i] = parent of i
    private byte[] rank;  // rank[i] = rank of subtree rooted at i (cannot be more than 31)
    private int count;    // number of components

    /**
     * Initializes an empty union-find data structure with <tt>N</tt>
     * isolated components <tt>0</tt> through <tt>N-1</tt>
     * @throws java.lang.IllegalArgumentException if <tt>N &lt; 0</tt>
     * @param N the number of sites
     */
    public UFF(int N) {
        if (N < 0) throw new IllegalArgumentException();
        count = N;
        id = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
            rank[i] = 0;
        }
    }

    /**
     * Returns the component identifier for the component containing site <tt>p</tt>.
     * @param p the integer representing one object
     * @return the component identifier for the component containing site <tt>p</tt>
     * @throws java.lang.IndexOutOfBoundsException unless <tt>0 &le; p &lt; N</tt>
     */
    public int find(int p) {
        if (p < 0 || p >= id.length) throw new IndexOutOfBoundsException();
        while (p != id[p]) {
            id[p] = id[id[p]];    // path compression by halving
            p = id[p];
        }
        return p;
    }

    /**
     * Returns the number of components.
     * @return the number of components (between <tt>1</tt> and <tt>N</tt>)
     */
    public int count() {
        return count;
    }
  
    /**
     * Are the two sites <tt>p</tt> and <tt>q</tt> in the same component?
     * @param p the integer representing one site
     * @param q the integer representing the other site
     * @return true if the two sites <tt>p</tt> and <tt>q</tt> are in the same component; false otherwise
     * @throws java.lang.IndexOutOfBoundsException unless
     *      both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
     */
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

  
    /**
     * Merges the component containing site <tt>p</tt> with the 
     * the component containing site <tt>q</tt>.
     * @param p the integer representing one site
     * @param q the integer representing the other site
     * @throws java.lang.IndexOutOfBoundsException unless
     *      both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
     */
    public void union(int p, int q) {
        int i = find(p);
        int j = find(q);
        if (i == j) return;

        // make root of smaller rank point to root of larger rank
        if      (rank[i] < rank[j]) id[i] = j;
        else if (rank[i] > rank[j]) id[j] = i;
        else {
            id[j] = i;
            rank[i]++;
        }
        count--;
    }
   
    /**
     * Reads in a an integer <tt>N</tt> and a sequence of pairs of integers
     * (between <tt>0</tt> and <tt>N-1</tt>) from standard input, where each integer
     * in the pair represents some site;
     * if the sites are in different components, merge the two components
     * and print the pair to standard output.
    public static void main(String[] args) {
        int N = StdIn.readInt();
        UFF uf = new UFF(N);
        while (!StdIn.isEmpty()) {
            int p = StdIn.readInt();
            int q = StdIn.readInt();
            if (uf.connected(p, q)) continue;
            uf.union(p, q);
            StdOut.println(p + "" "" + q);
        }
        StdOut.println(uf.count() + "" components"");
    }*/
}}
@6c2269af243cb76c9b12cc474add71d6@"
"b03611035","0","0","0","@3cf8e8032cf7523e73d68e6363ccf7e0@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""input.dat""))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(1234);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }
             
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",y,x);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@3cf8e8032cf7523e73d68e6363ccf7e0@"
"b03611035","0","0","0","@b947b2741122158e8c7d3d9df3f22651@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""input.dat""))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(1234);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@b947b2741122158e8c7d3d9df3f22651@"
"r04921028","9","2.52","162224","@7c6f9aaf222e2f7f8864fb57f7f764b0@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */



public class Percolation {
    
    public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
//===============================================================================
            
            String buf1[] = br.readLine().split("","");
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            int count2 = 1;
            while (br.ready())
            {
//            System.out.println(count2);
            String buf2[] = br.readLine().split("","");
            if(n==1){
                if(Mx[0]!=1){
                    System.out.println(""-1"");
                    break;
                }
                System.out.println(buf1[0]+"",""+buf1[1]);
                break;
            }
                
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
//          System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
                if (uf.connected(0,(n*n)+1))
                {
                StdOut.println(Mx[count2] + "","" + My[count2]);
                 break;
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
//            StdOut.println(Mx[count2] + "","" + My[count2]);
             break;
            }
            
            count2++;
            }
            if(!uf.connected(0,(n*n)+1))
            {    
            StdOut.println(""-1"");
            }
        }
        
    }
}
@7c6f9aaf222e2f7f8864fb57f7f764b0@"
"b03611035","0","0.39","104736","@79ff831bbdc6660ba0870c4934568a91@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""input.dat""))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(100);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@79ff831bbdc6660ba0870c4934568a91@"
"b03611011","1","0.37","105200","@a8109ed655b83c530d4eca62c889a713@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], tep[], count[];
    private static int num, recount, tf = 0;
    private static int number[] = new int[1];

    private static int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        if (p < num || p > num * (num - 1)) {
            id[p] = 1;
            if (p < num && id[p + num] != 0) {
                id[p + num] = id[p];
            }
            if (p >= num * (num)) {
                id[p] = id.length;
            }
        } else {
            quotient = p % num;
            switch (quotient) {
                case 1: {
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p] = id[p + 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p] = id[p + num];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0) {
                        id[p] = v;
                    }
                    break;
                }
                case 0:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p - 1] > 0) {
                        id[p] = id[p - 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p - 1] <= 0 && id[p + num] <= 0) {
                        id[p] = v;
                    }
                    break;
                default:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p] = id[p + 1];
                        tep[recount] = id[p];
                    }
                    if (id[p - 1] > 0) {
                        id[p] = id[p - 1];
                        tep[recount] = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep[recount] = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0 && id[p - 1] <= 0) {
                        id[p] = v;
                    }
            }
        }
        for (int i = 0; i < num; i++) {
            if (id[2 * num + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
//同步上下
        if (tf == 1) {
            for (int i = 0; i < 2; i++) {
                for (int k = 1; k < id.length - 1; k++) {
                    if (id[k] >0) {
                        id[k] = id[p - num];
                    }
                }
            }
        }
    }

    public int getnumber() {
        return number[0];
    }

    public static void point(int x, int y) {
        number[0] = 0;
        number[0] = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            num = Integer.parseInt(data[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            tep = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
                tep[i] = 0;
            }
            id[0] = 1;
            int j = 1;
            recount = 0;
            count = new int[2];
            number[0] = 0;
            while (j >= 0) {
                String[] data1 = br.readLine().split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                union(number[0]);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
                j++;
            }

        }
    }
}

@a8109ed655b83c530d4eca62c889a713@"
"b03611035","0","0","0","@956833b85a20fe5c504a78a84f34235c@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""input.dat""))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(100);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@956833b85a20fe5c504a78a84f34235c@"
"b03611035","0","0.39","104736","@e5eaa284ef69fc5eade26e7b92b2773a@public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""input.dat""))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(100);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@e5eaa284ef69fc5eade26e7b92b2773a@"
"b03611035","0","0.39","104736","@956833b85a20fe5c504a78a84f34235c@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""input.dat""))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(100);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@956833b85a20fe5c504a78a84f34235c@"
"b03611035","0","0","0","@956833b85a20fe5c504a78a84f34235c@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""input.dat""))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(100);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@956833b85a20fe5c504a78a84f34235c@"
"b03611035","2","0.58","105792","@c66c02536ca8b11555db317414e0151b@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(100);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //四周
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@c66c02536ca8b11555db317414e0151b@"
"b03611035","0","0.39","104736","@fd0bba88a7f9e34ef52bbc5dad9d83d4@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(300);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@fd0bba88a7f9e34ef52bbc5dad9d83d4@"
"b03611035","0","0.39","104736","@2392ab1c4bb2744c9c3d07a6072c9b7f@//import algs4.jar.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//記得刪掉++

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(300);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}

back return to list
@2392ab1c4bb2744c9c3d07a6072c9b7f@"
"b03611035","2","0.57","105760","@b962982dd14cf8645e3a871dd3a937c0@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(300);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連+開通，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id,idu,idd,idr,idl;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                System.out.printf(""%d,%d"",x,y);
                break;
             }else if(i==count-1)System.out.print(-1);
         } 
        }
    }

}
@b962982dd14cf8645e3a871dd3a937c0@"
"b03611035","2","0.56","105760","@b272288b208eaa2569b0037469f0aa13@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@b272288b208eaa2569b0037469f0aa13@"
"b03611035","0","0.39","104736","@0f67ec151824ad71d44881cf17db85e2@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}
@0f67ec151824ad71d44881cf17db85e2@"
"b03611035","0","0.39","104736","@0f67ec151824ad71d44881cf17db85e2@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}
@0f67ec151824ad71d44881cf17db85e2@"
"b03611035","0","0.39","104736","@0f67ec151824ad71d44881cf17db85e2@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}
@0f67ec151824ad71d44881cf17db85e2@"
"b03611035","2","0.57","105696","@0f67ec151824ad71d44881cf17db85e2@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         UF gg=new UF(order*order);
               
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通
        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
             //opcl[i]=0; opcl[order*order-1-i]=0;
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}
@0f67ec151824ad71d44881cf17db85e2@"
"b03611035","0","0.56","105760","@219b3c14c1db3f976d7024946b837828@import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.WeightedQuickUnionUF;
public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@219b3c14c1db3f976d7024946b837828@"
"b03611035","2","0.57","105792","@1556739adddf900d9a8d072a4699e8e4@import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@1556739adddf900d9a8d072a4699e8e4@"
"b03611035","0","0.39","104736","@ff3d08d4e39d4a16540b14b1dc1206ca@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.print(x);
                 System.out.printf("","");
                 System.out.print(y);
                 break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@ff3d08d4e39d4a16540b14b1dc1206ca@"
"b03611035","2","0.56","105760","@ff3d08d4e39d4a16540b14b1dc1206ca@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.print(x);
                 System.out.printf("","");
                 System.out.print(y);
                 break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@ff3d08d4e39d4a16540b14b1dc1206ca@"
"b03611035","2","0.57","105728","@6487959233f0bd984cde9bf9d8ddfbda@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.print(x);
                 System.out.printf("","");
                 System.out.print(y);
                // break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@6487959233f0bd984cde9bf9d8ddfbda@"
"b03611035","2","0.56","105792","@af86d9cd9dfa18268bf0292d277ef08a@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order，今天不split，ASCII的陰謀-48
         int order=br.read()-48;
         //int z=br.read();
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.print(x);
                 System.out.printf("","");
                 System.out.print(y);
                // break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@af86d9cd9dfa18268bf0292d277ef08a@"
"r04945025","10","0.109","126960","@14c3acf15436879a2c46c6973a95d996@import java.io.FileReader;
import java.io.BufferedReader;

class Percolation {

    private final int num;
    private UF uf;
    private boolean[] flag;

    public Percolation (int num){
        this.num = num;
        uf = new UF(num * num + 2);
        flag = new boolean[num * num + 2];
        flag[num * num] = true;
        flag[num * num + 1] = true;
    }

    public boolean getPos(int index){
        return flag[index];
    }

    public void setPos(int x, int y) {
        x--;
        y--;
        int up = (x - 1) * num + y;
        int index = x * num + y;
        int down = (x + 1) * num + y;
        int left = x * num + y - 1;
        int right = x * num + y + 1;

        flag[index] = true;

        union(index, up);
        union(index, down);
        union(index, left);
        union(index, right);

        if(index < num) {
            uf.union(index, num * num);
            // System.out.printf(""union (%d, %d) and top pseudo node...\n"", index / num + 1, index % num + 1, index);
        }
        if(index >= num * (num - 1)) {
            uf.union(index, num * num + 1);
            // System.out.printf(""union (%d, %d) and bottom pseudo node...\n"", index / num + 1, index % num + 1, index);
        }
    }

    public boolean checkPercolation(){
        return uf.connected(num * num, num * num + 1);
    }

    private void union(int index, int neighbor){
        if(neighbor < 0 || neighbor > num * num - 1) return;
        if(index < 0 || index > num * num - 1) return;
        if(flag[neighbor] == true){
            // System.out.printf(""union (%d, %d) and (%d, %d)...\n"", index / num + 1, index % num + 1, neighbor / num + 1, neighbor % num + 1);
            uf.union(index, neighbor);
        }
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num = Integer.parseInt(br.readLine());

            Percolation p = new Percolation(num);

            for(String in = br.readLine(); in != null; in = br.readLine()) {
                String[] data = in.split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);

                p.setPos(x, y);
                if(p.checkPercolation()){
                    System.out.printf(""%d,%d\n"", x, y);
                    break;
                }
            }


            if(!p.checkPercolation()) System.out.printf(""-1\n"");
            /*
            for(int i = 0; i < num * num; i++){
                System.out.printf(""%d\t"", p.getPos(i)? 1: 0);
                if(i % num == num - 1) System.out.printf(""\n"");
            }
            System.out.printf(""%d\t"", p.getPos(num * num)? 1: 0);
            System.out.printf(""%d\t"", p.getPos(num * num + 1)? 1: 0);
            */
        }
    }
}
@14c3acf15436879a2c46c6973a95d996@"
"b03611011","0","0.89","105344","@272a97189e5e3c25b02d87114550db07@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, recount, tf = 0, tep;
    private static int number[] = new int[1];

    private static int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        if (p < num || p > num * (num - 1)) {
            id[p] = 1;
            if (p < num && id[p + num] != 0) {
                id[p + num] = id[p];
            }
            if (p > num * (num - 1)) {
                id[p] = 2;
                if (id[p - num] > 0) {
                    id[p] = id[p - num];
                }
            }
        } else {
            quotient = p % num;
            switch (quotient) {
                case 1: {
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p + 1] = id[p];
                        tep = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p] = id[p + num];
                        tep = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0) {
                        id[p] = v;
                    }
                    break;
                }
                case 0:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p - 1] > 0) {
                        id[p - 1] = id[p];
                        tep = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep = id[p];
                    }
                    if (id[p - num] <= 0 && id[p - 1] <= 0 && id[p + num] <= 0) {
                        id[p] = v;
                    }
                    break;
                default:
                    if (id[p - num] > 0) {
                        id[p] = id[p - num];
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        id[p + 1] = id[p];
                        tep = id[p];
                    }
                    if (id[p - 1] > 0) {
                        id[p - 1] = id[p];
                        tep = id[p];
                    }
                    if (id[p + num] > 0) {
                        id[p + num] = id[p];
                        tep = id[p];
                    }
                    if (id[p - num] <= 0 && id[p + 1] <= 0 && id[p + num] <= 0 && id[p - 1] <= 0) {
                        id[p] = v;
                    }
            }
        }
//同步上下
        if (tf == 1) {
            for (int i = 0; i < 2; i++) {
                for (int k = num + 1; k < id.length - 1; k++) {
                    if (id[k] > 0 && id[k - num] > 1) {
                        id[k] = id[p - num];
                    }
                }
            }
        }
        //check connective
        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public int getnumber() {
        return number[0];
    }

    public static void point(int x, int y) {
        number[0] = 0;
        number[0] = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String[] data = br.readLine().split("","");
            num = Integer.parseInt(data[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            tep = 2;
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
                tep = 0;
            }
            id[0] = 1;
            int j = 1;
            recount = 0;
            count = new int[2];
            number[0] = 0;
            search:
            {
                while (data != null) {
                    data = br.readLine().split("","");
                    for (int i = 0; i < 2; i++) {
                        count[i] = Integer.parseInt(data[i]);
                        //define the point
                    }
                    point(count[0], count[1]);
                    union(number[0]);
                    if (tf == -1) {
                        System.out.println(count[0] + "","" + count[1]);
                        break search;
                    }
                    j++;
                }
                br.close();
            }
        } catch (Exception e) {
            System.err.println(-1);
        }
    }
}

@272a97189e5e3c25b02d87114550db07@"
"r04228002","10","0.179","157472","@490cc2724e66235eb6823d8d979ec81e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            
            String[] row1 = br.readLine().split("","");
            int SizeNum = Integer.parseInt(row1[0]);
            //System.out.println(SizeNum);
            
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(SizeNum*SizeNum+2);
            Point SupperTop = new Point(SizeNum*SizeNum,SizeNum*SizeNum+1,SizeNum*SizeNum+1);
            Point SupperBottom = new Point(SizeNum*SizeNum+1,SizeNum*SizeNum+1,SizeNum*SizeNum+1);
                    
            ArrayList<Point> PointList = new ArrayList<Point>();
            for (int i = 0; i< i+1;i++){
                String[] row;
                try{
                    row = br.readLine().split("","");
                }
                catch(Exception e){
                    break;
                }
                //String[] row = br.readLine().split("","");
                int x = Integer.parseInt(row[0]);
                int y = Integer.parseInt(row[1]);
                
                Point p1 = new Point(i,x,y);
                
                if (x == 1){
                    uf.union(SupperTop.ID, i); 
                }
                if (x == SizeNum){
                    uf.union(SupperBottom.ID, i);
                }
                PointList.add(p1);
                
                int x1 = x-1;
                int x2 = x+1;
                int y1 = y-1;
                int y2 = y+1;
                
                //System.out.println(PointList.size());
                
                for (int j=0;j < PointList.size();j++){
                    Point a = PointList.get(j);
                    int xx = a.XCOOR; 
                    int yy = a.YCOOR;
                    if (xx == x1 && yy == y){
                        uf.union(a.ID, i);
                    }
                    else if (xx == x2 && yy == y){
                        uf.union(a.ID, i);
                    } 
                    else if (xx == x && yy == y1){
                        uf.union(a.ID, i);
                    } 
                    else if (xx == x && yy == y2){
                        uf.union(a.ID, i);
                    }
                    int u = uf.find(a.ID);
                    //System.out.println(u);
                    
                }
                //System.out.println(""stop"");
                
                boolean result = uf.connected(SupperTop.ID,SupperBottom.ID);
                //System.out.println(result);
                if (result == true){
                    String out = row[0] + "","" + row[1];
                    System.out.println(out);
                    break;
                    }
                
            }
            boolean result = uf.connected(SupperTop.ID,SupperBottom.ID);
            if (result == false){
                System.out.println(""-1"");
            }
           
        }
    }
    
}

class Point{
    public int XCOOR;
    public int YCOOR;
    public int ID;
    public Point(int id,int x,int y){
        int XCOOR;
        XCOOR=x;
        this.XCOOR=x;
        int YCOOR;
        YCOOR=y;
        this.YCOOR=y;
        int ID;
        ID=id;
        this.ID=id;
        
    
    }
    public int getX(){
        return XCOOR;      
    }
    public int getY(){
        return YCOOR;
    }
    public int getID(){
        return ID;
    }
    
}

@490cc2724e66235eb6823d8d979ec81e@"
"r04921028","9","2.42","133760","@3712cc31338be3abbe90e080b5415f72@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */



public class Percolation {
    
    public static void main(String[] args) throws IOException{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
//===============================================================================

            String buf1[] = br.readLine().split("","");
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            int count2 = 1;
            while (br.ready())
            {
            String buf2[] = br.readLine().split("","");
            if(buf2[0].equals("""")){break;}
            
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
//          System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
                if (uf.connected(0,(n*n)+1))
                {
                StdOut.println(Mx[count2] + "","" + My[count2]);
                 break;
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
//            StdOut.println(Mx[count2] + "","" + My[count2]);
             break;
            }
            
            count2++;
            }
            if(!uf.connected(0,(n*n)+1))
            {    
            StdOut.println(""-1"");
            }
            
        }
        
    }
}
@3712cc31338be3abbe90e080b5415f72@"
"r04921028","10","0.239","138016","@af66c64b0558e3b6115e1915c9ed22d8@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;



/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */



public class Percolation {
    
    public static void main(String[] args) throws IOException{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String buf = br.readLine();
//          System.out.println(buf);
            int n = Integer.valueOf(buf);
            UF uf = new UF(n*n+2); //0~(n*n)+1
            int [][] M;
            M = new int[n][n];
            int [] Mx;
            Mx = new int[n*n];
            int [] My;
            My = new int[n*n];
            int count1 = 0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    count1++;
                    M[i][j] = count1;
                    //System.out.println(M[i][j]+""\n"");
                }
            }
            for(int i=0;i<n;i++){
                uf.union(M[0][i],0);
                uf.union(M[n-1][i],(n*n)+1);
            }
            
//===============================================================================

            String buf1[] = br.readLine().split("","");
            if(!buf1[0].equals("""")){
            Mx[0] = Integer.valueOf(buf1[0]);
            My[0] = Integer.valueOf(buf1[1]);
            }
            int count2 = 1;
            while (br.ready())
            {
            String buf2[] = br.readLine().split("","");
            if(buf2[0].equals("""")){break;}
            
            Mx[count2] = Integer.valueOf(buf2[0]);
            My[count2] = Integer.valueOf(buf2[1]);
            
//          System.out.println(Mx[count2]+"",""+My[count2]);
            
            for(int i=0;i<count2;i++){
                if (!uf.connected(M[Mx[count2-1-i]-1][My[count2-1-i]-1],M[Mx[count2]-1][My[count2]-1]))
                {
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==1)&&((Math.abs(My[count2]-My[count2-1-i]))==0))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                    if(((Math.abs(Mx[count2]-Mx[count2-1-i]))==0)&&((Math.abs(My[count2]-My[count2-1-i]))==1))
                    {
                        uf.union(M[Mx[count2-1-i]-1][My[count2-1-i]-1], M[Mx[count2]-1][My[count2]-1]);
//                        System.out.println(Mx[count2-1-i]+"",""+My[count2-1-i]+""~""+Mx[count2]+"",""+My[count2]);
//                        System.out.println(""cc"");
                    }
                }
                if (uf.connected(0,(n*n)+1))
                {
                StdOut.println(Mx[count2] + "","" + My[count2]);
                 break;
                }
            }
            
            if (uf.connected(0,(n*n)+1))
            {
//            StdOut.println(Mx[count2] + "","" + My[count2]);
             break;
            }
            
            count2++;
            }
            if(!uf.connected(0,(n*n)+1))
            {    
            StdOut.println(""-1"");
            }   
            if(n==1)
            {
               if(buf1[0].equals("""")){StdOut.println(""-1"");}
               else
                StdOut.println(""1,1"");
            }
        } 
    }
}
@af66c64b0558e3b6115e1915c9ed22d8@"
"b03611011","3","0.64","114128","@4b6842fa46269829533fd80804eb7e17@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, recount, tf = 0, tep;
    private static int number[] = new int[1];

    private static int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        if (p < num || p > num * (num - 1)) {
            id[p] = 1;
            if (p < num && id[p + num] != 0) {
                id[p + num] = id[p];
            }
            if (p > num * (num - 1)) {
                id[p] = 2;
                if (id[p - num] > 0) {
                    id[p] = id[p - num];
                    if (id[p - num] == 1) {
                        id[p] = 1;
                    }
                }
            }
        } else {
            quotient = p % num;
            switch (quotient) {
                case 1: {
                    if (id[p - num] > 0) {
                        if (id[p - num] == 1) {
                            id[p] = 1;
                        } else {
                            id[p - num] = id[p];
                        }
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                        } else {
                            id[p + 1] = id[p];
                        }
                    }
                    if (id[p + num] > 0) {
                        if (id[p + num] == 1) {
                            id[p] = 1;
                        } else {
                            id[p + num] = id[p];
                        }
                    }
                    break;
                }
                case 0:
                    if (id[p - num] > 0) {
                        if (id[p - num] == 1) {
                            id[p] = 1;
                        } else {
                            id[p - num] = id[p];
                        }
                        tf = 1;
                    }
                    if (id[p - 1] > 0) {
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                        } else {
                            id[p - 1] = id[p];
                        }
                    }
                    if (id[p + num] > 0) {
                        if (id[p + num] == 1) {
                            id[p] = 1;
                        } else {
                            id[p + num] = id[p];
                        }
                    }
                    break;
                default:
                    if (id[p - num] > 0) {
                        if (id[p - num] == 1) {
                            id[p] = 1;
                        } else {
                            id[p - num] = id[p];
                        }
                        tf = 1;
                    }
                    if (id[p + 1] > 0) {
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                        } else {
                            id[p + 1] = id[p];
                        }
                    }
                    if (id[p - 1] > 0) {
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                        } else {
                            id[p - 1] = id[p];
                        }
                    }
                    if (id[p + num] > 0) {
                        if (id[p + num] == 1) {
                            id[p] = 1;
                        } else {
                            id[p + num] = id[p];
                        }
                    }
            }
        }
//同步上下
        if (tf == 1) {
            for (int k = num + 1; k < id.length - 1; k++) {
                if (id[k] > 0 && id[k - num] > 1) {
                    id[k] = id[p - num];
                }
            }
        }
        //check connective
        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number[0] = 0;
        number[0] = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            num = Integer.parseInt(data[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            tep = 2;
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
                tep = 0;
            }
            id[0] = 1;
            int j = 1;
            recount = 0;
            count = new int[2];
            number[0] = 0;
            search:
            {
                while (data != null) {
                    data = br.readLine().split("","");
                    for (int i = 0; i < 2; i++) {
                        count[i] = Integer.parseInt(data[i]);
                        //define the point
                    }
                    point(count[0], count[1]);
                    id[number[0]] = 2;
                    union(number[0]);
                    if (tf == -1) {
                        System.out.println(count[0] + "","" + count[1]);
                        break search;
                    }
                    j++;
                }
                br.close();
                System.err.println(-1);
            }
        }
    }
}

@4b6842fa46269829533fd80804eb7e17@"
"b02611028","10","0.1","126432","@958603d38912b148c40362502bcbaa9a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Han
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int num = Integer.parseInt(data);
            //System.out.print(num);
            QuickUnionUF uf = new QuickUnionUF(num * num + 3);
            int[][] matrix = new int[num + 2][num + 2];
            for (int i = 1; i < num + 1; i++) {
                matrix[0][i] = num * num + 1;
                matrix[num + 1][i] = num * num + 2;
            }
            int[] coordinate = new int[2];

            while (matrix[0][1] != matrix[num + 1][1]) {
                if (br.ready() == false) {
                    System.out.print(-1);
                    break;
                }
                String[] coordinateString = br.readLine().split("","");
                
                coordinate[0] = Integer.parseInt(coordinateString[0]);
                coordinate[1] = Integer.parseInt(coordinateString[1]);
                //assign id
                matrix[coordinate[0]][coordinate[1]]=num*(coordinate[0]-1)+coordinate[1];
                if(matrix[coordinate[0]-1][coordinate[1]]!=0&&!uf.connected(matrix[coordinate[0]][coordinate[1]], matrix[coordinate[0]-1][coordinate[1]])){
                    uf.union(matrix[coordinate[0]][coordinate[1]], matrix[coordinate[0]-1][coordinate[1]]);
                }
                if(matrix[coordinate[0]+1][coordinate[1]]!=0&&!uf.connected(matrix[coordinate[0]][coordinate[1]], matrix[coordinate[0]+1][coordinate[1]])){
                    uf.union(matrix[coordinate[0]][coordinate[1]], matrix[coordinate[0]+1][coordinate[1]]);
                }
                if(matrix[coordinate[0]][coordinate[1]-1]!=0&&!uf.connected(matrix[coordinate[0]][coordinate[1]], matrix[coordinate[0]][coordinate[1]-1])){
                    uf.union(matrix[coordinate[0]][coordinate[1]], matrix[coordinate[0]][coordinate[1]-1]);
                }
                if(matrix[coordinate[0]][coordinate[1]+1]!=0&&!uf.connected(matrix[coordinate[0]][coordinate[1]], matrix[coordinate[0]][coordinate[1]+1])){
                    uf.union(matrix[coordinate[0]][coordinate[1]], matrix[coordinate[0]][coordinate[1]+1]);
                }
                
                
                if(uf.connected(matrix[0][1], matrix[num + 1][1]) ){
                    System.out.print(coordinate[0]+"",""+coordinate[1]);
                    break;
                }
                /*for (int i = 0; i < 2; i++) {
                 System.out.print(coordinate[i] + "" "");
                 }
                 System.out.printf(""%n"");*/

            }
        }
    }
}

@958603d38912b148c40362502bcbaa9a@"
"b01b01039","5","1.01","125312","@8f9d863ce2931b4107966434c880cbeb@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
	//
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String data = br.readLine();
            
			// store the second integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data);
			
            // initilization of a parent array
			/*
			First row and last row will be connect to sudo nodes
			ID of sudo nodes will be num*num and num*num-1
			node array for checking whether the node has been assign
			*/
			//System.out.println(num*num);
			QuickUnionUF uf = new QuickUnionUF(num * num + 2);
			boolean[] node = new boolean[num * num];
			
			for(int idx = 0; idx < num; idx++){
				uf.union(twod2oned(0, idx, num), num*num);
			}
			for(int idx = 0; idx < num; idx++){
				uf.union(twod2oned((num-1), idx, num), num*num+1);
			}			
			for(int idx = 0; idx < num*num+2; idx++){
				oned2twod(idx, num);
				//System.out.println(uf.find(idx));
			}
			
			
			// read file line by line
			String[] pos;
			int row, col;
			boolean fin = true;
			while ((data = br.readLine()) != null) {
				pos = data.split("","");
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				row = Integer.parseInt(pos[0])-1;
				col = Integer.parseInt(pos[1])-1;
				//System.out.printf(""\n"");
				//System.out.println(""row : "" + row + "" col : "" + col);
				//System.out.println(twod2oned(row, col, num));
				node[twod2oned(row, col, num)] = true;
				edge_formation(uf, row, col, num, node);
				if(uf.connected(num*num, num*num-1)){
					row ++; col++;
					System.out.printf(""%d,%d"",row,col);
					fin = false;
					break;
				}
				//boolean_array_print(node, num);
				//uf_array_check(uf, num);
			}
			if(fin) System.out.println(""End of file"");
			//uf_array_check(uf, num);
			//boolean_array_print(node, num);
        }
    }
	
	public static int twod2oned(int row, int col, int num){
		int pos;
		pos = row * num + col;
		//System.out.printf(""%d "", pos);
		return pos;
	}
	
	public static void oned2twod(int pos, int num){
		int row;
		int col;
		row = pos / 5;
		col = pos % 5;
		//System.out.printf(""row : %2d col : %2d "", row, col);
	}
	
	public static void edge_formation(QuickUnionUF uf, int row, int col, int num, boolean node[]){
		//System.out.println(""row : "" + row + "" col : "" + col);
		if(row-1 >= 0){
			//System.out.printf(""%b "", node[twod2oned(row-1, col, num)]);
			//System.out.printf(""UP"");
			if(node[twod2oned(row-1, col, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row-1, col, num));
			}
			//System.out.printf(""\n"");
		}
		if(row+1 < num){
			//System.out.printf(""%b "", node[twod2oned(row+1, col, num)]);
			//System.out.printf(""DOWN"");
			if(node[twod2oned(row+1, col, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row+1, col, num));
			}
			//System.out.printf(""\n"");
		}
		if(col-1 >= 0){
			//System.out.printf(""%b "", node[twod2oned(row, col-1, num)]);
			//System.out.printf(""LEFT"");
			if(node[twod2oned(row, col-1, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row, col-1, num));
			}
			//System.out.printf(""\n"");
		}
		if(col+1 < num){
			//System.out.printf(""%b "", node[twod2oned(row, col+1, num)]);
			//System.out.printf(""RIGHT"");
			if(node[twod2oned(row, col+1, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row, col+1, num));
			}
			//System.out.printf(""\n"");
		}
		//System.out.println(""\n"");
	}
	
	public static void uf_array_check(QuickUnionUF uf, int num){
		for(int row = 0; row < num; row++){
			for(int col = 0; col < num; col++){
				System.out.printf(""%2d "",uf.find(twod2oned(row, col, num)));
			}
			System.out.printf(""\n"");
		}
	}
	
	
	public static void int_array_print(int[] array, int col){
		int i = 0;
			for(int idx : array){
				if(i > 0 && i%col == 0)System.out.printf(""\n"");
				System.out.printf("" %3d"", idx);
				++i;
			}
			System.out.printf(""\n"");
	}
	// for printing out a boolean array
	public static void boolean_array_print(boolean[] array, int col){
		int i = 0;
			for(boolean idx : array){
				if(i > 0 && i%col == 0)System.out.printf(""\n"");
				if(idx) System.out.printf(""%2d "",1);
				else System.out.printf(""%2d "",0);
				++i;
			}
			System.out.printf(""\n\n"");
	}
	//public static viod array_union(){
		
	//}
}


@8f9d863ce2931b4107966434c880cbeb@"
"b01b01039","10","0.101","125472","@20b50adf977de8d4a4b8b5129e00acf6@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
	//
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String data = br.readLine();
            
			// store the second integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data);
			
            // initilization of a parent array
			/*
			First row and last row will be connect to sudo nodes
			ID of sudo nodes will be num*num and num*num-1
			node array for checking whether the node has been assign
			*/
			//System.out.println(num*num);
			QuickUnionUF uf = new QuickUnionUF(num * num + 2);
			boolean[] node = new boolean[num * num];
			
			for(int idx = 0; idx < num; idx++){
				uf.union(twod2oned(0, idx, num), num*num);
			}
			for(int idx = 0; idx < num; idx++){
				uf.union(twod2oned((num-1), idx, num), num*num+1);
			}			
			for(int idx = 0; idx < num*num+2; idx++){
				oned2twod(idx, num);
				//System.out.println(uf.find(idx));
			}
			
			
			// read file line by line
			String[] pos;
			int row, col;
			boolean fin = true;
			while ((data = br.readLine()) != null) {
				pos = data.split("","");
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				row = Integer.parseInt(pos[0])-1;
				col = Integer.parseInt(pos[1])-1;
				//System.out.printf(""\n"");
				//System.out.println(""row : "" + row + "" col : "" + col);
				//System.out.println(twod2oned(row, col, num));
				node[twod2oned(row, col, num)] = true;
				edge_formation(uf, row, col, num, node);
				if(uf.connected(num*num, num*num-1)){
					row ++; col++;
					System.out.printf(""%d,%d"",row,col);
					fin = false;
					break;
				}
				//boolean_array_print(node, num);
				//uf_array_check(uf, num);
			}
			if(fin) System.out.println(-1);
			//uf_array_check(uf, num);
			//boolean_array_print(node, num);
        }
    }
	
	public static int twod2oned(int row, int col, int num){
		int pos;
		pos = row * num + col;
		//System.out.printf(""%d "", pos);
		return pos;
	}
	
	public static void oned2twod(int pos, int num){
		int row;
		int col;
		row = pos / 5;
		col = pos % 5;
		//System.out.printf(""row : %2d col : %2d "", row, col);
	}
	
	public static void edge_formation(QuickUnionUF uf, int row, int col, int num, boolean node[]){
		//System.out.println(""row : "" + row + "" col : "" + col);
		if(row-1 >= 0){
			//System.out.printf(""%b "", node[twod2oned(row-1, col, num)]);
			//System.out.printf(""UP"");
			if(node[twod2oned(row-1, col, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row-1, col, num));
			}
			//System.out.printf(""\n"");
		}
		if(row+1 < num){
			//System.out.printf(""%b "", node[twod2oned(row+1, col, num)]);
			//System.out.printf(""DOWN"");
			if(node[twod2oned(row+1, col, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row+1, col, num));
			}
			//System.out.printf(""\n"");
		}
		if(col-1 >= 0){
			//System.out.printf(""%b "", node[twod2oned(row, col-1, num)]);
			//System.out.printf(""LEFT"");
			if(node[twod2oned(row, col-1, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row, col-1, num));
			}
			//System.out.printf(""\n"");
		}
		if(col+1 < num){
			//System.out.printf(""%b "", node[twod2oned(row, col+1, num)]);
			//System.out.printf(""RIGHT"");
			if(node[twod2oned(row, col+1, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row, col+1, num));
			}
			//System.out.printf(""\n"");
		}
		//System.out.println(""\n"");
	}
	
	public static void uf_array_check(QuickUnionUF uf, int num){
		for(int row = 0; row < num; row++){
			for(int col = 0; col < num; col++){
				System.out.printf(""%2d "",uf.find(twod2oned(row, col, num)));
			}
			System.out.printf(""\n"");
		}
	}
	
	
	public static void int_array_print(int[] array, int col){
		int i = 0;
			for(int idx : array){
				if(i > 0 && i%col == 0)System.out.printf(""\n"");
				System.out.printf("" %3d"", idx);
				++i;
			}
			System.out.printf(""\n"");
	}
	// for printing out a boolean array
	public static void boolean_array_print(boolean[] array, int col){
		int i = 0;
			for(boolean idx : array){
				if(i > 0 && i%col == 0)System.out.printf(""\n"");
				if(idx) System.out.printf(""%2d "",1);
				else System.out.printf(""%2d "",0);
				++i;
			}
			System.out.printf(""\n\n"");
	}
	//public static viod array_union(){
		
	//}
}


@20b50adf977de8d4a4b8b5129e00acf6@"
"b01b01039","10","0.101","123744","@d8acd3c9f1b3dbbe67d7fb2a0091917e@/**********************************************************************************
PDSA Homework1
date 2016/03/07
Author : Chia Yu Chang
Percolation problem
The model. 
	We model a percolation system using an N-by-N grid of sites. 
	Each site is either open or blocked. 
	A full site is an open site that can be connected to an open site 
	in the top row via a chain of neighboring (left, right, up, down) open sites.
	We say the system percolates if there is a full site in the bottom row.
	In other words, a system percolates if we fill all open sites connected to the 
	top row and that process fills some open site on the bottom row. 
Input
	num : the size of the block
	row,col : position
Output
	percolate : last position
	not percolate : -1
***********************************************************************************/

import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String data = br.readLine();
            
			// store the second integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data);
			
            // initilization of a parent array
			/*
			First row and last row will be connect to sudo nodes
			ID of sudo nodes will be num*num and num*num-1
			node array for checking whether the node has been assign
			*/
			//System.out.println(num*num);
			QuickUnionUF uf = new QuickUnionUF(num * num + 2);
			boolean[] node = new boolean[num * num];
			sudo_node_connect(uf, num);
			
			// read file line by line
			boolean fin = true; // if system did not percolate fin will stay true
			while ((data = br.readLine()) != null) {
				String[] pos = data.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				/* For input checking
				System.out.println(""row : "" + row + "" col : "" + col);
				*/
				node[twod2oned(row, col, num)] = true;
				edge_formation(uf, row, col, num, node);
				// if system percolate stop the loop
				if(uf.connected(num*num, num*num-1)){
					row ++; col++;
					System.out.printf(""%d,%d"",row,col);
					fin = false;
					break;
				}
				/*
				boolean_array_print(node, num);
				uf_array_check(uf, num);
				*/
			}
			if(fin) System.out.println(-1); // if system did not percolate print out -1
        }
    }
	
	// transform 2D array to 1D array
	public static int twod2oned(int row, int col, int num){
		int pos;
		pos = row * num + col;
		//System.out.printf(""%d "", pos);
		return pos;
	}
	
	// transform 1D array to 2D array
	public static void oned2twod(int pos, int num){
		int row;
		int col;
		row = pos / 5;
		col = pos % 5;
		//System.out.printf(""row : %2d col : %2d "", row, col);
	}

	// for making connection to sudo_node
	public static void sudo_node_connect(QuickUnionUF uf, int num){
		for(int idx = 0; idx < num; idx++){
			uf.union(twod2oned(0, idx, num), num*num);
		}
		for(int idx = 0; idx < num; idx++){
			uf.union(twod2oned((num-1), idx, num), num*num+1);
		}
	}
	
	// for making edge
	public static void edge_formation(QuickUnionUF uf, int row, int col, int num, boolean node[]){
		if(row-1 >= 0){
				if(node[twod2oned(row-1, col, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row-1, col, num));
			}
		}
		if(row+1 < num){
			if(node[twod2oned(row+1, col, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row+1, col, num));
			}
		}
		if(col-1 >= 0){
			if(node[twod2oned(row, col-1, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row, col-1, num));
			}
		}
		if(col+1 < num){
			if(node[twod2oned(row, col+1, num)]){
				uf.union(twod2oned(row, col, num), twod2oned(row, col+1, num));
			}
		}
	}
	
	// for print our uf parent array
	public static void uf_array_check(QuickUnionUF uf, int num){
		for(int row = 0; row < num; row++){
			for(int col = 0; col < num; col++){
				System.out.printf(""%2d "",uf.find(twod2oned(row, col, num)));
			}
			System.out.printf(""\n"");
		}
	}
	
	// for printing out a boolean array
	public static void boolean_array_print(boolean[] array, int col){
		int i = 0;
			for(boolean idx : array){
				if(i > 0 && i%col == 0)System.out.printf(""\n"");
				if(idx) System.out.printf(""%2d "",1);
				else System.out.printf(""%2d "",0);
				++i;
			}
			System.out.printf(""\n\n"");
	}
}


@d8acd3c9f1b3dbbe67d7fb2a0091917e@"
"b03611035","2","0.66","105456","@4cb2c8ab89ce4c3fe1762baa3a2fa9ca@import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階(order)，ASCII要-48
         int a=0,b=-1;
         double ordergg=0;
         int readd=br.read();
         while(readd!=10&&readd!=13){
             ordergg+=(readd-48)*(Math.pow(10,a));
             a--;
             b++;
             readd=br.read();
         }
         int order= (int)(ordergg*(Math.pow(10,b)));
         //int z=br.read();
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //分別討論中心 上下排 上下排以外的左右排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }
             else if (y==order){//下排
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){//上排
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.print(x);
                 System.out.printf("","");
                 System.out.print(y);
                 break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@4cb2c8ab89ce4c3fe1762baa3a2fa9ca@"
"r03228006","5","0.45","126176","@b35d32224303ebd33925d238fde0a7f4@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class Percolation {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
        public static boolean connected(int p, int q)
        {
            return root(p) == root(q);
        }
        
        public static void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (sz[i] < sz[j]) {id[i] = j; sz[j] += sz[i];}
            else               {id[j] = i; sz[i] += sz[j];} 
        }
    
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, or ""input4.txt""
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            int data = Integer.parseInt(br.readLine());
            //System.out.println(data);
            QuickUnionUF(data*data+2);
            for (int i = 1; i<=data; i++){
                union(0,i);
                union(data*data+1,data*data+1-i);
            }
            int [][] matrix = new int[data][data];
            for (int[] row : matrix){
            Arrays.fill(row, 0);}
            int [] announce = new int[2] ;
            while (true) {
                    String[] temp = br.readLine().split("","");    
                    if (temp == null) {
                        //System.out.println(""-1"");
                        break;
                    }
                    //System.out.println(temp[0]+"",""+temp[1]);
                    int t0 = Integer.parseInt(temp[0])-1;
                    int t1 = Integer.parseInt(temp[1])-1;
                    //System.out.println(t0+"",""+t1);
                    matrix[t0][t1]= 1;
                    int index=t0*data+t1+1;
                    // noted that the border excessive
                    if (t1!=(data-1)){if(matrix[t0][t1+1]==1) union(index,index+1);}
                    if (t1!=0)       {if(matrix[t0][t1-1]==1) union(index,index-1);}
                    if (t0!=(data-1)){if(matrix[t0+1][t1]==1) union(index,index+data);}
                    if (t0!=0)       {if(matrix[t0-1][t1]==1) union(index,index-data);}
                    
                    if (connected(0,data*data+1)) {
                        System.out.println(temp[0]+"",""+temp[1]);
                        break;
                    }
            }
            //for (int i = 0; i < data; i++) {
               // for (int j = 0; j < data; j++){
               // System.out.println(matrix[i][j]);  
               // }
            //System.out.println();
            //}
            }
        }
}


@b35d32224303ebd33925d238fde0a7f4@"
"r03228006","10","0.1","122752","@a435e2437bd2d66881540af909fca328@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class Percolation {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
        public static boolean connected(int p, int q)
        {
            return root(p) == root(q);
        }
        
        public static void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (sz[i] < sz[j]) {id[i] = j; sz[j] += sz[i];}
            else               {id[j] = i; sz[i] += sz[j];} 
        }
    
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, or ""input4.txt"" or ""input5.txt""
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            int data = Integer.parseInt(br.readLine());
            //System.out.println(data);
            QuickUnionUF(data*data+2);
            for (int i = 1; i<=data; i++){
                union(0,i);
                union(data*data+1,data*data+1-i);
            }
            int [][] matrix = new int[data][data];
            for (int[] row : matrix){
            Arrays.fill(row, 0);}
            int [] announce = new int[2] ;
            while (true) {
                    String temp = br.readLine();
                    if (temp == null) {
                        System.out.println(""-1"");
                        break;
                    }  
                    String[] temp2 = temp.split("","");
                    //System.out.println(temp2); 
                    //System.out.println(temp2[0]+"",""+temp2[1]);
                    int t0 = Integer.parseInt(temp2[0])-1;
                    int t1 = Integer.parseInt(temp2[1])-1;
                    //System.out.println(t0+"",""+t1);
                    matrix[t0][t1]= 1;
                    int index=t0*data+t1+1;
                    // noted that the border excessive
                    if (t1!=(data-1)){if(matrix[t0][t1+1]==1) union(index,index+1);}
                    if (t1!=0)       {if(matrix[t0][t1-1]==1) union(index,index-1);}
                    if (t0!=(data-1)){if(matrix[t0+1][t1]==1) union(index,index+data);}
                    if (t0!=0)       {if(matrix[t0-1][t1]==1) union(index,index-data);}
                    
                    if (connected(0,data*data+1)) {
                        System.out.println(temp2[0]+"",""+temp2[1]);
                        break;
                    }
            }
            //for (int i = 0; i < data; i++) {
               // for (int j = 0; j < data; j++){
               // System.out.println(matrix[i][j]);  
               // }
            //System.out.println();
            //}
            }
        }
}


@a435e2437bd2d66881540af909fca328@"
"b03611035","0","0","0","@863f345bcb0df7641a9c97cd10f5416f@import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階(order)，ASCII要-48
         int a=0,b=-1;
         double ordergg=0;
         int readd=br.read();
         while(readd!=10&&readd!=13){
             ordergg+=(readd-48)*(Math.pow(10,a));
             a--;
             b++;
             readd=br.read();
         }
         int order= (int)(ordergg*(Math.pow(10,b)));
         //int z=br.read();
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         readd=br.read();
         while(readd!=-1){
            if(readd==10) {
                count++;
            }
            readd=br.read();
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //分別討論中心 上下排 上下排以外的左右排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }
             else if (y==order){//下排
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){//上排
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.print(x);
                 System.out.printf("","");
                 System.out.print(y);
                 break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@863f345bcb0df7641a9c97cd10f5416f@"
"r04631034","7","1.04","230528","@7be81a9eb360e49baaa66905d0dbe3a4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.*;
import java.util.*;

/**
 *
 * @author user
 */
public class Percolation {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);

          int num = Integer.parseInt(in.readLine());
//          System.out.println(num);
          ArrayList<Integer> Row = new ArrayList<Integer>();
          ArrayList<Integer> Column = new ArrayList<Integer>();

          String line;
          String Text = """";
          while ((line = in.readLine()) != null) {
               Row.add(Integer.parseInt(line.split("","")[0]) - 1);
               Column.add(Integer.parseInt(line.split("","")[1]) - 1);
          }
//          for (int i = 0; i < Row.size(); i++) {
//               System.out.print(Row.get(i) + "","" + Column.get(i));
//               System.out.println("""");
//          }
          UF uf = new UF(num * num + 2);//   num*num+1  top  node   num*num+2 bottom node
          int[][] OpenSiteStorge = new int[Row.size()][Row.size()];

          for (int i = 0; i < Row.size(); i++) 
          {                       //Row.get(i) * num + Column.get(i) means ID index    /input coornate
//               set open site up
               OpenSiteStorge[Row.get(i)][Column.get(i)] = 1;

//               top row connect to the top node
               if (Row.get(i) == 0) 
               {
                    uf.union(Row.get(i) * num + Column.get(i), num * num);
                    if (OpenSiteStorge[Row.get(i) + 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) + 1) * num + Column.get(i));
                    }
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }
           }

//               last row connect to the bottom node
          else if (Row.get (i)   == num - 1)
          {
                    uf.union(Row.get(i) * num + Column.get(i), num * num + 1);
                     if (OpenSiteStorge[Row.get(i) - 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) - 1) * num + Column.get(i));
                         }  
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }      
     }
          else if(Row.get (i)  != num - 1 && Row.get (i)   != 0)//middle row 
            {               
               if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
               else if (Column.get(i) == num-1) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                         } 
               else if (Column.get(i) != num-1 && Column.get(i) != 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
          }
     
     if(uf.connected(num*num, num*num+1) == true)
     {
//          System.out.println(""output:"");
          System.out.println((Row.get(i)+1)+"",""+(Column.get(i)+1));
          break;
     }
     if( i == Row.size() - 1 && uf.connected(num*num, num*num+1) == false )
                              System.out.println(""-1"");
}
//for(int i = 0 ; i < num;i++){
//                    System.out.println(OpenSiteStorge[i][0]+"" ""+OpenSiteStorge[i][1]+"" ""+OpenSiteStorge[i][2]);
//          }
//          System.out.println(uf.connected(num*num, num*num+1));
//          System.out.println(uf.connected(0, 3));
//          System.out.println(uf.connected(0, num * num));
//          System.out.println(uf.connected(6, num * num + 1));
//          System.out.println(uf.connected(7, num * num + 1));
//          System.out.println(uf.connected(8, num * num + 1));
     }
}



@7be81a9eb360e49baaa66905d0dbe3a4@"
"r04945039","5","0.48","122432","@6f0f9a7744edf28ed8d071cc29032880@
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {
 
    private boolean[][] matrix;
    private int size;
    private int pseu1id=0;
    private int pseu2id;
    private WeightedQuickUnionUF qf;

    //Creates N-by-N grid, with all sites blocked.
    public Percolation (int N) {
        size = N;
        pseu2id = size*size+1;
        qf = new WeightedQuickUnionUF(size*size+2);
        matrix = new boolean[size][size];
    }
    
    public void open (int i, int j){
        matrix[i-1][j-1] =true;
        if (i==1){
            qf.union(getQFIndex(i, j), pseu1id);
        }
        
        if (i==size) {
            qf.union(getQFIndex(i, j), pseu2id);
        }
        
        if (j>1 && isOpen(i, j-1)){
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
        
    }


    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        String matrixsize= br.readLine();
        int input = Integer.parseInt(matrixsize);
        Percolation perc =new Percolation(input);
        
        
        for(String[] line; (line = br.readLine().split("","")) != null; ) {
            int i = Integer.parseInt(line[0]);
            int j = Integer.parseInt(line[1]);
            perc.open(i,j);
            if (perc.percolates()==true){
                System.out.println(i+"",""+j);
                break;
            }
  
        }          
                       
        }
         
     }

//    public Percolation(boolean[][] matrix, int size, int pseu2id, WeightedQuickUnionUF qf) {
//        this.matrix = matrix;
//        this.size = size;
//        this.pseu2id = pseu2id;
//        this.qf = qf;
//    }

    public boolean isOpen(int i, int j) {   
        return matrix[i-1][j-1];
    }
    
    public boolean percolates() {
        return qf.connected(pseu1id,pseu2id);
    }  
    
    
    private int getQFIndex (int i, int j){
        return (i-1)*size+j;
    }
    

}
    

@6f0f9a7744edf28ed8d071cc29032880@"
"r04945025","10","0.101","125424","@14c3acf15436879a2c46c6973a95d996@import java.io.FileReader;
import java.io.BufferedReader;

class Percolation {

    private final int num;
    private UF uf;
    private boolean[] flag;

    public Percolation (int num){
        this.num = num;
        uf = new UF(num * num + 2);
        flag = new boolean[num * num + 2];
        flag[num * num] = true;
        flag[num * num + 1] = true;
    }

    public boolean getPos(int index){
        return flag[index];
    }

    public void setPos(int x, int y) {
        x--;
        y--;
        int up = (x - 1) * num + y;
        int index = x * num + y;
        int down = (x + 1) * num + y;
        int left = x * num + y - 1;
        int right = x * num + y + 1;

        flag[index] = true;

        union(index, up);
        union(index, down);
        union(index, left);
        union(index, right);

        if(index < num) {
            uf.union(index, num * num);
            // System.out.printf(""union (%d, %d) and top pseudo node...\n"", index / num + 1, index % num + 1, index);
        }
        if(index >= num * (num - 1)) {
            uf.union(index, num * num + 1);
            // System.out.printf(""union (%d, %d) and bottom pseudo node...\n"", index / num + 1, index % num + 1, index);
        }
    }

    public boolean checkPercolation(){
        return uf.connected(num * num, num * num + 1);
    }

    private void union(int index, int neighbor){
        if(neighbor < 0 || neighbor > num * num - 1) return;
        if(index < 0 || index > num * num - 1) return;
        if(flag[neighbor] == true){
            // System.out.printf(""union (%d, %d) and (%d, %d)...\n"", index / num + 1, index % num + 1, neighbor / num + 1, neighbor % num + 1);
            uf.union(index, neighbor);
        }
    }

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num = Integer.parseInt(br.readLine());

            Percolation p = new Percolation(num);

            for(String in = br.readLine(); in != null; in = br.readLine()) {
                String[] data = in.split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);

                p.setPos(x, y);
                if(p.checkPercolation()){
                    System.out.printf(""%d,%d\n"", x, y);
                    break;
                }
            }


            if(!p.checkPercolation()) System.out.printf(""-1\n"");
            /*
            for(int i = 0; i < num * num; i++){
                System.out.printf(""%d\t"", p.getPos(i)? 1: 0);
                if(i % num == num - 1) System.out.printf(""\n"");
            }
            System.out.printf(""%d\t"", p.getPos(num * num)? 1: 0);
            System.out.printf(""%d\t"", p.getPos(num * num + 1)? 1: 0);
            */
        }
    }
}
@14c3acf15436879a2c46c6973a95d996@"
"r04945039","5","1.05","151152","@c68b6d196e6af23ce8cabb92e4856a58@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {
 
    private boolean[][] matrix;
    private int size;
    private int pseu1id=0;
    private int pseu2id;
    private WeightedQuickUnionUF qf;

    //Creates N-by-N grid, with all sites blocked.
    public Percolation (int N) {
        size = N;
        pseu2id = size*size+1;
        qf = new WeightedQuickUnionUF(size*size+2);
        matrix = new boolean[size][size];
    }
    
    public void open (int i, int j){
        matrix[i-1][j-1] =true;
        if (i==1){
            qf.union(getQFIndex(i, j), pseu1id);
        }
        
        if (i==size) {
            qf.union(getQFIndex(i, j), pseu2id);
        }
        
        if (j>1 && isOpen(i, j-1)){
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
        
    }


    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        String matrixsize= br.readLine();
        int input = Integer.parseInt(matrixsize);
        Percolation perc =new Percolation(input);
        
        
        for(String[] line;( line = br.readLine().split("","")) != null; ) {
            int i = Integer.parseInt(line[0]);
            int j = Integer.parseInt(line[1]);
            perc.open(i,j);
            if (perc.percolates()==true){
                System.out.println(i+"",""+j);
            }      
        }
        
        
        } 
        catch (Exception ex) {
            System.out.println(""-1"");    
            } 
     }


    public boolean isOpen(int i, int j) {   
        return matrix[i-1][j-1];
    }
    
    public boolean percolates() {
        return qf.connected(pseu1id,pseu2id);
    }  
    
    
    private int getQFIndex (int i, int j){
        return (i-1)*size+j;
    }
    

}
@c68b6d196e6af23ce8cabb92e4856a58@"
"r04945039","10","0.101","126880","@723b5c5ebef623f4d933e03ddb060831@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {
 
    private boolean[][] matrix;
    private int size;
    private int pseu1id=0;
    private int pseu2id;
    private WeightedQuickUnionUF qf;

    //Creates N-by-N grid, with all sites blocked.
    public Percolation (int N) {
        size = N;
        pseu2id = size*size+1;
        qf = new WeightedQuickUnionUF(size*size+2);
        matrix = new boolean[size][size];
    }
    
    public void open (int i, int j){
        matrix[i-1][j-1] =true;
        if (i==1){
            qf.union(getQFIndex(i, j), pseu1id);
        }
        
        if (i==size) {
            qf.union(getQFIndex(i, j), pseu2id);
        }
        
        if (j>1 && isOpen(i, j-1)){
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
        
    }


    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        String matrixsize= br.readLine();
        int input = Integer.parseInt(matrixsize);
        Percolation perc =new Percolation(input);
        
        
        for(String[] line;( line = br.readLine().split("","")) != null; ) {
            int i = Integer.parseInt(line[0]);
            int j = Integer.parseInt(line[1]);
            perc.open(i,j);
            if (perc.percolates()==true){
                System.out.println(i+"",""+j);
                break;
            }      
        }
        
        
        } 
        catch (Exception ex) {
            System.out.println(""-1"");    
            } 
     }


    public boolean isOpen(int i, int j) {   
        return matrix[i-1][j-1];
    }
    
    public boolean percolates() {
        return qf.connected(pseu1id,pseu2id);
    }  
    
    
    private int getQFIndex (int i, int j){
        return (i-1)*size+j;
    }
    

}
@723b5c5ebef623f4d933e03ddb060831@"
"r04631034","7","0.99","228112","@a602967e25d6a29bc7008d40f05381bd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.*;
import java.util.*;

/**
 *
 * @author user
 */
public class Percolation {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);

          int num = Integer.parseInt(in.readLine());
//          System.out.println(num);
          ArrayList<Integer> Row = new ArrayList<Integer>();
          ArrayList<Integer> Column = new ArrayList<Integer>();

          String line;
          String Text = """";
          while ((line = in.readLine()) != null) {
               Row.add(Integer.parseInt(line.split("","")[0]) - 1);
               Column.add(Integer.parseInt(line.split("","")[1]) - 1);
          }
//          for (int i = 0; i < Row.size(); i++) {
//               System.out.print(Row.get(i) + "","" + Column.get(i));
//               System.out.println("""");
//          }
          UF uf = new UF(num * num + 2);//   num*num+1  top  node   num*num+2 bottom node
          int[][] OpenSiteStorge = new int[Row.size()][Row.size()];

          for (int i = 0; i < Row.size(); i++) 
          {                       //Row.get(i) * num + Column.get(i) means ID index    /input coornate
                    if(Row.get(i)<num && Column.get(i)<num)
                    {
//               set open site up
               OpenSiteStorge[Row.get(i)][Column.get(i)] = 1;

//               top row connect to the top node
               if (Row.get(i) == 0) 
               {
                    uf.union(Row.get(i) * num + Column.get(i), num * num);
                    if (OpenSiteStorge[Row.get(i) + 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) + 1) * num + Column.get(i));
                    }
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }
           }

//               last row connect to the bottom node
          else if (Row.get (i)   == num - 1)
          {
                    uf.union(Row.get(i) * num + Column.get(i), num * num + 1);
                     if (OpenSiteStorge[Row.get(i) - 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) - 1) * num + Column.get(i));
                         }  
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }      
     }
          else if(Row.get (i)  != num - 1 && Row.get (i)   != 0)//middle row 
            {               
               if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
               else if (Column.get(i) == num-1) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                         } 
               else if (Column.get(i) != num-1 && Column.get(i) != 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
          }
     
     if(uf.connected(num*num, num*num+1) == true)
     {
//          System.out.println(""output:"");
          System.out.println((Row.get(i)+1)+"",""+(Column.get(i)+1));
          break;
     }
     if( i == Row.size() - 1 && uf.connected(num*num, num*num+1) == false )
     {           
               System.out.println(""-1"");
     }
     }
}
//for(int i = 0 ; i < num;i++){
//                    System.out.println(OpenSiteStorge[i][0]+"" ""+OpenSiteStorge[i][1]+"" ""+OpenSiteStorge[i][2]);
//          }
//          System.out.println(uf.connected(num*num, num*num+1));
//          System.out.println(uf.connected(0, 3));
//          System.out.println(uf.connected(0, num * num));
//          System.out.println(uf.connected(6, num * num + 1));
//          System.out.println(uf.connected(7, num * num + 1));
//          System.out.println(uf.connected(8, num * num + 1));
     }
}



@a602967e25d6a29bc7008d40f05381bd@"
"r04631033","0","0.101","126880","@611d92504968af0bf1e8e6a3ef30a0b0@private boolean[][] opened;
    private int top = 0;
    private int bottom;
    private int size;
    private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public Percolation(int N) {
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i - 1][j - 1] = true;
        if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
        if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }

    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i - 1][j - 1];
    }

    /**
     * Is site (row i, column j) full?
     */
    public boolean isFull(int i, int j) {
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Does the system percolate?
     */
    public boolean percolates() {
        return qf.connected(top, bottom);
    }

    private int getQFIndex(int i, int j) {
        return size * (i - 1) + j;
    }
}
@611d92504968af0bf1e8e6a3ef30a0b0@"
"r04921012","0","0.101","126880","@554a95d56c458b1ab19e0d59319d62df@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package percolation;

import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author steven
 */
public class Percolation {
    private boolean[][] opened;
    private int top = 0;
    private int bottom;
    private int size;
    private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public Percolation(int N) {
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i - 1][j - 1] = true;
        if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
        if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }

    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i - 1][j - 1];
    }

    /**
     * Is site (row i, column j) full?
     */
    public boolean isFull(int i, int j) {
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Does the system percolate?
     */
    public boolean percolates() {
        return qf.connected(top, bottom);
    }

    private int getQFIndex(int i, int j) {
        return size * (i - 1) + j;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String n= br.readLine();
            int N=Integer.parseInt(n);
            
            Percolation matrix=new Percolation(N);
            String position;
            while((position=br.readLine())!=null){
                String[] xy=position.split("","");
                int x = Integer.parseInt(xy[0]);
                int y = Integer.parseInt(xy[1]);
                matrix.open(y,x);
                if (matrix.percolates()){
                    System.out.println(position);
                    break;
                }
            }
        }
    }
    
}

@554a95d56c458b1ab19e0d59319d62df@"
"r04921012","1","0.99","125744","@45db8fdec6268de03fc2720ac7ed9cec@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author steven
 */
public class Percolation {
    private boolean[][] opened;
    private int top = 0;
    private int bottom;
    private int size;
    private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public Percolation(int N) {
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i - 1][j - 1] = true;
        if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
        if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }

    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i - 1][j - 1];
    }

    /**
     * Is site (row i, column j) full?
     */
    public boolean isFull(int i, int j) {
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Does the system percolate?
     */
    public boolean percolates() {
        return qf.connected(top, bottom);
    }

    private int getQFIndex(int i, int j) {
        return size * (i - 1) + j;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String n= br.readLine();
            int N=Integer.parseInt(n);
            
            Percolation matrix=new Percolation(N);
            String position;
            while((position=br.readLine())!=null){
                String[] xy=position.split("","");
                int x = Integer.parseInt(xy[0]);
                int y = Integer.parseInt(xy[1]);
                matrix.open(y,x);
                if (matrix.percolates()){
                    System.out.println(position);
                    break;
                }
            }
        }
    }
    
}

@45db8fdec6268de03fc2720ac7ed9cec@"
"r04921012","1","1.21","142416","@1954a0c982c316bf643e3ddc89dc33f5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author steven
 */
public class Percolation {
    private boolean[][] opened;
    private int top = 0;
    private int bottom;
    private int size;
    private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public Percolation(int N) {
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i - 1][j - 1] = true;
        if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
        if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }

    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i - 1][j - 1];
    }

    /**
     * Is site (row i, column j) full?
     */
    public boolean isFull(int i, int j) {
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Does the system percolate?
     */
    public boolean percolates() {
        return qf.connected(top, bottom);
    }

    private int getQFIndex(int i, int j) {
        return size * (i - 1) + j;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String n= br.readLine();
            int N=Integer.parseInt(n);
            
            Percolation matrix=new Percolation(N);
            String position;
            while((position=br.readLine())!=null){
                String[] xy=position.split("","");
                int x = Integer.parseInt(xy[0]);
                int y = Integer.parseInt(xy[1]);
                matrix.open(y,x);
                if (matrix.percolates()){
                    System.out.println(position);
                    break;
                }
            System.out.println(-1);
            }
        }
    }
    
}

@1954a0c982c316bf643e3ddc89dc33f5@"
"r04921012","4","0.99","123888","@d5526e549c5e7b9652b5614cde11ad3f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author steven
 */
public class Percolation {
    private boolean[][] opened;
    private int top = 0;
    private int bottom;
    private int size;
    private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public Percolation(int N) {
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i - 1][j - 1] = true;
        if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
        if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }

    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i - 1][j - 1];
    }

    /**
     * Is site (row i, column j) full?
     */
    public boolean isFull(int i, int j) {
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Does the system percolate?
     */
    public boolean percolates() {
        return qf.connected(top, bottom);
    }

    private int getQFIndex(int i, int j) {
        return size * (i - 1) + j;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String n= br.readLine();
            int N=Integer.parseInt(n);
            
            Percolation matrix=new Percolation(N);
            String position;
            while((position=br.readLine())!=null){
                String[] xy=position.split("","");
                int x = Integer.parseInt(xy[0]);
                int y = Integer.parseInt(xy[1]);
                matrix.open(y,x);
                if (matrix.percolates()){
                    System.out.println(position);
                    break;
                }
            }
        System.out.println(-1);
        }
    }
    
}

@d5526e549c5e7b9652b5614cde11ad3f@"
"r04921012","5","1","121536","@9dfe759177d966b9d2b938c2e532618b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author steven
 */
public class Percolation {
    private boolean[][] opened;
    private int top = 0;
    private int bottom;
    private int size;
    private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public Percolation(int N) {
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i - 1][j - 1] = true;
        if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
        if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }

    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i - 1][j - 1];
    }

    /**
     * Is site (row i, column j) full?
     */
    public boolean isFull(int i, int j) {
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Does the system percolate?
     */
    public boolean percolates() {
        return qf.connected(top, bottom);
    }

    private int getQFIndex(int i, int j) {
        return size * (i - 1) + j;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String n= br.readLine();
            int N=Integer.parseInt(n);
            
            Percolation matrix=new Percolation(N);
            String position;
            while((position=br.readLine())!=null){
                String[] xy=position.split("","");
                int x = Integer.parseInt(xy[0]);
                int y = Integer.parseInt(xy[1]);
                matrix.open(x,y);
                if (matrix.percolates()){
                    System.out.println(position);
                    break;
                }
            }
        System.out.println(-1);
        }
    }
    
}

@9dfe759177d966b9d2b938c2e532618b@"
"r04921012","5","1.03","123712","@3b5176b69d2e26814295aba7f048e495@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author steven
 */
public class Percolation {
    private boolean[][] opened;
    private int top = 0;
    private int bottom;
    private int size;
    private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public Percolation(int N) {
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i - 1][j - 1] = true;
        if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
        if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }

    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i - 1][j - 1];
    }

    /**
     * Is site (row i, column j) full?
     */
    public boolean isFull(int i, int j) {
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Does the system percolate?
     */
    public boolean percolates() {
        return qf.connected(top, bottom);
    }

    private int getQFIndex(int i, int j) {
        return size * (i - 1) + j;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String n= br.readLine();
            int N=Integer.parseInt(n);
            
            Percolation matrix=new Percolation(N);
            String position;
            while((position=br.readLine())!=null){
                String[] xy=position.split("","");
                int x = Integer.parseInt(xy[1]);
                int y = Integer.parseInt(xy[0]);
                matrix.open(y,x);
                if (matrix.percolates()){
                    System.out.println(position);
                    break;
                }
            }
        System.out.println(-1);
        }
    }
    
}

@3b5176b69d2e26814295aba7f048e495@"
"b01703032","0","0.85","105504","@9ade1c98a5e0d3ff7b039bd6c75d12de@public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 
    /**
     * Construction Method, declare two WQUUF, and two virtual node
     *
     * @param N the scale of the input
     * @throws java.lang.IllegalArgumentException if N < 0
     */
    public Percolation(int N) {               // create N-by-N grid, with all sites blocked
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }

    public void open(int i, int j) {         // open site (row i, column j) if it is not open already
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }
        
        if(backWash.connected(top, bottom)==true)
        {
            System.out.println(i+"",""+j);
        }
    }
    
    
    public boolean isOpen(int i, int j) {    // is site (row i, column j) open?
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {    // is site (row i, column j) full?
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {            // does the system percolate?
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
 
    public static void main(String[] args) {  // test client (optional)
        Percolation percolation = new Percolation(3);
        percolation.open(1, 1);
        percolation.open(2, 2);
        percolation.open(3, 3);
        percolation.open(2, 1);
        percolation.open(2, 3);
        percolation.open(3, 1);
        percolation.open(3, 2);

    }
 
}

@9ade1c98a5e0d3ff7b039bd6c75d12de@"
"r04921065","0","0.99","123888","@249304735545ac89b790780b527d2951@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package percolation;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import java.util.Arrays;


/**
 *
 * @author 余軒
 */

public class Percolation {

private WeightedQuickUnionUF qf;
private boolean[][] opened;
private int top = 0;
private int bottom;
private int size;

public Percolation(int N) {  //constuctor
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }




    /**
     * @param i
     * @param j
     * @param args the command line arguments
     * @throws java.io.IOException
     */


public void open(int i, int j) {     //Object Method
    opened[i-1][j-1]=true;
    if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
    if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }
    
 public boolean isFull(int i, int j) {    //Object Method
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }



public boolean isOpen(int i, int j) { //Object Method
        return opened[i - 1][j - 1];
   }

private int getQFIndex(int i, int j) { //Object Method
        return size * (i - 1) + j;
    }


public static void main(String[] args) throws IOException {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        
            String data = br.readLine();    //data不是串列，是單一元素
            int size = Integer.parseInt(data);
        System.out.println(size);
        boolean[][] opened = new boolean[size][size]; //size = 3; 0~2
        Percolation a = new Percolation(size);  //宣告a為指定某種物件指標
        

      
       while(br.ready()){
                String[] coordinate  =br.readLine().split("","");
                int i = Integer.parseInt(coordinate[0]);
                int j = Integer.parseInt(coordinate[1]);
                //String[] I = new String[i];
               // String[] J = new String[j];
                System.out.println(i+"",""+j);
                //opened[i-1][j-1]=true;
                a.open(i,j);   
              // open(i,j);  //在static函式中呼叫非static函式
               
                    if (a.percolates()){
                    System.out.println(""true"");
                    break;
                    }          
                
                }
                
   
            
       // System.out.println(opened[0][2]);
        
        }

     //public boolean isOpen    
    }
     public boolean percolates() {
        return qf.connected(top, bottom);
    }
     
}


@249304735545ac89b790780b527d2951@"
"r04921065","0","1.22","140432","@2757a70c70fc3240e2884334745479fc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import java.util.Arrays;


/**
 *
 * @author 余軒
 */

public class Percolation {

private WeightedQuickUnionUF qf;
private boolean[][] opened;
private int top = 0;
private int bottom;
private int size;

public Percolation(int N) {  //constuctor
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }




    /**
     * @param i
     * @param j
     * @param args the command line arguments
     * @throws java.io.IOException
     */


public void open(int i, int j) {     //Object Method
    opened[i-1][j-1]=true;
    if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
    if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }
    
 public boolean isFull(int i, int j) {    //Object Method
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }



public boolean isOpen(int i, int j) { //Object Method
        return opened[i - 1][j - 1];
   }

private int getQFIndex(int i, int j) { //Object Method
        return size * (i - 1) + j;
    }


public static void main(String[] args) throws IOException {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        
            String data = br.readLine();    //data不是串列，是單一元素
            int size = Integer.parseInt(data);
        System.out.println(size);
        boolean[][] opened = new boolean[size][size]; //size = 3; 0~2
        Percolation a = new Percolation(size);  //宣告a為指定某種物件指標
        

      
       while(br.ready()){
                String[] coordinate  =br.readLine().split("","");
                int i = Integer.parseInt(coordinate[0]);
                int j = Integer.parseInt(coordinate[1]);
                //String[] I = new String[i];
               // String[] J = new String[j];
                System.out.println(i+"",""+j);
                //opened[i-1][j-1]=true;
                a.open(i,j);   
              // open(i,j);  //在static函式中呼叫非static函式
               
                    if (a.percolates()){
                    System.out.println(""true"");
                    break;
                    }          
                
                }
                
   
            
       // System.out.println(opened[0][2]);
        
        }

     //public boolean isOpen    
    }
     public boolean percolates() {
        return qf.connected(top, bottom);
    }
     
}


@2757a70c70fc3240e2884334745479fc@"
"r04921065","5","1.01","126320","@a62fabe08756aeed27aec7e040f9a306@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import java.util.Arrays;


/**
 *
 * @author 余軒
 */

public class Percolation {

private WeightedQuickUnionUF qf;
private boolean[][] opened;
private int top = 0;
private int bottom;
private int size;

public Percolation(int N) {  //constuctor
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }




    /**
     * @param i
     * @param j
     * @param args the command line arguments
     * @throws java.io.IOException
     */


public void open(int i, int j) {     //Object Method
    opened[i-1][j-1]=true;
    if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
    if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }
    
 public boolean isFull(int i, int j) {    //Object Method
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }



public boolean isOpen(int i, int j) { //Object Method
        return opened[i - 1][j - 1];
   }

private int getQFIndex(int i, int j) { //Object Method
        return size * (i - 1) + j;
    }


public static void main(String[] args) throws IOException {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        
            String data = br.readLine();    //data不是串列，是單一元素
            int size = Integer.parseInt(data);
        //System.out.println(size);
        boolean[][] opened = new boolean[size][size]; //size = 3; 0~2
        Percolation a = new Percolation(size);  //宣告a為指定某種物件指標
        

      
       while(br.ready()){
                String[] coordinate  =br.readLine().split("","");
                int i = Integer.parseInt(coordinate[0]);
                int j = Integer.parseInt(coordinate[1]);
                //String[] I = new String[i];
               // String[] J = new String[j];
                //System.out.println(i+"",""+j);
                //opened[i-1][j-1]=true;
                a.open(i,j);   
              // open(i,j);  //在static函式中呼叫非static函式
               
                    if (a.percolates()){
                    System.out.println(i+"",""+j);
                    break;
                    }          
                
                }
                
   
            
       // System.out.println(opened[0][2]);
        
        }

     //public boolean isOpen    
    }
     public boolean percolates() {
        return qf.connected(top, bottom);
    }
     
}


@a62fabe08756aeed27aec7e040f9a306@"
"b01703032","5","1.01","125632","@ddaa5c3b931f10433b6ca40b66eeda1c@
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 
    /**
     * Construction Method, declare two WQUUF, and two virtual node
     *
     * @param N the scale of the input
     * @throws java.lang.IllegalArgumentException if N < 0
     */
    public Percolation(int N) {               // create N-by-N grid, with all sites blocked
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }

    public void open(int i, int j) {         // open site (row i, column j) if it is not open already
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }

    }
    
    
    public boolean isOpen(int i, int j) {    // is site (row i, column j) open?
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
    public boolean isFull(int i, int j) {    // is site (row i, column j) full?
        validateArray(i, j);
        return unionUF.connected(xyTo1D(i, j), top);
    }
 
    public boolean percolates() {            // does the system percolate?
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
 
    public static void main(String[] args) throws Exception {  // test client (optional)
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        String[] data = br.readLine().split("","");
        int stringCount = Integer.parseInt(data[0]);
        Percolation percolation = new Percolation(stringCount);
         String temp=null;
           while((temp=br.readLine())!=null)
           {
            String[] array;
                array = temp.split("","");
                int i = Integer.parseInt(array[0]);
                int j = Integer.parseInt(array[1]);
               percolation.open(i,j);
               if(percolation.percolates()==true)
               {
                   System.out.println(i + "","" +j);
                   break;
               }

            }
        }



    }
 
}

@ddaa5c3b931f10433b6ca40b66eeda1c@"
"r04921012","10","0.101","120448","@217daef3c820c14fe6b45ae90db4e25a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author steven
 */
public class Percolation {
    private boolean[][] opened;
    private int top = 0;
    private int bottom;
    private int size;
    private WeightedQuickUnionUF qf;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public Percolation(int N) {
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i - 1][j - 1] = true;
        if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
        if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }

    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i - 1][j - 1];
    }

    /**
     * Is site (row i, column j) full?
     */
    public boolean isFull(int i, int j) {
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }

    /**
     * Does the system percolate?
     */
    public boolean percolates() {
        return qf.connected(top, bottom);
    }

    private int getQFIndex(int i, int j) {
        return size * (i - 1) + j;
    }
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        int c=0;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String n= br.readLine();
            int N=Integer.parseInt(n);
            
            Percolation matrix=new Percolation(N);
            String position;
            while((position=br.readLine())!=null){
                String[] xy=position.split("","");
                int x = Integer.parseInt(xy[1]);
                int y = Integer.parseInt(xy[0]);
                matrix.open(y,x);
                if (matrix.percolates()){
                    System.out.println(position);
                    c=1;
                    break;
                }
            }
            if (c==0){
            System.out.println(-1);
            }
        }
    }
    
}

@217daef3c820c14fe6b45ae90db4e25a@"
"r04921065","10","0.1","122640","@f644f9a6af7d1a731cfd68bcf8497520@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import java.util.Arrays;


/**
 *
 * @author 余軒
 */

public class Percolation {

private WeightedQuickUnionUF qf;
private boolean[][] opened;
private int top = 0;
private int bottom;
private int size;

public Percolation(int N) {  //constuctor
        size = N;
        bottom = size * size + 1;
        qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
    }




    /**
     * @param i
     * @param j
     * @param args the command line arguments
     * @throws java.io.IOException
     */


public void open(int i, int j) {     //Object Method
    opened[i-1][j-1]=true;
    if (i == 1) {
            qf.union(getQFIndex(i, j), top);
        }
    if (i == size) {
            qf.union(getQFIndex(i, j), bottom);
        }

        if (j > 1 && isOpen(i, j - 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j - 1));
        }
        if (j < size && isOpen(i, j + 1)) {
            qf.union(getQFIndex(i, j), getQFIndex(i, j + 1));
        }
        if (i > 1 && isOpen(i - 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i - 1, j));
        }
        if (i < size && isOpen(i + 1, j)) {
            qf.union(getQFIndex(i, j), getQFIndex(i + 1, j));
        }
    }
    
 public boolean isFull(int i, int j) {    //Object Method
        if (0 < i && i <= size && 0 < j && j <= size) {
            return qf.connected(top, getQFIndex(i , j));
        } else {
            throw new IndexOutOfBoundsException();
        }
    }



public boolean isOpen(int i, int j) { //Object Method
        return opened[i - 1][j - 1];
   }

private int getQFIndex(int i, int j) { //Object Method
        return size * (i - 1) + j;
    }


public static void main(String[] args) throws IOException {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        
            String data = br.readLine();    //data不是串列，是單一元素
            int size = Integer.parseInt(data);
        //System.out.println(size);
        boolean[][] opened = new boolean[size][size]; //size = 3; 0~2
        Percolation a = new Percolation(size);  //宣告a為指定某種物件指標
        

      
       while(br.ready()){
                String[] coordinate  =br.readLine().split("","");
                int i = Integer.parseInt(coordinate[0]);
                int j = Integer.parseInt(coordinate[1]);
                //String[] I = new String[i];
               // String[] J = new String[j];
                //System.out.println(i+"",""+j);
                //opened[i-1][j-1]=true;
                a.open(i,j);   
              // open(i,j);  //在static函式中呼叫非static函式
               
                    if (a.percolates()){
                    System.out.println(i+"",""+j);
                    break;
                    }          
                    
                    
                    
                
                }
       if (!a.percolates()){
                System.out.println(""-1"");
           }
            
       // System.out.println(opened[0][2]);
        
        }

     //public boolean isOpen    
    }
     public boolean percolates() {
        return qf.connected(top, bottom);
    }
     
}


@f644f9a6af7d1a731cfd68bcf8497520@"
"r04631021","4","0.75","161456","@6845ee5a76cfd9f6b017951d392fa588@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
      _parent[root2] = root1;
    } else if (_rank[root2] > _rank[root1]) {
      _parent[root1] = root2;
    } else {
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData+1);
                //System.out.println(uf._parent[i]);
            }
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            while(true){
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                }
                }
            }
            }
            
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@6845ee5a76cfd9f6b017951d392fa588@"
"b02611012","0","0.99","123888","@6020a457b7d463648a8fdcbacd97692d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import edu.princeton.cs.algs4.QuickFindUF;
import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int gridsize = Integer.parseInt(data);
            String[][] grid = new String[gridsize][gridsize];
            QuickFindUF union = new QuickFindUF(gridsize*gridsize+2);
            for (int i = 0; i < gridsize; i++) {
               union.union(union.count()-1, i); 
               union.union(union.count()-2, union.count()-3-i); 
            }
            
            String str = null;
            while ((str = br.readLine())!= null) {
                String tempArray[]  = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);

                grid[x-1][y-1]=(""1"");
                int site = (x-1)*gridsize+(y-1);
                if(x != 1){
                    if (grid[x-2][y-1]==(""1"")) {
                        union.union(site, site-gridsize);
                    }
                }
                if(x != gridsize){
                    if (grid[x][y-1]==(""1"")) {
                        union.union(site, site+gridsize);
                    }
                }
                if(y != 1){
                    if (grid[x-1][y-2]==(""1"")) {
                        union.union(site, site-1);
                    }
                }
                if(y != gridsize){
                    if (grid[x-1][y]==(""1"")) {
                        union.union(site, site+1);
                    }
                }
                if (union.connected(union.count(), union.count()-1)) {
                    System.out.printf(tempArray[0]+"",""+tempArray[1]);
                    break;
                }
            }
            if (union.connected(union.count(), union.count()-1)==false) {
                    System.out.printf(""-1"");
                }
        }
    }
}

@6020a457b7d463648a8fdcbacd97692d@"
"b02611012","2","0.92","109648","@8de704712d1977d239aadda7faa1a7de@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int gridsize = Integer.parseInt(data);
            String[][] grid = new String[gridsize][gridsize];
            QuickFindUF union = new QuickFindUF(gridsize*gridsize+2);
            for (int i = 0; i < gridsize; i++) {
               union.union(union.count()-1, i); 
               union.union(union.count()-2, union.count()-3-i); 
            }
            
            String str = null;
            while ((str = br.readLine())!= null) {
                String tempArray[]  = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);

                grid[x-1][y-1]=(""1"");
                int site = (x-1)*gridsize+(y-1);
                if(x != 1){
                    if (grid[x-2][y-1]==(""1"")) {
                        union.union(site, site-gridsize);
                    }
                }
                if(x != gridsize){
                    if (grid[x][y-1]==(""1"")) {
                        union.union(site, site+gridsize);
                    }
                }
                if(y != 1){
                    if (grid[x-1][y-2]==(""1"")) {
                        union.union(site, site-1);
                    }
                }
                if(y != gridsize){
                    if (grid[x-1][y]==(""1"")) {
                        union.union(site, site+1);
                    }
                }
                if (union.connected(union.count(), union.count()-1)) {
                    System.out.printf(tempArray[0]+"",""+tempArray[1]);
                    break;
                }
            }
            if (union.connected(union.count(), union.count()-1)==false) {
                    System.out.printf(""-1"");
                }
        }
    }
}

@8de704712d1977d239aadda7faa1a7de@"
"b02611012","10","0.108","127184","@f2072e1fb140170d98008b968335364b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int gridsize = Integer.parseInt(data);
            String[][] grid = new String[gridsize][gridsize];
            QuickFindUF union = new QuickFindUF(gridsize*gridsize+2);
            int start = 0;
            int end = union.count()-1;
            for (int i = 0; i < gridsize; i++) {
               union.union(start, i+1); 
            }
            for (int i = 0; i < gridsize; i++) {
               union.union(end, end-1-i);
            }
          
            int site ;
            String str = null;
            while ((str = br.readLine())!= null) {
                String tempArray[]  = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                int gx = x-1;
                int gy = y-1;
                grid[gx][gy]=(""1"");
                site = gx*gridsize+y;
                if(x > 1){
                    if (grid[gx-1][gy]==(""1"")) {
                        union.union(site, site-gridsize);
                    }
                }
                if(x < gridsize){
                    if (grid[gx+1][gy]==(""1"")) {
                        union.union(site, site+gridsize);
                    }
                }
                if(y > 1){
                    if (grid[gx][gy-1]==(""1"")) {
                        union.union(site, site-1);
                    }
                }
                if(y != gridsize){
                    if (grid[gx][gy+1]==(""1"")) {
                        union.union(site, site+1);
                    }
                }
                if (union.connected(start, end)) {
                    System.out.printf(tempArray[0]+"",""+tempArray[1]);
                    break;
                }
            }
            if (union.connected(start, end)==false) {
                    System.out.printf(""-1"");
                }
        }
    }
}

@f2072e1fb140170d98008b968335364b@"
"r03945012","9","1.27","187584","@bc33ff5a75f4338a82adcc73198ccb93@
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.ArrayList;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Robert
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        InputStream is = null;
        InputStreamReader isr = null;
        BufferedReader br = null;

        try {
            is = new FileInputStream(args[0]);
            isr = new InputStreamReader(is, StandardCharsets.UTF_8);
            br = new BufferedReader(isr);
            
            
            // read file.txt
            boolean output = false;
            Scanner inputdata = new Scanner(br);
            String data = inputdata.nextLine();

            // num is matrix size(num*num)
            // matrix starts from 1
            // label = 00
            int num = Integer.parseInt(data);
            int[][] matrix = new int[num][num];
            int[][] label = new int[num][num];
            for (int[] row : label) {
                java.util.Arrays.fill(row, 0);
            }
            
            ArrayList myList = new ArrayList();

            while(inputdata.hasNextLine()){
                String[] tmp = inputdata.nextLine().split("","");
                for(int i=0; i<tmp.length; i++)
                    myList.add(tmp[i]);                
            }
            // nextLine(point) and totaline
            
            int k = myList.size()/2;
            int count = 0;
            int[][] point = new int[k][2];            
            for (int i=0; i< k; i++){
                point[i][0] = Integer.parseInt((String) myList.get(count)) - 1;
                point[i][1] = Integer.parseInt((String) myList.get(count+1)) - 1;
                count = count+2;
            }
                
            // create class uf (0 to num*num+1)
            // 0 = virtual top
            // num*num+1 = virtual bottom
            UF uf = new UF(num * num + 2);

            // start 1 (using for)
            for (int i = 0; i < point.length; i++) {
                int x = point[i][0];
                int y = point[i][1];
                label[x][y] = 1;
                int index = x * num + y + 1;

                // matrix union
                // union top
                if (x == 0) {
                    uf.union(index, 0);
                    if (label[x + 1][y] == 1)
                        uf.union(index, index + num);
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                } 
                //union bottom
                else if (x == num - 1) {
                    uf.union(index, num * num + 1);
                    if (label[x - 1][y] == 1)
                        uf.union(index, index - num);
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                } // union the rest
                else {
                    // union to top one
                    if (label[x - 1][y] == 1)
                        uf.union(index, index - num);
                    // union to down one
                    if (label[x + 1][y] == 1)
                        uf.union(index, index + num);
                    
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                }
                output = uf.connected(0, num * num + 1);
                if (output == true) {
                    System.out.print((x+1)+"",""+(y+1));
                    break;
                }
            }
            if (output == false)
                System.out.print(""-1""); 
        } catch (FileNotFoundException | NumberFormatException e) {
        } finally {
            // releases resources associated with the streams
            if (is != null) {
                is.close();
            }
            if (isr != null) {
                isr.close();
            }
            if (br != null) {
                br.close();
            }
        }
    }

}

@bc33ff5a75f4338a82adcc73198ccb93@"
"r04921115","0","1.51","178880","@880d00071d3758d03ac4c621c5618687@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation 
{	
	public static void main(String[] args) throws Exception 
    {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
        	String[] data = br.readLine().split("","");
            //N: matrix size
            int N = Integer.parseInt(data[0]);
            UF uf = new UF(N*N+2);
            //System.out.printf(""%d\n"",N);

            String temp;
	    	int[][] matrix = new int[N+2][N+2]; //error: have to initialize : type""new int[N][N]""
	    	boolean[][] status = new boolean[N+2][N+2];
	    	
	    	int k=0;
	    	int i;
	    	int j;
	    	for(i = 1; i<=N+1; i++)
	    	{
	    		for(j = 1; j<N+1; j++)
	    		{
	    			if(i!=(N+1))
	    			{
	    				k++;
	    				matrix[i][j]=k;
	    			}else
	    			{
	    				matrix[i][j]=N*N+1;
	    			}
	    		}
	    	}
	    	
	    	for(i = 0; i<N+2; i++)
	    	{
	    		for(j = 0; j<N+2; j++)
	    		{
	    			if(i==0 && j>=1 && j<=N)
	    			{
	    				status[i][j] = true; 
	    			}else if(i==N+1 && j>=1 && j<=N)
	    			{
	    				status[i][j] = true;
	    			}else
	    			{
	    				status[i][j] = false;
	    			}
	    		}
        	}

	    	/*just for test*/
//	    	for(i = 0; i<N+2; i++)
//	    	{
//	    		for(j = 0; j<N+2; j++)
//	    		{
//	    			System.out.printf(""%d "",matrix[i][j]);	
//	    		}
//	    		System.out.printf(""%n"");
//        	}
//	    	for(i = 0; i<N+2; i++)
//	    	{
//	    		for(j = 0; j<N+2; j++)
//	    		{
//	    			System.out.printf(""%b "",status[i][j]);	
//	    		}
//	    		System.out.printf(""%n"");
//        	}
	    	
	    	boolean flag = false;
	    	while((temp = br.readLine())!=null)
	    	{
	    		String[] coordinates = temp.split("","");
	    		int row = Integer.parseInt(coordinates[0]);
	            int col = Integer.parseInt(coordinates[1]);
	            status[row][col]=true;
	            System.out.printf(""%d \n"", matrix[row][col]);
	            if(status[row-1][col]==true)
	            {
	            	uf.union(matrix[row][col],matrix[row-1][col]);
	            	//System.out.printf(""row-1 %b \n"", uf.connected(matrix[row][col],matrix[row-1][col]));
	            }
	            if(status[row+1][col]==true)
	            {
	            	uf.union(matrix[row][col],matrix[row+1][col]);
	            	//System.out.printf(""row+1 %b \n"", uf.connected(matrix[row][col],matrix[row+1][col]));
	            }
	            if(status[row][col+1]==true)
	            {
	            	uf.union(matrix[row][col],matrix[row][col+1]);
	            	//System.out.printf(""col+1 %b \n"", uf.connected(matrix[row][col],matrix[row][col+1]));
	            }
	            if(status[row][col-1]==true)
	            {
	            	uf.union(matrix[row][col],matrix[row][col-1]);
	            	//System.out.printf(""col-1 %b \n"", uf.connected(matrix[row][col],matrix[row][col-1]));
	            }
	            if(uf.connected(0,N*N+1))
	            {
	            	System.out.printf(""%d,%d"",row,col);
	            	flag = true;
	            	break;
	            }
	            //System.out.printf(""::: %d %b \n"", uf.find(9) ,uf.connected(0,N*N+1));
	    	}
	    	if(flag==false)
	    	{
	    		System.out.printf(""-1"");
	    	}
        }
    }
}

@880d00071d3758d03ac4c621c5618687@"
"r04921115","10","0.103","124640","@5a7014ac4c3823697b77519c5576f847@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation 
{	
	public static void main(String[] args) throws Exception 
    {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
        	String[] data = br.readLine().split("","");
            //N: matrix size
            int N = Integer.parseInt(data[0]);
            UF uf = new UF(N*N+2);
            //System.out.printf(""%d\n"",N);

            String temp;
	    	int[][] matrix = new int[N+2][N+2]; //error: have to initialize : type""new int[N][N]""
	    	boolean[][] status = new boolean[N+2][N+2];
	    	
	    	int k=0;
	    	int i;
	    	int j;
	    	for(i = 1; i<=N+1; i++)
	    	{
	    		for(j = 1; j<N+1; j++)
	    		{
	    			if(i!=(N+1))
	    			{
	    				k++;
	    				matrix[i][j]=k;
	    			}else
	    			{
	    				matrix[i][j]=N*N+1;
	    			}
	    		}
	    	}
	    	
	    	for(i = 0; i<N+2; i++)
	    	{
	    		for(j = 0; j<N+2; j++)
	    		{
	    			if(i==0 && j>=1 && j<=N)
	    			{
	    				status[i][j] = true; 
	    			}else if(i==N+1 && j>=1 && j<=N)
	    			{
	    				status[i][j] = true;
	    			}else
	    			{
	    				status[i][j] = false;
	    			}
	    		}
        	}

	    	/*just for test*/
//	    	for(i = 0; i<N+2; i++)
//	    	{
//	    		for(j = 0; j<N+2; j++)
//	    		{
//	    			System.out.printf(""%d "",matrix[i][j]);	
//	    		}
//	    		System.out.printf(""%n"");
//        	}
//	    	for(i = 0; i<N+2; i++)
//	    	{
//	    		for(j = 0; j<N+2; j++)
//	    		{
//	    			System.out.printf(""%b "",status[i][j]);	
//	    		}
//	    		System.out.printf(""%n"");
//        	}
	    	
	    	boolean flag = false;
	    	while((temp = br.readLine())!=null)
	    	{
	    		String[] coordinates = temp.split("","");
	    		int row = Integer.parseInt(coordinates[0]);
	            int col = Integer.parseInt(coordinates[1]);
	            status[row][col]=true;
	            //System.out.printf(""%d \n"", matrix[row][col]);
	            if(status[row-1][col]==true)
	            {
	            	uf.union(matrix[row][col],matrix[row-1][col]);
	            	//System.out.printf(""row-1 %b \n"", uf.connected(matrix[row][col],matrix[row-1][col]));
	            }
	            if(status[row+1][col]==true)
	            {
	            	uf.union(matrix[row][col],matrix[row+1][col]);
	            	//System.out.printf(""row+1 %b \n"", uf.connected(matrix[row][col],matrix[row+1][col]));
	            }
	            if(status[row][col+1]==true)
	            {
	            	uf.union(matrix[row][col],matrix[row][col+1]);
	            	//System.out.printf(""col+1 %b \n"", uf.connected(matrix[row][col],matrix[row][col+1]));
	            }
	            if(status[row][col-1]==true)
	            {
	            	uf.union(matrix[row][col],matrix[row][col-1]);
	            	//System.out.printf(""col-1 %b \n"", uf.connected(matrix[row][col],matrix[row][col-1]));
	            }
	            if(uf.connected(0,N*N+1))
	            {
	            	System.out.printf(""%d,%d"",row,col);
	            	flag = true;
	            	break;
	            }
	            //System.out.printf(""::: %d %b \n"", uf.find(9) ,uf.connected(0,N*N+1));
	    	}
	    	if(flag==false)
	    	{
	    		System.out.printf(""-1"");
	    	}
        }
    }
}

@5a7014ac4c3823697b77519c5576f847@"
"r04631021","4","0.74","165072","@806436a84dcda1c3209003ac3cc7b34b@
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
      _parent[root2] = root1;
    } else if (_rank[root2] > _rank[root1]) {
      _parent[root1] = root2;
    } else {
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData+1);
                //System.out.println(uf._parent[i]);
            }
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            while(true){
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                }
                }
                else if(Drow == 0){
                    if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                else if(Drow == RankOfData -1){
                    if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }    
                    }
                }
            }
            }
            
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@806436a84dcda1c3209003ac3cc7b34b@"
"r04631021","6","1.3","161952","@ec409a6fcdbd14f69cd85a99a6b2fa8e@import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
      _parent[root2] = root1;
    } else if (_rank[root2] > _rank[root1]) {
      _parent[root1] = root2;
    } else {
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData+1);
                //System.out.println(uf._parent[i]);
            }
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            while(true){
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                }
                else if(Drow == 0){
                    if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                }
                else if(Drow == RankOfData -1){
                    if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                }
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                }
                
            }
            }
            
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@ec409a6fcdbd14f69cd85a99a6b2fa8e@"
"r04631021","8","1.34","163616","@4e5d9b4854dddd43314f67c0d7ee3d00@import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
      _parent[root2] = root1;
    } else if (_rank[root2] > _rank[root1]) {
      _parent[root1] = root2;
    } else {
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData+1);
                //System.out.println(uf._parent[i]);
            }
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            while(true){
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                }
                else if(Drow == 0){
                    if(matrix[Dcol+RankOfData+1]){
                    uf.union(Dcol+RankOfData+1, Dcol+1);
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                else if(Drow == RankOfData -1){
                    if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                }
                
            }
            }
            
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@4e5d9b4854dddd43314f67c0d7ee3d00@"
"b03704074","2","1.58","168992","@e8434391cea667b93c06c376917cc115@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
         for(int j=0;j<i;j++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*2 && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0&&numstring[i]!=0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1&&numstring[i]!=0)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if((numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)&&numstring[i]!=0)//其他的
              percolation.union(numstring[i], numstring[j]);
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back;}
         }
        }
        }
        }
        
        
}}

@e8434391cea667b93c06c376917cc115@"
"r04631021","8","1.36","161392","@4e5d9b4854dddd43314f67c0d7ee3d00@import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
      _parent[root2] = root1;
    } else if (_rank[root2] > _rank[root1]) {
      _parent[root1] = root2;
    } else {
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData+1);
                //System.out.println(uf._parent[i]);
            }
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            while(true){
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                }
                else if(Drow == 0){
                    if(matrix[Dcol+RankOfData+1]){
                    uf.union(Dcol+RankOfData+1, Dcol+1);
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                else if(Drow == RankOfData -1){
                    if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                }
                
            }
            }
            
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@4e5d9b4854dddd43314f67c0d7ee3d00@"
"b03704074","0","1.98","202960","@59e4b8da96e22b729c7980db92765682@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
         for(int j=0;j<i;j++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*2 && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0&&numstring[i]!=0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          
          else if(numstring[i]%N==1&&numstring[i]!=0)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          
          else if((numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)&&numstring[i]!=0)//其他的
              percolation.union(numstring[i], numstring[j]);
          
          if(percolation.connected(N*N+1,N*N+2)) 
            {System.out.println(""找到""+numstring[i]); 
            System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back;}
         }
        }
        }
        }
        
        
}}

@59e4b8da96e22b729c7980db92765682@"
"b03704074","2","1.57","166768","@d30cc1cc122c55fd7b0a679ea0be7afc@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
         for(int j=0;j<i;j++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*2 && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0&&numstring[i]!=0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1&&numstring[i]!=0)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if((numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)&&numstring[i]!=0)//其他的
              percolation.union(numstring[i], numstring[j]);
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back;}
         }
        }
        }
        }
        
        
}}
        
        


@d30cc1cc122c55fd7b0a679ea0be7afc@"
"b03704074","3","3.33","170544","@e656b0ce26ad82c27d6b9b6243037e08@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
         for(int j=0;j<i;j++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          if(!percolation.connected(numstring[i],numstring[j])&&numstring[i]!=0){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back;}
         }
        }
        }
        }
        
        
}}
        
        


@e656b0ce26ad82c27d6b9b6243037e08@"
"r04631021","5","1.34","169888","@cb7595cded0537795b5768b695d1c2be@import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
      _parent[root2] = root1;
    } else if (_rank[root2] > _rank[root1]) {
      _parent[root1] = root2;
    } else {
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData + 1);
                //System.out.println(uf._parent[i]);
            }
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            while(true){
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[0]==uf._parent[RankOfData*RankOfData+1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                }
                else if(Drow == 0){
                    if(matrix[Dcol+RankOfData+1]){
                    uf.union(Dcol+RankOfData+1, Dcol+1);
                    if(uf._parent[0]==uf._parent[RankOfData*RankOfData+1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                else if(Drow == RankOfData -1){
                    if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                    if(uf._parent[0]==uf._parent[RankOfData*RankOfData+1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                }
                
            }
            }
            
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@cb7595cded0537795b5768b695d1c2be@"
"r04631021","0","2.56","314128","@ecba6d6ab28c50bf1f6408128f867093@
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
      _parent[root2] = root1;
    } else if (_rank[root2] > _rank[root1]) {
      _parent[root1] = root2;
    } else {
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            while(true){for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData+1 );
                //System.out.println(uf._parent[i]);
            }
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[0]==uf._parent[RankOfData*RankOfData+1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                }
                else if(Drow == 0){
                    if(matrix[Dcol+RankOfData+1]){
                    uf.union(Dcol+RankOfData+1, Dcol+1);
                    if(uf._parent[0]==uf._parent[RankOfData*RankOfData+1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                else if(Drow == RankOfData -1){
                    if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                    if(uf._parent[0]==uf._parent[RankOfData*RankOfData+1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                System.out.println(uf._parent[0]);
                System.out.println(uf._parent[1]);
                System.out.println(uf._parent[2]);
                System.out.println(uf._parent[3]);
                System.out.println(uf._parent[4]);
                System.out.println(uf._parent[5]);
                System.out.println(uf._parent[6]);
                System.out.println(uf._parent[7]);
                System.out.println(uf._parent[8]);
                System.out.println(uf._parent[9]);
                System.out.println(uf._parent[RankOfData*RankOfData+1]);
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                }
                
            }
            }
            
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@ecba6d6ab28c50bf1f6408128f867093@"
"r04921044","0","3.33","170544","@87f782f484e626968c91d3e25a408a35@import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.*;

public class Percolation {
    int mapSize;
    int tailRoot;
    int[][] map;

    public Percolation(int _mapSize) {
        mapSize = _mapSize;
        tailRoot = mapSize*mapSize;
        map = new int[mapSize][mapSize];
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                map[i][j] = -1;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String mapSizeString = buffer.readLine();

        Percolation percolation = new Percolation(Integer.parseInt(mapSizeString));
        
        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            int row = Integer.parseInt(coord[0]) - 1;
            int col = Integer.parseInt(coord[1]) - 1;

            if (percolation.checkRunThrough(row, col)) {
                System.out.println(coordLine);
                break;
            }
        }
    }

    public Boolean checkRunThrough(int row, int col) {
        // set self root = self
        map[row][col] = row*mapSize + col;

        // connect with 4 direction
        // U, D, L, R
        if (row > 0 && map[row-1][col] != -1) {
            // connect with UP
            map[row][col] = map[row-1][col] = Math.min(map[row][col], findRoot(map[row-1][col]));
        }
        if (row < mapSize-1 && map[row+1][col] != -1) {
            // connect with DOWN
            map[row][col] = map[row+1][col] = Math.min(map[row][col], findRoot(map[row+1][col]));
        }
        if (col > 0 && map[row][col-1] != -1) {
            // connect with LEFT
            map[row][col] = map[row][col-1] = Math.min(map[row][col], findRoot(map[row][col-1]));
        }
        if (col < mapSize-1 && map[row][col+1] != -1) {
            // connect with RIGHT
            map[row][col] = map[row][col+1] = Math.min(map[row][col], findRoot(map[row][col+1]));
        }

        // check root of tail is first row
        if (row == mapSize-1) {
            tailRoot = findRoot(map[row][col]);
        }

// for (int i=0; i<mapSize; ++i) {
//     for (int j=0; j<mapSize; ++j) {
//         System.out.print(map[i][j] + "" "");
//     }
//     System.out.println();
// }

        int rootOfTail = findRoot(tailRoot);
// System.out.println(""TAILROOT: "" + tailRoot);
        if (rootOfTail < mapSize) {
            return true;
        }
        return false;
    }

    public int findRoot(int index) {
        if (index == mapSize*mapSize) {
            return index;
        }

        Vector<Integer> route = new Vector<>();
        while (map[index/mapSize][index%mapSize] != index) {
            route.add(index);
            index = map[index/mapSize][index%mapSize];
        }

        // post process
        for (int i=0; i<route.size(); ++i) {
            map[index/mapSize][index%mapSize] = index;
        }

        return index;
    }
}

@87f782f484e626968c91d3e25a408a35@"
"r04921044","4","0.96","135104","@695879807ba73a2d83c1483b3667a2a5@import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.ArrayList;

public class Percolation {
    int mapSize;
    int tailRoot;
    int[][] map;

    public Percolation(int _mapSize) {
        mapSize = _mapSize;
        tailRoot = mapSize*mapSize;
        map = new int[mapSize][mapSize];
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                map[i][j] = -1;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String mapSizeString = buffer.readLine();

        Percolation percolation = new Percolation(Integer.parseInt(mapSizeString));
        
        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            int row = Integer.parseInt(coord[0]) - 1;
            int col = Integer.parseInt(coord[1]) - 1;

            if (percolation.checkRunThrough(row, col)) {
                System.out.println(coordLine);
                break;
            }
        }
    }

    public Boolean checkRunThrough(int row, int col) {
        // set self root = self
        map[row][col] = row*mapSize + col;

        // connect with 4 direction
        // U, D, L, R
        if (row > 0 && map[row-1][col] != -1) {
            // connect with UP
            map[row][col] = map[row-1][col] = Math.min(map[row][col], findRoot(map[row-1][col]));
        }
        if (row < mapSize-1 && map[row+1][col] != -1) {
            // connect with DOWN
            map[row][col] = map[row+1][col] = Math.min(map[row][col], findRoot(map[row+1][col]));
        }
        if (col > 0 && map[row][col-1] != -1) {
            // connect with LEFT
            map[row][col] = map[row][col-1] = Math.min(map[row][col], findRoot(map[row][col-1]));
        }
        if (col < mapSize-1 && map[row][col+1] != -1) {
            // connect with RIGHT
            map[row][col] = map[row][col+1] = Math.min(map[row][col], findRoot(map[row][col+1]));
        }

        // check root of tail is first row
        if (row == mapSize-1) {
            tailRoot = findRoot(map[row][col]);
        }

// for (int i=0; i<mapSize; ++i) {
//     for (int j=0; j<mapSize; ++j) {
//         System.out.print(map[i][j] + "" "");
//     }
//     System.out.println();
// }

        int rootOfTail = findRoot(tailRoot);
// System.out.println(""TAILROOT: "" + tailRoot);
        if (rootOfTail < mapSize) {
            return true;
        }
        return false;
    }

    public int findRoot(int index) {
        if (index == mapSize*mapSize) {
            return index;
        }

        ArrayList<Integer> route = new ArrayList<>();
        while (map[index/mapSize][index%mapSize] != index) {
            route.add(index);
            index = map[index/mapSize][index%mapSize];
        }

        // post process
        for (int i=0; i<route.size(); ++i) {
            map[index/mapSize][index%mapSize] = index;
        }

        return index;
    }
}

@695879807ba73a2d83c1483b3667a2a5@"
"r04921044","4","0.98","135632","@74311b8d8ca3645632735bbb959e6704@import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.ArrayList;

public class Percolation {
    int mapSize;
    int tailRoot;
    int[][] map;

    public Percolation(int _mapSize) {
        mapSize = _mapSize;
        tailRoot = mapSize*mapSize;
        map = new int[mapSize][mapSize];
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                map[i][j] = -1;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String mapSizeString = buffer.readLine();

        Percolation percolation = new Percolation(Integer.parseInt(mapSizeString));
        
        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            int row = Integer.parseInt(coord[0]) - 1;
            int col = Integer.parseInt(coord[1]) - 1;

            if (percolation.checkRunThrough(row, col)) {
                System.out.println(coordLine);
                break;
            }
        }
    }

    public Boolean checkRunThrough(int row, int col) {
        // set self root = self
        map[row][col] = row*mapSize + col;

        // connect with 4 direction
        if (row > 0 && map[row-1][col] != -1) { // connect with UP
            map[row][col] = map[row-1][col] = Math.min(findRoot(map[row][col]), findRoot(map[row-1][col]));
        }
        if (row < mapSize-1 && map[row+1][col] != -1) { // connect with DOWN
            map[row][col] = map[row+1][col] = Math.min(findRoot(map[row][col]), findRoot(map[row+1][col]));
        }
        if (col > 0 && map[row][col-1] != -1) { // connect with LEFT
            map[row][col] = map[row][col-1] = Math.min(findRoot(map[row][col]), findRoot(map[row][col-1]));
        }
        if (col < mapSize-1 && map[row][col+1] != -1) { // connect with RIGHT
            map[row][col] = map[row][col+1] = Math.min(findRoot(map[row][col]), findRoot(map[row][col+1]));
        }

// for (int i=0; i<mapSize; ++i) {
//     for (int j=0; j<mapSize; ++j) {
//         System.out.print(map[i][j] + "" "");
//     }
//     System.out.println();
// }

        // check root of tail is first row
        if (row == mapSize-1) {
            tailRoot = Math.min(findRoot(tailRoot), findRoot(map[row][col]));
        }

        int rootOfTail = findRoot(tailRoot);
// System.out.println(""rootOfTail: "" + rootOfTail);
// System.out.println();
        if (rootOfTail < mapSize) {
            return true;
        }
        return false;
    }

    public int findRoot(int index) {
        if (index == mapSize*mapSize) {
            return index;
        }

        ArrayList<Integer> route = new ArrayList<>();
        while (map[index/mapSize][index%mapSize] != index) {
            route.add(index);
            index = map[index/mapSize][index%mapSize];
        }

        // post process
        for (int i=0; i<route.size(); ++i) {
            map[index/mapSize][index%mapSize] = index;
        }

        return index;
    }
}

@74311b8d8ca3645632735bbb959e6704@"
"r04921044","5","1.02","132208","@0327c18076feea8913b41b3d0da8e71f@import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.ArrayList;

public class Percolation {
    int mapSize;
    int tailRoot;
    int[][] map;

    public Percolation(int _mapSize) {
        mapSize = _mapSize;
        tailRoot = mapSize*mapSize;
        map = new int[mapSize][mapSize];
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                map[i][j] = -1;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String mapSizeString = buffer.readLine();

        Percolation percolation = new Percolation(Integer.parseInt(mapSizeString));
        
        Boolean found = false;
        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            int row = Integer.parseInt(coord[0]) - 1;
            int col = Integer.parseInt(coord[1]) - 1;

            if (percolation.checkRunThrough(row, col)) {
                System.out.println(coordLine);
                break;
            }
        }

        if (!found) {
            System.out.println(""-1"");
        }
    }

    public Boolean checkRunThrough(int row, int col) {
        // set self root = self
        map[row][col] = row*mapSize + col;

        // connect with 4 direction
        if (row > 0 && map[row-1][col] != -1) { // connect with UP
            map[row][col] = map[row-1][col] = Math.min(findRoot(map[row][col]), findRoot(map[row-1][col]));
        }
        if (row < mapSize-1 && map[row+1][col] != -1) { // connect with DOWN
            map[row][col] = map[row+1][col] = Math.min(findRoot(map[row][col]), findRoot(map[row+1][col]));
        }
        if (col > 0 && map[row][col-1] != -1) { // connect with LEFT
            map[row][col] = map[row][col-1] = Math.min(findRoot(map[row][col]), findRoot(map[row][col-1]));
        }
        if (col < mapSize-1 && map[row][col+1] != -1) { // connect with RIGHT
            map[row][col] = map[row][col+1] = Math.min(findRoot(map[row][col]), findRoot(map[row][col+1]));
        }

// for (int i=0; i<mapSize; ++i) {
//     for (int j=0; j<mapSize; ++j) {
//         System.out.print(map[i][j] + "" "");
//     }
//     System.out.println();
// }

        // check root of tail if last row
        if (row == mapSize-1) {
            tailRoot = Math.min(findRoot(tailRoot), findRoot(map[row][col]));
        }

        int rootOfTail = findRoot(tailRoot);
// System.out.println(""rootOfTail: "" + rootOfTail);
// System.out.println();
        if (rootOfTail < mapSize) {
            return true;
        }
        return false;
    }

    public int findRoot(int index) {
        if (index == mapSize*mapSize) {
            return index;
        }

        ArrayList<Integer> route = new ArrayList<>();
        while (map[index/mapSize][index%mapSize] != index) {
            route.add(index);
            index = map[index/mapSize][index%mapSize];
        }

        // post process
        for (int i=0; i<route.size(); ++i) {
            map[index/mapSize][index%mapSize] = index;
        }

        return index;
    }
}

@0327c18076feea8913b41b3d0da8e71f@"
"r04921044","9","0.97","138080","@af128a0d9ed0dc15676b70a0bee89350@import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.ArrayList;

public class Percolation {
    int mapSize;
    int tailRoot;
    int[][] map;

    public Percolation(int _mapSize) {
        mapSize = _mapSize;
        tailRoot = mapSize*mapSize;
        map = new int[mapSize][mapSize];
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                map[i][j] = -1;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String mapSizeString = buffer.readLine();

        Percolation percolation = new Percolation(Integer.parseInt(mapSizeString));
        
        Boolean found = false;
        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            int row = Integer.parseInt(coord[0]) - 1;
            int col = Integer.parseInt(coord[1]) - 1;

            if (percolation.checkRunThrough(row, col)) {
                System.out.println(coordLine);
                found = true;
                break;
            }
        }

        if (!found) {
            System.out.println(""-1"");
        }
    }

    public Boolean checkRunThrough(int row, int col) {
        // set self root = self
        map[row][col] = row*mapSize + col;

        // connect with 4 direction
        if (row > 0 && map[row-1][col] != -1) { // connect with UP
            map[row][col] = map[row-1][col] = Math.min(findRoot(map[row][col]), findRoot(map[row-1][col]));
        }
        if (row < mapSize-1 && map[row+1][col] != -1) { // connect with DOWN
            map[row][col] = map[row+1][col] = Math.min(findRoot(map[row][col]), findRoot(map[row+1][col]));
        }
        if (col > 0 && map[row][col-1] != -1) { // connect with LEFT
            map[row][col] = map[row][col-1] = Math.min(findRoot(map[row][col]), findRoot(map[row][col-1]));
        }
        if (col < mapSize-1 && map[row][col+1] != -1) { // connect with RIGHT
            map[row][col] = map[row][col+1] = Math.min(findRoot(map[row][col]), findRoot(map[row][col+1]));
        }

// for (int i=0; i<mapSize; ++i) {
//     for (int j=0; j<mapSize; ++j) {
//         System.out.print(map[i][j] + "" "");
//     }
//     System.out.println();
// }

        // check root of tail if last row
        if (row == mapSize-1) {
            tailRoot = Math.min(findRoot(tailRoot), findRoot(map[row][col]));
        }

        int rootOfTail = findRoot(tailRoot);
// System.out.println(""rootOfTail: "" + rootOfTail);
// System.out.println();
        if (rootOfTail < mapSize) {
            return true;
        }
        return false;
    }

    public int findRoot(int index) {
        if (index == mapSize*mapSize) {
            return index;
        }

        ArrayList<Integer> route = new ArrayList<>();
        while (map[index/mapSize][index%mapSize] != index) {
            route.add(index);
            index = map[index/mapSize][index%mapSize];
        }

        // post process
        for (int i=0; i<route.size(); ++i) {
            map[index/mapSize][index%mapSize] = index;
        }

        return index;
    }
}

@af128a0d9ed0dc15676b70a0bee89350@"
"r04921044","0","0","0","@a84f468d11d73ba9d78f37393db07626@import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.ArrayList;

public class Percolation {
    int mapSize;
    int tailRoot;
    int[][] map;

    public Percolation(int _mapSize) {
        mapSize = _mapSize;
        tailRoot = mapSize*mapSize;
        map = new int[mapSize][mapSize];
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                map[i][j] = -1;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String mapSizeString = buffer.readLine();

        Percolation percolation = new Percolation(Integer.parseInt(mapSizeString));

        Boolean found = false;
        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            int row = Integer.parseInt(coord[0]) - 1;
            int col = Integer.parseInt(coord[1]) - 1;

            if (percolation.checkRunThrough(row, col)) {
                System.out.println(coordLine);
                found = true;
                break;
            }
        }

        if (!found) {
            System.out.println(""-1"");
        }
    }

    public Boolean checkRunThrough(int row, int col) {
        ArrayList<Integer> minCandidate = new ArrayList<>();
        if (row > 0 && map[row-1][col] != -1) { // check UP
            minCandidate.add(findRoot(map[row-1][col]));
        }
        if (row < mapSize-1 && map[row+1][col] != -1) { // check DOWN
            minCandidate.add(findRoot(map[row+1][col]));
        }
        if (col > 0 && map[row][col-1] != -1) { // check LEFT
            minCandidate.add(findRoot(map[row][col-1]));
        }
        if (col < mapSize-1 && map[row][col+1] != -1) { // check RIGHT
            minCandidate.add(findRoot(map[row][col+1]));
        }

        int min = row*mapSize + col;
        for (int i=0; i<minCandidate.size(); ++i) {
            if (minCandidate.get(i) < min) {
                min = minCandidate.get(i);
            }
        }

        for (int i=0; i<minCandidate.size(); ++i) {
            int index = minCandidate.get(i);
            map[index/mapSize][index%mapSize] = min;
        }

        int oldRoot = findRoot(map[row][col]);
        map[row][col] = map[oldRoot/mapSize][oldRoot%mapSize] = min;

        if (row == mapSize-1) { // check root of tail if last row
            tailRoot = Math.min(findRoot(tailRoot), findRoot(map[row][col]));
        }

        int rootOfTail = findRoot(tailRoot);
        if (rootOfTail < mapSize) {
            return true;
        }
        return false;
    }

    public int findRoot(int index) {
        if (index == mapSize*mapSize) {
            return index;
        }

        ArrayList<Integer> route = new ArrayList<>();
        while (map[index/mapSize][index%mapSize] != index) {
            route.add(index);
            index = map[index/mapSize][index%mapSize];
        }

        // post process
        for (int i=0; i<route.size(); ++i) {
            int _index = route.get(i);
            map[_index/mapSize][_index%mapSize] = index;
        }

        return index;
    }
}

@a84f468d11d73ba9d78f37393db07626@"
"r04921044","10","0.098","128976","@ebda73d18186f8ba7a3315c71019192a@import java.io.FileReader;
import java.io.BufferedReader;
import java.lang.Math;
import java.util.ArrayList;

public class Percolation {
    int mapSize;
    int tailRoot;
    int[][] map;

    public Percolation(int _mapSize) {
        mapSize = _mapSize;
        tailRoot = mapSize*mapSize;
        map = new int[mapSize][mapSize];
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                map[i][j] = -1;
            }
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String mapSizeString = buffer.readLine();

        Percolation percolation = new Percolation(Integer.parseInt(mapSizeString));

        Boolean found = false;
        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            int row = Integer.parseInt(coord[0]) - 1;
            int col = Integer.parseInt(coord[1]) - 1;

            if (percolation.checkRunThrough(row, col)) {
                System.out.println(coordLine);
                found = true;
                break;
            }
        }

        if (!found) {
            System.out.println(""-1"");
        }
    }

    public Boolean checkRunThrough(int row, int col) {
        map[row][col] = row*mapSize + col;

        ArrayList<Integer> minCandidate = new ArrayList<>();
        if (row > 0 && map[row-1][col] != -1) { // check UP
            minCandidate.add(findRoot(map[row-1][col]));
        }
        if (row < mapSize-1 && map[row+1][col] != -1) { // check DOWN
            minCandidate.add(findRoot(map[row+1][col]));
        }
        if (col > 0 && map[row][col-1] != -1) { // check LEFT
            minCandidate.add(findRoot(map[row][col-1]));
        }
        if (col < mapSize-1 && map[row][col+1] != -1) { // check RIGHT
            minCandidate.add(findRoot(map[row][col+1]));
        }

        int min = row*mapSize + col;
        for (int i=0; i<minCandidate.size(); ++i) {
            if (minCandidate.get(i) < min) {
                min = minCandidate.get(i);
            }
        }

        for (int i=0; i<minCandidate.size(); ++i) {
            int index = minCandidate.get(i);
            map[index/mapSize][index%mapSize] = min;
        }

        int oldRoot = findRoot(map[row][col]);
        map[row][col] = map[oldRoot/mapSize][oldRoot%mapSize] = min;

        if (row == mapSize-1) { // check root of tail if last row
            tailRoot = Math.min(findRoot(tailRoot), findRoot(map[row][col]));
        }

        int rootOfTail = findRoot(tailRoot);
        if (rootOfTail < mapSize) {
            return true;
        }
        return false;
    }

    public int findRoot(int index) {
        if (index == mapSize*mapSize) {
            return index;
        }

        ArrayList<Integer> route = new ArrayList<>();
        while (map[index/mapSize][index%mapSize] != index) {
            route.add(index);
            index = map[index/mapSize][index%mapSize];
        }

        // post process
        for (int i=0; i<route.size(); ++i) {
            int _index = route.get(i);
            map[_index/mapSize][_index%mapSize] = index;
        }

        return index;
    }
}

@ebda73d18186f8ba7a3315c71019192a@"
"b03611033","4","0.45","105584","@d826d2d0a17d2023b5ddbf1c70a86fb5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Arrays;

public class Percolation {
    
   public UF uf;
   
   public boolean matrix[];
    public Percolation(int n){
        uf = new UF(n*n+2);
        matrix = new boolean[n*n];
        for(int i=0;i<n;i++){
            uf.union(n*n, i);
            uf.union(n*n+1, n*(n-1)+i);
        }
    }
    public void black(int n,int p, int q){
        matrix[p*n+q] = true;
    }
    
    public void line(int n,int p,int q){
        if(p>0){
            if(matrix[p*n+q] & matrix[(p-1)*n+q]){
                uf.union(p*n+q,(p-1)*n+q);    
            }
        }
        if(p<n-1){
            if(matrix[p*n+q] & matrix[(p+1)*n+q]){
                uf.union(p*n+q,(p+1)*n+q);
            }
        }
        if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                uf.union(p*n+q,(p-1)*n+(q-1));
            }
        }
        if(q<n-1){
            if(matrix[p*n+q] & matrix[p*n+(q+1)]){
                uf.union(p*n+q,(p-1)*n+(q+1));
            }
        }
    }
    
    public boolean percolates(int n){
        if(uf.connected(n*n, n*n+1)){
            return true;
        }
        else{
            return false;
        }
        
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String num = br.readLine();
                int N = Integer.parseInt(num);
                //StdOut.println(N); 
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String data ;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    //StdOut.println(row+"",""+column);
                    percolation.black(N,row-1, column-1);
                    percolation.line(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
                
            }
        }
             
    }


@d826d2d0a17d2023b5ddbf1c70a86fb5@"
"r02b48003","0","0","0","@a545ffaf0409b0124946896ea66d52bc@public class Percolation {
    private int[] board;
    private boolean[] openGrid;
    private final int dim; 
    
    public Percolation(int n) {
        dim = n;
        board = new int[n*n];
        openGrid = new boolean[n*n];
        reset();
    } // end constructor
        
    public int[] getBoard() { 
        return board.clone(); 
    } // end func getBoard
        
    public int getDim() { 
        return dim; 
    } // end func getDim
     
    public int getBoardItem(int row, int col) {
        assert row > 0 & row <= dim;
        assert col > 0 & col <= dim;
        return board[(row-1) * dim + (col-1)];
    } // end func getBoardItem
    
    public boolean isOpen(int row, int col){
        return openGrid[(row-1) * dim + (col-1)];
    }
    public Bag getBoardNeighbor(int row, int col) {
        assert row > 0 & row <= dim;
        assert col > 0 & col <= dim;
        
        Bag<Integer> neighbor = new Bag<>();
        
        if (row > 1) {
            //StdOut.println(getBoardItem(row-1, col));
            if (isOpen(row-1, col)) {
                neighbor.add(getBoardItem(row-1, col));
            }
        }
        if (row < dim) {
            //StdOut.println(getBoardItem(row+1, col));
            if (isOpen(row+1, col)) {
                neighbor.add(getBoardItem(row+1, col));
            }
        }
        if (col > 1) {
            //StdOut.println();
            if (isOpen(row, col-1)) {
                neighbor.add(getBoardItem(row, col-1));
            }
        }
        if (col < dim) {
            //StdOut.println(getBoardItem(row, col+1));
            if (isOpen(row, col+1)) {
                neighbor.add(getBoardItem(row, col+1));
            }
        }
        return neighbor;
    } // end func getBoardNeighbor
        
    public void openBoardItem(int row, int col) {
        assert row > 1 & row <= dim;
        assert col > 1 & col <= dim;
        openGrid[(row-1) * dim + (col-1)] = true;
    } // end func setBoardItem
        
    public void reset(){
        for (int idx = 0; idx < dim*dim; idx++) {
            board[idx] = idx;
            openGrid[idx] = false;
        } // end loop
    } // end func reset
        
    public void display() {
        System.out.println(""--------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.printf(""%d "", getBoardItem(row, col));
            } // end inner for
            System.out.println();
        } // end outer for
        System.out.println(""--------------------------"");
    } // end display
    
    public static void main(String[] args) {
        // initialization
        String[] readLines = In.readStrings(""input01.txt"");
        int n = Integer.valueOf(readLines[0]);
        Percolation percolate = new Percolation(n);
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(n*n+2);
        int nodeUP = n*n;
        int nodeDW = n*n+1;               
        
        //
        for (int idx = 0; idx < n; idx++){
            //System.out.println(uf.connected(nodeUP, idx));
            uf.union(nodeUP, idx);
            //System.out.println(uf.connected(nodeUP, idx));
        } 
        for (int idx = n*(n-1); idx < n*n; idx++){
            uf.union(nodeDW, idx);
        }
        
        //
        for (int idx = 1; idx < readLines.length; idx++){
            String[] line = readLines[idx].split("","");
            int row = Integer.valueOf(line[0]);
            int col = Integer.valueOf(line[1]);
            int node = percolate.getBoardItem(row, col);
            
            //
            percolate.openBoardItem(row, col);
            
            //
            Bag<Integer> neighbors = percolate.getBoardNeighbor(row, col);
            //System.out.printf(""%d %d\n"", row, col);
            
            //
            for (Integer t : neighbors) {  
                //StdOut.println(t);
                uf.union(node, t);
            //    StdOut.print("" "");
            }
            if(uf.connected(nodeUP, nodeDW)){
                StdOut.printf(""%d %d\n"", row, col);
                break;
            }
            //StdOut.println(uf.connected(nodeUP, nodeDW));
            //StdOut.println();
                    
        } // end loop for
    } // end main
} // end class Percolation
@a545ffaf0409b0124946896ea66d52bc@"
"r02b48003","0","0","0","@dcbdf78e0d0d56bd783c4348b475e77e@public class Percolation {
    private int[] board;
    private boolean[] openGrid;
    private final int dim; 
    
    public Percolation(int n) {
        dim = n;
        board = new int[n*n];
        openGrid = new boolean[n*n];
        reset();
    } // end constructor
        
    public int[] getBoard() { 
        return board.clone(); 
    } // end func getBoard
        
    public int getDim() { 
        return dim; 
    } // end func getDim
     
    public int getBoardItem(int row, int col) {
        assert row > 0 & row <= dim;
        assert col > 0 & col <= dim;
        return board[(row-1) * dim + (col-1)];
    } // end func getBoardItem
    
    public boolean isOpen(int row, int col){
        return openGrid[(row-1) * dim + (col-1)];
    }
    public Bag getBoardNeighbor(int row, int col) {
        assert row > 0 & row <= dim;
        assert col > 0 & col <= dim;
        
        Bag<Integer> neighbor = new Bag<>();
        
        if (row > 1) {
            //StdOut.println(getBoardItem(row-1, col));
            if (isOpen(row-1, col)) {
                neighbor.add(getBoardItem(row-1, col));
            }
        }
        if (row < dim) {
            //StdOut.println(getBoardItem(row+1, col));
            if (isOpen(row+1, col)) {
                neighbor.add(getBoardItem(row+1, col));
            }
        }
        if (col > 1) {
            //StdOut.println();
            if (isOpen(row, col-1)) {
                neighbor.add(getBoardItem(row, col-1));
            }
        }
        if (col < dim) {
            //StdOut.println(getBoardItem(row, col+1));
            if (isOpen(row, col+1)) {
                neighbor.add(getBoardItem(row, col+1));
            }
        }
        return neighbor;
    } // end func getBoardNeighbor
        
    public void openBoardItem(int row, int col) {
        assert row > 1 & row <= dim;
        assert col > 1 & col <= dim;
        openGrid[(row-1) * dim + (col-1)] = true;
    } // end func setBoardItem
        
    public void reset(){
        for (int idx = 0; idx < dim*dim; idx++) {
            board[idx] = idx;
            openGrid[idx] = false;
        } // end loop
    } // end func reset
        
    public void display() {
        System.out.println(""--------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.printf(""%d "", getBoardItem(row, col));
            } // end inner for
            System.out.println();
        } // end outer for
        System.out.println(""--------------------------"");
    } // end display
    
    public static void main(String[] args) {
        // initialization
        String[] readLines = In.readStrings(""input01.txt"");
        int n = Integer.valueOf(readLines[0]);
        Percolation percolate = new Percolation(n);
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(n*n+2);
        int nodeUP = n*n;
        int nodeDW = n*n+1;               
        
        //
        for (int idx = 0; idx < n; idx++){
            //System.out.println(uf.connected(nodeUP, idx));
            uf.union(nodeUP, idx);
            //System.out.println(uf.connected(nodeUP, idx));
        } 
        for (int idx = n*(n-1); idx < n*n; idx++){
            uf.union(nodeDW, idx);
        }
        
        //
        for (int idx = 1; idx < readLines.length; idx++){
            String[] line = readLines[idx].split("","");
            int row = Integer.valueOf(line[0]);
            int col = Integer.valueOf(line[1]);
            int node = percolate.getBoardItem(row, col);
            
            //
            percolate.openBoardItem(row, col);
            
            //
            Bag<Integer> neighbors = percolate.getBoardNeighbor(row, col);
            //System.out.printf(""%d %d\n"", row, col);
            
            //
            for (Integer t : neighbors) {  
                //StdOut.println(t);
                uf.union(node, t);
            //    StdOut.print("" "");
            }
            if(uf.connected(nodeUP, nodeDW)){
                StdOut.printf(""%d,%d"", row, col);
                break;
            }
            //StdOut.println(uf.connected(nodeUP, nodeDW));
            //StdOut.println();
                    
        } // end loop for
    } // end main
} // end class Percolation

@dcbdf78e0d0d56bd783c4348b475e77e@"
"b03611011","7","1","125760","@12127f6114378b2f7e05b6b29a34fbc2@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = p / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1) {

        }
        //check connective
        for (int i = 0;
                i < num;
                i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@12127f6114378b2f7e05b6b29a34fbc2@"
"r04631004","8","1.02","135728","@55ea8d611556b6a03f891d1f71d30aec@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class Percolation {

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if(temp.readLine()!=null){
              
            data=br.readLine().split("","");
            
            
            
            // store the integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[0]);
            int i,j,k;            
            int[][] connectarray=new int[num][num];
            int connectnum=1;
            for(i=0;i<num;i++)  //將座標與數字相結合
                for(j=0;j<num;j++)
                {
                    connectarray[i][j]=connectnum;
                    connectnum++;
                }

            int[][] checkarray = new int[num][num];
         
            
            WeightedQuickUnionUF ufstruct= new WeightedQuickUnionUF(num*num+2); 
          
            for(i=1;i<num*num+1;i++)
            {
                if(i<=num)
                    ufstruct.union(i,0);
                else if(i>=num*num-2)
                    ufstruct.union(i,num*num+1);
            }
            
//            for(i=1;i<num*num+1;i++)
//            {
//                System.out.print(ufstruct.connected(i,0)+"" "");
//                System.out.println(ufstruct.connected(i,10));
//            }

            int tempcoord[]=new int[2];
            int xa,xd,ya,yd;
            int checkpoint=0;
            while(temp.readLine()!=null) 
            {
                data = br.readLine().split("","");
                tempcoord[0]=Integer.parseInt(data[0]);
                tempcoord[1]=Integer.parseInt(data[1]);
                checkarray[tempcoord[0]-1][tempcoord[1]-1]=1;
                xa=tempcoord[0]-1+1;
                xd=tempcoord[0]-1-1;
                ya=tempcoord[1]-1+1;    
                yd=tempcoord[1]-1-1;
                if(xa>=0 && xa<num)
                    if(checkarray[xa][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xa][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(xd>=0 && xd<num)
                    if(checkarray[xd][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xd][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ya>=0 && ya<num)
                    if(checkarray[tempcoord[0]-1][ya]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][ya], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(yd>=0 && yd<num)
                    if(checkarray[tempcoord[0]-1][yd]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][yd], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ufstruct.connected(0, num*num+1)==true)
                {
                    System.out.println(tempcoord[0]+"",""+tempcoord[1]);
                    checkpoint=1;
                    break;
                }
            }
            if(checkpoint==0)
                System.out.println(-1);
                            
          //  data = br.readLine().split("",""); //read second line{
        // TODO code application logic here
     }
        }
    }
    
}

@55ea8d611556b6a03f891d1f71d30aec@"
"b03611033","4","0.44","105568","@c228b295339daf4b377cf012fd7dc53e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {    
   public WeightedQuickUnionUF uf;
   public boolean matrix[];
    public Percolation(int n){
        uf = new WeightedQuickUnionUF(n*n+2);
        matrix = new boolean[n*n];
        for(int i=0;i<n;i++){
            uf.union(n*n, i);
            uf.union(n*n+1, n*(n-1)+i);
        }
    }
    
    public void line(int n,int p,int q){
         matrix[p*n+q] = true;
        if(p>0){
            if(matrix[p*n+q] & matrix[(p-1)*n+q]){
                uf.union(p*n+q,(p-1)*n+q);    
            }
        }
        if(p<n-1){
            if(matrix[p*n+q] & matrix[(p+1)*n+q]){
                uf.union(p*n+q,(p+1)*n+q);
            }
        }
        if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                uf.union(p*n+q,(p-1)*n+(q-1));
            }
        }
        if(q<n-1){
            if(matrix[p*n+q] & matrix[p*n+(q+1)]){
                uf.union(p*n+q,(p-1)*n+(q+1));
            }
        }
    }
    
    public boolean percolates(int n){
        if(uf.connected(n*n, n*n+1)){
            return true;
        }
        else{
            return false;
        }
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String data = br.readLine();
                int N = Integer.parseInt(data);
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    percolation.line(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
            }
        }        
    }


@c228b295339daf4b377cf012fd7dc53e@"
"b03704074","4","3.71","171088","@8a5b0b29523a0f17b375e1162063666a@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if((!percolation.connected(numstring[i],numstring[j]))&&numstring[i]!=0){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        }
        }
        
        
}}
        
        


@8a5b0b29523a0f17b375e1162063666a@"
"b03704074","4","3.59","169088","@8a5b0b29523a0f17b375e1162063666a@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if((!percolation.connected(numstring[i],numstring[j]))&&numstring[i]!=0){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        }
        }
        
        
}}
        
        


@8a5b0b29523a0f17b375e1162063666a@"
"b03704074","4","3.65","166048","@99ea8816c227b6f0f4f2f593f7e84a23@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if((!percolation.connected(numstring[i],numstring[j]))&&numstring[i]!=0 && numstring[j]!=0){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        }
        }
        
        
}}
        
        


@99ea8816c227b6f0f4f2f593f7e84a23@"
"r04631021","8","1.53","184768","@addda5dcee7535b1c1d0bde233f98101@
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);
    int root3 = root1 ;
    int root4 = root2 ;

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
        for (int k = 0; k <_parent.length ; k++){
           if(_parent[k] ==_parent[root2] ){
               _parent[k] = root1 ;
           }
       }
       _parent[root2] = root1;
       
    } else if (_rank[root2] > _rank[root1]) {
        for(int k=0 ; k < _parent.length ; k++){
            if(_parent[k] == _parent[root1]){
                _parent[k] = root2 ;
            }
        }
      _parent[root1] = root2;
    } else {
         for(int k=0 ; k < _parent.length ; k++){
            if(_parent[k] == _parent[root2]){
                _parent[k] = root1 ;
            }
        }
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData+1 );
                //System.out.println(uf._parent[i]);
            }
            
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            while(true){
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                }
                else if(Drow == 0){
                    if(matrix[Dcol+RankOfData+1]){
                    uf.union(Dcol+RankOfData+1, Dcol+1);
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                else if(Drow == RankOfData -1){
                    if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                /*System.out.println(uf._parent[0]);
                System.out.println(uf._parent[1]);
                System.out.println(uf._parent[2]);
                System.out.println(uf._parent[3]);
                System.out.println(uf._parent[4]);
                System.out.println(uf._parent[5]);
                System.out.println(uf._parent[6]);
                System.out.println(uf._parent[7]);
                System.out.println(uf._parent[8]);
                System.out.println(uf._parent[9]);
                System.out.println(uf._parent[RankOfData*RankOfData+1]);*/
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                }
                
            }
            }
            
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@addda5dcee7535b1c1d0bde233f98101@"
"r04631021","8","1.49","177840","@66e8327def4dc6fde1042d66959e728d@
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);
    int root3 = root1 ;
    int root4 = root2 ;

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
        for (int k = 0; k <_parent.length ; k++){
           if(_parent[k] ==_parent[root2] ){
               _parent[k] = root1 ;
           }
       }
       _parent[root2] = root1;
       
    } else if (_rank[root2] > _rank[root1]) {
        for(int k=0 ; k < _parent.length ; k++){
            if(_parent[k] == _parent[root1]){
                _parent[k] = root2 ;
            }
        }
      _parent[root1] = root2;
    } else {
         for(int k=0 ; k < _parent.length ; k++){
            if(_parent[k] == _parent[root2]){
                _parent[k] = root1 ;
            }
        }
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData+1 );
                //System.out.println(uf._parent[i]);
            }
            
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            while(true){
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[1]==uf._parent[RankOfData*RankOfData-1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                }
                else if(Drow == 0){
                    if(matrix[Dcol+RankOfData+1]){
                    uf.union(Dcol+RankOfData+1, Dcol+1);
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData-1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                else if(Drow == RankOfData -1){
                    if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData-1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                }
                
            }
            }
            
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@66e8327def4dc6fde1042d66959e728d@"
"r04631004","9","0.99","131232","@c2634b16a19431ff494520ccfa735147@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class Percolation {

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if(temp.readLine()!=null){
              
            data=br.readLine().split("","");
            
            
            
            // store the integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[0]);
            int i,j,k;            
            int[][] connectarray=new int[num][num];
            int connectnum=1;
            for(i=0;i<num;i++)  //將座標與數字相結合
                for(j=0;j<num;j++)
                {
                    connectarray[i][j]=connectnum;
                    connectnum++;
                }

            int[][] checkarray = new int[num][num];
         
            
            WeightedQuickUnionUF ufstruct= new WeightedQuickUnionUF(num*num+2); 
          


            int tempcoord[]=new int[2];
            int xa,xd,ya,yd;
            int checkpoint=0;
            while(temp.readLine()!=null) 
            {
                data = br.readLine().split("","");
                tempcoord[0]=Integer.parseInt(data[0]);
                tempcoord[1]=Integer.parseInt(data[1]);
                checkarray[tempcoord[0]-1][tempcoord[1]-1]=1;
                xa=tempcoord[0]-1+1;
                xd=tempcoord[0]-1-1;
                ya=tempcoord[1]-1+1;    
                yd=tempcoord[1]-1-1;
                if(xa>=0 && xa<num)
                    if(checkarray[xa][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xa][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(xd>=0 && xd<num)
                    if(checkarray[xd][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xd][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ya>=0 && ya<num)
                    if(checkarray[tempcoord[0]-1][ya]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][ya], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(yd>=0 && yd<num)
                    if(checkarray[tempcoord[0]-1][yd]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][yd], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(connectarray[tempcoord[0]-1][tempcoord[1]-1]<=num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],0);
                else if(connectarray[tempcoord[0]-1][tempcoord[1]-1]>num*num-num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],num*num+1);
                
                if(ufstruct.connected(0, num*num+1)==true)
                {
                    System.out.println(tempcoord[0]+"",""+tempcoord[1]);
                    checkpoint=1;
                    break;
                }
            }
            if(checkpoint==0)
                System.out.println(-1);
                            
          //  data = br.readLine().split("",""); //read second line{
        // TODO code application logic here
     }
        }
    }
    
}

@c2634b16a19431ff494520ccfa735147@"
"f02631008","6","1.49","201808","@ce5ed3ea8f4ac98a805825e67db421ec@import java.io.*;
import java.io.IOException;
import java.util.Scanner;
import java.util.*;

/**
 *
 * @author philip
 */

public class Percolation {
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }
    }
    public Percolation(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        File file = new File(args[0]);
        try{
            
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_1);
            int[] TrueArr;
            int Flag = 1;
            
            int[][] IndexMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    IndexMat[i][j] = ArrNum*i+j+1;
                    //System.out.println(IndexMat[i][j]);
                }
                
            }
            
            int[][] TrueMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    TrueMat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }
            
            Percolation uf = new Percolation(ArrNum*ArrNum +1);
            //System.out.println(uf);
            
            while (File_in.hasNextLine() && Flag ==1 )
            {
                String line_2 = File_in.nextLine();
                String[] Nums = line_2.split("","");

                int Row = Integer.parseInt(Nums[0]);
                int Col = Integer.parseInt(Nums[1]);
                
                int NumIndex = ArrNum*(Row-1)+Col;
                
                TrueMat[Row-1][Col-1] = 1;
                
                
                if(Row-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-2][Col-1]){
                    uf.union(NumIndex,NumIndex-ArrNum);
                    //System.out.println(uf);
                }
                if(Row+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row][Col-1]){
                    uf.union(NumIndex,NumIndex+ArrNum);
                    //System.out.println(uf);
                }
                if(Col-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col-2]){
                    uf.union(NumIndex,NumIndex-1);
                    //System.out.println(uf);
                }
                if(Col+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col]){
                    uf.union(NumIndex,NumIndex+1);
                    //System.out.println(uf);
                }
                //System.out.println(uf);
                /*if(uf._rank[6] == 2){
                        System.out.println(line_2);
                        break;
                }*/
                for (int i = 0; i < ArrNum*ArrNum+1; i++){
                    if(uf._rank[i] == ArrNum-1){
                        System.out.println(line_2);
                        Flag = 0;
                    }
                }
                if(!File_in.hasNextLine()){
                    System.out.println(-1);
                }
            }
            
            
            /*for (int i = 0; i < ArrNum*ArrNum+1; i++) {
                    //System.out.println(TrueArr[i]);
            }
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    //Mat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }*/
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@ce5ed3ea8f4ac98a805825e67db421ec@"
"r04631004","9","1.01","138192","@fcaa693a6de7cdab312efff633278e35@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class Percolation {

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if(temp.readLine()!=null){
              
            data=br.readLine().split("","");
            
            
            
            // store the integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[0]);
            int i,j,k;            
            int[][] connectarray=new int[num][num];
            int connectnum=1;
            for(i=0;i<num;i++)  //將座標與數字相結合
                for(j=0;j<num;j++)
                {
                    connectarray[i][j]=connectnum;
                    connectnum++;
                }

            int[][] checkarray = new int[num][num];
         
            
            WeightedQuickUnionUF ufstruct= new WeightedQuickUnionUF(num*num+2); 
          
//            for(i=1;i<num*num+1;i++)
//            {
//                if(i<=num)
//                    ufstruct.union(i,0);
//                else if(i>=num*num-2)
//                    ufstruct.union(i,num*num+1);
//            }
            
//            for(i=1;i<num*num+1;i++)
//            {
//                System.out.print(ufstruct.connected(i,0)+"" "");
//                System.out.println(ufstruct.connected(i,10));
//            }

            int tempcoord[]=new int[2];
            int xa=0,xd=0,ya=0,yd=0;
            int checkpoint=0;
            while(temp.readLine()!=null) 
            {
                data = br.readLine().split("","");
                tempcoord[0]=Integer.parseInt(data[0]);
                tempcoord[1]=Integer.parseInt(data[1]);
                checkarray[tempcoord[0]-1][tempcoord[1]-1]=1;
                if(connectarray[tempcoord[0]-1][tempcoord[1]-1]<=num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],0);
                else if(connectarray[tempcoord[0]-1][tempcoord[1]-1]>num*num-num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],num*num+1);
                xa=tempcoord[0]-1+1;
                xd=tempcoord[0]-1-1;
                ya=tempcoord[1]-1+1;    
                yd=tempcoord[1]-1-1;
                if(xa>=0 && xa<num)
                    if(checkarray[xa][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xa][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(xd>=0 && xd<num)
                    if(checkarray[xd][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xd][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ya>=0 && ya<num)
                    if(checkarray[tempcoord[0]-1][ya]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][ya], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(yd>=0 && yd<num)
                    if(checkarray[tempcoord[0]-1][yd]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][yd], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                
                
                if(ufstruct.connected(0, num*num+1)==true)
                {
                    System.out.println(tempcoord[0]+"",""+tempcoord[1]);
                    checkpoint=1;
                    break;
                }
            }
            if(checkpoint==0)
                System.out.println(-1);
                            
          //  data = br.readLine().split("",""); //read second line{
        // TODO code application logic here
     }
        }
    }
    
}
@fcaa693a6de7cdab312efff633278e35@"
"r04631004","9","1.02","134896","@938ecef080e12f4fc3ccd6b4ca26f5ea@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class Percolation {

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if(temp.readLine()!=null){
              
            data=br.readLine().split("","");
            
            
            
            // store the integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[0]);
            int i,j,k;            
            int[][] connectarray=new int[num][num];
            int connectnum=1;
            for(i=0;i<num;i++)  //將座標與數字相結合
                for(j=0;j<num;j++)
                {
                    connectarray[i][j]=connectnum;
                    connectnum++;
                }

            int[][] checkarray = new int[num][num];
         
            
            WeightedQuickUnionUF ufstruct= new WeightedQuickUnionUF(num*num+2); 
          
//            for(i=1;i<num*num+1;i++)
//            {
//                if(i<=num)
//                    ufstruct.union(i,0);
//                else if(i>=num*num-2)
//                    ufstruct.union(i,num*num+1);
//            }
            
//            for(i=1;i<num*num+1;i++)
//            {
//                System.out.print(ufstruct.connected(i,0)+"" "");
//                System.out.println(ufstruct.connected(i,10));
//            }

            int []tempcoord=new int[2];
            int xa=0,xd=0,ya=0,yd=0;
            int checkpoint=0;
            while(temp.readLine()!=null) 
            {
                data = br.readLine().split("","");
                tempcoord[0]=Integer.parseInt(data[0]);
                tempcoord[1]=Integer.parseInt(data[1]);
                checkarray[tempcoord[0]-1][tempcoord[1]-1]=1;
                if(connectarray[tempcoord[0]-1][tempcoord[1]-1]<=num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],0);
                else if(connectarray[tempcoord[0]-1][tempcoord[1]-1]>num*num-num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],num*num+1);
                xa=tempcoord[0]-1+1;
                xd=tempcoord[0]-1-1;
                ya=tempcoord[1]-1+1;    
                yd=tempcoord[1]-1-1;
                if(xa>=0 && xa<num)
                    if(checkarray[xa][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xa][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(xd>=0 && xd<num)
                    if(checkarray[xd][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xd][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ya>=0 && ya<num)
                    if(checkarray[tempcoord[0]-1][ya]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][ya], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(yd>=0 && yd<num)
                    if(checkarray[tempcoord[0]-1][yd]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][yd], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                
                
                if(ufstruct.connected(0, num*num+1)==true)
                {
                    System.out.println(tempcoord[0]+"",""+tempcoord[1]);
                    checkpoint=1;
                    break;
                }
            }
            if(checkpoint==0)
                System.out.println(""-1"");
                            
          //  data = br.readLine().split("",""); //read second line{
        // TODO code application logic here
     }
        }
    }
    
}
@938ecef080e12f4fc3ccd6b4ca26f5ea@"
"r04631004","6","1.49","131312","@b20b3e1c91eb8c4fc1d0c8fc6d502b67@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class Percolation {

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if(temp.readLine()!=null){
              
            data=br.readLine().split("","");
            
            
            
            // store the integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[0]);
            int i,j,k;            
            int[][] connectarray=new int[num][num];
            int connectnum=1;
            for(i=0;i<num;i++)  //將座標與數字相結合
                for(j=0;j<num;j++)
                {
                    connectarray[i][j]=connectnum;
                    connectnum++;
                }

            int[][] checkarray = new int[num][num];
         
            
            WeightedQuickUnionUF ufstruct= new WeightedQuickUnionUF(num*num+2); 
          
//            for(i=1;i<num*num+1;i++)
//            {
//                if(i<=num)
//                    ufstruct.union(i,0);
//                else if(i>=num*num-2)
//                    ufstruct.union(i,num*num+1);
//            }
            
//            for(i=1;i<num*num+1;i++)
//            {
//                System.out.print(ufstruct.connected(i,0)+"" "");
//                System.out.println(ufstruct.connected(i,10));
//            }

            int []tempcoord=new int[2];
            int xa=0,xd=0,ya=0,yd=0;
            int checkpoint=0;
            while(temp.readLine()!=null) 
            {
                data = br.readLine().split("","");
                tempcoord[0]=Integer.parseInt(data[0]);
                tempcoord[1]=Integer.parseInt(data[1]);
                checkarray[tempcoord[0]-1][tempcoord[1]-1]=1;
                if(connectarray[tempcoord[0]-1][tempcoord[1]-1]<=num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],0);
                else if(connectarray[tempcoord[0]-1][tempcoord[1]-1]>num*num-num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],num*num+1);
                xa=tempcoord[0]-1+1;
                xd=tempcoord[0]-1-1;
                ya=tempcoord[1]-1+1;    
                yd=tempcoord[1]-1-1;
                if(xa>=0 && xa<num)
                    if(checkarray[xa][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xa][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(xd>=0 && xd<num)
                    if(checkarray[xd][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xd][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ya>=0 && ya<num)
                    if(checkarray[tempcoord[0]-1][ya]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][ya], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(yd>=0 && yd<num)
                    if(checkarray[tempcoord[0]-1][yd]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][yd], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                
                
                for(i=0;i<num;i++)
                    for(j=0;j<num;j++)
                        if(ufstruct.connected(connectarray[0][i],connectarray[num-1][j])==true)
                    {
                        System.out.println(tempcoord[0]+"",""+tempcoord[1]);
                        checkpoint=1;
                        break;
                    }
                        
//                if(ufstruct.connected(0, num*num+1)==true)
//                {
//                    System.out.println(tempcoord[0]+"",""+tempcoord[1]);
//                    checkpoint=1;
//                    break;
//                }
            }
            if(checkpoint==0)
                System.out.println(""-1"");
                            
          //  data = br.readLine().split("",""); //read second line{
        // TODO code application logic here
     }
        }
    }
    
}
@b20b3e1c91eb8c4fc1d0c8fc6d502b67@"
"r04631004","0","1.49","201808","@24e772065fd937deefebb4870ee14adc@import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class Percolation {

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if(temp.readLine()!=null){
              
            data=br.readLine().split("","");
            
            
            
            // store the integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[0]);
            int i,j,k;            
            int[][] connectarray=new int[num][num];
            int connectnum=1;
            for(i=0;i<num;i++)  //將座標與數字相結合
                for(j=0;j<num;j++)
                {
                    connectarray[i][j]=connectnum;
                    connectnum++;
                }

            int[][] checkarray = new int[num][num];
         
            
            WeightedQuickUnionUF ufstruct= new WeightedQuickUnionUF(num*num+2); 
          
//            for(i=1;i<num*num+1;i++)
//            {
//                if(i<=num)
//                    ufstruct.union(i,0);
//                else if(i>=num*num-2)
//                    ufstruct.union(i,num*num+1);
//            }
            
//            for(i=1;i<num*num+1;i++)
//            {
//                System.out.print(ufstruct.connected(i,0)+"" "");
//                System.out.println(ufstruct.connected(i,10));
//            }

            int []tempcoord=new int[2];
            int xa=0,xd=0,ya=0,yd=0;
            int checkpoint=0;
            while(temp.readLine()!=null) 
            {
                data = br.readLine().split("","");
                tempcoord[0]=Integer.parseInt(data[0]);
                tempcoord[1]=Integer.parseInt(data[1]);
                checkarray[tempcoord[0]-1][tempcoord[1]-1]=1;
                if(connectarray[tempcoord[0]-1][tempcoord[1]-1]<=num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],0);
                else if(connectarray[tempcoord[0]-1][tempcoord[1]-1]>num*num-num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],num*num+1);
                xa=tempcoord[0]-1+1;
                xd=tempcoord[0]-1-1;
                ya=tempcoord[1]-1+1;    
                yd=tempcoord[1]-1-1;
                if(xa>=0 && xa<num)
                    if(checkarray[xa][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xa][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(xd>=0 && xd<num)
                    if(checkarray[xd][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xd][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ya>=0 && ya<num)
                    if(checkarray[tempcoord[0]-1][ya]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][ya], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(yd>=0 && yd<num)
                    if(checkarray[tempcoord[0]-1][yd]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][yd], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                
                
                for(i=0;i<num;i++)
                    for(j=0;j<num;j++)
                        if(ufstruct.connected(connectarray[0][i],connectarray[num-1][j])==true)
                    {
                        System.out.println(tempcoord[0]+"",""+tempcoord[1]);
                        checkpoint=1;
                        break;
                    }
                if(checkpoint==1)
                    break;
                        
//                if(ufstruct.connected(0, num*num+1)==true)
//                {
//                    System.out.println(tempcoord[0]+"",""+tempcoord[1]);
//                    checkpoint=1;
//                    break;
//                }
            }
            if(checkpoint==0)
                System.out.println(""-1"");
                            
          //  data = br.readLine().split("",""); //read second line{
        // TODO code application logic here
     }
        }
    }
    
}
@24e772065fd937deefebb4870ee14adc@"
"r04631004","8","2.16","134000","@edb4e09191f0a833fa35f1e98aeccd53@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class Percolation {

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if(temp.readLine()!=null){
              
            data=br.readLine().split("","");
            
            
            
            // store the integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[0]);
            int i,j,k;            
            int[][] connectarray=new int[num][num];
            int connectnum=1;
            for(i=0;i<num;i++)  //將座標與數字相結合
                for(j=0;j<num;j++)
                {
                    connectarray[i][j]=connectnum;
                    connectnum++;
                }

            int[][] checkarray = new int[num][num];
         
            
            WeightedQuickUnionUF ufstruct= new WeightedQuickUnionUF(num*num+2); 
          
//            for(i=1;i<num*num+1;i++)
//            {
//                if(i<=num)
//                    ufstruct.union(i,0);
//                else if(i>=num*num-2)
//                    ufstruct.union(i,num*num+1);
//            }
            
//            for(i=1;i<num*num+1;i++)
//            {
//                System.out.print(ufstruct.connected(i,0)+"" "");
//                System.out.println(ufstruct.connected(i,10));
//            }

            int []tempcoord=new int[2];
            int xa=0,xd=0,ya=0,yd=0;
            int checkpoint=0;
            while(temp.readLine()!=null) 
            {
                data = br.readLine().split("","");
                tempcoord[0]=Integer.parseInt(data[0]);
                tempcoord[1]=Integer.parseInt(data[1]);
                checkarray[tempcoord[0]-1][tempcoord[1]-1]=1;
                if(connectarray[tempcoord[0]-1][tempcoord[1]-1]<=num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],0);
                else if(connectarray[tempcoord[0]-1][tempcoord[1]-1]>num*num-num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],num*num+1);
                xa=tempcoord[0]-1+1;
                xd=tempcoord[0]-1-1;
                ya=tempcoord[1]-1+1;    
                yd=tempcoord[1]-1-1;
                if(xa>=0 && xa<num)
                    if(checkarray[xa][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xa][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(xd>=0 && xd<num)
                    if(checkarray[xd][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xd][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ya>=0 && ya<num)
                    if(checkarray[tempcoord[0]-1][ya]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][ya], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(yd>=0 && yd<num)
                    if(checkarray[tempcoord[0]-1][yd]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][yd], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                
                
                for(i=0;i<num;i++)
                    for(j=0;j<num;j++)
                        if(ufstruct.connected(connectarray[0][i],connectarray[num-1][j])==true)
                    {
                        System.out.println(tempcoord[0]+"",""+tempcoord[1]);
                        checkpoint=1;
                        break;
                    }
                if(checkpoint==1)
                    break;
                        
//                if(ufstruct.connected(0, num*num+1)==true)
//                {
//                    System.out.println(tempcoord[0]+"",""+tempcoord[1]);
//                    checkpoint=1;
//                    break;
//                }
            }
            if(checkpoint==0)
                System.out.println(""-1"");
                            
          //  data = br.readLine().split("",""); //read second line{
        // TODO code application logic here
     }
        }
    }
    
}
@edb4e09191f0a833fa35f1e98aeccd53@"
"r04631004","8","2.18","133392","@9780bdcab3714195d9549b5c9f6b45e6@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class Percolation {

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if(temp.readLine()!=null){
              
            data=br.readLine().split("","");
            
            
            
            // store the integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[0]);
            int i,j,k;            
            int[][] connectarray=new int[num][num];
            int connectnum=1;
            for(i=0;i<num;i++)  //將座標與數字相結合
                for(j=0;j<num;j++)
                {
                    connectarray[i][j]=connectnum;
                    connectnum++;
                }

            int[][] checkarray = new int[num][num];
         
            
            WeightedQuickUnionUF ufstruct= new WeightedQuickUnionUF(num*num+2); 
          
//            for(i=1;i<num*num+1;i++)
//            {
//                if(i<=num)
//                    ufstruct.union(i,0);
//                else if(i>=num*num-2)
//                    ufstruct.union(i,num*num+1);
//            }
            
//            for(i=1;i<num*num+1;i++)
//            {
//                System.out.print(ufstruct.connected(i,0)+"" "");
//                System.out.println(ufstruct.connected(i,10));
//            }

            int []tempcoord=new int[2];
            int xa=0,xd=0,ya=0,yd=0;
            int checkpoint=0;
            while(temp.readLine()!=null) 
            {
                data = br.readLine().split("","");
                tempcoord[0]=Integer.parseInt(data[0]);
                tempcoord[1]=Integer.parseInt(data[1]);
                checkarray[tempcoord[0]-1][tempcoord[1]-1]=1;
                if(connectarray[tempcoord[0]-1][tempcoord[1]-1]<=num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],0);
                else if(connectarray[tempcoord[0]-1][tempcoord[1]-1]>num*num-num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],num*num+1);
                xa=tempcoord[0]-1+1;
                xd=tempcoord[0]-1-1;
                ya=tempcoord[1]-1+1;    
                yd=tempcoord[1]-1-1;
                if(xa>=0 && xa<num)
                    if(checkarray[xa][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xa][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(xd>=0 && xd<num)
                    if(checkarray[xd][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xd][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ya>=0 && ya<num)
                    if(checkarray[tempcoord[0]-1][ya]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][ya], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(yd>=0 && yd<num)
                    if(checkarray[tempcoord[0]-1][yd]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][yd], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                
                
                for(i=0;i<num;i++)
                    for(j=0;j<num;j++)
                        if(ufstruct.connected(connectarray[0][i],connectarray[num-1][j])==true)
                    {
                        System.out.println(tempcoord[0]+"",""+tempcoord[1]);
                        checkpoint=1;
                        break;
                    }
                if(checkpoint==1)
                    break;
                        
//                if(ufstruct.connected(0, num*num+1)==true)
//                {
//                    System.out.println(tempcoord[0]+"",""+tempcoord[1]);
//                    checkpoint=1;
//                    break;
//                }
            }
            if(checkpoint==0)
                System.out.println(-1);
                            
          //  data = br.readLine().split("",""); //read second line{
        // TODO code application logic here
     }
        }
    }
    
}
@9780bdcab3714195d9549b5c9f6b45e6@"
"r04945022","0","1.02","134896","@7ed9b2a194e556665620f07e77b84dd6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String data = """";
        String[] inputarray;
        int[] inputnumber = null;
        do{
            data = br.readLine();
            inputarray = data.split("","");
            if(data.length()==1){
                int N = Integer.parseInt(data);
                Perco1.Percolate(N);
            }
            for(int i=0;i<inputarray.length;i++){
                inputnumber[i] = Integer.parseInt(inputarray[i]);
                Perco1.open(inputnumber[i], inputnumber[i+1]);
            }
            
            
        }while(!Perco1.percolates());
           if(Perco1.percolates()){
               System.out.println(inputnumber[0]+"",""+inputnumber[1]);
           }else{
               System.out.println(""-1"");
           }
         
     
    }
    
}

@7ed9b2a194e556665620f07e77b84dd6@"
"r04945022","0","0","0","@68ba36ba2ebf2beabf8093b6f223a660@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String data = """";
        String[] inputarray;
        int[] inputnumber = null;
        do{
            data = br.readLine();
            inputarray = data.split("","");
            if(data.length()==1){
                int N = Integer.parseInt(data);
                Perco1.Percolate(N);
            }
            for(int i=0;i<inputarray.length;i++){
                inputnumber[i] = Integer.parseInt(inputarray[i]);
                Perco1.open(inputnumber[i], inputnumber[i+1]);
            }
            
            
        }while(!Perco1.percolates());
           if(Perco1.percolates()){
               System.out.println(inputnumber[0]+"",""+inputnumber[1]);
           }else{
               System.out.println(""-1"");
           }
         
     
    }
    
}

@68ba36ba2ebf2beabf8093b6f223a660@"
"r04631004","10","0.099","132304","@770d6003e9bb25264b40d223269ea5ec@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class Percolation {

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if(temp.readLine()!=null){
              
            data=br.readLine().split("","");
            
            
            
            // store the integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[0]);
            int i,j,k;            
            int[][] connectarray=new int[num][num];
            int connectnum=1;
            for(i=0;i<num;i++)  //將座標與數字相結合
                for(j=0;j<num;j++)
                {
                    connectarray[i][j]=connectnum;
                    connectnum++;
                }

            int[][] checkarray = new int[num][num];
         
            
            WeightedQuickUnionUF ufstruct= new WeightedQuickUnionUF(num*num+2); 
          
//            for(i=1;i<num*num+1;i++)
//            {
//                if(i<=num)
//                    ufstruct.union(i,0);
//                else if(i>=num*num-2)
//                    ufstruct.union(i,num*num+1);
//            }
            
//            for(i=1;i<num*num+1;i++)
//            {
//                System.out.print(ufstruct.connected(i,0)+"" "");
//                System.out.println(ufstruct.connected(i,10));
//            }

            int []tempcoord=new int[2];
            int xa=0,xd=0,ya=0,yd=0;
            int checkpoint=0;
            while(temp.readLine()!=null) 
            {
                data = br.readLine().split("","");
                tempcoord[0]=Integer.parseInt(data[0]);
                tempcoord[1]=Integer.parseInt(data[1]);
                checkarray[tempcoord[0]-1][tempcoord[1]-1]=1;
                if(connectarray[tempcoord[0]-1][tempcoord[1]-1]<=num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],0);
                if(connectarray[tempcoord[0]-1][tempcoord[1]-1]>num*num-num)
                    ufstruct.union(connectarray[tempcoord[0]-1][tempcoord[1]-1],num*num+1);
                xa=tempcoord[0]-1+1;
                xd=tempcoord[0]-1-1;
                ya=tempcoord[1]-1+1;    
                yd=tempcoord[1]-1-1;
                if(xa>=0 && xa<num)
                    if(checkarray[xa][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xa][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(xd>=0 && xd<num)
                    if(checkarray[xd][tempcoord[1]-1]==1)
                        ufstruct.union(connectarray[xd][tempcoord[1]-1], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(ya>=0 && ya<num)
                    if(checkarray[tempcoord[0]-1][ya]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][ya], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                if(yd>=0 && yd<num)
                    if(checkarray[tempcoord[0]-1][yd]==1)
                        ufstruct.union(connectarray[tempcoord[0]-1][yd], connectarray[tempcoord[0]-1][tempcoord[1]-1]);
                
                
//                for(i=0;i<num;i++)
//                    for(j=0;j<num;j++)
//                        if(ufstruct.connected(connectarray[0][i],connectarray[num-1][j])==true)
//                    {
//                        System.out.println(tempcoord[0]+"",""+tempcoord[1]);
//                        checkpoint=1;
//                        break;
//                    }
//                if(checkpoint==1)
//                    break;
                   
                if(ufstruct.connected(0, num*num+1)==true)
                {
                    System.out.println(tempcoord[0]+"",""+tempcoord[1]);
                    checkpoint=1;
                    break;
                }
            }
            if(checkpoint==0)
                System.out.println(-1);
                            
          //  data = br.readLine().split("",""); //read second line{
        // TODO code application logic here
     }
        }
    }
    
}
@770d6003e9bb25264b40d223269ea5ec@"
"b03704074","4","3.66","166864","@99ea8816c227b6f0f4f2f593f7e84a23@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if((!percolation.connected(numstring[i],numstring[j]))&&numstring[i]!=0 && numstring[j]!=0){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        }
        }
        
        
}}
        
        


@99ea8816c227b6f0f4f2f593f7e84a23@"
"b01703032","6","1.01","127024","@441a5fafd0f75ec102e03394eb656993@
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {               // create N-by-N grid, with all sites blocked
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }

    public void open(int i, int j) {         // open site (row i, column j) if it is not open already
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }

    }
    
    
    public boolean isOpen(int i, int j) {    // is site (row i, column j) open?
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
   
 
    public boolean percolates() {            // does the system percolate?
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
 
    public static void main(String[] args) throws Exception {  // test client (optional)
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        String[] data = br.readLine().split("","");
        int stringCount = Integer.parseInt(data[0]);
        Percolation percolation = new Percolation(stringCount);
        String temp=null;
        boolean check = true;
        while((temp=br.readLine())!=null)
           {
            String[] array;
                array = temp.split("","");
                int i = Integer.parseInt(array[0]);
                int j = Integer.parseInt(array[1]);
               percolation.open(i,j);
               if(percolation.percolates()==true)
               {
                   System.out.println(i + "","" +j);
                   break;
               }
               else
               {
                   check = false;
               }
            }
          if(check==false)
          {
              System.out.printf(""-1"");
          }
        }
    }

}

@441a5fafd0f75ec102e03394eb656993@"
"b01703032","6","0.99","125648","@a696d4352056d34c7d6aac680cce72ec@
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {               // create N-by-N grid, with all sites blocked
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }

    public void open(int i, int j) {         // open site (row i, column j) if it is not open already
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }

    }
    
    
    public boolean isOpen(int i, int j) {    // is site (row i, column j) open?
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
   
 
    public boolean percolates() {            // does the system percolate?
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
 
    public static void main(String[] args) throws Exception {  // test client (optional)
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        String[] data = br.readLine().split("","");
        int stringCount = Integer.parseInt(data[0]);
        Percolation percolation = new Percolation(stringCount);
        String temp=null;
        boolean check = true;
        while((temp=br.readLine())!=null)
           {
            String[] array;
                array = temp.split("","");
                int i = Integer.parseInt(array[0]);
                int j = Integer.parseInt(array[1]);
               percolation.open(i,j);
               if(percolation.percolates()==true)
               {
                   System.out.println(i + "","" +j);
                   break;
               }
               else
               {
                   check = false;
               }
            }
          if(check==false)
          {
              System.out.println(""-1"");
          }
        }
    }
}

@a696d4352056d34c7d6aac680cce72ec@"
"b01703032","10","0.1","123184","@9aa405226d8d4710885adc25dd2f94bd@
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {
 
    private boolean[][] grid;
    private int gridSize;
    private WeightedQuickUnionUF unionUF;
    private WeightedQuickUnionUF backWash;
    private final int top;
    private final int bottom;
 

    public Percolation(int N) {               // create N-by-N grid, with all sites blocked
        if (N <= 0) {
            throw new IllegalArgumentException(""The input N is illegal!"");
        }
        grid = new boolean[N][N];
        gridSize = N;
        top = 0;
        bottom = N * N + 1;
        unionUF = new WeightedQuickUnionUF(N * N + 1);
        backWash = new WeightedQuickUnionUF(N * N + 2);
    }

    public void open(int i, int j) {         // open site (row i, column j) if it is not open already
        validateArray(i, j);
        grid[i - 1][j - 1] = true;
        if (i == 1) {
            unionUF.union(top, xyTo1D(i, j));
            backWash.union(top, xyTo1D(i, j));
        }
 
        if (i == gridSize) {
            backWash.union(xyTo1D(i, j), bottom);
        }
 
        if (i > 1 && isOpen(i - 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i - 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i - 1, j));
        }
 
        if (i < gridSize && isOpen(i + 1, j)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i + 1, j));
            backWash.union(xyTo1D(i, j), xyTo1D(i + 1, j));
        }
 
        if (j > 1 && isOpen(i, j - 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j - 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j - 1));
        }
 
        if (j < gridSize && isOpen(i, j + 1)) {
            unionUF.union(xyTo1D(i, j), xyTo1D(i, j + 1));
            backWash.union(xyTo1D(i, j), xyTo1D(i, j + 1));
        }

    }
    
    
    public boolean isOpen(int i, int j) {    // is site (row i, column j) open?
        validateArray(i, j);
        return grid[i - 1][j - 1];
    }
 
  
    public boolean percolates() {            // does the system percolate?
        return backWash.connected(top, bottom);
    }
 
    private int xyTo1D(int i, int j) {
        return (i - 1) * gridSize + j;
    }
 
    private void validateArray(int i, int j) {
        if (i <= 0 || j <= 0 || i > gridSize || j > gridSize) {
            throw new IndexOutOfBoundsException(""index: ("" + i + "", "" + j + "") are out of bound!"");
        }
    }
 
    public static void main(String[] args) throws Exception {  // test client (optional)
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        String[] data = br.readLine().split("","");
        int stringCount = Integer.parseInt(data[0]);
        Percolation percolation = new Percolation(stringCount);
        String temp=null;
        boolean check = true;
        while((temp=br.readLine())!=null)
           {
            String[] array;
                array = temp.split("","");
                int i = Integer.parseInt(array[0]);
                int j = Integer.parseInt(array[1]);
               percolation.open(i,j);
               if(percolation.percolates()==true)
               {
                   System.out.println(i + "","" +j);
                   check =true; 
                   break;
               }
               else
               {
                   check = false;
               }
            }
          if(check==false)
          {
              System.out.println(""-1"");
          }
        }
    }
}

@9aa405226d8d4710885adc25dd2f94bd@"
"b03704074","9","3.87","165888","@cdfc4d14411c7efa9f6566c10a1adc45@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+2];
        for(int i=1;i<N*N+2;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+2;i++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if((!percolation.connected(numstring[i],numstring[j]))&&numstring[i]!=0 && numstring[j]!=0){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        if (i==N*N-1) System.out.println(""-1"");
        }
        }
        
        
}}
        
        


@cdfc4d14411c7efa9f6566c10a1adc45@"
"b03704074","9","3.62","168736","@89ce46018ab8d1fba9ca3b9a72fe9304@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+2;i++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if((!percolation.connected(numstring[i],numstring[j]))&&numstring[i]!=0 && numstring[j]!=0){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        if (i==N*N-1) System.out.println(""-1"");
        }
        }
        
        
}}
        
        


@89ce46018ab8d1fba9ca3b9a72fe9304@"
"b02611016","6","0.76","113952","@27d46107063c28bb2baeab5aef904ac4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row-1)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1)
                   {for(int j=0;j<num*num;j++)
                      {if(id[j]==id[(row-1)*num+cloumn-2])
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                    if(matrix[row-1][cloumn+1]==1)
                   {for(int j=0;j<num*num;j++)
                      {if(id[j]==id[(row-1)*num+cloumn])
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                     if(matrix[row][cloumn]==1)
                   {for(int j=0;j<num*num;j++)
                      {if(id[j]==id[(row)*num+cloumn])
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1)
                   {for(int k=0;k<num*num;k++)
                     {if(id[k]==id[(row-1)*num+cloumn])
                        {id[k]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row][cloumn]==1)
                   {for(int k=0;k<num*num;k++)
                     {if(id[k]==id[(row)*num+cloumn-1])
                        {id[k]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 {for(int m=0;m<num*num;m++)
                   {if(id[m]==id[row*num+cloumn-1])
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
           //System.out.printf(""data %d %d %d %d %d %d %d %d %d \n"", id[0],id[1],id[2],id[3],id[4],id[5],id[6],id[7],id[8] );
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@27d46107063c28bb2baeab5aef904ac4@"
"r04945022","0","0","0","@dbda1f6ce6761ffac15c9011ca0b6def@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        
        do{
            String[] inputarray = br.readLine().split("","");


             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             System.out.println(inputnumber1+"",""+inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
 
        }while(br.readLine()!=null);
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
         
     
    }
    
}

@dbda1f6ce6761ffac15c9011ca0b6def@"
"b03704074","9","4.29","167168","@c6fc75cab75e05634169c13db6bc5026@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          if (numstring[i]<=N &&numstring[i]!=0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N&&numstring[i]!=0) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if((!percolation.connected(numstring[i],numstring[j]))&&(numstring[i]!=0 || numstring[j]!=0)){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        if (i==N*N-1) System.out.println(""-1"");
        }
        }
        
        
}}
        
        


@c6fc75cab75e05634169c13db6bc5026@"
"r04945022","0","0","0","@f42593388b1c502cc0a446b75d8fe579@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int inputnumber1 = 0 , inputnumber2 = 0;

        do{
            if(br.readLine().length()==1){
            int newside = Integer.parseInt(br.readLine());
            Perco1.Percolate(newside);
            }else{
            String[] inputarray = br.readLine().split("","");

             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             System.out.println(inputnumber1+"",""+inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
          }
 
        }while(br.readLine()!=null);
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
         
     
    }
    
}

@f42593388b1c502cc0a446b75d8fe579@"
"b03704074","9","4.3","172416","@497816265ae7aaf02a8bb3d16db78f12@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          if (numstring[i]<=N &&numstring[i]>0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if((!percolation.connected(numstring[i],numstring[j]))||numstring[i]!=0 || numstring[j]!=0){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        if (i==N*N-1) System.out.println(""-1"");
        }
        }
        
        
}}
        
        


@497816265ae7aaf02a8bb3d16db78f12@"
"b03704074","9","4.24","169104","@093cd389e0dfef160c167201d5fc593a@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          if (numstring[i]<=N &&numstring[i]>0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        if (i==N*N-1) System.out.println(""-1"");
        }
        }
        
        
}}
        
        


@093cd389e0dfef160c167201d5fc593a@"
"b03704074","4","2.93","169232","@b08f06a64e2537c350c42ff6fd27133d@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          if(numstring[i]==0)System.out.println(""-1"");
          if (numstring[i]<=N &&numstring[i]>0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        //if (i==N*N-1) System.out.println(""-1"");
        }
        }
        
        
}}
        
        


@b08f06a64e2537c350c42ff6fd27133d@"
"b03704074","5","3.52","168096","@4a8ea8300a6cd7a3f175187e4eb7627e@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          
          if (numstring[i]<=N &&numstring[i]>0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          /*if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}*/
        }
        //if (i==N*N-1) System.out.println(""-1"");
        }
        }
        System.out.println(""-1"");
        
}}
        
        


@4a8ea8300a6cd7a3f175187e4eb7627e@"
"b03704074","4","4.09","168240","@61ff763e0f3abdac283d3c8fa1b3ed61@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          
          if (numstring[i]<=N &&numstring[i]>0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
            if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        
        }
        }
        
        
}}
        
        


@61ff763e0f3abdac283d3c8fa1b3ed61@"
"b03704074","9","4.27","183168","@dcd3d58d49302625674c290f3b907bec@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<N*N+3;i++){
          if (numstring[i]<=N &&numstring[i]>0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        if (i==N*N-1) System.out.println(""-1"");
        }
        }
        
        
}}
        


@dcd3d58d49302625674c290f3b907bec@"
"b03704074","9","4.01","184784","@2a734eca233a5fee66a71c8f1bdee88e@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<numstring.length;i++){
          if (numstring[i]<=N &&numstring[i]>0) percolation.union(N*N+1, numstring[i]);//第一排
          else if(numstring[i]>N*(N-1) && numstring[i]<=N*N) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        if (i==N*N-1) System.out.println(""-1"");
        }
        }
        
        
}}
        


@2a734eca233a5fee66a71c8f1bdee88e@"
"r04945022","0","0","0","@90881920be7b9d844723856b6c5c03c0@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String[] inputarray;
        while((inputarray = br.readLine().split("",""))!=null){
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             System.out.println(inputnumber1+"",""+inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
        }
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
         
     
    }
    
}

@90881920be7b9d844723856b6c5c03c0@"
"r04945022","0","4.09","168240","@cbcb73a506588d8eee31b020663c79da@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String[] inputarray;
        while((inputarray = br.readLine().split("",""))!=null){
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
        }
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
         
     
    }
    
}

@cbcb73a506588d8eee31b020663c79da@"
"r04945022","0","0","0","@6b69f8c9d91555a1de9e847f0b198f67@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String[] inputarray;
        while((inputarray = br.readLine().split("",""))!=null){
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
        }
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
         
     
    }
    
}

@6b69f8c9d91555a1de9e847f0b198f67@"
"b03704074","10","0.407","166736","@1c95a91711d72058afd4f837826b7e06@import java.util.*; 
import java.io.FileReader;
import java.io.BufferedReader;
public class Percolation {
    private int[]parent;
    private byte[]rank;
    public Percolation(int N){              //初始化
        if(N<0) throw new IllegalArgumentException();
        parent = new int[N*N+3];
        rank = new byte[N*N+3];
        for(int i=1;i<N*N+3;i++)
        {parent[i]=i;
         rank[i]=0;
        }
    }
    public int find(int p){                 //找根
        while(p!=parent[p]){
                parent[p]=parent[parent[p]];//壓縮
        p=parent[p];
        }
    return p;
    }
    public boolean connected (int p,int q){
        return find(p)==find(q);//看兩個的根有沒有相等
    }
    public void union(int p,int q){        //連接
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        if(rank[rootP]<rank[rootQ])
            parent[rootP] = rootQ ; //若p的樹比較矮，則p接到q上
        else if (rank[rootP]>rank[rootQ])
            parent[rootQ] = rootP;  //若Q的樹比較矮，則Q接到P上
        else {parent[rootQ] = rootP;//若一樣的高度，則q接到p然後p的高度加一
            rank[rootP]++;
        }
    }
    public static void main(String[] args){
        In in = new In(args[0]);
        int N = in.readInt();
        Percolation percolation= new Percolation(N); 
        //System.out.println(N);
        String[] data = new String[2];
        int[] numstring = new int[N*N+3];
        int i = 0;
        while(!in.isEmpty()){
            data=in.readString().split("","");
            //System.out.println(""座標""+data[0]+"",""+data[1]);
            int a = Integer.parseInt(data[0]); 
            int b = Integer.parseInt(data[1]);
            numstring[i] = (a-1)*N+b;
            //System.out.println(""換算值為""+numstring[i]);
            i++;
        }
        back:{
        for(i =0;i<numstring.length;i++){
          if (N==1&&numstring[i]==1){System.out.println(""1,1""); break;}
          
          if (numstring[i]<=N &&numstring[i]>0) percolation.union(N*N+1, numstring[i]);//第一排
          if(numstring[i]>N*(N-1) && numstring[i]<=N*N) percolation.union(N*N+2,numstring[i]);//最後一排
          
          for(int j=0;j<i;j++){
          if(!percolation.connected(numstring[i],numstring[j])){
          if(numstring[i]%N==0)  //最右邊
          {if(numstring[j]==numstring[i]-1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[i]%N==1)//最左邊
          {if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)
                percolation.union(numstring[i], numstring[j]);}
          else if(numstring[j]==numstring[i]+1 ||numstring[j]==numstring[i]-1 || numstring[j]==numstring[i]+N ||numstring[j]==numstring[i]-N)//其他的
              percolation.union(numstring[i], numstring[j]);}
          if(percolation.connected(N*N+1,N*N+2)) 
            {//System.out.println(""找到""+numstring[i]); 
            if(numstring[i]%N==0)System.out.println((numstring[i]/N)+"",""+N);
            else System.out.println((numstring[i]/N+1)+"",""+numstring[i]%N);
            break back ;}
        }
        if (i==N*N-1) System.out.println(""-1"");
        }
        }
        
        
}}
        


@1c95a91711d72058afd4f837826b7e06@"
"b02611016","6","0.91","120816","@9618d699f64161f4250759fa55ae37d8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row-1)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1)
                   {int k=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                    if(matrix[row-1][cloumn+1]==1)
                   {int k=id[(row-1)*num+cloumn];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                     if(matrix[row][cloumn]==1)
                   {int k=id[(row)*num+cloumn];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1)
                   {int k=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row][cloumn]==1)
                   {int k=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 {int k=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.println("""");*/
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}



@9618d699f64161f4250759fa55ae37d8@"
"b02611016","7","0.91","129920","@5c53096422b1ec1dd80711267b7516e3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1)
                   {int k=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                    if(matrix[row-1][cloumn+1]==1)
                   {int k=id[(row-1)*num+cloumn];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                     if(matrix[row][cloumn]==1)
                   {int k=id[(row)*num+cloumn];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1)
                   {int k=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row][cloumn]==1)
                   {int k=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 {int k=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
         /*  for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}



@5c53096422b1ec1dd80711267b7516e3@"
"b02611016","8","0.78","127760","@4e59aa3cfbb9723e86e89c8bfdcef2d2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                    if(matrix[row-1][cloumn+1]==1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                     if(matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}



@4e59aa3cfbb9723e86e89c8bfdcef2d2@"
"r04945009","0","0.91","120816","@4b52ba6f8e39a97a0d5eabed7f88f0e5@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class percolation {
    private static int [] states;
    private static int side;
    private static UF cellStorage;
// create N-by-N grid, with all sites blocked
    public static void Percolation(int N){
        side=N;
        //+2 are for additional top and bottom cells
        cellStorage=new UF(N*N+2);      
        states=new int[N*N+2];
        for(int index=0;index<N*N;index++){
            states[index]=0;
        }
        states[N*N]=1;
        states[N*N+1]=1;            
    }
   // open site (row i, column j) if it is not already  
    public static void open(int i, int j){ 
        checkRange(i,j);
        if(isOpen(i,j))return;       
        int cell=getCellIndex(i,j);
        states[cell]=1;
        //if not top row
        if(i!=1 && isOpen(i-1,j)){
            cellStorage.union(getCellIndex(i-1,j),cell);
        }else if(i==1){
            //connect to virtual top cell
            cellStorage.union(cell,side*side);
        }
        //if not bottom row
        if(i!=side && isOpen(i+1,j)){       
            cellStorage.union(getCellIndex(i+1,j),cell);
        }else if (i==side){
            //connect to virtual bottom cell
            cellStorage.union(cell,side*side+1);
        }
        //if not left border
        if(j!=1 && isOpen(i,j-1)){
            cellStorage.union(getCellIndex(i,j-1),cell);
        }
        //if not right border
        if(j!=side && isOpen(i,j+1)){
            cellStorage.union(getCellIndex(i,j+1),cell);
        }
    }
     
    private static void checkRange(int i, int j){
        if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
    }
    
    // is site (row i, column j) open?
    public static boolean isOpen(int i, int j){
        checkRange(i,j);
        return states[getCellIndex(i,j)]==1;
    }   
  
    // does the system percolate?
    public static boolean percolates(){
        return cellStorage.connected(side*side,side*side+1);
    }           
     
    private static int getCellIndex(int row, int column){
        return (side*(row-1))+column-1;
    }
     
     
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            //initialization
            Percolation(N);
            String[] datatemp = new String[2];
            while ((datatemp = br.readLine().split("","")) != null){
                int i = Integer.parseInt(datatemp[0]);
                int j = Integer.parseInt(datatemp[1]);
                open(i,j);
                if (percolates()){
                    System.out.println(i + "","" + j);
                    break;
                }
            }
            if (!percolates())
                System.out.println(-1);
            

        }
            
    }
}

@4b52ba6f8e39a97a0d5eabed7f88f0e5@"
"r04945009","5","0.48","119408","@a0815b28517e4075e9b03f5058309bd0@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Percolation {
    private static int [] states;
    private static int side;
    private static UF cellStorage;
// create N-by-N grid, with all sites blocked
    public static void percolation(int N){
        side=N;
        //+2 are for additional top and bottom cells
        cellStorage=new UF(N*N+2);      
        states=new int[N*N+2];
        for(int index=0;index<N*N;index++){
            states[index]=0;
        }
        states[N*N]=1;
        states[N*N+1]=1;            
    }
   // open site (row i, column j) if it is not already  
    public static void open(int i, int j){ 
        checkRange(i,j);
        if(isOpen(i,j))return;       
        int cell=getCellIndex(i,j);
        states[cell]=1;
        //if not top row
        if(i!=1 && isOpen(i-1,j)){
            cellStorage.union(getCellIndex(i-1,j),cell);
        }else if(i==1){
            //connect to virtual top cell
            cellStorage.union(cell,side*side);
        }
        //if not bottom row
        if(i!=side && isOpen(i+1,j)){       
            cellStorage.union(getCellIndex(i+1,j),cell);
        }else if (i==side){
            //connect to virtual bottom cell
            cellStorage.union(cell,side*side+1);
        }
        //if not left border
        if(j!=1 && isOpen(i,j-1)){
            cellStorage.union(getCellIndex(i,j-1),cell);
        }
        //if not right border
        if(j!=side && isOpen(i,j+1)){
            cellStorage.union(getCellIndex(i,j+1),cell);
        }
    }
     
    private static void checkRange(int i, int j){
        if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
    }
    
    // is site (row i, column j) open?
    public static boolean isOpen(int i, int j){
        checkRange(i,j);
        return states[getCellIndex(i,j)]==1;
    }   
  
    // does the system percolate?
    public static boolean percolates(){
        return cellStorage.connected(side*side,side*side+1);
    }           
     
    private static int getCellIndex(int row, int column){
        return (side*(row-1))+column-1;
    }
     
     
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            //initialization
            percolation(N);
            String[] datatemp = new String[2];
            while ((datatemp = br.readLine().split("","")) != null){
                int i = Integer.parseInt(datatemp[0]);
                int j = Integer.parseInt(datatemp[1]);
                open(i,j);
                if (percolates()){
                    System.out.println(i + "","" + j);
                    break;
                }
            }
            if (!percolates())
                System.out.println(-1);
            

        }
            
    }
}

@a0815b28517e4075e9b03f5058309bd0@"
"r04945009","5","0.47","120048","@51933816678231fe77724ad66359e976@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Percolation {
    private static int [] states;
    private static int side;
    private static UF cellStorage;
// create N-by-N grid, with all sites blocked
    public static void percolation(int N){
        side=N;
        //+2 are for additional top and bottom cells
        cellStorage=new UF(N*N+2);      
        states=new int[N*N+2];
        for(int index=0;index<N*N;index++){
            states[index]=0;
        }
        states[N*N]=1;
        states[N*N+1]=1;            
    }
   // open site (row i, column j) if it is not already  
    public static void open(int i, int j){ 
        checkRange(i,j);
        if(isOpen(i,j))return;       
        int cell=getCellIndex(i,j);
        states[cell]=1;
        //if not top row
        if(i!=1 && isOpen(i-1,j)){
            cellStorage.union(getCellIndex(i-1,j),cell);
        }else if(i==1){
            //connect to virtual top cell
            cellStorage.union(cell,side*side);
        }
        //if not bottom row
        if(i!=side && isOpen(i+1,j)){       
            cellStorage.union(getCellIndex(i+1,j),cell);
        }else if (i==side){
            //connect to virtual bottom cell
            cellStorage.union(cell,side*side+1);
        }
        //if not left border
        if(j!=1 && isOpen(i,j-1)){
            cellStorage.union(getCellIndex(i,j-1),cell);
        }
        //if not right border
        if(j!=side && isOpen(i,j+1)){
            cellStorage.union(getCellIndex(i,j+1),cell);
        }
    }
     
    private static void checkRange(int i, int j){
        if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
    }
    
    // is site (row i, column j) open?
    public static boolean isOpen(int i, int j){
        checkRange(i,j);
        return states[getCellIndex(i,j)]==1;
    }   
  
    // does the system percolate?
    public static boolean percolates(){
        return cellStorage.connected(side*side,side*side+1);
    }           
     
    private static int getCellIndex(int row, int column){
        return (side*(row-1))+column-1;
    }
     
     
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            //initialization
            percolation(N);
            String[] datatemp = new String[2];
            while ((datatemp = br.readLine().split("","")) != null){
                if (datatemp.length == 1)
                    break;
                int i = Integer.parseInt(datatemp[0]);
                int j = Integer.parseInt(datatemp[1]);
                open(i,j);
                if (percolates()){
                    System.out.println(i + "","" + j);
                    break;
                }
            }
            if (!percolates())
                System.out.println(-1);
            

        }
            
    }
}

@51933816678231fe77724ad66359e976@"
"r04945009","5","0.48","122048","@0c5663a1f48bc1c47669c02f33256a67@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Percolation {
    private static int [] states;
    private static int side;
    private static UF cellStorage;
// create N-by-N grid, with all sites blocked
    public static void percolation(int N){
        side=N;
        //+2 are for additional top and bottom cells
        cellStorage=new UF(N*N+2);      
        states=new int[N*N+2];
        for(int index=0;index<N*N;index++){
            states[index]=0;
        }
        states[N*N]=1;
        states[N*N+1]=1;            
    }
   // open site (row i, column j) if it is not already  
    public static void open(int i, int j){ 
        checkRange(i,j);
        if(isOpen(i,j))return;       
        int cell=getCellIndex(i,j);
        states[cell]=1;
        //if not top row
        if(i!=1 && isOpen(i-1,j)){
            cellStorage.union(getCellIndex(i-1,j),cell);
        }else if(i==1){
            //connect to virtual top cell
            cellStorage.union(cell,side*side);
        }
        //if not bottom row
        if(i!=side && isOpen(i+1,j)){       
            cellStorage.union(getCellIndex(i+1,j),cell);
        }else if (i==side){
            //connect to virtual bottom cell
            cellStorage.union(cell,side*side+1);
        }
        //if not left border
        if(j!=1 && isOpen(i,j-1)){
            cellStorage.union(getCellIndex(i,j-1),cell);
        }
        //if not right border
        if(j!=side && isOpen(i,j+1)){
            cellStorage.union(getCellIndex(i,j+1),cell);
        }
    }
     
    private static void checkRange(int i, int j){
        if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
    }
    
    // is site (row i, column j) open?
    public static boolean isOpen(int i, int j){
        checkRange(i,j);
        return states[getCellIndex(i,j)]==1;
    }   
  
    // does the system percolate?
    public static boolean percolates(){
        return cellStorage.connected(side*side,side*side+1);
    }           
     
    private static int getCellIndex(int row, int column){
        return (side*(row-1))+column-1;
    }
     
     
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            //initialization
            percolation(N);
            String[] datatemp = new String[2];
            while ((datatemp = br.readLine().split("","")).length != 1){
                int i = Integer.parseInt(datatemp[0]);
                int j = Integer.parseInt(datatemp[1]);
                open(i,j);
                if (percolates()){
                    System.out.println(i + "","" + j);
                    break;
                }
            }
            if (!percolates())
                System.out.println(-1);
            

        }
            
    }
}

@0c5663a1f48bc1c47669c02f33256a67@"
"r04945009","1","0.82","105568","@c2a77f470bc1a7a9f9c82809309f7ffb@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Percolation {
    private static int [] states;
    private static int side;
    private static UF cellStorage;
// create N-by-N grid, with all sites blocked
    public static void percolation(int N){
        side=N;
        //+2 are for additional top and bottom cells
        cellStorage=new UF(N*N+2);      
        states=new int[N*N+2];
        for(int index=0;index<N*N;index++){
            states[index]=0;
        }
        states[N*N]=1;
        states[N*N+1]=1;            
    }

     

    
    // is site (row i, column j) open?
    public static boolean isOpen(int i, int j){
        return states[(side*(i-1))+j-1]==1;
    }   
  
    // does the system percolate?
    public static boolean percolates(){
        return cellStorage.connected(side*side,side*side+1);
    }           

     
     
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String data = br.readLine();
            int N = Integer.parseInt(data);
            //initialization
            int side;
            side=N;
            //+2 are for additional top and bottom cells
            cellStorage=new UF(N*N+2);      
            states=new int[N*N+2];
            for(int index=0;index<N*N;index++){
                states[index]=0;
            }
            states[N*N]=1;
            states[N*N+1]=1;                    
            
            
            String[] datatemp = new String[2];
            
            
            while ((datatemp = br.readLine().split("","")).length != 1){
                int i = Integer.parseInt(datatemp[0]);
                int j = Integer.parseInt(datatemp[1]);
        if(isOpen(i,j))return;       
        int cell=(side*(i-1))+j-1;
        states[cell]=1;
        //if not top row
        if(i!=1 && isOpen(i-1,j)){
            cellStorage.union((side*(i-2))+j-1,cell);
        }else if(i==1){
            //connect to virtual top cell
            cellStorage.union(cell,side*side);
        }
        //if not bottom row
        if(i!=side && isOpen(i+1,j)){       
            cellStorage.union((side*(i))+j-1,cell);
        }else if (i==side){
            //connect to virtual bottom cell
            cellStorage.union(cell,side*side+1);
        }
        //if not left border
        if(j!=1 && isOpen(i,j-1)){
            cellStorage.union((side*(i-1))+j-2,cell);
        }
        //if not right border
        if(j!=side && isOpen(i,j+1)){
            cellStorage.union((side*(i-1))+j,cell);
        }
                if (percolates()){
                    System.out.println(i + "","" + j);
                    break;
                }
            }
            if (!percolates())
                System.out.println(-1);
            

        }
            
    }
}

@c2a77f470bc1a7a9f9c82809309f7ffb@"
"b03611003","5","0.47","125136","@dd9d973d5ee669bb7ad9d4fd940efa6e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 */
public class Percolation {

    /**
     * @param args the command line arguments
     *
     *
     * by union!!!!!!!!!!!!!!
     *
     *
     *
     *
     */
    private static int[] id;
    private static int[] bw;
//    0 as black, 1 as white
    static int N;
    static int siteid;

    public Percolation(int N) {
//        initial the id&bw of the mitrix
        id = new int[N * N + 2];
        bw = new int[N * N + 2];
//       [0] is top, [N+1] is bottom
        for (int i = 0; i < N * N + 2; i++) {
            id[i] = i;
            bw[i] = 0;
        }
//       martix begin from 1 end at N
        bw[0] = 1;
        bw[N * N + 1] = 1;
    }

    public static void open(int row, int col) {
//        open a new site and check the connection
        siteid = (row - 1) * N + col;
        bw[siteid] = 1;

        if (siteid <= N) {
            union(siteid, 0);
//          connect the top     

            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
//            connect the one below

        } else if (siteid > N * N - N) {
            union(siteid, N * N + 1);
//          connect the bottom 

            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
//            connect the one above

        } else {
//          the sites between
            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
            if (bw[siteid - 1] == 1) {
                union(siteid, siteid - 1);
            }
            if (bw[siteid + 1] == 1) {
                union(siteid, siteid + 1);
            }
            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
        }

    }

    public static void union(int A, int B) {
//        把id 設成最小的位子
        int a = root(A);
        int b = root(B);

        if (a < b) {
            id[b] = a;
        } else {
            id[a] = b;
        }
    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static boolean connection(int A, int B) {
        return root(A) == root(B);
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            N = Integer.parseInt(data);

            Percolation matrix = new Percolation(N);

            String[] randc = new String[2];
            int row = 0;
            int col = 0;            
            
            while (!connection(0, N * N + 1)) {

                randc = br.readLine().split("","");
                row = Integer.parseInt(randc[0]);
                col = Integer.parseInt(randc[1]);

                open(row, col);
            }

            System.out.print(row + "","" + col);
        }
    }

}

@dd9d973d5ee669bb7ad9d4fd940efa6e@"
"r04945009","5","0.49","120704","@a7ceec17db52f9376a818fb0560d0020@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Percolation {

   // open site (row i, column j) if it is not already  
     
    
    // is site (row i, column j) open?

  
    // does the system percolate?
     

     
     
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            //initialization
            int side = N;
            //+2 are for additional top and bottom cells
            UF cellStorage=new UF(N*N+2);      
            int [] states=new int[N*N+2];
            for(int index=0;index<N*N;index++){
                states[index]=0;
            }
            states[N*N]=1;
            states[N*N+1]=1;      
            
            
            
            String[] datatemp = new String[2];
            while ((datatemp = br.readLine().split("","")) != null){
                if (datatemp.length == 1)
                    break;
                 
                int i = Integer.parseInt(datatemp[0]);
                int j = Integer.parseInt(datatemp[1]);
                
                
                
                   
            int cell=(side*(i-1))+j-1;
            states[cell]=1;
            //if not top row
            if(i!=1 && states[(side*(i-2))+j-1]==1){
                cellStorage.union((side*(i-2))+j-1,cell);
            }else if(i==1){
            //connect to virtual top cell
            cellStorage.union(cell,side*side);
            }
            //if not bottom row
            if(i!=side && states[(side*(i))+j-1]==1){       
                cellStorage.union((side*(i))+j-1,cell);
            }else if (i==side){
            //connect to virtual bottom cell
            cellStorage.union(cell,side*side+1);
            }
            //if not left border
            if(j!=1 && states[(side*(i-1))+j-2]==1){
                cellStorage.union((side*(i-1))+j-2,cell);
            }
            //if not right border
            if(j!=side && states[(side*(i-1))+j]==1){
                cellStorage.union((side*(i-1))+j,cell);
            }
                
                

                
                if (cellStorage.connected(side*side,side*side+1)){
                    System.out.println(i + "","" + j);
                    break;
                }
            }
            if (!cellStorage.connected(side*side,side*side+1))
                System.out.println(-1);
            

        }
            
    }
}

@a7ceec17db52f9376a818fb0560d0020@"
"r04945009","7","0.65","102528","@9fc0e4b0f2ddf335b8411e0a5fa49225@

import java.io.BufferedReader;
import java.io.FileReader;


public class Percolation {

     
     
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            int lines = 0;
            br.mark(1000);
            while (br.readLine() != null) lines++;
            br.reset();

            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            //initialization
            int side = N;
            //+2 are for additional top and bottom cells
            UF cellStorage=new UF(N*N+2);      
            int [] states=new int[N*N+2];
            for(int index=0;index<N*N;index++){
                states[index]=0;
            }
            states[N*N]=1;
            states[N*N+1]=1;      
            
            
            

            for (int s=1; s<lines; s++ ){
                
                String[] datatemp = br.readLine().split("","");
                int i = Integer.parseInt(datatemp[0]);
                int j = Integer.parseInt(datatemp[1]);
                
                
                
                   
            int cell=(side*(i-1))+j-1;
            states[cell]=1;
            //if not top row
            if(i!=1 && states[(side*(i-2))+j-1]==1){
                cellStorage.union((side*(i-2))+j-1,cell);
            }else if(i==1){
            //connect to virtual top cell
            cellStorage.union(cell,side*side);
            }
            //if not bottom row
            if(i!=side && states[(side*(i))+j-1]==1){       
                cellStorage.union((side*(i))+j-1,cell);
            }else if (i==side){
            //connect to virtual bottom cell
            cellStorage.union(cell,side*side+1);
            }
            //if not left border
            if(j!=1 && states[(side*(i-1))+j-2]==1){
                cellStorage.union((side*(i-1))+j-2,cell);
            }
            //if not right border
            if(j!=side && states[(side*(i-1))+j]==1){
                cellStorage.union((side*(i-1))+j,cell);
            }
                
                

                
                if (cellStorage.connected(side*side,side*side+1)){
                    System.out.println(i + "","" + j);
                    break;
                }
            }
            if (!cellStorage.connected(side*side,side*side+1))
                System.out.println(-1);
            

        }
            
    }
}

@9fc0e4b0f2ddf335b8411e0a5fa49225@"
"r03525008","9","1.38","141200","@92e146b367ffce66ad7cd3c465eadbba@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;


/**
 * Created by 其昌 on 2016/3/4.
 */
public class Percolation {
    public static void main(String[] args){
        try{
            String filename = args[0];
            BufferedReader br = new BufferedReader(new FileReader(filename));
            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();
            while(br.ready()){
                lines.add(br.readLine());
            }
            br.close();

            boolean stop = false;
            ArrayList<Grid> gridList = new ArrayList<Grid>();
            Grid root = new Grid(0,0);
            ArrayList<Grid> bottomGrid = new ArrayList<Grid>();
            for(String line:lines){
                String[] coordinate = line.split("","");
                Grid grid = new Grid(Integer.parseInt(coordinate[0]),Integer.parseInt(coordinate[1]));
                addGridToList(gridList , root , grid);
                if(grid.getX()==num){
                    bottomGrid.add(grid);
                }


                for(Grid bot:bottomGrid){
                    if(bot.getRoot()==root){
                        stop = true;
                        break;
                    }
                }

                if(stop){
                    System.out.println(line);
                    break;
                }
            }
            if(!stop){
                System.out.println(-1);
            }



        } catch (IOException e){
            System.out.println(e.getMessage());
            e.printStackTrace();
        }

    }

    public static void addGridToList(ArrayList<Grid> gridList , Grid root , Grid newGrid){
        if(newGrid.getX()==1){
            newGrid.setParent(root);
        } else {
            for (Grid grid : gridList) {
                if (newGrid.isConnected(grid)) {
                    grid.union(newGrid);
                }
            }
        }
        gridList.add(newGrid);
    }





    static class Grid {

        private int x;
        private int y;
        private Grid parent;

        Grid(int x , int y){
            this.x = x;
            this.y = y;
            this.parent = this;
        }

        public boolean isRoot(){
            return this == parent;
        }

        public Grid getRoot(){
            Grid grid = this;
            while(!grid.isRoot()){
                grid = grid.getParent();
            }
            return grid;
        }

        public void union(Grid grid){
            Grid root1 = this.getRoot();
            Grid root2 = grid.getRoot();
            if(root1.isHigher(root2)){
                root2.setParent(root1);
            } else {
                root1.setParent(root2);
            }
        }

        public boolean isHigher(Grid grid){
            return this.getX() < grid.getX();
        }

        public boolean isConnected(Grid p){
            if(x == p.getX()){
                if(y-p.getY() == 1 || y-p.getY() == -1){
                    return true;
                }
            } else if(y==p.getY()){
                if(x-p.getX() == 1 || x-p.getX() == -1){
                    return true;
                }
            }
            return false;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        public Grid getParent() {
            return parent;
        }

        public void setParent(Grid parent) {
            this.parent = parent;
        }
    }


}

@92e146b367ffce66ad7cd3c465eadbba@"
"r04945009","10","0.102","124896","@ac54542573b0f9957f17308285a14fc0@

import java.io.BufferedReader;
import java.io.FileReader;


public class Percolation {

     
     
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            int lines = 0;
            br.mark(100000);
            while (br.readLine() != null) lines++;
            br.reset();

            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            //initialization
            int side = N;
            //+2 are for additional top and bottom cells
            UF cellStorage=new UF(N*N+2);      
            int [] states=new int[N*N+2];
            for(int index=0;index<N*N;index++){
                states[index]=0;
            }
            states[N*N]=1;
            states[N*N+1]=1;      
            
            
            

            for (int s=1; s<lines; s++ ){
                
                String[] datatemp = br.readLine().split("","");
                int i = Integer.parseInt(datatemp[0]);
                int j = Integer.parseInt(datatemp[1]);
                
                
                
                   
            int cell=(side*(i-1))+j-1;
            states[cell]=1;
            //if not top row
            if(i!=1 && states[(side*(i-2))+j-1]==1){
                cellStorage.union((side*(i-2))+j-1,cell);
            }else if(i==1){
            //connect to virtual top cell
            cellStorage.union(cell,side*side);
            }
            //if not bottom row
            if(i!=side && states[(side*(i))+j-1]==1){       
                cellStorage.union((side*(i))+j-1,cell);
            }else if (i==side){
            //connect to virtual bottom cell
            cellStorage.union(cell,side*side+1);
            }
            //if not left border
            if(j!=1 && states[(side*(i-1))+j-2]==1){
                cellStorage.union((side*(i-1))+j-2,cell);
            }
            //if not right border
            if(j!=side && states[(side*(i-1))+j]==1){
                cellStorage.union((side*(i-1))+j,cell);
            }
                
                

                
                if (cellStorage.connected(side*side,side*side+1)){
                    System.out.println(i + "","" + j);
                    break;
                }
            }
            if (!cellStorage.connected(side*side,side*side+1))
                System.out.println(-1);
            

        }
            
    }
}

@ac54542573b0f9957f17308285a14fc0@"
"b02611016","8","0.77","131408","@fd9ffe8cfab913021af34bb0a28aae1d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num)
            {System.out.println(""-1"");
            break;}
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                    if(matrix[row-1][cloumn+1]==1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                     if(matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@fd9ffe8cfab913021af34bb0a28aae1d@"
"b02611016","8","0.78","124832","@cf2911bbb45fe1c2253a70cf395066ca@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num)
            {System.out.println(""-1"");
            break search;}
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                    if(matrix[row-1][cloumn+1]==1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                     if(matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@cf2911bbb45fe1c2253a70cf395066ca@"
"b02611026","5","1.03","127184","@f5c4c261d1f50c979ffdfe788762c592@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            //Union the upper row
            for (int i = 0; i < matrix_length; i++) {
                if (i + 1 == matrix_length) {
                    break;
                }
                uf.union(i, i + 1);
            }
            //Union the downner row
            for (int i = (matrix_size - matrix_length); i < (matrix_size - 1); i++) {
                if (i + 1 == (matrix_size - 1)) {
                    break;
                }
                uf.union(i, i + 1);
            }
            //Create a matrx in order to mark the cell
            String[][] markmatrix = new String[matrix_length][matrix_length];
            for (int i = 0; i < matrix_length; i++) {
                for (int j = 0; j < matrix_length; j++) {
                    markmatrix[i][j] = ""0"";
                }
            }

            String[] pos;
            while (br.ready()) {
                pos = br.readLine().split("","");
                if (pos == null) {
                    break;
                }
//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");

                //mark the opened position
                int x = Integer.parseInt(pos[0]) - 1;
                int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");

                markmatrix[x][y] = ""1"";
                int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                if (x == 0 && y == 0) { // 左上角
                    if (markmatrix[x][y + 1].equals(""1"")) {
                        uf.union(num, num + 1);
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }

                } else if (x == 0 && y == matrix_length - 1) { //右上角
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                } else if (y == 0 && x == matrix_length - 1) { //左下角
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                } else if (x == matrix_length - 1 && y == matrix_length - 1) { //右下角
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                } else if (y == 0) { //最左排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                } else if (x == 0) { //最上排
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                } else if (y == matrix_length - 1) { //最右排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                } else if (x == matrix_length - 1) { //最下排
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                } else if (x != 0 && y != 0) {
                    //if up is opened
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                    //if down is opened
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    //if left is opened
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                    //if right is opened
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                }

                if (uf.connected(0, matrix_size - 1)) {
                    state = 0;
                    System.out.printf(pos[0] + "" , "" + pos[1]);
                    System.out.printf(""\n"");
                    break;
                } else {
                    state = -1;
                }

            }
            if (state == -1) {
                System.out.printf(""%d"", state);
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@f5c4c261d1f50c979ffdfe788762c592@"
"b02611026","5","1.04","123824","@30411c67ce25514de54e8cab7290ff59@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);
            
            //Union the upper row
            for (int i = 0; i < matrix_length; i++) {
                if (i + 1 == matrix_length) {
                    break;
                }
                uf.union(i, i + 1);
            }
            //Union the downner row
            for (int i = (matrix_size - matrix_length); i < (matrix_size - 1); i++) {
                if (i + 1 == (matrix_size - 1)) {
                    break;
                }
                uf.union(i, i + 1);
            }
            //Create a matrx in order to mark the cell
            String[][] markmatrix = new String[matrix_length][matrix_length];
            for (int i = 0; i < matrix_length; i++) {
                for (int j = 0; j < matrix_length; j++) {
                    markmatrix[i][j] = ""0"";
                }
            }

            String[] pos;
            while (br.ready()) {
                pos = br.readLine().split("","");
                if (pos == null) {
                    break;
                }
                if(matrix_length == 0){
                    state = -1;
                    break;
                }
//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");

                //mark the opened position
                int x = Integer.parseInt(pos[0]) - 1;
                int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");

                markmatrix[x][y] = ""1"";
                int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                if (x == 0 && y == 0) { // 左上角
                    if (markmatrix[x][y + 1].equals(""1"")) {
                        uf.union(num, num + 1);
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }

                } else if (x == 0 && y == matrix_length - 1) { //右上角
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                } else if (y == 0 && x == matrix_length - 1) { //左下角
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                } else if (x == matrix_length - 1 && y == matrix_length - 1) { //右下角
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                } else if (y == 0) { //最左排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                } else if (x == 0) { //最上排
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                } else if (y == matrix_length - 1) { //最右排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                } else if (x == matrix_length - 1) { //最下排
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                } else if (x != 0 && y != 0) {
                    //if up is opened
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                    }
                    //if down is opened
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                    }
                    //if left is opened
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                    }
                    //if right is opened
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                    }
                }

                if (uf.connected(0, matrix_size - 1)) {
                    state = 0;
                    System.out.printf(pos[0] + "" , "" + pos[1]);
                    System.out.printf(""\n"");
                    break;
                } else {
                    state = -1;
                }

            }
            if (state == -1) {
                System.out.printf(""%d"", state);
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@30411c67ce25514de54e8cab7290ff59@"
"r03525006","3","0.9","135536","@cd26176681efee2c897f8ec4072df978@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int rowAns = 0;
            int colAns = 0;
            int i = 0;

            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                isPercolation = true;
                                rowAns = row[j];
                                colAns = col[j];
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()) {
                        i++;
                    } else {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
                System.out.println(rowAns + "","" + colAns);
            } else {
                System.out.println(-1);
            }
        }
    }
}

@cd26176681efee2c897f8ec4072df978@"
"b02611016","8","0.79","128256","@abced94f8799714cfcbe9b8e7828a048@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                    if(matrix[row-1][cloumn+1]==1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                     if(matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@abced94f8799714cfcbe9b8e7828a048@"
"b02611026","0","1.07","312752","@3c59e2e64c36dc301f30a013d055aefb@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            //Union the upper row
            for (int i = 0; i < matrix_length; i++) {
                uf.union(i, i + 1);
                if ((i + 1) == matrix_length) {
                    break;                    
                }
            }
            //Union the downner row
            for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                uf.union(i, i + 1);
                if ((i + 1) == (matrix_size-1)) {
                    break;                    
                }
            }
            //Create a matrx in order to mark the cell
            String[][] markmatrix = new String[matrix_length][matrix_length];
            for (int i = 0; i < matrix_length; i++) {
                for (int j = 0; j < matrix_length; j++) {
                    markmatrix[i][j] = ""0"";
                }
            }

            String[] pos;
            while (br.ready()) {
                pos = br.readLine().split("","");
                if (pos == null) {
                    break;
                }
                if (matrix_length == 0) {
                    state = -1;
                    break;
                }
                System.out.printf(""position："" + pos[0]);
                System.out.printf("" "");
                System.out.printf(pos[1]);
                System.out.printf(""\n"");

                //mark the opened position
                int x = Integer.parseInt(pos[0]) - 1;
                int y = Integer.parseInt(pos[1]) - 1;
                if (matrix_length == 1) {
                    if (x == 0 && y == 0) {
                        state = 0;
                        System.out.printf(pos[0] + "" , "" + pos[1]);
                        break;
                    } else {
                        state = -1;
                        break;
                    }
                }
                System.out.printf(""x : "" + ""%d  "", x);
                System.out.printf("" "");
                System.out.printf(""y : "" + ""%d"", y);
                System.out.printf(""\n"");

                markmatrix[x][y] = ""1"";
                int num = x * matrix_length + y;
                System.out.printf(""num = "" + ""%d   "", num);
                System.out.printf(""\n"");

                if (x == 0 && y == 0) { // 左上角
                    if (markmatrix[x][y + 1].equals(""1"")) {
                        uf.union(num, num + 1);
                        System.out.printf(""a\n"");
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        System.out.printf(""b\n"");
                    }

                } else if (x == 0 && y == matrix_length - 1) { //右上角
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        System.out.printf(""c\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        System.out.printf(""d\n"");
                    }
                } else if (y == 0 && x == matrix_length - 1) { //左下角
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        System.out.printf(""e\n"");
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        System.out.printf(""f\n"");
                    }
                } else if (x == matrix_length - 1 && y == matrix_length - 1) { //右下角
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        System.out.printf(""g\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        System.out.printf(""h\n"");
                    }
                } else if (y == 0) { //最左排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        System.out.printf(""i\n"");
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        System.out.printf(""j\n"");
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        System.out.printf(""k\n"");
                    }
                } else if (x == 0) { //最上排
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        System.out.printf(""m\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        System.out.printf(""n\n"");
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        System.out.printf(""o\n"");
                    }
                } else if (y == matrix_length - 1) { //最右排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        System.out.printf(""p\n"");
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        System.out.printf(""q\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        System.out.printf(""r\n"");
                    }
                } else if (x == matrix_length - 1) { //最下排
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        System.out.printf(""s\n"");
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        System.out.printf(""t\n"");
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        System.out.printf(""u\n"");
                    }
                } else if (x != 0 && y != 0) {
                    //if up is opened
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        System.out.printf(""v\n"");
                    }
                    //if down is opened
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        System.out.printf(""w\n"");
                    }
                    //if left is opened
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        System.out.printf(""x\n"");
                    }
                    //if right is opened
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        System.out.printf(""y\n"");
                    }
                }

                if (uf.connected(0, matrix_size - 1)) {
                    state = 0;
                    System.out.printf(pos[0] + "" , "" + pos[1]);
                    //System.out.printf(""\n"");
                    break;
                } else {
                    state = -1;
                }

            }
            if (state == -1) {
                System.out.printf(""%d"", state);
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@3c59e2e64c36dc301f30a013d055aefb@"
"r04522627","0","0.9","135536","@837ca84cbe265e8a1914dd0ee1fdc27c@import java.io.FileReader;
import java.io.BufferedReader;


public class HW1 {

   
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
          
            int n = Integer.parseInt(data[0]);
            WeightedQuickUnionUF WQUF = new  WeightedQuickUnionUF(n*n + 2);
            for(int i = 1;i < n + 1;i++)
            {
                WQUF.union(0, i);
                WQUF.union(n*n+1, i + (n - 1) * n);
            }
            //reset objects
            int[] objects = new int[n*n];
            for(int i = 0;i< objects.length;i++)
            {
                objects[i] = 0;   // 0 means close
            }
            
            
            do
            {
                 data = br.readLine().split("","");
                 if(data == null) 
                 {
                     System.out.printf(""%d"",-1);
                     break;
                 }
                 int num1 = Integer.parseInt(data[0]);  // x coordinate
                 int num2 = Integer.parseInt(data[1]);  // y coordinate
                 int m = num1 + (num2-1) * n -1;
                 objects[m] = 1; //1 means open
                 if(num1 % n == 0)    //最右
                 {
                     if(num2 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num2 % n == 1) //最上
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1)  //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                     }
                 }
                 else if(num1 % n == 1) //最左
                 {
                      if(num2 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num2 % n == 1) //最上
                     {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                     }
                    else
                    {
                       if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 else
                 {
                    if(num2 % n == 0) //最下
                    {
                         if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else if(num2 % n == 1) //最上
                    {
                      if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d, %d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 
            }while(data != null);
        }
    }
    
}

@837ca84cbe265e8a1914dd0ee1fdc27c@"
"r04631033","0","0.9","135536","@d4f582ff1c7b685b48a781b1cebfe7b2@import edu.princeton.cs.algs4.WeightedQuickUnionUF;

/**
 *
 * @author 育修
 */
public class Percolation {
 private WeightedQuickUnionUF weightedQuickUnionUF;
    private WeightedQuickUnionUF weightedQuickUnionUFBackEnd;
    private int row = 0;
    private int column = 0;
    private boolean[] open = null;
    private boolean createFlow = false;
    private boolean ijIsFull = false;

    // create N-by-N grid, with all sites blocked
    public Percolation(int N) {
        // [NOTE] Check that IllegalArgumentException is thrown if N <= 0 in
        // constructor
        if (N <= 0)
            throw new java.lang.IllegalArgumentException();
        // WQUUF for Percolation
        // weightedQuickUnionUF[N * N] virtual top site
        // weightedQuickUnionUF[N * N + 1] virtual bottom site
        this.weightedQuickUnionUF = new WeightedQuickUnionUF(N * N + 2);
        // [NOTE] WQUUF for Full, without virtual bottom site
        this.weightedQuickUnionUFBackEnd = new WeightedQuickUnionUF(N * N + 1);
        this.row = N;
        this.column = N;
        this.open = new boolean[N * N + 2];
        open[N * N] = true;
    }

    // open site (row i, column j) if it is not open already
    public void open(int i, int j) {
        validateIndex(i, j);
        if (!this.open[matchCoordinateToIndex(i, j)]) {
            this.open[matchCoordinateToIndex(i, j)] = true;
            // initialize ij is full
            ijIsFull = false;
            // check adjacent open sites and the site's position
            checkPositionAdjacent(i, j, this.row);
        }

    }

    private void validateIndex(int i, int j) {
        if (i <= 0 || i > this.row)
            throw new IndexOutOfBoundsException(""row index i out of bounds"");
        if (j <= 0 || j > this.column)
            throw new IndexOutOfBoundsException(""column index j out of bounds"");
    }

    private void checkPositionAdjacent(int i, int j, int N) {
        if (i == 1)
        // set it as a full site
        {
            // connect it with virtual top site
            weightedQuickUnionUF.union(this.row * this.column, (matchCoordinateToIndex(i, j)));
            weightedQuickUnionUFBackEnd.union(this.row * this.column, (matchCoordinateToIndex(i, j)));
            // it creates liquid flow
            ijIsFull = true;
            createFlow = true;
        }
        // if-else for time saving
        else
            checkAdjacentUp(i, j);
        if (i == N) {
            //// connect it with bottom top site
            weightedQuickUnionUF.union(this.row * this.column + 1, (matchCoordinateToIndex(i, j)));
        } else
            checkAdjacentDown(i, j);
        if (j > 1)
            checkAdjacentLeft(i, j);
        if (j < N)
            checkAdjacentRight(i, j);
    }

    private void checkAdjacentLeft(int i, int j) {
        unionAdjacent(i, j, i, j - 1);
    }

    private void checkAdjacentRight(int i, int j) {
        unionAdjacent(i, j, i, j + 1);
    }

    private void checkAdjacentUp(int i, int j) {
        unionAdjacent(i, j, i - 1, j);
    }

    private void checkAdjacentDown(int i, int j) {
        unionAdjacent(i, j, i + 1, j);
    }

    private void unionAdjacent(int i, int j, int k, int l) {
        // if the adjacent one is also open
        if (this.open[matchCoordinateToIndex(k, l)]) {
            // if i,j is full
            // loop 1 for unionAdjacent, ijIsFull = (i == 1)
            // loop 2-4 for unionAdjacent, ijIsFull is the result in the former
            // loop
            boolean full = ijIsFull;
            // if i,j is not full but k,l is full
            if (!full) {
                full = isFull(k, l);
            }
            // connect them
            weightedQuickUnionUF.union((matchCoordinateToIndex(k, l)), (matchCoordinateToIndex(i, j)));
            weightedQuickUnionUFBackEnd.union((matchCoordinateToIndex(k, l)), (matchCoordinateToIndex(i, j)));
            if (full) {
                // it creates liquid flow!
                createFlow = true;
                ijIsFull = true;
            }
        }
    }

    // is site (row i, column j) open?
    public boolean isOpen(int i, int j) {
        validateIndex(i, j);
        return this.open[matchCoordinateToIndex(i, j)];
    }

    // is site (row i, column j) full?
    public boolean isFull(int i, int j) {
        validateIndex(i, j);
        // is the site even opened?
        if (!this.isOpen(i, j))
            return false;
        // if the root is full
        // save WeightedQuickUnionUF calls
        if (weightedQuickUnionUFBackEnd.connected(matchCoordinateToIndex(i, j), this.row * this.column))
            return true;
        else if (weightedQuickUnionUFBackEnd.connected(weightedQuickUnionUFBackEnd.find(matchCoordinateToIndex(i, j)),
                this.row * this.column))
            return true;
        else
            return false;
    }

    // does the system percolate?
    public boolean percolates() {
        // no liquid flow, no need to check percolation
        if (!createFlow)
            return false;
        if (weightedQuickUnionUF.connected(this.row * this.column, this.row * this.column + 1)) {
            return true;
        }
        createFlow = false;
        return false;
    }

    // get site index from coordinates
    // (1,1) -> 0; N = 8 (8,8) -> 63
    private int matchCoordinateToIndex(int i, int j) {
        return this.column * (i - 1) + j - 1;
    }

    public static void main(String[] args) {

    }

}
@d4f582ff1c7b685b48a781b1cebfe7b2@"
"r04631033","0","0.88","105184","@83d78505cd6ac023926bca1d4c57309a@public class Percolation {
 private WeightedQuickUnionUF weightedQuickUnionUF;
    private WeightedQuickUnionUF weightedQuickUnionUFBackEnd;
    private int row = 0;
    private int column = 0;
    private boolean[] open = null;
    private boolean createFlow = false;
    private boolean ijIsFull = false;

    // create N-by-N grid, with all sites blocked
    public Percolation(int N) {
        // [NOTE] Check that IllegalArgumentException is thrown if N <= 0 in
        // constructor
        if (N <= 0)
            throw new java.lang.IllegalArgumentException();
        // WQUUF for Percolation
        // weightedQuickUnionUF[N * N] virtual top site
        // weightedQuickUnionUF[N * N + 1] virtual bottom site
        this.weightedQuickUnionUF = new WeightedQuickUnionUF(N * N + 2);
        // [NOTE] WQUUF for Full, without virtual bottom site
        this.weightedQuickUnionUFBackEnd = new WeightedQuickUnionUF(N * N + 1);
        this.row = N;
        this.column = N;
        this.open = new boolean[N * N + 2];
        open[N * N] = true;
    }

    // open site (row i, column j) if it is not open already
    public void open(int i, int j) {
        validateIndex(i, j);
        if (!this.open[matchCoordinateToIndex(i, j)]) {
            this.open[matchCoordinateToIndex(i, j)] = true;
            // initialize ij is full
            ijIsFull = false;
            // check adjacent open sites and the site's position
            checkPositionAdjacent(i, j, this.row);
        }

    }

    private void validateIndex(int i, int j) {
        if (i <= 0 || i > this.row)
            throw new IndexOutOfBoundsException(""row index i out of bounds"");
        if (j <= 0 || j > this.column)
            throw new IndexOutOfBoundsException(""column index j out of bounds"");
    }

    private void checkPositionAdjacent(int i, int j, int N) {
        if (i == 1)
        // set it as a full site
        {
            // connect it with virtual top site
            weightedQuickUnionUF.union(this.row * this.column, (matchCoordinateToIndex(i, j)));
            weightedQuickUnionUFBackEnd.union(this.row * this.column, (matchCoordinateToIndex(i, j)));
            // it creates liquid flow
            ijIsFull = true;
            createFlow = true;
        }
        // if-else for time saving
        else
            checkAdjacentUp(i, j);
        if (i == N) {
            //// connect it with bottom top site
            weightedQuickUnionUF.union(this.row * this.column + 1, (matchCoordinateToIndex(i, j)));
        } else
            checkAdjacentDown(i, j);
        if (j > 1)
            checkAdjacentLeft(i, j);
        if (j < N)
            checkAdjacentRight(i, j);
    }

    private void checkAdjacentLeft(int i, int j) {
        unionAdjacent(i, j, i, j - 1);
    }

    private void checkAdjacentRight(int i, int j) {
        unionAdjacent(i, j, i, j + 1);
    }

    private void checkAdjacentUp(int i, int j) {
        unionAdjacent(i, j, i - 1, j);
    }

    private void checkAdjacentDown(int i, int j) {
        unionAdjacent(i, j, i + 1, j);
    }

    private void unionAdjacent(int i, int j, int k, int l) {
        // if the adjacent one is also open
        if (this.open[matchCoordinateToIndex(k, l)]) {
            // if i,j is full
            // loop 1 for unionAdjacent, ijIsFull = (i == 1)
            // loop 2-4 for unionAdjacent, ijIsFull is the result in the former
            // loop
            boolean full = ijIsFull;
            // if i,j is not full but k,l is full
            if (!full) {
                full = isFull(k, l);
            }
            // connect them
            weightedQuickUnionUF.union((matchCoordinateToIndex(k, l)), (matchCoordinateToIndex(i, j)));
            weightedQuickUnionUFBackEnd.union((matchCoordinateToIndex(k, l)), (matchCoordinateToIndex(i, j)));
            if (full) {
                // it creates liquid flow!
                createFlow = true;
                ijIsFull = true;
            }
        }
    }

    // is site (row i, column j) open?
    public boolean isOpen(int i, int j) {
        validateIndex(i, j);
        return this.open[matchCoordinateToIndex(i, j)];
    }

    // is site (row i, column j) full?
    public boolean isFull(int i, int j) {
        validateIndex(i, j);
        // is the site even opened?
        if (!this.isOpen(i, j))
            return false;
        // if the root is full
        // save WeightedQuickUnionUF calls
        if (weightedQuickUnionUFBackEnd.connected(matchCoordinateToIndex(i, j), this.row * this.column))
            return true;
        else if (weightedQuickUnionUFBackEnd.connected(weightedQuickUnionUFBackEnd.find(matchCoordinateToIndex(i, j)),
                this.row * this.column))
            return true;
        else
            return false;
    }

    // does the system percolate?
    public boolean percolates() {
        // no liquid flow, no need to check percolation
        if (!createFlow)
            return false;
        if (weightedQuickUnionUF.connected(this.row * this.column, this.row * this.column + 1)) {
            return true;
        }
        createFlow = false;
        return false;
    }

    // get site index from coordinates
    // (1,1) -> 0; N = 8 (8,8) -> 63
    private int matchCoordinateToIndex(int i, int j) {
        return this.column * (i - 1) + j - 1;
    }

    public static void main(String[] args) {

    }

}
@83d78505cd6ac023926bca1d4c57309a@"
"r04522627","0","0.5","122720","@b6278828ddceac34f7e0b84d105a2d8a@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String[] data = br.readLine().split("","");
          
            int n = Integer.parseInt(data[0]);
            WeightedQuickUnionUF WQUF = new  WeightedQuickUnionUF(n*n + 2);
            for(int i = 1;i < n + 1;i++)
            {
                WQUF.union(0, i);
                WQUF.union(n*n+1, i + (n - 1) * n);
            }
            //reset objects
            int[] objects = new int[n*n];
            for(int i = 0;i< objects.length;i++)
            {
                objects[i] = 0;   // 0 means close
            }
            
            
            do
            {
                 data = br.readLine().split("","");
                 if(data == null) 
                 {
                     System.out.printf(""%d"",-1);
                     break;
                 }
                 int num1 = Integer.parseInt(data[0]);  // x coordinate
                 int num2 = Integer.parseInt(data[1]);  // y coordinate
                 int m = num1 + (num2-1) * n -1;
                 objects[m] = 1; //1 means open
                 if(num1 % n == 0)    //最右
                 {
                     if(num2 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num2 % n == 1) //最上
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1)  //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                 }
                 else if(num1 % n == 1) //最左
                 {
                      if(num2 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num2 % n == 1) //最上
                     {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                    else
                    {
                       if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 else
                 {
                    if(num2 % n == 0) //最下
                    {
                         if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else if(num2 % n == 1) //最上
                    {
                      if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 
            }while(data != null);
        }
    }
    
}

@b6278828ddceac34f7e0b84d105a2d8a@"
"r04522627","4","0.92","123536","@604c9770b7facb65d1a6434a0c51e59c@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String datastream = br.readLine();
            String[] data = datastream.split("","");
          
            int n = Integer.parseInt(data[0]);
            WeightedQuickUnionUF WQUF = new  WeightedQuickUnionUF(n*n + 2);
            for(int i = 1;i < n + 1;i++)
            {
                WQUF.union(0, i);
                WQUF.union(n*n+1, i + (n - 1) * n);
            }
            //reset objects
            int[] objects = new int[n*n];
            for(int i = 0;i< objects.length;i++)
            {
                objects[i] = 0;   // 0 means close
            }
            
            
            do
            {
                 datastream = br.readLine();
                 if(datastream == null) 
                 {
                     System.out.printf(""%d"",-1);
                     br.close();
                     break;
                 }
                 else
                 {
                     data = datastream.split("","");
                 }
                 int num1 = Integer.parseInt(data[0]);  // x coordinate
                 int num2 = Integer.parseInt(data[1]);  // y coordinate
                 int m = num1 + (num2-1) * n -1;
                 objects[m] = 1; //1 means open
                 if(num1 % n == 0)    //最右
                 {
                     if(num2 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num2 % n == 1) //最上
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1)  //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                 }
                 else if(num1 % n == 1) //最左
                 {
                      if(num2 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num2 % n == 1) //最上
                     {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                    else
                    {
                       if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 else
                 {
                    if(num2 % n == 0) //最下
                    {
                         if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else if(num2 % n == 1) //最上
                    {
                      if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 
            }while(datastream != null);
        }
    }
    
}

@604c9770b7facb65d1a6434a0c51e59c@"
"r04522616","0","0.88","105184","@b03cd54ac6a0177b452bff0a50aac8f0@
import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                        
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);

            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(N*N +2);
            
            int [] open=new int[N*N+1];
            for(int i=1;i<N*N+1;i++)
            {
                open[i]=0;
            }
            
            do{
                data = br.readLine().split("","");               
                if(data[0]==null)
                {
                    if(!wQUF.connected(0, N*N+1))
                    {
                        System.out.print(""-1"");
                    }
                    break;
                }               
            
                int x = Integer.parseInt(data[0]);//x座標
                int y = Integer.parseInt(data[1]);//y座標
                
                open[N*(x-1)+y]=1;
                
                if(N*(x-1)+y-N<1)//第一列與虛擬開頭連
                {
                    wQUF.union(N*(x-1)+y,0);
                }
                if(N*(x-1)+y+N>N*N)//最後一列與虛擬結尾連
                {
                    wQUF.union(N*(x-1)+y,N*N+1);
                }
                
                if(N*(x-1)+y-N>=1)//上方可連
                {
                    if(open[N*(x-1)+y-N]==1)//上方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y-N);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if((N*(x-1)+y)%N!=1)//左方可連
                {
                    if(open[N*(x-1)+y-1]==1)//左方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y-1);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if((N*(x-1)+y)%N!=0)//右方可連
                {
                    if(open[N*(x-1)+y+1]==1)//右方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y+1);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if(N*(x-1)+y+N<=N*N)//下方可連
                {
                    if(open[N*(x-1)+y+N]==1)//下方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y+N);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                
            }
            while(data[0]!=null);
            
            
            
        }
    }
}

@b03cd54ac6a0177b452bff0a50aac8f0@"
"r04522627","9","0.94","126688","@ee83d415179d18856765d96c599c545e@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String datastream = br.readLine();
            String[] data = datastream.split("","");
          
            int n = Integer.parseInt(data[0]);
            WeightedQuickUnionUF WQUF = new  WeightedQuickUnionUF(n*n + 2);
            for(int i = 1;i < n + 1;i++)
            {
                WQUF.union(0, i);
                WQUF.union(n*n+1, i + (n - 1) * n);
            }
            //reset objects
            int[] objects = new int[n*n];
            for(int i = 0;i< objects.length;i++)
            {
                objects[i] = 0;   // 0 means close
            }
            
            
            do
            {
                 datastream = br.readLine();
                 if(datastream == null) 
                 {
                     System.out.printf(""%d"",-1);
                     br.close();
                     break;
                 }
                 else
                 {
                     data = datastream.split("","");
                 }
                 int num1 = Integer.parseInt(data[0]);  // x coordinate
                 int num2 = Integer.parseInt(data[1]);  // y coordinate
                 int m = num2 + (num1-1) * n -1;
                 objects[m] = 1; //1 means open
                 if(num2 % n == 0)    //最右
                 {
                     if(num1 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num1 % n == 1) //最上
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1)  //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                 }
                 else if(num2 % n == 1) //最左
                 {
                      if(num1 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num1 % n == 1) //最上
                     {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                    else
                    {
                       if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 else
                 {
                    if(num1 % n == 0) //最下
                    {
                         if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else if(num1 % n == 1) //最上
                    {
                      if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 
            }while(datastream != null);
        }
    }
    
}

@ee83d415179d18856765d96c599c545e@"
"r04522616","4","0.4","123920","@252e192e4b906afec09e96137cf03039@
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                        
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);

            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(N*N +2);
            
            int [] open=new int[N*N+1];
            for(int i=1;i<N*N+1;i++)
            {
                open[i]=0;
            }
            
            do{
                data = br.readLine().split("","");               
                if(data[0]==null)
                {
                    if(!wQUF.connected(0, N*N+1))
                    {
                        System.out.print(""-1"");
                    }
                    break;
                }               
            
                int x = Integer.parseInt(data[0]);//x座標
                int y = Integer.parseInt(data[1]);//y座標
                
                open[N*(x-1)+y]=1;
                
                if(N*(x-1)+y-N<1)//第一列與虛擬開頭連
                {
                    wQUF.union(N*(x-1)+y,0);
                }
                if(N*(x-1)+y+N>N*N)//最後一列與虛擬結尾連
                {
                    wQUF.union(N*(x-1)+y,N*N+1);
                }
                
                if(N*(x-1)+y-N>=1)//上方可連
                {
                    if(open[N*(x-1)+y-N]==1)//上方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y-N);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if((N*(x-1)+y)%N!=1)//左方可連
                {
                    if(open[N*(x-1)+y-1]==1)//左方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y-1);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if((N*(x-1)+y)%N!=0)//右方可連
                {
                    if(open[N*(x-1)+y+1]==1)//右方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y+1);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if(N*(x-1)+y+N<=N*N)//下方可連
                {
                    if(open[N*(x-1)+y+N]==1)//下方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y+N);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                
            }
            while(data[0]!=null);
            
            
            
        }
    }
}

@252e192e4b906afec09e96137cf03039@"
"r04522627","9","0.93","129312","@ee83d415179d18856765d96c599c545e@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String datastream = br.readLine();
            String[] data = datastream.split("","");
          
            int n = Integer.parseInt(data[0]);
            WeightedQuickUnionUF WQUF = new  WeightedQuickUnionUF(n*n + 2);
            for(int i = 1;i < n + 1;i++)
            {
                WQUF.union(0, i);
                WQUF.union(n*n+1, i + (n - 1) * n);
            }
            //reset objects
            int[] objects = new int[n*n];
            for(int i = 0;i< objects.length;i++)
            {
                objects[i] = 0;   // 0 means close
            }
            
            
            do
            {
                 datastream = br.readLine();
                 if(datastream == null) 
                 {
                     System.out.printf(""%d"",-1);
                     br.close();
                     break;
                 }
                 else
                 {
                     data = datastream.split("","");
                 }
                 int num1 = Integer.parseInt(data[0]);  // x coordinate
                 int num2 = Integer.parseInt(data[1]);  // y coordinate
                 int m = num2 + (num1-1) * n -1;
                 objects[m] = 1; //1 means open
                 if(num2 % n == 0)    //最右
                 {
                     if(num1 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num1 % n == 1) //最上
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1)  //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                 }
                 else if(num2 % n == 1) //最左
                 {
                      if(num1 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num1 % n == 1) //最上
                     {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                    else
                    {
                       if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 else
                 {
                    if(num1 % n == 0) //最下
                    {
                         if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else if(num1 % n == 1) //最上
                    {
                      if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 
            }while(datastream != null);
        }
    }
    
}

@ee83d415179d18856765d96c599c545e@"
"r04945009","10","0.102","129056","@85beadc89a6801ff227a63bd66aed948@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hung-wei
 */
public class Percolation {
    private static int [] states;
    private static int side;
    private static UF cellStorage;
// create N-by-N grid, with all sites blocked
    public static void percolation(int N){
        side=N;
        //+2 are for additional top and bottom cells
        cellStorage=new UF(N*N+2);      
        states=new int[N*N+2];
        for(int index=0;index<N*N;index++){
            states[index]=0;
        }
        states[N*N]=1;
        states[N*N+1]=1;            
    }
   // open site (row i, column j) if it is not already  
    public static void open(int i, int j){ 
        checkRange(i,j);
        if(isOpen(i,j))return;       
        int cell=getCellIndex(i,j);
        states[cell]=1;
        //if not top row
        if(i!=1 && isOpen(i-1,j)){
            cellStorage.union(getCellIndex(i-1,j),cell);
        }else if(i==1){
            //connect to virtual top cell
            cellStorage.union(cell,side*side);
        }
        //if not bottom row
        if(i!=side && isOpen(i+1,j)){       
            cellStorage.union(getCellIndex(i+1,j),cell);
        }else if (i==side){
            //connect to virtual bottom cell
            cellStorage.union(cell,side*side+1);
        }
        //if not left border
        if(j!=1 && isOpen(i,j-1)){
            cellStorage.union(getCellIndex(i,j-1),cell);
        }
        //if not right border
        if(j!=side && isOpen(i,j+1)){
            cellStorage.union(getCellIndex(i,j+1),cell);
        }
    }
     
    private static void checkRange(int i, int j){
        if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
    }
    
    // is site (row i, column j) open?
    public static boolean isOpen(int i, int j){
        checkRange(i,j);
        return states[getCellIndex(i,j)]==1;
    }   
  
    // does the system percolate?
    public static boolean percolates(){
        return cellStorage.connected(side*side,side*side+1);
    }           
     
    private static int getCellIndex(int row, int column){
        return (side*(row-1))+column-1;
    }
     
     
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            int lines = 0;
            br.mark(100000);
            while (br.readLine() != null) lines++;
            br.reset();

            String data = br.readLine();
            int N = Integer.parseInt(data);
            //initialization
            percolation(N);

            for (int s=1; s<lines; s++ ){
                
                String[] datatemp = br.readLine().split("","");
                int i = Integer.parseInt(datatemp[0]);
                int j = Integer.parseInt(datatemp[1]);
                open(i,j);
                if (percolates()){
                    System.out.println(i + "","" + j);
                    break;
                }
            }
            if (!percolates())
                System.out.println(-1);
            

        }
            
    }
}

@85beadc89a6801ff227a63bd66aed948@"
"r04522616","9","0.98","124576","@e6a6d39f95e8ee5f84444ab1cb8654d6@
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);

            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(N*N +2);
            
            int [] open=new int[N*N+1];
            for(int i=1;i<N*N+1;i++)
            {
                open[i]=0;
            }
            
            do{
                nullData=br.readLine();                          
                if(nullData ==null)
                {
                    if(!wQUF.connected(0, N*N+1))
                    {
                        System.out.print(""-1"");
                    }
                    break;
                }               
                data = nullData.split("","");     
                int x = Integer.parseInt(data[0]);//x座標
                int y = Integer.parseInt(data[1]);//y座標
                
                open[N*(x-1)+y]=1;
                
                if(N*(x-1)+y-N<1)//第一列與虛擬開頭連
                {
                    wQUF.union(N*(x-1)+y,0);
                }
                if(N*(x-1)+y+N>N*N)//最後一列與虛擬結尾連
                {
                    wQUF.union(N*(x-1)+y,N*N+1);
                }
                
                if(N*(x-1)+y-N>=1)//上方可連
                {
                    if(open[N*(x-1)+y-N]==1)//上方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y-N);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if((N*(x-1)+y)%N!=1)//左方可連
                {
                    if(open[N*(x-1)+y-1]==1)//左方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y-1);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if((N*(x-1)+y)%N!=0)//右方可連
                {
                    if(open[N*(x-1)+y+1]==1)//右方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y+1);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if(N*(x-1)+y+N<=N*N)//下方可連
                {
                    if(open[N*(x-1)+y+N]==1)//下方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y+N);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                
            }
            while(data[0]!=null);
            
            
            
        }
    }
}

@e6a6d39f95e8ee5f84444ab1cb8654d6@"
"r04522616","10","0.099","122064","@611d41c58e89b177e398d32f9dd6a208@
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);

            WeightedQuickUnionUF wQUF=new WeightedQuickUnionUF(N*N +2);
            
            int [] open=new int[N*N+1];
            for(int i=1;i<N*N+1;i++)
            {
                open[i]=0;
            }
            
            do{
                nullData=br.readLine();                          
                if(nullData ==null)
                {
                    if(!wQUF.connected(0, N*N+1))
                    {
                        System.out.print(""-1"");
                    }
                    break;
                }               
                data = nullData.split("","");     
                int x = Integer.parseInt(data[0]);//x座標
                int y = Integer.parseInt(data[1]);//y座標
                
                open[N*(x-1)+y]=1;
                
                if(N*(x-1)+y-N<1)//第一列與虛擬開頭連
                {
                    wQUF.union(N*(x-1)+y,0);
                }
                if(N*(x-1)+y+N>N*N)//最後一列與虛擬結尾連
                {
                    wQUF.union(N*(x-1)+y,N*N+1);
                }
                if(wQUF.connected(0, N*N+1))
                {
                    System.out.print(x+"",""+y);
                    break;
                }
                
                if(N*(x-1)+y-N>=1)//上方可連
                {
                    if(open[N*(x-1)+y-N]==1)//上方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y-N);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if((N*(x-1)+y)%N!=1)//左方可連
                {
                    if(open[N*(x-1)+y-1]==1)//左方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y-1);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if((N*(x-1)+y)%N!=0)//右方可連
                {
                    if(open[N*(x-1)+y+1]==1)//右方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y+1);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                if(N*(x-1)+y+N<=N*N)//下方可連
                {
                    if(open[N*(x-1)+y+N]==1)//下方已開
                    {
                        wQUF.union(N*(x-1)+y,N*(x-1)+y+N);
                        if(wQUF.connected(0, N*N+1))
                        {
                            System.out.print(x+"",""+y);
                            break;
                        }
                    }
                }
                
            }
            while(data[0]!=null);
            
            
            
        }
    }
}

@611d41c58e89b177e398d32f9dd6a208@"
"r04522627","10","0.105","126544","@987577041b361f9d4f27a39da3fe058c@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read a line and split by ','
            String datastream = br.readLine();
            String[] data = datastream.split("","");
          
            int n = Integer.parseInt(data[0]);
            WeightedQuickUnionUF WQUF = new  WeightedQuickUnionUF(n*n + 2);
            for(int i = 1;i < n + 1;i++)
            {
                WQUF.union(0, i);
                WQUF.union(n*n+1, i + (n - 1) * n);
            }
            //reset objects
            int[] objects = new int[n*n];
            for(int i = 0;i< objects.length;i++)
            {
                objects[i] = 0;   // 0 means close
            }
            
            
            do
            {
                 datastream = br.readLine();
                 if(datastream == null) 
                 {
                     System.out.printf(""%d"",-1);
                     br.close();
                     break;
                 }
                 else
                 {
                     data = datastream.split("","");
                 }
                 int num1 = Integer.parseInt(data[0]);  // x coordinate
                 int num2 = Integer.parseInt(data[1]);  // y coordinate
                 int m = num2 + (num1-1) * n -1;
                 objects[m] = 1; //1 means open
                 if(num2 % n == 0)    //最右
                 {
                     if(num1 % n == 0) //最下
                     {
                        if(num1 == num2 && num1 ==1)
                        {
                             System.out.printf(""%d,%d"",num1,num2);
                             break;
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num1 % n == 1) //最上
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1)  //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else
                     {
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                 }
                 else if(num2 % n == 1) //最左
                 {
                      if(num1 % n == 0) //最下
                     {
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                     else if(num1 % n == 1) //最上
                     {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                     }
                    else
                    {
                       if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 else
                 {
                    if(num1 % n == 0) //最下
                    {
                         if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else if(num1 % n == 1) //最上
                    {
                      if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if(objects[m + 1] == 1) // 右
                        {
                            WQUF.union(m+1, m + 1 + 1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m + n] == 1) //下
                        {
                            WQUF.union(m+1, m + n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - n] == 1) // 上
                        {
                            WQUF.union(m+1, m - n +1);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                        if(objects[m - 1] == 1) //左
                        {
                            WQUF.union(m+1, m);
                            if(WQUF.connected(0, n*n+1))
                            {
                                System.out.printf(""%d,%d"",num1,num2);
                                break;
                            }
                        }
                    }
                 }
                 
            }while(datastream != null);
        }
    }
    
}

@987577041b361f9d4f27a39da3fe058c@"
"r04631009","0","0.88","105184","@43a29adbfe15bf87a911b5041dbadb5c@public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//
            int oldx = 0;
            int oldy = 0;
            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column
                if (matrix[oldx][oldy] == 2 && oldx == size - 1) {
                    break;
                }
                oldx = x;
                oldy = y;

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top
                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }
                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }
                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }
            }
            int row = oldx + 1;
            int column = oldy + 1;
            System.out.println(row + "","" + column);

        }

    }

}

@43a29adbfe15bf87a911b5041dbadb5c@"
"r04631009","0","0.88","105184","@43a29adbfe15bf87a911b5041dbadb5c@public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//
            int oldx = 0;
            int oldy = 0;
            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column
                if (matrix[oldx][oldy] == 2 && oldx == size - 1) {
                    break;
                }
                oldx = x;
                oldy = y;

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top
                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }
                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }
                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }
            }
            int row = oldx + 1;
            int column = oldy + 1;
            System.out.println(row + "","" + column);

        }

    }

}

@43a29adbfe15bf87a911b5041dbadb5c@"
"r04631009","1","0.9","124368","@e817c65b97a33f0a5099446c5c569750@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//
            int oldx = 0;
            int oldy = 0;
            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column
                if (matrix[oldx][oldy] == 2 && oldx == size - 1) {
                    break;
                }
                oldx = x;
                oldy = y;

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top
                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }
                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }
                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }
            }
            int row = oldx + 1;
            int column = oldy + 1;
            System.out.println(row + "","" + column);

        }

    }

}

@e817c65b97a33f0a5099446c5c569750@"
"b02611016","8","0.8","136448","@73f15072321d60f86f25436eccd3462c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@73f15072321d60f86f25436eccd3462c@"
"b02611016","8","0.78","138368","@73f15072321d60f86f25436eccd3462c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@73f15072321d60f86f25436eccd3462c@"
"r04631036","0","0.88","105184","@03e3e1bf8562a3baa5029c8d267e119a@
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.*;

public class Percolation {

    public int size;
    public int id;
    public static int[] state;
    public WeightedQuickUnionUF qf;

    Percolation(int sizee, WeightedQuickUnionUF qff) {
        size = sizee;
        qf = qff;
    }

    public void open(int i, int j) {
        checkrange(i, j);
        if (checkopen(i, j)) {
            return;
        }
        id = getindex(i, j);
        state[id] = 1;
        //if not top row
        if (i != 1 && checkopen(i - 1, j)) {
            union(getindex(i - 1, j), id);
        } else if (i == 1) {
            //connect to virtual top cell
            union(id, size * size);
        }
        //if not bottom row
        if (i != size && checkopen(i + 1, j)) {
            union(getindex(i + 1, j), id);
        } else if (i == size) {
            //connect to virtual bottom cell
            union(id, size * size + 1);
        }
        //if not left border
        if (j != 1 && checkopen(i, j - 1)) {
            union(getindex(i, j - 1), id);
        }
        //if not right border
        if (j != size && checkopen(i, j + 1)) {
            union(getindex(i, j + 1), id);
        }
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public boolean checkopen(int i, int j) {
        checkrange(i, j);
        return state[getindex(i, j)] == 1;
    }

    public boolean isfull(int i, int j) {
        checkrange(i, j);
        return qf.connected(size * size, getindex(i, j));
    }

    public void union(int i, int j) {
        if (!qf.connected(i, j)) {
            qf.union(i, j);
        }
    }

    public boolean percolate(int i, int j) {
        return qf.connected(size * size, size * size + 1);
    }

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int top = 0;
            int bottom;
            boolean ok = false;
            //WeightedQuickUnionUF qf;
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            //System.out.printf(""%d"", size);

            bottom = size;
            state = new int[size * size + 2];
            WeightedQuickUnionUF qf = new WeightedQuickUnionUF(size * size + 2);
            for (int i = 0; i < size * size; i++) {
                state[i] = 0;
            }
            state[size * size] = 1;
            state[size * size + 1] = 1;
            Percolation per = new Percolation(size, qf);
            boolean doo;
            int count = 0;
            
            while (!ok) {
                String[] location = br.readLine().split("","");
                count++;
                //System.out.printf(""\n%s %s\n"", location[0], location[1]);
                int i = Integer.parseInt(location[0]);
                int j = Integer.parseInt(location[1]);
                //System.out.printf(""i=%d j=%d\n"", i, j);
                per.open(i, j);
                doo = per.percolate(i, j);
                //System.out.printf(""i=%b\n"", doo);
                ok = doo;
                if(ok==true){
                    System.out.printf(""%d,%d"",i,j);
                    return;
                }
//            }
            }
        }
        catch(Exception e){
    System.err.println(""-1"");
}
        
        
        
        
        
        
        
        
        
    }
}

@03e3e1bf8562a3baa5029c8d267e119a@"
"r04631036","5","1.05","123808","@38bc0477fbf741febc5a4fa2ea66a6ec@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public int size;
    public int id;
    public static int[] state;
    public WeightedQuickUnionUF qf;

    Percolation(int sizee, WeightedQuickUnionUF qff) {
        size = sizee;
        qf = qff;
    }

    public void open(int i, int j) {
        checkrange(i, j);
        if (checkopen(i, j)) {
            return;
        }
        id = getindex(i, j);
        state[id] = 1;
        //if not top row
        if (i != 1 && checkopen(i - 1, j)) {
            union(getindex(i - 1, j), id);
        } else if (i == 1) {
            //connect to virtual top cell
            union(id, size * size);
        }
        //if not bottom row
        if (i != size && checkopen(i + 1, j)) {
            union(getindex(i + 1, j), id);
        } else if (i == size) {
            //connect to virtual bottom cell
            union(id, size * size + 1);
        }
        //if not left border
        if (j != 1 && checkopen(i, j - 1)) {
            union(getindex(i, j - 1), id);
        }
        //if not right border
        if (j != size && checkopen(i, j + 1)) {
            union(getindex(i, j + 1), id);
        }
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public boolean checkopen(int i, int j) {
        checkrange(i, j);
        return state[getindex(i, j)] == 1;
    }

    public boolean isfull(int i, int j) {
        checkrange(i, j);
        return qf.connected(size * size, getindex(i, j));
    }

    public void union(int i, int j) {
        if (!qf.connected(i, j)) {
            qf.union(i, j);
        }
    }

    public boolean percolate(int i, int j) {
        return qf.connected(size * size, size * size + 1);
    }

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int top = 0;
            int bottom;
            boolean ok = false;
            //WeightedQuickUnionUF qf;
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            //System.out.printf(""%d"", size);

            bottom = size;
            state = new int[size * size + 2];
            WeightedQuickUnionUF qf = new WeightedQuickUnionUF(size * size + 2);
            for (int i = 0; i < size * size; i++) {
                state[i] = 0;
            }
            state[size * size] = 1;
            state[size * size + 1] = 1;
            Percolation per = new Percolation(size, qf);
            boolean doo;
            int count = 0;
            
            while (!ok) {
                String[] location = br.readLine().split("","");
                count++;
                //System.out.printf(""\n%s %s\n"", location[0], location[1]);
                int i = Integer.parseInt(location[0]);
                int j = Integer.parseInt(location[1]);
                //System.out.printf(""i=%d j=%d\n"", i, j);
                per.open(i, j);
                doo = per.percolate(i, j);
                //System.out.printf(""i=%b\n"", doo);
                ok = doo;
                if(ok==true){
                    System.out.printf(""%d,%d"",i,j);
                    return;
                }
//            }
            }
        }
        catch(Exception e){
    System.err.println(""-1"");
}
        
        
        
        
        
        
        
        
        
    }
}

@38bc0477fbf741febc5a4fa2ea66a6ec@"
"r04631036","5","1.02","124432","@95845e80bd153e9132ba1eec31cf045b@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public int size;
    public int id;
    public static int[] state;
    public WeightedQuickUnionUF qf;

    Percolation(int sizee, WeightedQuickUnionUF qff) {
        size = sizee;
        qf = qff;
    }

    public void open(int i, int j) {
        checkrange(i, j);
        if (checkopen(i, j)) {
            return;
        }
        id = getindex(i, j);
        state[id] = 1;
        //if not top row
        if (i != 1 && checkopen(i - 1, j)) {
            union(getindex(i - 1, j), id);
        } else if (i == 1) {
            //connect to virtual top cell
            union(id, size * size);
        }
        //if not bottom row
        if (i != size && checkopen(i + 1, j)) {
            union(getindex(i + 1, j), id);
        } else if (i == size) {
            //connect to virtual bottom cell
            union(id, size * size + 1);
        }
        //if not left border
        if (j != 1 && checkopen(i, j - 1)) {
            union(getindex(i, j - 1), id);
        }
        //if not right border
        if (j != size && checkopen(i, j + 1)) {
            union(getindex(i, j + 1), id);
        }
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public boolean checkopen(int i, int j) {
        checkrange(i, j);
        return state[getindex(i, j)] == 1;
    }

    public boolean isfull(int i, int j) {
        checkrange(i, j);
        return qf.connected(size * size, getindex(i, j));
    }

    public void union(int i, int j) {
        if (!qf.connected(i, j)) {
            qf.union(i, j);
        }
    }

    public boolean percolate(int i, int j) {
        return qf.connected(size * size, size * size + 1);
    }

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int top = 0;
            int bottom;
            boolean ok = false;
            //WeightedQuickUnionUF qf;
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            //System.out.printf(""%d"", size);

            bottom = size;
            state = new int[size * size + 2];
            WeightedQuickUnionUF qf = new WeightedQuickUnionUF(size * size + 2);
            for (int i = 0; i < size * size; i++) {
                state[i] = 0;
            }
            state[size * size] = 1;
            state[size * size + 1] = 1;
            Percolation per = new Percolation(size, qf);
            boolean doo;
            int count = 0;
            int i =0;
                int j =0;
            
            
            while (!ok) {
                String[] location = br.readLine().split("","");
                count++;
                //System.out.printf(""\n%s %s\n"", location[0], location[1]);
                i = Integer.parseInt(location[0]);
                j = Integer.parseInt(location[1]);
                //System.out.printf(""i=%d j=%d\n"", i, j);
                per.open(i, j);
                doo = per.percolate(i, j);
                //System.out.printf(""i=%b\n"", doo);
                ok = doo;
                if(ok==true){
                    System.out.printf(""%d,%d"",i,j);
                    return;
                }
//            }
            }
        }
        catch(Exception e){
    System.err.println(""-1"");
}
    }
}

@95845e80bd153e9132ba1eec31cf045b@"
"b02611016","8","0.91","147648","@73f15072321d60f86f25436eccd3462c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=5;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@73f15072321d60f86f25436eccd3462c@"
"r03525008","10","0.137","136512","@48e42dc004e0cb235352c04f3d6a7d3f@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;


/**
 * Created by 其昌 on 2016/3/4.
 */
public class Percolation {
    public static void main(String[] args){
        try{
            String filename = args[0];
            BufferedReader br = new BufferedReader(new FileReader(filename));
            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();
            while(br.ready()){
                lines.add(br.readLine());
            }
            br.close();

            boolean stop = false;
            ArrayList<Grid> gridList = new ArrayList<Grid>();
            Grid root = new Grid(0,0);
            ArrayList<Grid> bottomGrid = new ArrayList<Grid>();
            for(String line:lines){
                String[] coordinate = line.split("","");
                Grid grid = new Grid(Integer.parseInt(coordinate[0]),Integer.parseInt(coordinate[1]));
                addGridToList(gridList , root , grid);
                if(grid.getX()==num){
                    bottomGrid.add(grid);
                }

                for(Grid bot:bottomGrid){
                    if(bot.getRoot()==root){
                        stop = true;
                        break;
                    }
                }

                if(stop){
                    System.out.println(line);
                    break;
                }
            }
            if(!stop){
                System.out.println(-1);
            }



        } catch (IOException e){
            System.out.println(e.getMessage());
            e.printStackTrace();
        }

    }

    public static void addGridToList(ArrayList<Grid> gridList , Grid root , Grid newGrid){
        if(newGrid.getX()==1){
            newGrid.setParent(root);
        }
        for (Grid grid : gridList) {
            if (newGrid.isConnected(grid)) {
                grid.union(newGrid);
            }
        }
        gridList.add(newGrid);
    }

    static class Grid {

        private int x;
        private int y;
        private Grid parent;

        Grid(int x , int y){
            this.x = x;
            this.y = y;
            this.parent = this;
        }

        public boolean isRoot(){
            return this == parent;
        }

        public Grid getRoot(){
            Grid grid = this;
            while(!grid.isRoot()){
                grid = grid.getParent();
            }
            return grid;
        }

        public void union(Grid grid){
            Grid root1 = this.getRoot();
            Grid root2 = grid.getRoot();
            if(root1.isHigher(root2)){
                root2.setParent(root1);
            } else {
                root1.setParent(root2);
            }
        }

        public boolean isHigher(Grid grid){
            return this.getX() < grid.getX();
        }

        public boolean isConnected(Grid p){
            if(x == p.getX()){
                if(y-p.getY() == 1 || y-p.getY() == -1){
                    return true;
                }
            } else if(y==p.getY()){
                if(x-p.getX() == 1 || x-p.getX() == -1){
                    return true;
                }
            }
            return false;
        }

        public int getX() {
            return x;
        }

        public int getY() {
            return y;
        }

        public Grid getParent() {
            return parent;
        }

        public void setParent(Grid parent) {
            this.parent = parent;
        }
    }


}

@48e42dc004e0cb235352c04f3d6a7d3f@"
"r04631036","5","1.04","127888","@17ead6654f2023554924604e65254240@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public int size;
    public int id;
    public static int[] state;
    public WeightedQuickUnionUF qf;

    Percolation(int sizee, WeightedQuickUnionUF qff) {
        size = sizee;
        qf = qff;
        state = new int[size*size+2];
    }

    public void open(int i, int j) {
        checkrange(i, j);
        if (checkopen(i, j)) {
            return;
        }
        id = getindex(i, j);
        state[id] = 1;
        //if not top row
        if (i != 1 && checkopen(i - 1, j)) {
            union(getindex(i - 1, j), id);
        } else if (i == 1) {
            //connect to virtual top cell
            union(id, size * size);
        }
        //if not bottom row
        if (i != size && checkopen(i + 1, j)) {
            union(getindex(i + 1, j), id);
        } else if (i == size) {
            //connect to virtual bottom cell
            union(id, size * size + 1);
        }
        //if not left border
        if (j != 1 && checkopen(i, j - 1)) {
            union(getindex(i, j - 1), id);
        }
        //if not right border
        if (j != size && checkopen(i, j + 1)) {
            union(getindex(i, j + 1), id);
        }
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public boolean checkopen(int i, int j) {
        checkrange(i, j);
        return state[getindex(i, j)] == 1;
    }

    public boolean isfull(int i, int j) {
        checkrange(i, j);
        return qf.connected(size * size, getindex(i, j));
    }

    public void union(int i, int j) {
        if (!qf.connected(i, j)) {
            qf.union(i, j);
        }
    }

    public boolean percolate(int i, int j) {
        return qf.connected(size * size, size * size + 1);
    }
    
    public void setstate(int i,int value)
    {
        state[i] = value;
    }
    
    public int getstate(int i)
    {
        return state[i];
    }

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int top = 0;
            int bottom;
            boolean ok = false;
            //WeightedQuickUnionUF qf;
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            //System.out.printf(""%d"", size);

            bottom = size;
            //state = new int[size * size + 2];
            WeightedQuickUnionUF qf = new WeightedQuickUnionUF(size * size + 2);
            
            Percolation per = new Percolation(size, qf);
            for (int i = 0; i < size * size; i++) {
                per.setstate(i, 0);
                //state[i] = 0;
            }
            per.setstate(size*size, 1);
            per.setstate(size*size+1,1);
            //state[size * size] = 1;
            //state[size * size + 1] = 1;

            boolean doo;
            int count = 0;
            int i =0;
                int j =0;
            
            
            while (!ok) {
                String[] location = br.readLine().split("","");
                count++;
                //System.out.printf(""\n%s %s\n"", location[0], location[1]);
                i = Integer.parseInt(location[0]);
                j = Integer.parseInt(location[1]);
                //System.out.printf(""i=%d j=%d\n"", i, j);
                per.open(i, j);
                doo = per.percolate(i, j);
                //System.out.printf(""i=%b\n"", doo);
                ok = doo;
                 //System.out.printf(""___________________ \n"");
                //System.out.printf(""%d , %d is open \n"",i,j );
                for(int k=0;k<size*size+2;k++)
                {                   
                    //System.out.println
                    //System.out.printf(""%d == %d  \n"",k,per.getstate(k));
                }
                if(ok==true){
                    System.out.printf(""%d,%d"",i,j);
                    return;
                }
//            }
            }
        }
        catch(Exception e){
    System.err.println(""-1"");
}
    }
}

@17ead6654f2023554924604e65254240@"
"r04631036","10","0.103","127264","@78b209e50be6d4f3046251efdaa1b6a9@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public int size;
    public int id;
    public static int[] state;
    public WeightedQuickUnionUF qf;

    Percolation(int sizee, WeightedQuickUnionUF qff) {
        size = sizee;
        qf = qff;
        state = new int[size*size+2];
    }

    public void open(int i, int j) {
        checkrange(i, j);
        if (checkopen(i, j)) {
            return;
        }
        id = getindex(i, j);
        state[id] = 1;
        //if not top row
        if (i != 1 && checkopen(i - 1, j)) {
            union(getindex(i - 1, j), id);
        } else if (i == 1) {
            //connect to virtual top cell
            union(id, size * size);
        }
        //if not bottom row
        if (i != size && checkopen(i + 1, j)) {
            union(getindex(i + 1, j), id);
        } else if (i == size) {
            //connect to virtual bottom cell
            union(id, size * size + 1);
        }
        //if not left border
        if (j != 1 && checkopen(i, j - 1)) {
            union(getindex(i, j - 1), id);
        }
        //if not right border
        if (j != size && checkopen(i, j + 1)) {
            union(getindex(i, j + 1), id);
        }
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public boolean checkopen(int i, int j) {
        checkrange(i, j);
        return state[getindex(i, j)] == 1;
    }

    public boolean isfull(int i, int j) {
        checkrange(i, j);
        return qf.connected(size * size, getindex(i, j));
    }

    public void union(int i, int j) {
        if (!qf.connected(i, j)) {
            qf.union(i, j);
        }
    }

    public boolean percolate(int i, int j) {
        return qf.connected(size * size, size * size + 1);
    }
    
    public void setstate(int i,int value)
    {
        state[i] = value;
    }
    
    public int getstate(int i)
    {
        return state[i];
    }

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            int top = 0;
            int bottom;
            boolean ok = false;
            //WeightedQuickUnionUF qf;
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            //System.out.printf(""%d"", size);

            bottom = size;
            //state = new int[size * size + 2];
            WeightedQuickUnionUF qf = new WeightedQuickUnionUF(size * size + 2);
            
            Percolation per = new Percolation(size, qf);
            for (int i = 0; i < size * size; i++) {
                per.setstate(i, 0);
                //state[i] = 0;
            }
            per.setstate(size*size, 1);
            per.setstate(size*size+1,1);
            //state[size * size] = 1;
            //state[size * size + 1] = 1;

            boolean doo;
            int count = 0;
            int i =0;
                int j =0;
            
            
            while (!ok) {
                String[] location = br.readLine().split("","");
                count++;
                //System.out.printf(""\n%s %s\n"", location[0], location[1]);
                i = Integer.parseInt(location[0]);
                j = Integer.parseInt(location[1]);
                //System.out.printf(""i=%d j=%d\n"", i, j);
                per.open(i, j);
                doo = per.percolate(i, j);
                //System.out.printf(""i=%b\n"", doo);
                ok = doo;
                 //System.out.printf(""___________________ \n"");
                //System.out.printf(""%d , %d is open \n"",i,j );
                for(int k=0;k<size*size+2;k++)
                {                   
                    //System.out.println
                    //System.out.printf(""%d == %d  \n"",k,per.getstate(k));
                }
                if(ok==true){
                    System.out.printf(""%d,%d"",i,j);
                    return;
                }
//            }
            }
        }
        catch(Exception e){
//    System.err.println(""-1"");
    System.out.printf(""-1"");
}
    }
}

@78b209e50be6d4f3046251efdaa1b6a9@"
"r04631009","0","1.13","164272","@a2272b4335d494ba2ce3395467b33056@
/**
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//

            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top
                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }
                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }
                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }
            }
            //show for debug
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    System.out.print(matrix[i][j] + "" "");
                }
                System.out.println("""");
            }

        }

    }

}

@a2272b4335d494ba2ce3395467b33056@"
"r03522826","0","1.28","158832","@947568ccf39c40482701b5995a92d9c6@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

     private static int convert(int x, int y, int N){
       int p = (x-1)*N + y;
       return p;
    }
     
     
    
    
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           
           String [] data = br.readLine().split("","");
           int N = Integer.parseInt(data[0]);
           int [][] check = new int [N][N];
           QuickUnionUF uf = new QuickUnionUF(N*N+2);
           int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;
           String d;

          while((d = br.readLine())!= null){
           String [] data1 = d.split("","");
            x =  Integer.parseInt(data1[0]);
            y =  Integer.parseInt(data1[1]);
           
            
           int inx = x -1, iny = y -1 ;
             check[inx][iny] = 1;
             
             int p = convert(x,y,N);
             
             if(1 == x){
                 uf.union(p,0);
             }
             
             if(N == x){
                 uf.union(p,N*N+1);
             }
             
             if((x-1)>0 && (x-1)<=N){
                int pu = convert(x-1,y,N);
                if( 1 == check[x-2][y-1]){
                uf.union(p,pu);
                }
             }
             
             if((x+1)<=N && (x+1)>0){
                int pl = convert(x+1,y,N);
                if( 1 == check[x][y-1]){
                uf.union(p,pl);
                }
             }
            
              if((y-1)>0 && (y-1)<=N){
                int pl = convert(x,y-1,N);
                if(1 == check[x-1][y-2]){
                uf.union(p,pl);
                }
             }
              
             if((y+1)<=N && (y+1)>0){
                int pr = convert(x,y+1,N);
                if(1 == check[x-1][y]){
                uf.union(p,pr);
                }
             }
             
           if((uf.connected(0, N*N+1))&&(0 == end)){
               x1 = x;
               y1 = y;
               end = 1;
               j = 2;
           }
             switch(j){
                 case 1:
                     System.out.println(x+"" ""+y);
                     break;
                 case 2:
                     System.out.println(x1+"" ""+y1);
                     break;
                 default:
             }
                 
          }
         
//            System.out.println(j);
//            System.out.println(end);
//          System.out.println(check[0][0]);
//          System.out.println(check[0][1]);
//          System.out.println(check[0][2]);
//          System.out.println(check[1][0]);
//          System.out.println(check[1][1]);
//          System.out.println(check[1][2]);
//          System.out.println(check[2][0]);
//          System.out.println(check[2][1]);
//          System.out.println(check[2][2]);
        }
    }
    
}
@947568ccf39c40482701b5995a92d9c6@"
"r03522826","0","1.29","162112","@947568ccf39c40482701b5995a92d9c6@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

     private static int convert(int x, int y, int N){
       int p = (x-1)*N + y;
       return p;
    }
     
     
    
    
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           
           String [] data = br.readLine().split("","");
           int N = Integer.parseInt(data[0]);
           int [][] check = new int [N][N];
           QuickUnionUF uf = new QuickUnionUF(N*N+2);
           int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;
           String d;

          while((d = br.readLine())!= null){
           String [] data1 = d.split("","");
            x =  Integer.parseInt(data1[0]);
            y =  Integer.parseInt(data1[1]);
           
            
           int inx = x -1, iny = y -1 ;
             check[inx][iny] = 1;
             
             int p = convert(x,y,N);
             
             if(1 == x){
                 uf.union(p,0);
             }
             
             if(N == x){
                 uf.union(p,N*N+1);
             }
             
             if((x-1)>0 && (x-1)<=N){
                int pu = convert(x-1,y,N);
                if( 1 == check[x-2][y-1]){
                uf.union(p,pu);
                }
             }
             
             if((x+1)<=N && (x+1)>0){
                int pl = convert(x+1,y,N);
                if( 1 == check[x][y-1]){
                uf.union(p,pl);
                }
             }
            
              if((y-1)>0 && (y-1)<=N){
                int pl = convert(x,y-1,N);
                if(1 == check[x-1][y-2]){
                uf.union(p,pl);
                }
             }
              
             if((y+1)<=N && (y+1)>0){
                int pr = convert(x,y+1,N);
                if(1 == check[x-1][y]){
                uf.union(p,pr);
                }
             }
             
           if((uf.connected(0, N*N+1))&&(0 == end)){
               x1 = x;
               y1 = y;
               end = 1;
               j = 2;
           }
             switch(j){
                 case 1:
                     System.out.println(x+"" ""+y);
                     break;
                 case 2:
                     System.out.println(x1+"" ""+y1);
                     break;
                 default:
             }
                 
          }
         
//            System.out.println(j);
//            System.out.println(end);
//          System.out.println(check[0][0]);
//          System.out.println(check[0][1]);
//          System.out.println(check[0][2]);
//          System.out.println(check[1][0]);
//          System.out.println(check[1][1]);
//          System.out.println(check[1][2]);
//          System.out.println(check[2][0]);
//          System.out.println(check[2][1]);
//          System.out.println(check[2][2]);
        }
    }
    
}
@947568ccf39c40482701b5995a92d9c6@"
"r03522826","5","1","130784","@fbf92a3a4e70b947557567bf780933a0@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

     private static int convert(int x, int y, int N){
       int p = (x-1)*N + y;
       return p;
    }
     
     
    
    
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           
           String [] data = br.readLine().split("","");
           int N = Integer.parseInt(data[0]);
           int [][] check = new int [N][N];
           QuickUnionUF uf = new QuickUnionUF(N*N+2);
           int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;
           String d;

          while((d = br.readLine())!= null){
           String [] data1 = d.split("","");
            x =  Integer.parseInt(data1[0]);
            y =  Integer.parseInt(data1[1]);
           
            
           int inx = x -1, iny = y -1 ;
             check[inx][iny] = 1;
             
             int p = convert(x,y,N);
             
             if(1 == x){
                 uf.union(p,0);
             }
             
             if(N == x){
                 uf.union(p,N*N+1);
             }
             
             if((x-1)>0 && (x-1)<=N){
                int pu = convert(x-1,y,N);
                if( 1 == check[x-2][y-1]){
                uf.union(p,pu);
                }
             }
             
             if((x+1)<=N && (x+1)>0){
                int pl = convert(x+1,y,N);
                if( 1 == check[x][y-1]){
                uf.union(p,pl);
                }
             }
            
              if((y-1)>0 && (y-1)<=N){
                int pl = convert(x,y-1,N);
                if(1 == check[x-1][y-2]){
                uf.union(p,pl);
                }
             }
              
             if((y+1)<=N && (y+1)>0){
                int pr = convert(x,y+1,N);
                if(1 == check[x-1][y]){
                uf.union(p,pr);
                }
             }
             
           if((uf.connected(0, N*N+1))&&(0 == end)){
               x1 = x;
               y1 = y;
               end = 1;
               j = 2;
           }
             
                 
          }
         switch(j){
                 case 1:
                     System.out.println(-1);
                     break;
                 case 2:
                     System.out.println(x1+"" ""+y1);
                     break;
                 default:
             }
//            System.out.println(j);
//            System.out.println(end);
//          System.out.println(check[0][0]);
//          System.out.println(check[0][1]);
//          System.out.println(check[0][2]);
//          System.out.println(check[1][0]);
//          System.out.println(check[1][1]);
//          System.out.println(check[1][2]);
//          System.out.println(check[2][0]);
//          System.out.println(check[2][1]);
//          System.out.println(check[2][2]);
        }
    }
    
}
@fbf92a3a4e70b947557567bf780933a0@"
"r04631023","0","0","0","@1495e8579e83ccf843216762f4d58770@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(""args[0]""))) {

            // read a line and split by ','
            String[] data = br.readLine().split("" "");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String[] Open = br.readLine().split("","");
            String check = Open[0];

            while (!check.isEmpty()) {
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0]+"",""+Open[1];
                    System.out.println(s);
                    break;
                }
                Open = br.readLine().split("","");
                check = Open[0];
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}

@1495e8579e83ccf843216762f4d58770@"
"r03522826","5","1.12","175296","@bfb0b63334b36366005e21726644cc75@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

     private static int convert(int x, int y, int N){
       int p = (x-1)*N + y;
       return p;
    }
     
     
    
    
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           
           String [] data = br.readLine().split("","");
           int N = Integer.parseInt(data[0]);
           int [][] check = new int [N][N];
           QuickUnionUF uf = new QuickUnionUF(N*N+2);
           int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;
           String d;

          while((d = br.readLine())!= null){
           
            d = d.replaceAll("" "", """");
            String [] data1 = d.split("","");
           
            x =  Integer.parseInt(data1[0]);
            y =  Integer.parseInt(data1[1]);
           
            
           int inx = x -1, iny = y -1 ;
             check[inx][iny] = 1;
             
             int p = convert(x,y,N);
             
             if(1 == x){
                 uf.union(p,0);
             }
             
             if(N == x){
                 uf.union(p,N*N+1);
             }
             
             if((x-1)>0 && (x-1)<=N){
                int pu = convert(x-1,y,N);
                if( 1 == check[x-2][y-1]){
                uf.union(p,pu);
                }
             }
             
             if((x+1)<=N && (x+1)>0){
                int pl = convert(x+1,y,N);
                if( 1 == check[x][y-1]){
                uf.union(p,pl);
                }
             }
            
              if((y-1)>0 && (y-1)<=N){
                int pl = convert(x,y-1,N);
                if(1 == check[x-1][y-2]){
                uf.union(p,pl);
                }
             }
              
             if((y+1)<=N && (y+1)>0){
                int pr = convert(x,y+1,N);
                if(1 == check[x-1][y]){
                uf.union(p,pr);
                }
             }
             
           if((uf.connected(0, N*N+1))&&(0 == end)){
               x1 = x;
               y1 = y;
               end = 1;
               j = 2;
           }
             
                 
          }
         switch(j){
                 case 1:
                     System.out.print(-1);
                     break;
                 case 2:
                     System.out.print(x1+"" ""+y1);
                     break;
                 default:
             }
//            System.out.println(j);
//            System.out.println(end);
//          System.out.println(check[0][0]);
//          System.out.println(check[0][1]);
//          System.out.println(check[0][2]);
//          System.out.println(check[1][0]);
//          System.out.println(check[1][1]);
//          System.out.println(check[1][2]);
//          System.out.println(check[2][0]);
//          System.out.println(check[2][1]);
//          System.out.println(check[2][2]);
        }
    }
    
}
@bfb0b63334b36366005e21726644cc75@"
"r04631023","3","0.39","122560","@7c278c9ef7626f4f2de46515921d9d05@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("" "");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String[] Open = br.readLine().split("","");
            String check = Open[0];

            while (!check.isEmpty()) {
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0]+"",""+Open[1];
                    System.out.println(s);
                    break;
                }
                Open = br.readLine().split("","");
                check = Open[0];
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}

@7c278c9ef7626f4f2de46515921d9d05@"
"r03522826","10","0.111","170288","@3d061640fe2db818a0525348b503cf9c@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

     private static int convert(int x, int y, int N){
       int p = (x-1)*N + y;
       return p;
    }
     
     
    
    
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           
           String [] data = br.readLine().split("","");
           int N = Integer.parseInt(data[0]);
           int [][] check = new int [N][N];
           QuickUnionUF uf = new QuickUnionUF(N*N+2);
           int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;
           String d;

          while((d = br.readLine())!= null){
           
            d = d.replaceAll("" "", """");
            String [] data1 = d.split("","");
           
            x =  Integer.parseInt(data1[0]);
            y =  Integer.parseInt(data1[1]);
           
            
           int inx = x -1, iny = y -1 ;
             check[inx][iny] = 1;
             
             int p = convert(x,y,N);
             
             if(1 == x){
                 uf.union(p,0);
             }
             
             if(N == x){
                 uf.union(p,N*N+1);
             }
             
             if((x-1)>0 && (x-1)<=N){
                int pu = convert(x-1,y,N);
                if( 1 == check[x-2][y-1]){
                uf.union(p,pu);
                }
             }
             
             if((x+1)<=N && (x+1)>0){
                int pl = convert(x+1,y,N);
                if( 1 == check[x][y-1]){
                uf.union(p,pl);
                }
             }
            
              if((y-1)>0 && (y-1)<=N){
                int pl = convert(x,y-1,N);
                if(1 == check[x-1][y-2]){
                uf.union(p,pl);
                }
             }
              
             if((y+1)<=N && (y+1)>0){
                int pr = convert(x,y+1,N);
                if(1 == check[x-1][y]){
                uf.union(p,pr);
                }
             }
             
           if((uf.connected(0, N*N+1))&&(0 == end)){
               x1 = x;
               y1 = y;
               end = 1;
               j = 2;
           }
             
                 
          }
         switch(j){
                 case 1:
                     System.out.println(-1);
                     break;
                 case 2:
                     System.out.println(x1+"",""+y1);
                     break;
                 default:
             }
//            System.out.println(j);
//            System.out.println(end);
//          System.out.println(check[0][0]);
//          System.out.println(check[0][1]);
//          System.out.println(check[0][2]);
//          System.out.println(check[1][0]);
//          System.out.println(check[1][1]);
//          System.out.println(check[1][2]);
//          System.out.println(check[2][0]);
//          System.out.println(check[2][1]);
//          System.out.println(check[2][2]);
        }
    }
    
}
@3d061640fe2db818a0525348b503cf9c@"
"b02611016","8","0.78","135120","@d7b1ce28b4d757503293d94bff27629c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int label=num+1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     }
                   }
                 }
                 id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               label=label+1;
               }
           }
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@d7b1ce28b4d757503293d94bff27629c@"
"r04945022","0","0","0","@9ca1973dc2c41be16359fa3850eadc1b@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try{
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String[] inputarray;
        while((inputarray = br.readLine().split("",""))!=null){
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
//             System.out.println(inputnumber1+"",""+inputnumber2); check my lines
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
        }
        }catch(IOException ex){
            err.println(ex.getMessage());
        } 
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
         
     
    }
    
}
@9ca1973dc2c41be16359fa3850eadc1b@"
"b01502105","5","0.93","105776","@787994dfeabd74a9a572a90649378457@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //inout size
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num*num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for(int i=0; i<element_num; i++){
                index[i]=i;
            }
//            System.out.printf(data[1]+"" ""+data[2]+""\n"");
            for(int j=1;j<=num;j++){
                uf.union(index[0],index[j]);
                uf.union(index[element_num-1-j],index[element_num-1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:{
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
                    matrix[row][column] = 1;
//                    System.out.println(matrix[0][0]+"" ""+matrix[0][1]+"" ""+matrix[0][2]);
//                    System.out.println(matrix[1][0]+"" ""+matrix[1][1]+"" ""+matrix[1][2]);
//                    System.out.println(matrix[2][0]+"" ""+matrix[2][1]+"" ""+matrix[2][2]);

                    int open = num*row + column + 1;
                    //down
                    if( row+1<num && matrix[row+1][column] == 1){
                        uf.union(index[open],index[open+num]);
//                        System.out.printf(""union:""+(row+1)+"",""+(column+1)+"" ""+(row+2)+"",""+(column+1)+""\n"");
                    }
                    //up
                    if( row-1>=0 && matrix[row-1][column] == 1){
                        uf.union(index[open],index[open-num]);
//                        System.out.printf(""union:""+(row+1)+"",""+(column+1)+"" ""+row+"",""+(column+1)+""\n"");
                    }
                    //left
                    if( column-1>=0 && matrix[row][column-1] == 1){
                        uf.union(index[open-1],index[open]);
//                        System.out.printf(""union:""+(row+1)+"",""+(column+1)+"" ""+(row+1)+"",""+(column)+""\n"");
                    }
                    //right
                    if( column+1<num && matrix[row][column+1] == 1){
                        uf.union(index[open+1],index[open]);
//                        System.out.printf(""union:""+(row+1)+"",""+(column+1)+"" ""+(row+1)+"",""+(column+2)+""\n"");
                    }
                    //checking connection
                    if( uf.connected(index[0],index[element_num-1])){
//                        System.out.printf(""Done!"" + ""\n"");
                        System.out.printf(input[0]+"",""+input[1]+""\n"");
                        break loop;
                    }
//                    System.out.println("" "");
                }
            }
            if(k>=len){
                System.out.printf(-1+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}

@787994dfeabd74a9a572a90649378457@"
"r04631023","8","0.93","125072","@1e62c4afd5c7919875757a3b5d14d90f@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("" "");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String() ;             
            String[] Open = new String[2] ;

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","") ;
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0]+"",""+Open[1];
                    System.out.println(s);
                    break;
                }
                //Open = br.readLine().split("","");
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}
@1e62c4afd5c7919875757a3b5d14d90f@"
"r04631023","5","0.98","105776","@70450506cbe1cea1ffa4a00b8df56a50@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("" "");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String() ;             
            String[] Open = new String[2] ;

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","") ;
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if(x >= N || y >= N){
                    System.out.printf(""%d\n"", -1);
                    return ;
                }
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0]+"",""+Open[1];
                    System.out.println(s);
                    break;
                }
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}
@70450506cbe1cea1ffa4a00b8df56a50@"
"r04631023","8","0.93","126320","@25fbce6b51003a46a78d582024821959@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("" "");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String() ;             
            String[] Open = new String[2] ;

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","") ;
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if(x > N || y > N){
                    System.out.printf(""%d\n"", -1);
                    return ;
                }
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0]+"",""+Open[1];
                    System.out.println(s);
                    break;
                }
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}

@25fbce6b51003a46a78d582024821959@"
"r04631025","0","0.93","125072","@54993635c3787b3e4116cf0d2e9f1d03@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    
    UF uf;// = new UF(N * N);

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 1; i <= a; i++) {
            id[i - 1] = i;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 2][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (x != 3) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 2], matrix[x - 1][y - 1]);
            }
        }
        if (y != 3) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        if(uf.connected(matrix[2][2], matrix[0][0])||uf.connected(matrix[2][1],matrix[0][0])||uf.connected(matrix[2][0],matrix[0][0])){
            return true;
        }
        else return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            
            while (!PL.check()) {
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]);
                int y = Integer.parseInt(coordinate[1]);

                PL.un(x, y);
                n++;
            }
        }
    }
}


@54993635c3787b3e4116cf0d2e9f1d03@"
"r04631025","2","0.28","105872","@394a625493b524308746cc161ef7af2e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    
    UF uf;// = new UF(N * N);

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 1; i <= a; i++) {
            id[i - 1] = i;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 2][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (x != 3) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 2], matrix[x - 1][y - 1]);
            }
        }
        if (y != 3) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        if(uf.connected(matrix[2][2], matrix[0][0])||uf.connected(matrix[2][1],matrix[0][0])||uf.connected(matrix[2][0],matrix[0][0])){
            return true;
        }
        else return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            
            while (!PL.check()) {
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]);
                int y = Integer.parseInt(coordinate[1]);

                PL.un(x, y);
                n++;
            }
        }
    }
}


@394a625493b524308746cc161ef7af2e@"
"r04631023","9","0.92","122048","@b8f2363648cd7745d3fd87e57440cd41@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("" "");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String() ;             
            String[] Open = new String[2] ;

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","") ;
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if(x > N || y > N){
                    System.out.printf(""%d\n"", -1);
                    return ;
                }
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + -N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0]+"",""+Open[1];
                    System.out.println(s);
                    break;
                }
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}

@b8f2363648cd7745d3fd87e57440cd41@"
"r04631023","9","0.92","121168","@e819de00cbb3e64ee6a252cf76d5ff8e@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("" "");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String() ;             
            String[] Open = new String[2] ;

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","") ;
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if(x > N || y > N){
                    System.out.printf(""%d\n"", -1);
                    return ;
                }
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0]+"",""+Open[1];
                    System.out.println(s);
                    break;
                }
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}
@e819de00cbb3e64ee6a252cf76d5ff8e@"
"r04945022","0","0","0","@1ed4c77996969a4feb33565ab408fbfa@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
//        try{
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while(!data.isEmpty()){
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
//             System.out.println(inputnumber1+"",""+inputnumber2); check my lines
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
             data = br.readLine();
        }
//        }catch(IOException ex){
//            err.println(ex.getMessage());
//        } 
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
         
     
    }
    
}
@1ed4c77996969a4feb33565ab408fbfa@"
"r04945022","0","0","0","@f77d8935f28d75611ce106f6e8e64d2e@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try{
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while(!data.isEmpty()){
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
//             System.out.println(inputnumber1+"",""+inputnumber2); check my lines
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
             data = br.readLine();
        }
        }catch(IOException ex){
            err.println(ex.getMessage());
        } 
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
         
     
    }
    
}
@f77d8935f28d75611ce106f6e8e64d2e@"
"b01502105","5","0.92","105728","@60f1597ad07bd3cb5b7e3420cd7c8312@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //inout size
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
//            System.out.printf(data[1]+"" ""+data[2]+""\n"");
            for (int j = 1; j <= num; j++) {
                uf.union(index[0], index[j]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open - 1], index[open]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open + 1], index[open]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
//                        System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}
@60f1597ad07bd3cb5b7e3420cd7c8312@"
"r04631031","5","0.52","127120","@c4da23b285a7b9f71618ed5f67e0d7f6@
//import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int num = size * size + 2;

            //build checkmatrix which is bigger than matrix and cover all matrix
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(num);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point num
            for (int i = num - size-1; i <= num - 2; i++) {
                uf.union(i, num-1);
            }
            
            int row = 0;
            int column = 0;
            int matrixnum = 0;      
            do {
                //read the input data
                String[] announce = br.readLine().split("","");
                row = Integer.parseInt(announce[0]);
                column = Integer.parseInt(announce[1]);
                matrixnum = size * (row - 1) + column;

                //mark the announced site
                checkmatrix[row][column] = true;

                //check up, down, left, right side of announced site
                while (checkmatrix[row - 1][column]) {
                    uf.union(matrixnum, matrixnum - size);
                    break;
                }
                while (checkmatrix[row + 1][column]) {
                    uf.union(matrixnum, matrixnum + size);
                    break;
                }
                while (checkmatrix[row][column - 1]) {
                    uf.union(matrixnum, matrixnum - 1);
                    break;
                }
                while (checkmatrix[row][column + 1]) {
                    uf.union(matrixnum, matrixnum + 1);
                    break;
                }
            } 
            while (!uf.connected(0, num-1));
            
            System.out.printf(""%d,%d"", row, column);
        }
    }
}

@c4da23b285a7b9f71618ed5f67e0d7f6@"
"r04631031","0","0","0","@75fbc0d08d61b7e1a390660bed0c3b05@
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int num = size * size + 2;

            //build checkmatrix which is bigger than matrix and cover all matrix
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(num);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point num
            for (int i = num - size-1; i <= num - 2; i++) {
                uf.union(i, num-1);
            }
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
            int matrixnum = 0;      
            do {
                //read the input data
                announce = br.readLine().split("","");
                row = Integer.parseInt(announce[0]);
                column = Integer.parseInt(announce[1]);
                matrixnum = size * (row - 1) + column;

                //mark the announced site
                checkmatrix[row][column] = true;

                //check up, down, left, right side of announced site
                while (checkmatrix[row - 1][column]) {
                    uf.union(matrixnum, matrixnum - size);
                    break;
                }
                while (checkmatrix[row + 1][column]) {
                    uf.union(matrixnum, matrixnum + size);
                    break;
                }
                while (checkmatrix[row][column - 1]) {
                    uf.union(matrixnum, matrixnum - 1);
                    break;
                }
                while (checkmatrix[row][column + 1]) {
                    uf.union(matrixnum, matrixnum + 1);
                    break;
                }
            } 
            while (!uf.connected(0, num-1));
            
            System.out.printf(""%d,%d"", row, column);
        }
    }
}

@75fbc0d08d61b7e1a390660bed0c3b05@"
"r04631031","5","0.49","122448","@5883a1b9b53434fc7ddb73f177b91b4d@
//import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int num = size * size + 2;

            //build checkmatrix which is bigger than matrix and cover all matrix
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(num);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point num
            for (int i = num - size-1; i <= num - 2; i++) {
                uf.union(i, num-1);
            }
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
            int matrixnum = 0;      
            do {
                //read the input data
                announce = br.readLine().split("","");
                row = Integer.parseInt(announce[0]);
                column = Integer.parseInt(announce[1]);
                matrixnum = size * (row - 1) + column;

                //mark the announced site
                checkmatrix[row][column] = true;

                //check up, down, left, right side of announced site
                while (checkmatrix[row - 1][column]) {
                    uf.union(matrixnum, matrixnum - size);
                    break;
                }
                while (checkmatrix[row + 1][column]) {
                    uf.union(matrixnum, matrixnum + size);
                    break;
                }
                while (checkmatrix[row][column - 1]) {
                    uf.union(matrixnum, matrixnum - 1);
                    break;
                }
                while (checkmatrix[row][column + 1]) {
                    uf.union(matrixnum, matrixnum + 1);
                    break;
                }
            } 
            while (!uf.connected(0, num-1));
            
            System.out.printf(""%d,%d"", row, column);
        }
    }
}

@5883a1b9b53434fc7ddb73f177b91b4d@"
"r04631023","9","0.9","122144","@48d47fdcc669db0bb7c6f3f8767d73a2@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("" "");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String() ;             
            String[] Open = new String[2] ;

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","") ;
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if(x > N || y > N || x < 1 || y < 1){
                    System.out.printf(""%d\n"", -1);
                    return ;
                }
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0]+"",""+Open[1];
                    System.out.println(s);
                    break;
                }
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}

@48d47fdcc669db0bb7c6f3f8767d73a2@"
"r04945022","0","0","0","@c3c34531a15f9a8921b29d183c352d16@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while(!data.isEmpty()){
            try{
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
             data = br.readLine();
             }catch(IOException ex){
            err.println(ex.getMessage());
        } 
        }
        
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
         
     
    }
    
}
@c3c34531a15f9a8921b29d183c352d16@"
"r04631023","9","0.91","126592","@7699790302a99a3677529331f2355bb1@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String data = br.readLine();

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String() ;             
            String[] Open = new String[2] ;

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","") ;
                if(Open[0].isEmpty()){
                    System.out.printf(""%d\n"", -1);
                    return ;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if(x > N || y > N || x < 1 || y < 1){
                    System.out.printf(""%d\n"", -1);
                    return ;
                }
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y -N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y -N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0]+"",""+Open[1];
                    System.out.println(s);
                    break;
                }
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}

@7699790302a99a3677529331f2355bb1@"
"r03522809","0","1.27","136688","@d946befe7f6014f5e489cf4d66c58c3f@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ans=0,res=0;
        QuickUnionUF uf = new QuickUnionUF(N*N+2);
        System.out.println(N);
        int i =0;
        int x =0 , y =0;
        int checkxup =0 , checkxdown =0, checkyleft = 0, checkyright =0 ;
        int checkansup=0,checkansdown=0,checkansleft=0,checkansright=0;
        int sysend=0 ,findx=0,findy=0;
        String d;
        
        while( (d = br.readLine()) != null )
        {
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            ans = (x-1)*N+y;
            
            if(x==1)
            {
                uf.union(ans,0);
            }
            if(x==N)
            {
                uf.union(ans,N*N+1);
            }
            checkxup=x-1;
            checkansup = (checkxup-1)*N+y;
            checkxdown=x+1;
            checkansdown = (checkxdown-1)*N+y;
            checkyleft=y-1;
            checkansleft = (x-1)*N+checkyleft;
            checkyright=y+1;
            checkansright = (x-1)*N+checkyright;
            
            if( checkxup != 0 )
            {
                uf.union(ans,checkansup);
            }
            if( checkxdown < N )
            {
                uf.union(ans,checkansdown);          
            }
            if( checkyleft != 0)
            {
                  uf.union(ans,checkansleft);         
            }
            if( checkyright < N )
            {
                  uf.union(ans,checkansright);   
            }
            
            if(uf.connected(0, N*N+1) && sysend == 0)
            {
                sysend = 1;
                findx = x;
                findy = y;
            }

        }
        
        if( sysend == 1)
        {                
            System.out.println(findx +"",""+ findy);
        }
        else if( sysend != 1)
        {                
            System.out.println(-1);
        }
        
        }
    }
}
@d946befe7f6014f5e489cf4d66c58c3f@"
"r03522809","6","1.25","138064","@14a2faad794f476c059ac188945ec3e9@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ans=0,res=0;
        QuickUnionUF uf = new QuickUnionUF(N*N+2);

        int i =0;
        int x =0 , y =0;
        int checkxup =0 , checkxdown =0, checkyleft = 0, checkyright =0 ;
        int checkansup=0,checkansdown=0,checkansleft=0,checkansright=0;
        int sysend=0 ,findx=0,findy=0;
        String d;
        
        while( (d = br.readLine()) != null )
        {
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            ans = (x-1)*N+y;
            
            if(x==1)
            {
                uf.union(ans,0);
            }
            if(x==N)
            {
                uf.union(ans,N*N+1);
            }
            checkxup=x-1;
            checkansup = (checkxup-1)*N+y;
            checkxdown=x+1;
            checkansdown = (checkxdown-1)*N+y;
            checkyleft=y-1;
            checkansleft = (x-1)*N+checkyleft;
            checkyright=y+1;
            checkansright = (x-1)*N+checkyright;
            
            if( checkxup != 0 )
            {
                uf.union(ans,checkansup);
            }
            if( checkxdown < N )
            {
                uf.union(ans,checkansdown);          
            }
            if( checkyleft != 0)
            {
                  uf.union(ans,checkansleft);         
            }
            if( checkyright < N )
            {
                  uf.union(ans,checkansright);   
            }
            
            if(uf.connected(0, N*N+1) && sysend == 0)
            {
                sysend = 1;
                findx = x;
                findy = y;
            }

        }
        
        if( sysend == 1)
        {                
            System.out.println(findx +"",""+ findy);
        }
        else if( sysend != 1)
        {                
            System.out.println(-1);
        }
        
        }
    }
}
@14a2faad794f476c059ac188945ec3e9@"
"r04631025","0","0.91","126592","@36aea7dc9af8f42381498306323a0e11@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    
    UF uf;// = new UF(N * N);

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 1; i <= a; i++) {
            id[i - 1] = i;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 2][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (x != 3) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 2], matrix[x - 1][y - 1]);
            }
        }
        if (y != 3) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        if(uf.connected(matrix[2][2], matrix[0][0])||uf.connected(matrix[2][1],matrix[0][0])||uf.connected(matrix[2][0],matrix[0][0])){
            return true;
        }
        else return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@36aea7dc9af8f42381498306323a0e11@"
"r04631025","5","0.54","105760","@3cb94d065612cf52b4af23ea365b70a1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    
    UF uf;// = new UF(N * N);

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 1; i <= a; i++) {
            id[i - 1] = i;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 2][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (x != 3) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 2], matrix[x - 1][y - 1]);
            }
        }
        if (y != 3) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        if(uf.connected(matrix[2][2], matrix[0][0])||uf.connected(matrix[2][1],matrix[0][0])||uf.connected(matrix[2][0],matrix[0][0])){
            return true;
        }
        else return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@3cb94d065612cf52b4af23ea365b70a1@"
"r04631025","7","1.01","125120","@7ec89bdcd3a3829f69c228ec3cf343f3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    private int N;
    UF uf;// = new UF(N * N);

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        N=n;
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 1; i <= a; i++) {
            id[i - 1] = i;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 2][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (x != N) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 2], matrix[x - 1][y - 1]);
            }
        }
        if (y != N) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        if(uf.connected(matrix[N-1][N-1], matrix[0][0])||uf.connected(matrix[N-1][N-2],matrix[0][0])||uf.connected(matrix[N-1][N-3],matrix[0][0])){
            return true;
        }
        else return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@7ec89bdcd3a3829f69c228ec3cf343f3@"
"r04631023","10","0.101","125520","@eca5d12029dfb6f56ee42129584d5c3e@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author SimonHan
 */
public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String data = br.readLine();

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data);

            // initilization of aUF uf = new UF(N*N+2) ; String array in Java
            String[][] matrix = new String[N][N];

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if(N == 1){
                    System.out.println(""1,1"");
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                id[N * (x - 1) + y] = N * (x - 1) + y;
                if (x != 1 && x != N && y != 1 && y != N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == 1 && y == N) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == N && y == 1) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N && y == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                } else if (x == 1) {
                    uf.union(0, N * (x - 1) + y);
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (x == N) {
                    uf.union(N * N + 1, N * (x - 1) + y);
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == 1) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y + 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                        }
                    }
                } else if (y == N) {
                    if (id[N * (x - 1) + y - N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                        }
                    }
                    if (id[N * (x - 1) + y + N] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                        }
                    }
                    if (id[N * (x - 1) + y - 1] != 0) {
                        if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                            uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                        }
                    }
                }
                if (uf.connected(0, N * N + 1)) {
                    String s = Open[0] + "","" + Open[1];
                    System.out.println(s);
                    break;
                }
            }
            if (!uf.connected(0, N * N + 1)) {
                System.out.printf(""%d\n"", -1);
            }
        }
    }
}

@eca5d12029dfb6f56ee42129584d5c3e@"
"r03522809","6","1.28","134352","@84cd315fb2556f4a5394cb4ed1a6698e@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ans=0,res=0;
        QuickUnionUF uf = new QuickUnionUF(N*N+2);

        int i =0;
        int x =0 , y =0;
        int checkxup =0 , checkxdown =0, checkyleft = 0, checkyright =0 ;
        int checkansup=0,checkansdown=0,checkansleft=0,checkansright=0;
        int sysend=0 ,findx=0,findy=0;
        String d;
        
        while( (d = br.readLine()) != null )
        {
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            ans = (x-1)*N+y;
            
            if(x==1)
            {
                uf.union(ans,0);
            }
            if(x==N)
            {
                uf.union(ans,N*N+1);
            }
            
            checkxup=x-1;
            checkansup = (checkxup-1)*N+y;
            if( checkxup != 0 )
            {
                uf.union(ans,checkansup);
            }
            
            checkxdown=x+1;
            checkansdown = (checkxdown-1)*N+y;
            if( checkxdown < N )
            {
                uf.union(ans,checkansdown);          
            }
            
            checkyleft=y-1;
            checkansleft = (x-1)*N+checkyleft;
            if( checkyleft != 0)
            {
                  uf.union(ans,checkansleft);         
            }
            
            checkyright=y+1;
            checkansright = (x-1)*N+checkyright;
            if( checkyright < N )
            {
                  uf.union(ans,checkansright);   
            }
            
            if(uf.connected(0, N*N+1) && sysend == 0)
            {
                sysend = 1;
                findx = x;
                findy = y;
            }

        }
        
        if( sysend == 1)
        {                
            System.out.println(findx +"",""+ findy);
        }
        else if( sysend != 1)
        {                
            System.out.println(-1);
        }
        
        }
    }
}
@84cd315fb2556f4a5394cb4ed1a6698e@"
"r04631034","0","1.16","232896","@cdf369094e64299f84031c50ab10169c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.*;
import java.util.*;

/**
 *
 * @author user
 */
public class Percolation {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);

          int num = Integer.parseInt(in.readLine());
//          System.out.println(num);
          ArrayList<Integer> Row = new ArrayList<Integer>();
          ArrayList<Integer> Column = new ArrayList<Integer>();

          String line;
          while ((line = in.readLine()) != null) {
               Row.add(Integer.parseInt(line.split("","")[0]) - 1);
               Column.add(Integer.parseInt(line.split("","")[1]) - 1);
          }
          for (int i = 0; i < Row.size(); i++) {
               System.out.print(Row.get(i) + "","" + Column.get(i));
               System.out.println("""");
          }
          UF uf = new UF(num * num + 2);//   num*num+1  top  node   num*num+2 bottom node
          int[][] OpenSiteStorge = new int[Row.size()][Row.size()];

          for (int i = 0; i < Row.size(); i++) 
          {                       //Row.get(i) * num + Column.get(i) means ID index    /input coornate
                    if(Row.get(i)<num && Column.get(i)<num)
                    {
//               set open site up
               OpenSiteStorge[Row.get(i)][Column.get(i)] = 1;

//               top row connect to the top node
               if (Row.get(i) == 0) 
               {
                    uf.union(Row.get(i) * num + Column.get(i), num * num);
                    if ( Row.get(i)+1<num &&OpenSiteStorge[Row.get(i) + 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) + 1) * num + Column.get(i));
                    }
                     if (Column.get(i) == 0) 
                      {
                              if (Column.get(i)+1<num &&OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                      } 
                     else if (Column.get(i) == num - 1)
                     {
                              if (Column.get(i)-1>=0 && OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                               }
                      } 
                         else 
                         {
                              if (num-(Column.get(i)+1)>0 &&OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (Column.get(i)-1>=0 &&OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }
           }

//               last row connect to the bottom node
          if (Row.get (i)   == num - 1)
          {
                    uf.union(Row.get(i) * num + Column.get(i), num * num + 1);
                     if (Row.get(i)-1>=0 && OpenSiteStorge[Row.get(i) - 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) - 1) * num + Column.get(i));
                         }  
                         if (Column.get(i) == 0) 
                         {
                              if (num-(Column.get(i)+1)>0 && OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (Column.get(i)-1>=0 && OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (num-(Column.get(i)+1)>0 && OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (Column.get(i)-1>=0 &&OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }      
     }
          else if(Row.get (i)  != num - 1 && Row.get (i)   != 0)//middle row 
            {               
               if (Column.get(i) == 0) 
                         {
                              if (Row.get(i)-1>=0 && OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (Row.get(i)+1<num && OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if ( Column.get(i)+1<num && OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
               else if (Column.get(i) == num-1) 
                         {
                              if (Row.get(i)-1>=0 && OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (Row.get(i)+1<num && OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if ( Column.get(i)-1>=0 && OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                         } 
               else if (Column.get(i) != num-1 && Column.get(i) != 0) 
                         {
                              if (Row.get(i)-1>=0 &&OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if ( Row.get(i)+1<num &&  OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (Column.get(i)-1>=0 && OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                              if ( Column.get(i)+1<num && OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
          }
     
     if(uf.connected(num*num, num*num+1) == true)
     {
//          System.out.println(""output:"");
          System.out.println((Row.get(i)+1)+"",""+(Column.get(i)+1));
          break;
     }
     if( i == Row.size() - 1 && uf.connected(num*num, num*num+1) == false )
     {           
               System.out.println(""-1"");
     }
     }
}
//for(int i = 0 ; i < num;i++){
//                    System.out.println(OpenSiteStorge[i][0]+"" ""+OpenSiteStorge[i][1]+"" ""+OpenSiteStorge[i][2]);
//          }
//          System.out.println(uf.connected(num*num, num*num+1));
//          System.out.println(uf.connected(0, 3));
//          System.out.println(uf.connected(0, num * num));
//          System.out.println(uf.connected(6, num * num + 1));
//          System.out.println(uf.connected(7, num * num + 1));
//          System.out.println(uf.connected(8, num * num + 1));
     }
}
@cdf369094e64299f84031c50ab10169c@"
"r04631025","2","0.96","109056","@62a113168eecde00e154f2452d236885@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    private int N;
    UF uf;// = new UF(N * N);

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        N=n;
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 1; i <= a; i++) {
            id[i - 1] = i;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 2][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (x != N) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 2], matrix[x - 1][y - 1]);
            }
        }
        if (y != N) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        //if(uf.connected(matrix[N-1][N-1], matrix[0][0])||uf.connected(matrix[N-1][N-2],matrix[0][0])||uf.connected(matrix[N-1][N-3],matrix[0][0])){
        for(int i=N*N-1;i>N*2;i--){
            if(uf.find(i)!=i){
                return true;
            }
        }
        return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@62a113168eecde00e154f2452d236885@"
"r04631025","7","1.03","134064","@44362ea9332910895215225a405a8901@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    private int N;
    UF uf;// = new UF(N * N);

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        N=n;
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 1; i <= a; i++) {
            id[i - 1] = i;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 2][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (x != N) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x][y - 1], matrix[x - 1][y - 1]);
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 2], matrix[x - 1][y - 1]);
            }
        }
        if (y != N) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        if(uf.connected(matrix[N-1][N-1], matrix[0][0])||uf.connected(matrix[N-1][N-2],matrix[0][0])||uf.connected(matrix[N-1][N-3],matrix[0][0])){
            return true;
        }
//        for(int i=N*N-1;i>N*2;i--){
//            if(uf.find(i)!=i){
//                return true;
//            }
//        }
        else return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@44362ea9332910895215225a405a8901@"
"r04631025","9","3.21","149360","@4124c10933e1a82cc4e5820c13bfe581@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    private int N;
    UF uf;// = new UF(N * N);

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        N=n;
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 1; i <= a; i++) {
            id[i - 1] = i;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 2][y - 1]);
            }
        }
        if (x != N) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1],matrix[x][y - 1] );
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 1][y - 2]);
            }
        }
        if (y != N) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
//        if(uf.connected(matrix[N-1][N-1], matrix[0][0])||uf.connected(matrix[N-1][N-2],matrix[0][0])||uf.connected(matrix[N-1][N-3],matrix[0][0])){
//            return true;
//        }
        for(int i=1;i<=N;i++){
            for(int j=0;j<N;j++){
                if(uf.connected(matrix[N-1][N-i],matrix[0][j])){
                    return true;
                }
            }
        }
        return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@4124c10933e1a82cc4e5820c13bfe581@"
"r03522809","8","1.02","129776","@f321b2c441511aceba08c3b779689d0c@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ans=0,res=0;
        QuickUnionUF uf = new QuickUnionUF(N*N+2);

        int i =0;
        int x =0 , y =0;
        int checkxup =0 , checkxdown =0, checkyleft = 0, checkyright =0 ;
        int checkansup=0,checkansdown=0,checkansleft=0,checkansright=0;
        int sysend=0 ,findx=0,findy=0;
        int [][] table =new int [N][N];
        String d;
        
        while( (d = br.readLine()) != null )
        {
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=1;
            ans = (x-1)*N+y;
            
            if(x==1)
            {
                uf.union(ans,0);
            }
            if(x==N)
            {
                uf.union(ans,N*N+1);
            }
            
            checkxup=x-1;
            checkansup = (checkxup-1)*N+y;
            if( checkxup != 0 && table[checkxup-1][y-1]==1)
            {
                uf.union(ans,checkansup);
            }
            
            checkxdown=x+1;
            checkansdown = (checkxdown-1)*N+y;
            if( checkxdown < N && table[checkxdown-1][y-1]==1 )
            {
                uf.union(ans,checkansdown );          
            }
            
            checkyleft=y-1;
            checkansleft = (x-1)*N+checkyleft;
            if( checkyleft != 0 && table[x-1][checkyleft-1]==1)
            {
                  uf.union(ans,checkansleft);         
            }
            
            checkyright=y+1;
            checkansright = (x-1)*N+checkyright;
            if( checkyright < N && table[x-1][checkyright-1]==1 )
            {
                  uf.union(ans,checkansright);   
            }
            
            if(uf.connected(0, N*N+1) && sysend == 0)
            {
                sysend = 1;
                findx = x;
                findy = y;
            }

        }
        
        if( sysend == 1)
        {                
            System.out.println(findx +"",""+ findy);
        }
        else if( sysend != 1)
        {                
            System.out.println(-1);
        }
        
        }
    }
}
@f321b2c441511aceba08c3b779689d0c@"
"r04631009","3","0.88","127072","@ca190527bcb0c34bf9e8ed25bbbbd5a8@
/**
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//

            int xold = 0;
            int yold = 0;
            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column

                if (br.readLine() != null) {

                    if (matrix[xold][yold] == 2 && xold == size - 1) {
                        System.out.println(xold + "","" + yold);
                    } 

                }
                if (br.readLine() == null){
                    if (matrix[xold][yold] == 2 && xold == size - 1) {
                        System.out.println(xold + "","" + yold);
                    } else {
                        System.out.println(""-1"");
                    }
                }
                xold=x;
                yold=y;

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;

                //test for neighbor
                //when the site is on the top
                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }
                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }
                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }

            }

        }

    }
}

@ca190527bcb0c34bf9e8ed25bbbbd5a8@"
"r04631034","8","1.12","230000","@a8a296664c29cf27bf4b3ad5631d6c54@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.*;
import java.util.*;

/**
 *
 * @author user
 */
public class Percolation {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);

          int num = Integer.parseInt(in.readLine());
//          System.out.println(num);
          ArrayList<Integer> Row = new ArrayList<Integer>();
          ArrayList<Integer> Column = new ArrayList<Integer>();

          String line;
          while ((line = in.readLine()) != null) {
               Row.add(Integer.parseInt(line.split("","")[0]) - 1);
               Column.add(Integer.parseInt(line.split("","")[1]) - 1);
          }
//          for (int i = 0; i < Row.size(); i++) {
//               System.out.print(Row.get(i) + "","" + Column.get(i));
//               System.out.println("""");
//          }
          UF uf = new UF(num * num + 2);//   num*num+1  top  node   num*num+2 bottom node
          int[][] OpenSiteStorge = new int[Row.size()][Row.size()];
           
          if(num!=1){
                  
          
          
          
          for (int i = 0; i < Row.size(); i++) 
          {                       //Row.get(i) * num + Column.get(i) means ID index    /input coornate
                    if(Row.get(i)<num && Column.get(i)<num)
                    {
//               set open site up
               OpenSiteStorge[Row.get(i)][Column.get(i)] = 1;

//               top row connect to the top node
               if (Row.get(i) == 0) 
               {
                    uf.union(Row.get(i) * num + Column.get(i), num * num);
                    if (OpenSiteStorge[Row.get(i) + 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) + 1) * num + Column.get(i));
                    }
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }
           }

//               last row connect to the bottom node
          else if (Row.get (i)   == num - 1)
          {
                    uf.union(Row.get(i) * num + Column.get(i), num * num + 1);
                     if (OpenSiteStorge[Row.get(i) - 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) - 1) * num + Column.get(i));
                         }  
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }      
     }
          else if(Row.get (i)  != num - 1 && Row.get (i)   != 0)//middle row 
            {               
               if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
               else if (Column.get(i) == num-1) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                         } 
               else if (Column.get(i) != num-1 && Column.get(i) != 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
          }
     
     if(uf.connected(num*num, num*num+1) == true)
     {
//          System.out.println(""output:"");
          System.out.println((Row.get(i)+1)+"",""+(Column.get(i)+1));
          break;
     }
     if( i == Row.size() - 1 && uf.connected(num*num, num*num+1) == false )
     {           
               System.out.println(""-1"");
     }
     }
}
          }
          else{
          System.out.println((Row.get(0)+1)+"",""+(Column.get(0)+1));
          }
//for(int i = 0 ; i < num;i++){
//                    System.out.println(OpenSiteStorge[i][0]+"" ""+OpenSiteStorge[i][1]+"" ""+OpenSiteStorge[i][2]);
//          }
//          System.out.println(uf.connected(num*num, num*num+1));
//          System.out.println(uf.connected(0, 3));
//          System.out.println(uf.connected(0, num * num));
//          System.out.println(uf.connected(6, num * num + 1));
//          System.out.println(uf.connected(7, num * num + 1));
//          System.out.println(uf.connected(8, num * num + 1));
     }
}
@a8a296664c29cf27bf4b3ad5631d6c54@"
"r04631031","5","0.49","126528","@59dc96c9bfa911dd259b9645b34bac33@
//import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int NumOfmatrix = size * size + 2;

            //build checkmatrix which is bigger than old matrix and cover it
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(NumOfmatrix);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point matrixNum-1
            for (int i = NumOfmatrix - size-1; i <= NumOfmatrix - 2; i++) {
                uf.union(i, NumOfmatrix-1);
            }
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
            int matrixnum = 0;      
            do {
                //read the input data
                announce = br.readLine().split("","");
                row = Integer.parseInt(announce[0]);
                column = Integer.parseInt(announce[1]);
                matrixnum = size * (row - 1) + column;

                //mark the announced site
                checkmatrix[row][column] = true;

                //check up, down, left, right side of announced site
                while (checkmatrix[row - 1][column]) {
                    uf.union(matrixnum, matrixnum - size);
                    break;
                }
                while (checkmatrix[row + 1][column]) {
                    uf.union(matrixnum, matrixnum + size);
                    break;
                }
                while (checkmatrix[row][column - 1]) {
                    uf.union(matrixnum, matrixnum - 1);
                    break;
                }
                while (checkmatrix[row][column + 1]) {
                    uf.union(matrixnum, matrixnum + 1);
                    break;
                }
            } 
            while (!uf.connected(0, NumOfmatrix-1));
            
            System.out.printf(""%d,%d"", row, column);
        }
    }
}

@59dc96c9bfa911dd259b9645b34bac33@"
"r03522809","10","0.099","133600","@cd6f9fe0ebad4fdd3c2ad80130ee7038@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
 
     try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ans=0,res=0;
        QuickUnionUF uf = new QuickUnionUF(N*N+2);

        int i =0;
        int x =0 , y =0;
        int checkxup =0 , checkxdown =0, checkyleft = 0, checkyright =0 ;
        int checkansup=0,checkansdown=0,checkansleft=0,checkansright=0;
        int sysend=0 ,findx=0,findy=0;
        int [][] table = new int [N][N];
        String d;
        
        while( (d = br.readLine()) != null )
        {
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=1;
            ans = (x-1)*N+y;
            
            if(x==1)
            {
                uf.union(ans,0);
            }
            if(x==N)
            {
                uf.union(ans,N*N+1);
            }
            
            checkxup=x-1;
            checkansup = (checkxup-1)*N+y;
            
            if( checkxup != 0 && table[checkxup-1][y-1]==1)
            {
                uf.union(ans,checkansup);
            }
            
            checkxdown=x+1;
            checkansdown = (checkxdown-1)*N+y;
            if( checkxdown <= N && table[checkxdown-1][y-1]==1 )
            {
                uf.union(ans,checkansdown );          
            }
            
            checkyleft=y-1;
            checkansleft = (x-1)*N+checkyleft;
            
            if( checkyleft != 0 && table[x-1][checkyleft-1]==1)
            {
                  uf.union(ans,checkansleft);         
            }
            
            checkyright=y+1;
            checkansright = (x-1)*N+checkyright;
            if( checkyright <= N && table[x-1][checkyright-1]==1 )
            {
                  uf.union(ans,checkansright);   
            }
            
            if(uf.connected(0, N*N+1) && sysend == 0)
            {
                sysend = 1;
                findx = x;
                findy = y;
            }

        }
        
        if( sysend == 1)
        {                
            System.out.println(findx +"",""+ findy);
        }
        else if( sysend != 1)
        {                
            System.out.println(-1);
        }
        
//        for(int k=0;k<N;k++)
//        {
//        for(int j=0;j<N;j++)
//            {
//                System.out.println(table[k][j]);
//            }
//        }
//        }
        
    }
}
}
@cd6f9fe0ebad4fdd3c2ad80130ee7038@"
"r04631031","0","0.49","126528","@2e69d9ee3e062e41f11a23e40ed65898@
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int NumOfmatrix = size * size + 2;

            //build checkmatrix which is bigger than old matrix and cover it
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(NumOfmatrix);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point matrixNum-1
            for (int i = NumOfmatrix - size-1; i <= NumOfmatrix - 2; i++) {
                uf.union(i, NumOfmatrix-1);
            }
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
            int matrixnum = 0;     
            int count = 0;
            int errnum = -1;
            do {
                //read the input data
                announce = br.readLine().split("","");
                row = Integer.parseInt(announce[0]);
                column = Integer.parseInt(announce[1]);
                matrixnum = size * (row - 1) + column;

                //mark the announced site
                checkmatrix[row][column] = true;

                //check up, down, left, right side of announced site
                while (checkmatrix[row - 1][column]) {
                    uf.union(matrixnum, matrixnum - size);
                    break;
                }
                while (checkmatrix[row + 1][column]) {
                    uf.union(matrixnum, matrixnum + size);
                    break;
                }
                while (checkmatrix[row][column - 1]) {
                    uf.union(matrixnum, matrixnum - 1);
                    break;
                }
                while (checkmatrix[row][column + 1]) {
                    uf.union(matrixnum, matrixnum + 1);
                    break;
                }
                count++;
                if(count >= NumOfmatrix-2){
                    break;
                }
            } 
            while (!uf.connected(0, NumOfmatrix-1));
            if(count >= NumOfmatrix-2){
                System.out.println(""-1"");
            }
            else{
                System.out.printf(""%d,%d"", row, column);
            }
        }
    }
}

@2e69d9ee3e062e41f11a23e40ed65898@"
"r04631031","4","0.49","127296","@a4af473f1ca055286cbd1b911c4bea09@
//import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int NumOfmatrix = size * size + 2;

            //build checkmatrix which is bigger than old matrix and cover it
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(NumOfmatrix);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point matrixNum-1
            for (int i = NumOfmatrix - size-1; i <= NumOfmatrix - 2; i++) {
                uf.union(i, NumOfmatrix-1);
            }
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
            int matrixnum = 0;     
            int count = 0;
            int errnum = -1;
            do {
                //read the input data
                announce = br.readLine().split("","");
                row = Integer.parseInt(announce[0]);
                column = Integer.parseInt(announce[1]);
                matrixnum = size * (row - 1) + column;

                //mark the announced site
                checkmatrix[row][column] = true;

                //check up, down, left, right side of announced site
                while (checkmatrix[row - 1][column]) {
                    uf.union(matrixnum, matrixnum - size);
                    break;
                }
                while (checkmatrix[row + 1][column]) {
                    uf.union(matrixnum, matrixnum + size);
                    break;
                }
                while (checkmatrix[row][column - 1]) {
                    uf.union(matrixnum, matrixnum - 1);
                    break;
                }
                while (checkmatrix[row][column + 1]) {
                    uf.union(matrixnum, matrixnum + 1);
                    break;
                }
                count++;
                if(count >= NumOfmatrix-2){
                    break;
                }
            } 
            while (!uf.connected(0, NumOfmatrix-1));
            //print the result of percolation
            if(count >= NumOfmatrix-2){
                System.out.println(""-1"");
            }
            else{
                System.out.printf(""%d,%d"", row, column);
            }
        }
    }
}

@a4af473f1ca055286cbd1b911c4bea09@"
"b03611033","8","0.99","128176","@07e2af2e33019b6a0d612ecedd01117c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {    
   private boolean[] matrix;
   private int[] self;  
    public Percolation(int n){
        matrix = new boolean[n*n];
        self = new int[n*n];
        for(int i=0;i<n*n;i++){
            if(i<n){
                self[i]=0;
            }
            else if(i>(n-1)*n-1){
                self[i]=n*n;
            }
            else{
                self[i]=i;
            }    
        }
    }
    
    public void line(int n,int p,int q){
         matrix[p*n+q] = true;
         if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                self[p*n+q]=self[p*n+(q-1)];
            }
        }
        if(p>0){
            if(matrix[p*n+q] & matrix[(p-1)*n+q]){
                self[p*n+q]=self[(p-1)*n+q];
            }
        }
        if(p<n-1){
            if(matrix[p*n+q] & matrix[(p+1)*n+q]){
                self[(p+1)*n+q]=self[p*n+q];
            }
        }
        
        if(q<n-1){
            if(matrix[p*n+q] & matrix[p*n+(q+1)]){
                self[p*n+(q+1)]=self[p*n+q];
            }
        }
    }
    
    public boolean percolates(int n){
        for(int i=(n-1)*n;i<n*n;i++){
            if(self[i]==0){
                return true;
            }
        }
        return false;
        
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String data = br.readLine();
                int N = Integer.parseInt(data);
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    percolation.line(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
            }
        }        
    }


@07e2af2e33019b6a0d612ecedd01117c@"
"b03611003","9","0.99","122320","@3c74f3f0a135ad32e78f36d2f909c278@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 */
public class Percolation {

    /**
     * @param args the command line arguments
     *
     *
     * by union!!!!!!!!!!!!!!
     *
     *
     *
     *
     */
    private static int[] id;
    private static int[] bw;
//    0 as black, 1 as white
    static int N;
    static int siteid;

    public Percolation(int N) {
//        initial the id&bw of the mitrix
        id = new int[N * N + 2];
        bw = new int[N * N + 2];
//       [0] is top, [N+1] is bottom
        for (int i = 0; i < N * N + 2; i++) {
            id[i] = i;
            bw[i] = 0;
        }
//       martix begin from 1 end at N
        bw[0] = 1;
        bw[N * N + 1] = 1;
    }

    public static void open(int row, int col) {
//        open a new site and check the connection
        siteid = (row - 1) * N + col;
        bw[siteid] = 1;

        if (siteid <= N) {
            union(siteid, 0);
//          connect the top     

            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
//            connect the one below

        } else if (siteid > N * N - N) {
            union(siteid, N * N + 1);
//          connect the bottom 

            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
//            connect the one above

        } else {
//          the sites between
            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
            if (bw[siteid - 1] == 1) {
                union(siteid, siteid - 1);
            }
            if (bw[siteid + 1] == 1) {
                union(siteid, siteid + 1);
            }
            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
        }

    }

    public static void union(int A, int B) {
//        把id 設成最小的位子
        int a = root(A);
        int b = root(B);

        if (a < b) {
            id[b] = a;
        } else {
            id[a] = b;
        }
    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static boolean connection(int A, int B) {
        return root(A) == root(B);
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            N = Integer.parseInt(data);

            Percolation matrix = new Percolation(N);

            String[] randc = new String[2];
            int row = 0;
            int col = 0;
            String brs;
            
            while (!connection(0, N * N + 1)) {

                brs = br.readLine();

                if (brs == null) {
                    System.out.print(-1);
                    break;
                }
                randc = brs.split("","");
                row = Integer.parseInt(randc[0]);
                col = Integer.parseInt(randc[1]);

                open(row, col);
            }

            if (br.readLine() != null) {
                System.out.print(row + "","" + col);
            }

        }
    }

}

@3c74f3f0a135ad32e78f36d2f909c278@"
"r04631009","6","0.89","122336","@2d2075789e6afbf6a513cf8958958468@
/**
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//

            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top

                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }

                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }

                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }

                }
                if (matrix[x][y] == 2 && x == size - 1) {
                    System.out.println(Integer.parseInt(data[0]) + "","" + Integer.parseInt(data[1]));
                    System.exit(0);
                }
            }

            System.out.println(""-1"");
            //show for debug
            //for (int i = 0; i < size; i++) {
            //    for (int j = 0; j < size; j++) {
            //        System.out.print(matrix[i][j] + "" "");
            //   }
            //   System.out.println("""");
            // }

        }

    }

}

@2d2075789e6afbf6a513cf8958958468@"
"r04631031","5","0.49","122432","@6622cdd141ac934ef8de0b0d8403ef9c@
//import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int NumOfmatrix = size * size + 2;

            //build checkmatrix which is bigger than old matrix and cover it
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(NumOfmatrix);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point matrixNum-1
            for (int i = NumOfmatrix - size-1; i <= NumOfmatrix - 2; i++) {
                uf.union(i, NumOfmatrix-1);
            }
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
            int matrixnum = 0;
            int count = 0;
            
             
            do {
                    announce = br.readLine().split("","");
                    while("""".equals(announce[0])){
                        count++;
                        break;
                    }
                    if(count == 1)
                        break;
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    matrixnum = size * (row - 1) + column;
                    //mark the announced site
                     checkmatrix[row][column] = true;

                    //check up, down, left, right side of announced site
                    while (checkmatrix[row - 1][column]) {
                        uf.union(matrixnum, matrixnum - size);
                        break;
                    }
                    while (checkmatrix[row + 1][column]) {
                        uf.union(matrixnum, matrixnum + size);
                        break;
                    }
                    while (checkmatrix[row][column - 1]) {
                        uf.union(matrixnum, matrixnum - 1);
                        break;
                    }
                    while (checkmatrix[row][column + 1]) {
                        uf.union(matrixnum, matrixnum + 1);
                        break;
                    }
            } 
            while (!uf.connected(0, NumOfmatrix-1));
            
            if(count == 1){
                System.out.printf(""-1"");
            }
            else
                System.out.printf(""%d,%d"", row, column);
            
        }
    }
}

@6622cdd141ac934ef8de0b0d8403ef9c@"
"b02611026","5","1.01","126992","@791f06654369010313742d6d69d08768@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            //Union the upper row
            for (int i = 0; i < matrix_length; i++) {
                uf.union(i, i + 1);
                if ((i + 1) == matrix_length) {
                    break;                    
                }
            }
            //Union the downner row
            for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                uf.union(i, i + 1);
                if ((i + 1) == (matrix_size-1)) {
                    break;                    
                }
            }
            //Create a matrx in order to mark the cell
            String[][] markmatrix = new String[matrix_length][matrix_length];
            for (int i = 0; i < matrix_length; i++) {
                for (int j = 0; j < matrix_length; j++) {
                    markmatrix[i][j] = ""0"";
                }
            }

            String[] pos;
            while (br.ready()) {
                pos = br.readLine().split("","");
                if (pos == null) {
                    break;
                }
                if (matrix_length == 0) {
                    state = -1;
                    break;
                }
//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");

                //mark the opened position
                int x = Integer.parseInt(pos[0]) - 1;
                int y = Integer.parseInt(pos[1]) - 1;
                if (matrix_length == 1) {
                    if (x == 0 && y == 0) {
                        state = 0;
                        System.out.printf(pos[0] + "" , "" + pos[1]);
                        break;
                    } else {
                        state = -1;
                        break;
                    }
                }
//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");

                markmatrix[x][y] = ""1"";
                int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                if (x == 0 && y == 0) { // 左上角
                    if (markmatrix[x][y + 1].equals(""1"")) {
                        uf.union(num, num + 1);
                        //System.out.printf(""a\n"");
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""b\n"");
                    }

                } else if (x == 0 && y == matrix_length - 1) { //右上角
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""c\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""d\n"");
                    }
                } else if (y == 0 && x == matrix_length - 1) { //左下角
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""e\n"");
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""f\n"");
                    }
                } else if (x == matrix_length - 1 && y == matrix_length - 1) { //右下角
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""g\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""h\n"");
                    }
                } else if (y == 0) { //最左排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""i\n"");
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""j\n"");
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""k\n"");
                    }
                } else if (x == 0) { //最上排
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""m\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""n\n"");
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""o\n"");
                    }
                } else if (y == matrix_length - 1) { //最右排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                       // System.out.printf(""p\n"");
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""q\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""r\n"");
                    }
                } else if (x == matrix_length - 1) { //最下排
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""s\n"");
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""t\n"");
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""u\n"");
                    }
                } else if (x != 0 && y != 0) {
                    //if up is opened
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""v\n"");
                    }
                    //if down is opened
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""w\n"");
                    }
                    //if left is opened
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""x\n"");
                    }
                    //if right is opened
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""y\n"");
                    }
                }

                if (uf.connected(0, matrix_size - 1)) {
                    state = 0;
                    System.out.printf(pos[0] + "" , "" + pos[1]);
                    //System.out.printf(""\n"");
                    break;
                } else {
                    state = -1;
                }

            }
            if (state == -1) {
                System.out.printf(""%d"", state);
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@791f06654369010313742d6d69d08768@"
"b02611026","5","1.02","125328","@791f06654369010313742d6d69d08768@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            //Union the upper row
            for (int i = 0; i < matrix_length; i++) {
                uf.union(i, i + 1);
                if ((i + 1) == matrix_length) {
                    break;                    
                }
            }
            //Union the downner row
            for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                uf.union(i, i + 1);
                if ((i + 1) == (matrix_size-1)) {
                    break;                    
                }
            }
            //Create a matrx in order to mark the cell
            String[][] markmatrix = new String[matrix_length][matrix_length];
            for (int i = 0; i < matrix_length; i++) {
                for (int j = 0; j < matrix_length; j++) {
                    markmatrix[i][j] = ""0"";
                }
            }

            String[] pos;
            while (br.ready()) {
                pos = br.readLine().split("","");
                if (pos == null) {
                    break;
                }
                if (matrix_length == 0) {
                    state = -1;
                    break;
                }
//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");

                //mark the opened position
                int x = Integer.parseInt(pos[0]) - 1;
                int y = Integer.parseInt(pos[1]) - 1;
                if (matrix_length == 1) {
                    if (x == 0 && y == 0) {
                        state = 0;
                        System.out.printf(pos[0] + "" , "" + pos[1]);
                        break;
                    } else {
                        state = -1;
                        break;
                    }
                }
//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");

                markmatrix[x][y] = ""1"";
                int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                if (x == 0 && y == 0) { // 左上角
                    if (markmatrix[x][y + 1].equals(""1"")) {
                        uf.union(num, num + 1);
                        //System.out.printf(""a\n"");
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""b\n"");
                    }

                } else if (x == 0 && y == matrix_length - 1) { //右上角
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""c\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""d\n"");
                    }
                } else if (y == 0 && x == matrix_length - 1) { //左下角
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""e\n"");
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""f\n"");
                    }
                } else if (x == matrix_length - 1 && y == matrix_length - 1) { //右下角
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""g\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""h\n"");
                    }
                } else if (y == 0) { //最左排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""i\n"");
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""j\n"");
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""k\n"");
                    }
                } else if (x == 0) { //最上排
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""m\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""n\n"");
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""o\n"");
                    }
                } else if (y == matrix_length - 1) { //最右排
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                       // System.out.printf(""p\n"");
                    }
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""q\n"");
                    }
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""r\n"");
                    }
                } else if (x == matrix_length - 1) { //最下排
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""s\n"");
                    }
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""t\n"");
                    }
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""u\n"");
                    }
                } else if (x != 0 && y != 0) {
                    //if up is opened
                    if (markmatrix[x - 1][y] == ""1"") {
                        uf.union(num, num - matrix_length);
                        //System.out.printf(""v\n"");
                    }
                    //if down is opened
                    if (markmatrix[x + 1][y] == ""1"") {
                        uf.union(num, num + matrix_length);
                        //System.out.printf(""w\n"");
                    }
                    //if left is opened
                    if (markmatrix[x][y - 1] == ""1"") {
                        uf.union(num, num - 1);
                        //System.out.printf(""x\n"");
                    }
                    //if right is opened
                    if (markmatrix[x][y + 1] == ""1"") {
                        uf.union(num, num + 1);
                        //System.out.printf(""y\n"");
                    }
                }

                if (uf.connected(0, matrix_size - 1)) {
                    state = 0;
                    System.out.printf(pos[0] + "" , "" + pos[1]);
                    //System.out.printf(""\n"");
                    break;
                } else {
                    state = -1;
                }

            }
            if (state == -1) {
                System.out.printf(""%d"", state);
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@791f06654369010313742d6d69d08768@"
"r04631006","9","1.03","125536","@8f64976947108403157fc72aa2cedfa2@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            UF uf = new UF(num * num + 2);

            int[][] ma = new int[num][num];
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    ma[i][j] = i * num + j ;
//                    System.out.printf(""%d\n "", ma[i][j]);
//                }
//            }
//            
            if (num < 2) {
                System.out.printf(""%d"", -1);
            } else {
                for (int i = 0; i < num; i++) {
                    uf.union(num * num, i);
                    uf.union((num * num - i - 1), (num * num + 1));
                }

//            String[] loca = br.readLine().split("","");
//            int x = Integer.parseInt(loca[0]);
//            int y = Integer.parseInt(loca[1]);
//            int loca_num1 = (x - 1) * num + y - 1;
//            int xx = x - 1;
//            int yy = y - 1;
//            ma[xx][yy] = 1;
                String loca;
                String[] loca1;

                String[] no;
                int x = 0;
                int y = 0;
                int loca_num2;
                int xx;
                int yy;

                while (!uf.connected(num * num, (num * num + 1))) {

                    if ((loca = br.readLine()) == null) {
                        System.out.printf(""%d"", -1);
                        return;
                    } else {

                        loca1 = loca.split("","");
                        x = Integer.parseInt(loca1[0]);
                        y = Integer.parseInt(loca1[1]);
                        loca_num2 = (x - 1) * num + y - 1;
                        xx = x - 1;
                        yy = y - 1;
                        ma[xx][yy] = 1;

                        if (xx == 0 && yy == 0) {
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        } else if (xx == 0 && yy == num - 1) {
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }

                        } else if (xx == num - 1 && yy == num - 1) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }
                        } else if (xx == num - 1 && yy == 0) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }

                        } else if (xx == 0 && yy != 0 && yy != num - 1) {
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }

                        } else if (xx == num - 1 && yy != 0 && yy != num - 1) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }

                        } else if (yy == 0 && xx != num - 1 && xx != 0) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        } else if (yy == num - 1 && xx != num - 1 && xx != 0) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        } else {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        }

                    }
                }
                System.out.printf(""%d,%d\n"", x, y);

            }

        }

    }

}

@8f64976947108403157fc72aa2cedfa2@"
"r04631006","9","1.01","127312","@ce94d4dd3758926d59eb0d3188d13998@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            UF uf = new UF(num * num + 2);

            int[][] ma = new int[num][num];
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    ma[i][j] = i * num + j ;
//                    System.out.printf(""%d\n "", ma[i][j]);
//                }
//            }
//            
            if (num < 2) {
                System.out.printf(""%d"", -1);
                return;
            } else {
                for (int i = 0; i < num; i++) {
                    uf.union(num * num, i);
                    uf.union((num * num - i - 1), (num * num + 1));
                }

//            String[] loca = br.readLine().split("","");
//            int x = Integer.parseInt(loca[0]);
//            int y = Integer.parseInt(loca[1]);
//            int loca_num1 = (x - 1) * num + y - 1;
//            int xx = x - 1;
//            int yy = y - 1;
//            ma[xx][yy] = 1;
                String loca;
                String[] loca1;

                String[] no;
                int x = 0;
                int y = 0;
                int loca_num2;
                int xx;
                int yy;

                while (!uf.connected(num * num, (num * num + 1))) {

                    if ((loca = br.readLine()) == null) {
                        System.out.printf(""%d"", -1);
                        return;
                    } else {

                        loca1 = loca.split("","");
                        x = Integer.parseInt(loca1[0]);
                        y = Integer.parseInt(loca1[1]);
                        loca_num2 = (x - 1) * num + y - 1;
                        xx = x - 1;
                        yy = y - 1;
                        ma[xx][yy] = 1;

                        if (xx == 0 && yy == 0) {
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        } else if (xx == 0 && yy == num - 1) {
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }

                        } else if (xx == num - 1 && yy == num - 1) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }
                        } else if (xx == num - 1 && yy == 0) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }

                        } else if (xx == 0 && yy != 0 && yy != num - 1) {
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }

                        } else if (xx == num - 1 && yy != 0 && yy != num - 1) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }

                        } else if (yy == 0 && xx != num - 1 && xx != 0) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        } else if (yy == num - 1 && xx != num - 1 && xx != 0) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        } else {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        }

                    }
                }
                System.out.printf(""%d,%d\n"", x, y);

            }

        }

    }

}

@ce94d4dd3758926d59eb0d3188d13998@"
"r04631009","5","0.93","130384","@2fb48b644fb981f6c19700a953e89659@
/**
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//

            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top

                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }

                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }

                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }

                }
                //    System.out.println(x);
                //    System.out.println(y);
                //    System.out.println(matrix[x][y]);
                for (int k =0 ;k<size-1;k++ ){
                    if (matrix[size-1][k]==2){
                        System.out.println(x+"",""+y);
                        System.exit(0);
                    }
                }
            
                //if (matrix[x][y] == 2 && x == size - 1) {
                //    System.out.println(x);
                //    System.out.println(y);
                //    System.out.println(matrix[x][y]);
                //    System.out.println(Integer.parseInt(data[0]) + "","" + Integer.parseInt(data[1]));
                //    System.exit(0);
                //}
            }

            System.out.println(""-1"");
            //show for debug
            //for (int i = 0; i < size; i++) {
            //    for (int j = 0; j < size; j++) {
            //        System.out.print(matrix[i][j] + "" "");
            //   }
            //   System.out.println("""");
            // }

        }

    }

}

@2fb48b644fb981f6c19700a953e89659@"
"r04631009","0","1.14","147056","@bb065e7b413d116ea87d4e01c7ed24c0@
/**
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//

            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top

                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }

                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }

                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }

                }
                
                if (matrix[size - 1][2] == 2) {
                    System.out.println(Integer.parseInt(data[0]) + "","" + Integer.parseInt(data[1]));
                    System.exit(0);
                }
                

                //    System.out.println(x);
                //    System.out.println(y);
                //    System.out.println(matrix[x][y]);
                //if (matrix[x][y] == 2 && x == size - 1) {
                //    System.out.println(x);
                //    System.out.println(y);
                //    System.out.println(matrix[x][y]);
                //    System.out.println(Integer.parseInt(data[0]) + "","" + Integer.parseInt(data[1]));
                //    System.exit(0);
                //}
            }

            System.out.println(""-1"");
            //show for debug
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    System.out.print(matrix[i][j] + "" "");
                }
                System.out.println("""");
            }

        }

    }

}

@bb065e7b413d116ea87d4e01c7ed24c0@"
"b03611011","0","1.01","127312","@b03976cd85b42ca1735ad83b84e9af82@
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = p / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num) {
            switch (tep) {
                case 1:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    break;
                case 0:
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
            if (id[p + num] == 2) {
                id[p + num] = 1;
            }
        }
        //check connective
        for (int i = 0;
                i < num;
                i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@b03976cd85b42ca1735ad83b84e9af82@"
"b03611011","8","1","124112","@550d09c96fe4de7fb692c575af961455@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = p / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num) {
            switch (tep) {
                case 1:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    break;
                case 0:
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
            if (id[p + num] == 2) {
                id[p + num] = 1;
            }
        }
        //check connective
        for (int i = 0;
                i < num;
                i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@550d09c96fe4de7fb692c575af961455@"
"b03611035","0","1.14","147056","@7c825b2bfd750a25377ca4cff9f6092c@import java.io.FileReader;
import java.io.BufferedReader;
ㄥimport edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}

@7c825b2bfd750a25377ca4cff9f6092c@"
"b03611035","2","0.67","104624","@d5bbadf49221f3f796ce45e44032cf89@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         while(br.read()!=-1){
            if(br.read()==10||br.read()==13) {
                count++;
            }
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
         br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][count];
         for(int i=0;i<count;i++) ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1||x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}
@d5bbadf49221f3f796ce45e44032cf89@"
"b03611035","3","0.54","105744","@aca5e1cdcfaf679088c6fea6554ae527@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(147);
         
        //數有幾個座標要開通
         int count=0;
         int readd=br.read();
         while(readd!=-1){
            if(readd==44) {
                count++;
            }
            readd=br.read();
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
        // br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][2];
         for(int i=0;i<count;i++) 
             ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;
         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}

@aca5e1cdcfaf679088c6fea6554ae527@"
"r04631006","10","0.104","124688","@fb2b73b472c29ab0747a1060e8239514@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            UF uf = new UF(num * num + 2);

            int[][] ma = new int[num][num];

            String loca;
            String[] loca1;

            String[] no;
            int x = 0;
            int y = 0;
            int loca_num2;
            int xx;
            int yy;

            if (num == 1) {
                loca1 = br.readLine().split("","");
                x = Integer.parseInt(loca1[0]);
                y = Integer.parseInt(loca1[1]);
//                if (Integer.parseInt(loca1[0]) == 1 && Integer.parseInt(loca1[1]) == 1) {
                System.out.printf(""%d,%d"", x, y);
//                } else {
//                    System.out.printf(""%d"", -1);
//                    return;


            } else {
                for (int i = 0; i < num; i++) {
                    uf.union(num * num, i);
                    uf.union((num * num - i - 1), (num * num + 1));
                }
                while (!uf.connected(num * num, (num * num + 1))) {

                    if ((loca = br.readLine()) == null) {
                        System.out.printf(""%d"", -1);
                        return;
                    } else {

                        loca1 = loca.split("","");
                        x = Integer.parseInt(loca1[0]);
                        y = Integer.parseInt(loca1[1]);
                        loca_num2 = (x - 1) * num + y - 1;
                        xx = x - 1;
                        yy = y - 1;
                        ma[xx][yy] = 1;

                        if (xx == 0 && yy == 0) {
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        } else if (xx == 0 && yy == num - 1) {
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }

                        } else if (xx == num - 1 && yy == num - 1) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }
                        } else if (xx == num - 1 && yy == 0) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }

                        } else if (xx == 0 && yy != 0 && yy != num - 1) {
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }

                        } else if (xx == num - 1 && yy != 0 && yy != num - 1) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }

                        } else if (yy == 0 && xx != num - 1 && xx != 0) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        } else if (yy == num - 1 && xx != num - 1 && xx != 0) {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        } else {
                            if (ma[xx - 1][yy] == 1) {
                                uf.union(((x - 1 - 1) * num + y - 1), loca_num2);
                            }
                            if (ma[xx][yy + 1] == 1) {
                                uf.union(((x - 1) * num + (y + 1) - 1), loca_num2);
                            }
                            if (ma[xx][yy - 1] == 1) {
                                uf.union((x - 1) * num + (y - 1) - 1, loca_num2);
                            }
                            if (ma[xx + 1][yy] == 1) {
                                uf.union((x) * num + (y) - 1, loca_num2);
                            }
                        }

                    }
                }
                System.out.printf(""%d,%d\n"", x, y);

            }

        }

    }

}

@fb2b73b472c29ab0747a1060e8239514@"
"b03611011","4","0.86","111904","@2e0c034d2525142f8a8e3dab1f993cd6@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = p / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num) {
            switch (tep) {
                case 1:
                    for (int i = 1; id[p + i] != 0 && i < num - 1; i++) {
                        if (id[p + i] == 2) {
                            id[p + i] = 1;
                        }
                    }
                    break;
                case 0:
                    for (int i = 1; id[p - i] != 0 && i < num - 1; i++) {
                        if (id[p - i] == 2) {
                            id[p - i] = 1;
                        }
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
            if (id[p + num] == 2) {
                id[p + num] = 1;
                tf = -1;
                return;
            }
        }
        //check connective
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@2e0c034d2525142f8a8e3dab1f993cd6@"
"b03611033","8","0.99","130592","@ee21b1ce3ac50e2e061b1abfa1767f0b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {    
   public boolean[] matrix;
   public int[] self;  
    public Percolation(int n){
        matrix = new boolean[n*n];
        self = new int[n*n];
        for(int i=0;i<n*n;i++){
            if(i<n){
                self[i]=0;
            }
            else{
                self[i]=i;
            }    
        }
    }
    public void line(int n,int p,int q){
         matrix[p*n+q] = true;
         if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                self[p*n+q]=self[p*n+(q-1)];
            }
        }
        if(p>0){
            if(matrix[p*n+q] & matrix[(p-1)*n+q]){
                self[p*n+q]=self[(p-1)*n+q];
            }
            if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                self[p*n+(q-1)]=self[p*n+q];
            }
        }
        }
        if(p<n-1){
            if(matrix[p*n+q] & matrix[(p+1)*n+q]){
                self[(p+1)*n+q]=self[p*n+q];
            }
        }
        
        if(q<n-1){
            if(matrix[p*n+q] & matrix[p*n+(q+1)]){
                self[p*n+(q+1)]=self[p*n+q];
            }
        }
    }
    
    public boolean percolates(int n){
        for(int i=(n-1)*n;i<n*n;i++){
            if(self[i]==0){
                return true;
            }
        }
        return false;
        
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String data = br.readLine();
                int N = Integer.parseInt(data);
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    percolation.line(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
            }
        }        
    }


@ee21b1ce3ac50e2e061b1abfa1767f0b@"
"b03611011","4","0.86","111152","@92b0403da1d82b377f9abf0df8e9bfdd@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = p / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num) {
            switch (tep) {
                case 1:
                    for (int i = 1; id[p + i] != 0 && i < num - 1; i++) {
                        if (id[p + i] == 2) {
                            id[p + i] = 1;
                        }
                    }
                    break;
                case 0:
                    for (int i = 1; id[p - i] != 0 && i < num - 1; i++) {
                        if (id[p - i] == 2) {
                            id[p - i] = 1;
                        }
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
            if (id[p + num] == 2) {
                id[p + num] = 1;
                tf = -1;
                return;
            }
        }
        //check connective
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@92b0403da1d82b377f9abf0df8e9bfdd@"
"b03611011","5","0.88","123424","@b1a976a01c7e69ed7292c110e44fc876@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = p / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num - 1) {
            switch (tep) {
                case 1:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    break;
                case 0:
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
            if (id[p + num] == 2) {
                id[p + num] = 1;
            }
        }
        //check connective
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@b1a976a01c7e69ed7292c110e44fc876@"
"b03611011","8","1.01","126608","@53f6bf9527e3370c303061454269c2f4@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = p / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num - 1) {
            switch (tep) {
                case 1:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    break;
                case 0:
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
            if (id[p + num] == 2) {
                id[p + num] = 1;
            }
        }
        //check connective
        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@53f6bf9527e3370c303061454269c2f4@"
"r04945022","0","0","0","@295268e29a8bbd149c316b882810945f@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        Percolation Perco1 = new Percolation();
//        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try(BufferedReader br = new BufferedReader(new FileReader(""input.txt""))){
        
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while(!data.isEmpty()){
//            try{
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
             data = br.readLine();
//             }catch(IOException ex){
//            err.println(ex.getMessage());
//        } 
        }
        
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
        }
     
    }
    
}
@295268e29a8bbd149c316b882810945f@"
"b03611011","0","0","0","@09c945a9ff9910638cb483a8cf21907e@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = p / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num - 1) {
            switch (tep) {
                case 1:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    break;
                case 0:
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
            if (tep <= num - 2) {
                if (id[p + num] == 2) {
                    id[p + num] = 1;
                }
            }else{
            if(id[p]==1){
            tf=-1;
            return;
            }
            }
        }
        //check connective
        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@09c945a9ff9910638cb483a8cf21907e@"
"b03611011","7","0.99","125184","@19cc82ea4b99cb0ea543b60b70f159eb@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = p / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num - 1) {
            switch (tep) {
                case 1:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    break;
                case 0:
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
            if (tep <= num - 2) {
                if (id[p + num] == 2) {
                    id[p + num] = 1;
                }
            }else{
            if(id[p]==1){
            tf=-1;
            return;
            }
            }
        }
        //check connective
        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@19cc82ea4b99cb0ea543b60b70f159eb@"
"r04945022","5","0.48","123632","@fbbf34b22d08902d093359eaa09a5450@import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
                int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while(!data.isEmpty()){
//            try{
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
             data = br.readLine();
//             }catch(IOException ex){
//            err.println(ex.getMessage());
//        } 
        }
        
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
        
     
    }
    
}
@fbbf34b22d08902d093359eaa09a5450@"
"r04945022","5","0.49","119552","@708548ca6c5730433cca67e5768676b3@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
                int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while(!data.isEmpty()){
            try{
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
             data = br.readLine();
             }catch(IOException ex){
            err.println(ex.getMessage());
        } 
        }
        
           if(!Perco1.percolates()){
               System.out.println(""-1"");
           }
        
     
    }
    
}
@708548ca6c5730433cca67e5768676b3@"
"b03611003","10","0.099","125648","@e8301bc2c29351b8a75989cbe331091f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 */
public class Percolation {

    /**
     * @param args the command line arguments
     *
     *
     * by union!!!!!!!!!!!!!!
     *
     *
     *
     *
     */
    private static int[] id;
    private static int[] bw;
//    0 as black, 1 as white
    static int N;
    static int siteid;

    public Percolation(int N) {
//        initial the id&bw of the mitrix
        id = new int[N * N + 2];
        bw = new int[N * N + 2];
//       [0] is top, [N+1] is bottom
        for (int i = 0; i < N * N + 2; i++) {
            id[i] = i;
            bw[i] = 0;
        }
//       martix begin from 1 end at N
        bw[0] = 1;
        bw[N * N + 1] = 1;
    }

    public static void open(int row, int col) {
//        open a new site and check the connection
        siteid = (row - 1) * N + col;
        bw[siteid] = 1;

        if (siteid <= N) {
            union(siteid, 0);
//          connect the top     

            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
//            connect the one below

        } else if (siteid > N * N - N) {
            union(siteid, N * N + 1);
//          connect the bottom 

            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
//            connect the one above

        } else {
//          the sites between
            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
            if (bw[siteid - 1] == 1) {
                union(siteid, siteid - 1);
            }
            if (bw[siteid + 1] == 1) {
                union(siteid, siteid + 1);
            }
            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
        }

    }

    public static void union(int A, int B) {
//        把id 設成最小的位子
        int a = root(A);
        int b = root(B);

        if (a < b) {
            id[b] = a;
        } else {
            id[a] = b;
        }
    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static boolean connection(int A, int B) {
        return root(A) == root(B);
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            N = Integer.parseInt(data);

            Percolation matrix = new Percolation(N);

            String[] randc = new String[2];
            int row = 0;
            int col = 0;
            String brs;
            
            while (Boolean.TRUE) {

                brs = br.readLine();
                if(connection(0, N * N + 1)){
                     System.out.print(row + "","" + col);
                     break;
                }
                if (brs == null) {
                    System.out.print(-1);
                    break;
                }
                randc = brs.split("","");
                row = Integer.parseInt(randc[0]);
                col = Integer.parseInt(randc[1]);

                open(row, col);
            }

//            if (br.readLine() != null) {
//                System.out.print(row + "","" + col);
//            }

        }
    }

}

@e8301bc2c29351b8a75989cbe331091f@"
"r04945022","5","0.49","120096","@9304fc2376391e94f884c5d5d00d5c6a@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
                int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while(!data.isEmpty()){
//            try{
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
             data = br.readLine();
//             }catch(IOException ex){
//            err.println(ex.getMessage());
//        } 
        }
        
           if(!Perco1.percolates()){
               System.out.printf(""-1"");
           }
        
     
    }
    
}
@9304fc2376391e94f884c5d5d00d5c6a@"
"r04945022","0","0.49","120096","@ab0951dbe17473fd6a17fe0184efdcd1@import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        nt inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while((data = br.readLine())!=null){
//            try{
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
//             data = br.readLine();
//             }catch(IOException ex){
//            err.println(ex.getMessage());
//        } 
        }
        
           if(!Perco1.percolates()){
               System.out.printf(""-1"");
           }
        
     
    }
    
}
@ab0951dbe17473fd6a17fe0184efdcd1@"
"r04945022","8","1.02","122224","@911fafa87d7c376831f80fabe62b82f4@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while((data = br.readLine())!=null){
//            try{
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
//             data = br.readLine();
//             }catch(IOException ex){
//            err.println(ex.getMessage());
//        } 
        }
        
           if(!Perco1.percolates()){
               System.out.printf(""-1"");
           }
        
     
    }
    
}
@911fafa87d7c376831f80fabe62b82f4@"
"r04631046","0","1.02","122224","@1754c0cf270ce0f8ffc7b18285d05fe5@
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {
//        read size
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
//            UF basic setting
            UF uf = new UF(num * num + 2);
            for (int i = 1; i <= num; i++) {
                uf.union(0, i);
                uf.union(num * num + 1, num * num + 1 - i);
            }
//            record open/colse coordinate
            boolean[] dataMatrix = new boolean[num * num + 2];
            int position;
            while (br.ready()) {
//                read open coordinate
                String[] Open = br.readLine().split("","");
                position = (Integer.parseInt(Open[0]) - 1) * num + Integer.parseInt(Open[1]);
                dataMatrix[position] = true;
//                start union
//                upside
                if (position - num > 0) {
                    if (dataMatrix[position - num]) {
                        uf.union(position - num, position);
                    }
                }
//                left side
                if (position - 1 > 0) {
                    if (dataMatrix[position - 1]) {
                        uf.union(position - 1, position);
                    }
                }
//                right side
                if (position + 1 < num * num + 1) {
                    if (dataMatrix[position + 1]) {
                        uf.union(position + 1, position);
                    }
                }
//                lower side
                if (position + num < num * num + 1) {
                    if (dataMatrix[position + num]) {
                        uf.union(position + num, position);
                    }
                }
//                connect confirm
                if (uf.connected(0, num * num + 1)) {
                    System.out.printf(""%s,%s\n"", Open[0], Open[1]);
                    break;
                }
                
            }
            if(uf.connected(0, num*num+1)==false){
                    System.out.println(-1);
                }
        }

    }
}

@1754c0cf270ce0f8ffc7b18285d05fe5@"
"r04631046","10","0.101","127264","@fc85516109d648adcf5fbd2a340b90f9@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {
//        read size
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
//            UF basic setting
            UF uf = new UF(num * num + 2);
            for (int i = 1; i <= num; i++) {
                uf.union(0, i);
                uf.union(num * num + 1, num * num + 1 - i);
            }
//            record open/colse coordinate
            boolean[] dataMatrix = new boolean[num * num + 2];
            int position;
            while (br.ready()) {
//                read open coordinate
                String[] Open = br.readLine().split("","");
                position = (Integer.parseInt(Open[0]) - 1) * num + Integer.parseInt(Open[1]);
                dataMatrix[position] = true;
//                start union
//                upside
                if (position - num > 0) {
                    if (dataMatrix[position - num]) {
                        uf.union(position - num, position);
                    }
                }
//                left side
                if (position - 1 > 0) {
                    if (dataMatrix[position - 1]) {
                        uf.union(position - 1, position);
                    }
                }
//                right side
                if (position + 1 < num * num + 1) {
                    if (dataMatrix[position + 1]) {
                        uf.union(position + 1, position);
                    }
                }
//                lower side
                if (position + num < num * num + 1) {
                    if (dataMatrix[position + num]) {
                        uf.union(position + num, position);
                    }
                }
//                connect confirm
                if (uf.connected(0, num * num + 1)) {
                    System.out.printf(""%s,%s\n"", Open[0], Open[1]);
                    break;
                }
                
            }
            if(uf.connected(0, num*num+1)==false){
                    System.out.println(-1);
                }
        }

    }
}

@fc85516109d648adcf5fbd2a340b90f9@"
"r04631046","10","0.099","122240","@cda9fb8906def9c2785718e1e736751b@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {
//        read size
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
//            UF basic setting
            UF uf = new UF(num * num + 2);
            for (int i = 1; i <= num; i++) {
                uf.union(0, i);
                uf.union(num * num + 1, num * num + 1 - i);
            }
//            record open/colse coordinate
            boolean[] dataMatrix = new boolean[num * num + 2];
            int position;
            while (br.ready()) {
//                read open coordinate
                String[] Open = br.readLine().split("","");
                position = (Integer.parseInt(Open[0]) - 1) * num + Integer.parseInt(Open[1]);
                dataMatrix[position] = true;
//                start union
//                upside
                if (position - num > 0) {
                    if (dataMatrix[position - num]) {
                        uf.union(position - num, position);
                    }
                }
//                left side
                if (position - 1 > 0) {
                    if (dataMatrix[position - 1]) {
                        uf.union(position - 1, position);
                    }
                }
//                right side
                if (position + 1 < num * num + 1) {
                    if (dataMatrix[position + 1]) {
                        uf.union(position + 1, position);
                    }
                }
//                lower side
                if (position + num < num * num + 1) {
                    if (dataMatrix[position + num]) {
                        uf.union(position + num, position);
                    }
                }
//                connect confirm
                if (uf.connected(0, num * num + 1)) {
                    System.out.printf(""%s,%s\n"", Open[0], Open[1]);
                    break;
                }
                
            }
//            false reaction
            if(uf.connected(0, num*num+1)==false){
                    System.out.println(-1);
                }
        }

    }
}

@cda9fb8906def9c2785718e1e736751b@"
"r04631025","9","3.24","144320","@2aef091cd4a34708c37274063b2030e1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    private int N;
   UF uf;

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        N=n;
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 1; i <= a; i++) {
            id[i - 1] = i;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 2][y - 1]);
            }
        }
        if (x != N) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1],matrix[x][y - 1] );
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 1][y - 2]);
            }
        }
        if (y != N) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        for(int i=1;i<=N;i++){
            for(int j=0;j<N;j++){
                if(uf.connected(matrix[N-1][N-i],matrix[0][j])){
                    return true;
                }
            }
        }
        return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@2aef091cd4a34708c37274063b2030e1@"
"b02611016","10","0.148","201744","@6cb66453798b20b71461cc33846cc033@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=num+1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            
            //Date date = new Date();
            search: 
            
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break ;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break ;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               { labelcount[id[(row)*num+cloumn-1]]=labelcount[id[(row)*num+cloumn-1]]+1;
                   id[cloumn-1]=id[(row)*num+cloumn-1];
               }
               else {id[cloumn-1]=label ;
                   labelcount[label]=labelcount[label]+1 ;      
               label=label+1 ;}
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                   if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                   if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
           /*for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@6cb66453798b20b71461cc33846cc033@"
"b02611026","5","1.12","125728","@384f077629a14bfe0df1f9835f637b66@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            if (matrix_length == 1) {
                String[] pos1;
                pos1 = br.readLine().split("","");

//                System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");
                if ((pos1[0].equals(""1"")) && (pos1[1].equals(""1""))) {
                    state = 2;
//                    System.out.printf(""%d\n"", matrix_length);
//                    System.out.printf(""%d\n"", state);
                    System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");

                } else {
                    state = -1;
//                    System.out.printf(""%d"", matrix_length);
                    System.out.printf(""%d"", state);

                }
            } else if (matrix_length == 0) {
                state = -1;
                System.out.printf(""%d"", state);
            }
            else {
                //Union the upper row
                for (int i = 0; i < matrix_length; i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == matrix_length) {
                        break;
                    }
                }
                //Union the downner row
                for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == (matrix_size - 1)) {
                        break;
                    }
                }
                //Create a matrx in order to mark the cell
                String[][] markmatrix = new String[matrix_length][matrix_length];
                for (int i = 0; i < matrix_length; i++) {
                    for (int j = 0; j < matrix_length; j++) {
                        markmatrix[i][j] = ""0"";
                    }
                }

                String[] pos;
                while (br.ready()) {
                    pos = br.readLine().split("","");
                    if (pos == null) {
                        break;
                    }

//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");
                    //mark the opened position
                    int x = Integer.parseInt(pos[0]) - 1;
                    int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");
                    markmatrix[x][y] = ""1"";
                    int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                    if (x == 0 && y == 0) { // 左上角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""a\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""b\n"");
                        }

                    } else if (x == 0 && y == matrix_length - 1) { //右上角
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""c\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""d\n"");
                        }
                    } else if (y == 0 && x == matrix_length - 1) { //左下角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""e\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""f\n"");
                        }
                    } else if (x == matrix_length - 1 && y == matrix_length - 1) { //右下角
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""g\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""h\n"");
                        }
                    } else if (y == 0) { //最左排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""i\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""j\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""k\n"");
                        }
                    } else if (x == 0) { //最上排
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""m\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""n\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""o\n"");
                        }
                    } else if (y == matrix_length - 1) { //最右排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            // System.out.printf(""p\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""q\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""r\n"");
                        }
                    } else if (x == matrix_length - 1) { //最下排
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""s\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""t\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""u\n"");
                        }
                    } else if (x != 0 && y != 0) {
                        //if up is opened
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""v\n"");
                        }
                        //if down is opened
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""w\n"");
                        }
                        //if left is opened
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""x\n"");
                        }
                        //if right is opened
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""y\n"");
                        }
                    }

                    if (uf.connected(0, matrix_size - 1)) {
                        state = 0;
                        System.out.printf(pos[0] + "" , "" + pos[1]);
                        //System.out.printf(""\n"");
                        break;
                    } else {
                        state = -1;
                    }

                }
                if (state == -1) {
                    System.out.printf(""%d"", state);
                }
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@384f077629a14bfe0df1f9835f637b66@"
"r03945012","9","1.29","180464","@944816fd5290417be3ebc16db9f6791f@
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.ArrayList;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Robert
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        InputStream is = null;
        InputStreamReader isr = null;
        BufferedReader br = null;

        try {
            is = new FileInputStream(args[0]);
            isr = new InputStreamReader(is, StandardCharsets.UTF_8);
            br = new BufferedReader(isr);
            
            
            // read file.txt
            boolean output = false;
            Scanner inputdata = new Scanner(br);
            String data = inputdata.nextLine();

            // num is matrix size(num*num)
            // matrix starts from 1
            // label = 00
            int num = Integer.parseInt(data);
            int[][] label = new int[num][num];
            for (int[] row : label) {
                java.util.Arrays.fill(row, 0);
            }
            
            ArrayList myList = new ArrayList();

            while(inputdata.hasNextLine()){
                String[] tmp = inputdata.nextLine().split("","");
                for(int i=0; i<tmp.length; i++)
                    myList.add(tmp[i]);                
            }
            // nextLine(point) and totaline
            
            int k = myList.size()/2;
            int count = 0;
            int[][] point = new int[k][2];            
            for (int i=0; i< k; i++){
                point[i][0] = Integer.parseInt((String) myList.get(count)) - 1;
                point[i][1] = Integer.parseInt((String) myList.get(count+1)) - 1;
                count = count+2;
            }
                
            // create class uf (0 to num*num+1)
            // 0 = virtual top
            // num*num+1 = virtual bottom
            UF uf = new UF(num * num + 2);

            // start 1 (using for)
            for (int i = 0; i < point.length; i++) {
                int x = point[i][0];
                int y = point[i][1];
                label[x][y] = 1;
                int index = x * num + y + 1;

                // matrix union
                // union top
                if (x == 0) {
                    uf.union(index, 0);
                    if (label[x + 1][y] == 1)
                        uf.union(index, index + num);
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                } 
                //union bottom
                else if (x == num - 1) {
                    uf.union(index, num * num + 1);
                    if (label[x - 1][y] == 1)
                        uf.union(index, index - num);
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                } // union the rest
                else {
                    // union to top one
                    if (label[x - 1][y] == 1)
                        uf.union(index, index - num);
                    // union to down one
                    if (label[x + 1][y] == 1)
                        uf.union(index, index + num);
                    
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                }
                output = uf.connected(0, num * num + 1);
                if (output == true) {
                    System.out.print((x+1)+"",""+(y+1));
                    break;
                }
            }
            if (output == false)
                System.out.print(""-1""); 
        } catch (FileNotFoundException | NumberFormatException e) {
        } finally {
            // releases resources associated with the streams
            if (is != null) {
                is.close();
            }
            if (isr != null) {
                isr.close();
            }
            if (br != null) {
                br.close();
            }
        }
    }

}

@944816fd5290417be3ebc16db9f6791f@"
"r04631025","9","3.28","149584","@b40ed27a704b2bba9f5645ea17bc5868@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    private int N;
   UF uf;

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        N=n;
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 0; i < a; i++) {
            id[i] = 1;
        }
        
    }

    public void un(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 2][y - 1]);
            }
        }
        if (x != N) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1],matrix[x][y - 1] );
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 1][y - 2]);
            }
        }
        if (y != N) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        for(int i=1;i<=N;i++){
            for(int j=0;j<N;j++){
                if(uf.connected(matrix[N-1][N-i],matrix[0][j])){
                    return true;
                }
            }
        }
        return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@b40ed27a704b2bba9f5645ea17bc5868@"
"r03945012","9","1.24","190368","@3ec025a4968d6e58e97fd370563a6822@
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.ArrayList;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Robert
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        InputStream is = null;
        InputStreamReader isr = null;
        BufferedReader br = null;

        try {
            is = new FileInputStream(args[0]);
            isr = new InputStreamReader(is, StandardCharsets.UTF_8);
            br = new BufferedReader(isr);
            
            
            // read file.txt
            boolean output = false;
            Scanner inputdata = new Scanner(br);
            String data = inputdata.nextLine();

            // num is matrix size(num*num)
            // matrix starts from 1
            // label = 00
            int num = Integer.parseInt(data);
            int[][] label = new int[num][num];
            for (int[] row : label) {
                java.util.Arrays.fill(row, 0);
            }
            
            ArrayList<String> myList = new ArrayList<String>();

            while(inputdata.hasNextLine()){
                String[] tmp = inputdata.nextLine().split("","");
                for(int i=0; i<tmp.length; i++)
                    myList.add(tmp[i]);                
            }
            // nextLine(point) and totaline
            
            int k = myList.size()/2;
            int count = 0;
            int[][] point = new int[k][2];            
            for (int i=0; i< k; i++){
                point[i][0] = Integer.parseInt((String) myList.get(count)) - 1;
                point[i][1] = Integer.parseInt((String) myList.get(count+1)) - 1;
                count = count+2;
            }
                
            // create class uf (0 to num*num+1)
            // 0 = virtual top
            // num*num+1 = virtual bottom
            UF uf = new UF(num * num + 2);

            // start 1 (using for)
            for (int i = 0; i < point.length; i++) {
                int x = point[i][0];
                int y = point[i][1];
                label[x][y] = 1;
                int index = x * num + y + 1;

                // matrix union
                // union top
                if (x == 0) {
                    uf.union(index, 0);
                    if (label[x + 1][y] == 1)
                        uf.union(index, index + num);
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                } 
                //union bottom
                else if (x == num - 1) {
                    uf.union(index, num * num + 1);
                    if (label[x - 1][y] == 1)
                        uf.union(index, index - num);
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                } // union the rest
                else {
                    // union to top one
                    if (label[x - 1][y] == 1)
                        uf.union(index, index - num);
                    // union to down one
                    if (label[x + 1][y] == 1)
                        uf.union(index, index + num);
                    
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                }
                output = uf.connected(0, num * num + 1);
                if (output == true) {
                    System.out.print((x+1)+"",""+(y+1));
                    break;
                }
            }
            if (output == false)
                System.out.print(""-1""); 
        } catch (FileNotFoundException | NumberFormatException e) {
        } finally {
            // releases resources associated with the streams
            if (is != null) {
                is.close();
            }
            if (isr != null) {
                isr.close();
            }
            if (br != null) {
                br.close();
            }
        }
    }

}

@3ec025a4968d6e58e97fd370563a6822@"
"b02611026","5","1.12","128304","@6c1bf29ced6cda8aae082122b34a362b@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            if (matrix_length == 1) {
                String[] pos1;
                pos1 = br.readLine().split("","");

//                System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");
                if ((pos1[0].equals(""1"")) && (pos1[1].equals(""1""))) {
                    state = 2;
//                    System.out.printf(""%d\n"", matrix_length);
//                    System.out.printf(""%d\n"", state);
                    System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");

                } else {
                    state = -1;
//                    System.out.printf(""%d"", matrix_length);
                    System.out.printf(""%d"", state);

                }
            } else if (matrix_length == 0) {
                state = -1;
                System.out.printf(""%d"", state);
            } else {
                //Union the upper row
                for (int i = 0; i < matrix_length; i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == matrix_length) {
                        break;
                    }
                }
                //Union the downner row
                for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == (matrix_size - 1)) {
                        break;
                    }
                }
                //Create a matrx in order to mark the cell
                String[][] markmatrix = new String[matrix_length][matrix_length];
                for (int i = 0; i < matrix_length; i++) {
                    for (int j = 0; j < matrix_length; j++) {
                        markmatrix[i][j] = ""0"";
                    }
                }

                String[] pos;
                while (br.ready()) {
                    pos = br.readLine().split("","");
                    if (pos == null) {
                        break;
                    }

//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");
                    //mark the opened position
                    int x = Integer.parseInt(pos[0]) - 1;
                    int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");
                    markmatrix[x][y] = ""1"";
                    int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                    if (x != 0 && y != 0 && x != matrix_length-1 && y != matrix_length-1) {
                        //if up is opened
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""v\n"");
                        }
                        //if down is opened
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""w\n"");
                        }
                        //if left is opened
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""x\n"");
                        }
                        //if right is opened
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""y\n"");
                        }
                    } else if (x == 0 && y == 0) { // 左上角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""a\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""b\n"");
                        }

                    } else if (x == 0 && y == matrix_length - 1) { //右上角
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""c\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""d\n"");
                        }
                    } else if (y == 0 && x == matrix_length - 1) { //左下角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""e\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""f\n"");
                        }
                    } else if (x == matrix_length - 1 && y == matrix_length - 1) { //右下角
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""g\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""h\n"");
                        }
                    } else if (y == 0) { //最左排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""i\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""j\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""k\n"");
                        }
                    } else if (x == 0) { //最上排
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""m\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""n\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""o\n"");
                        }
                    } else if (y == matrix_length - 1) { //最右排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            // System.out.printf(""p\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""q\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""r\n"");
                        }
                    } else if (x == matrix_length - 1) { //最下排
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""s\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""t\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""u\n"");
                        }
                    }

                    if (uf.connected(0, matrix_size - 1)) {
                        state = 0;
                        System.out.printf(pos[0] + "" , "" + pos[1]);
                        //System.out.printf(""\n"");
                        break;
                    } else {
                        state = -1;
                    }

                }
                if (state == -1) {
                    System.out.printf(""%d"", state);
                }
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@6c1bf29ced6cda8aae082122b34a362b@"
"b02611026","5","1.11","127952","@5232ac39fd38d83054a0cde89f844b6a@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            if (matrix_length == 1) {
                String[] pos1;
                pos1 = br.readLine().split("","");

//                System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");
                if ((pos1[0].equals(""1"")) && (pos1[1].equals(""1""))) {
                    state = 2;
//                    System.out.printf(""%d\n"", matrix_length);
//                    System.out.printf(""%d\n"", state);
                    System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");

                } else {
                    state = -1;
//                    System.out.printf(""%d"", matrix_length);
                    System.out.printf(""%d"", state);

                }
            } else if (matrix_length == 0) {
                state = -1;
                System.out.printf(""%d"", state);
            } else {
                //Union the upper row
                for (int i = 0; i < matrix_length; i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == matrix_length) {
                        break;
                    }
                }
                //Union the downner row
                for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == (matrix_size - 1)) {
                        break;
                    }
                }
                //Create a matrx in order to mark the cell
                String[][] markmatrix = new String[matrix_length][matrix_length];
                for (int i = 0; i < matrix_length; i++) {
                    for (int j = 0; j < matrix_length; j++) {
                        markmatrix[i][j] = ""0"";
                    }
                }

                String[] pos;
                while (br.ready()) {
                    pos = br.readLine().split("","");
                    if (pos == null) {
                        break;
                    }

//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");
                    //mark the opened position
                    int x = Integer.parseInt(pos[0]) - 1;
                    int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");
                    markmatrix[x][y] = ""1"";
                    int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                    if (x != 0 && y != 0 && x != (matrix_length-1) && y != (matrix_length-1)) {
                        //if up is opened
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""v\n"");
                        }
                        //if down is opened
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""w\n"");
                        }
                        //if left is opened
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""x\n"");
                        }
                        //if right is opened
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""y\n"");
                        }
                    } else if (x == 0 && y == 0) { // 左上角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""a\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""b\n"");
                        }

                    } else if (x == 0 && y == matrix_length - 1) { //右上角
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""c\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""d\n"");
                        }
                    } else if (y == 0 && x == matrix_length - 1) { //左下角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""e\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""f\n"");
                        }
                    } else if (x == matrix_length - 1 && y == matrix_length - 1) { //右下角
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""g\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""h\n"");
                        }
                    } else if (y == 0) { //最左排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""i\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""j\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""k\n"");
                        }
                    } else if (x == 0) { //最上排
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""m\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""n\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""o\n"");
                        }
                    } else if (y == matrix_length - 1) { //最右排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            // System.out.printf(""p\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""q\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""r\n"");
                        }
                    } else if (x == matrix_length - 1) { //最下排
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""s\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""t\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""u\n"");
                        }
                    }

                    if (uf.connected(0, matrix_size - 1)) {
                        state = 0;
                        System.out.printf(pos[0] + "" , "" + pos[1]);
                        //System.out.printf(""\n"");
                        break;
                    } else {
                        state = -1;
                    }

                }
                if (state == -1) {
                    System.out.printf(""%d"", state);
                }
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@5232ac39fd38d83054a0cde89f844b6a@"
"b02611026","8","1.17","127824","@0330ea556a06da396c48097d09044615@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            if (matrix_length == 1) {
                String[] pos1;
                pos1 = br.readLine().split("","");

//                System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");
                if ((pos1[0].equals(""1"")) && (pos1[1].equals(""1""))) {
                    state = 2;
//                    System.out.printf(""%d\n"", matrix_length);
//                    System.out.printf(""%d\n"", state);
                    System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");

                } else {
                    state = -1;
//                    System.out.printf(""%d"", matrix_length);
                    System.out.printf(""%d"", state);

                }
            } else if (matrix_length == 0) {
                state = -1;
                System.out.printf(""%d"", state);
            } else {
                //Union the upper row
                for (int i = 0; i < matrix_length; i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == matrix_length) {
                        break;
                    }
                }
                //Union the downner row
                for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == (matrix_size - 1)) {
                        break;
                    }
                }
                //Create a matrx in order to mark the cell
                String[][] markmatrix = new String[matrix_length][matrix_length];
                for (int i = 0; i < matrix_length; i++) {
                    for (int j = 0; j < matrix_length; j++) {
                        markmatrix[i][j] = ""0"";
                    }
                }

                String[] pos;
                while (br.ready()) {
                    pos = br.readLine().split("","");
                    if (pos == null) {
                        break;
                    }

//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");
                    //mark the opened position
                    int x = Integer.parseInt(pos[0]) - 1;
                    int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");
                    markmatrix[x][y] = ""1"";
                    int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                    if (x != 0 && y != 0 && x != (matrix_length-1) && y != (matrix_length-1)) {
                        //if up is opened
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""v\n"");
                        }
                        //if down is opened
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""w\n"");
                        }
                        //if left is opened
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""x\n"");
                        }
                        //if right is opened
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""y\n"");
                        }
                    } else if (x == 0 && y == 0) { // 左上角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""a\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""b\n"");
                        }

                    } else if (x == 0 && y == matrix_length - 1) { //右上角
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""c\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""d\n"");
                        }
                    } else if (y == 0 && x == matrix_length - 1) { //左下角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""e\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""f\n"");
                        }
                    } else if (x == matrix_length - 1 && y == matrix_length - 1) { //右下角
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""g\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""h\n"");
                        }
                    } else if (y == 0) { //最左排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""i\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""j\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""k\n"");
                        }
                    } else if (x == 0) { //最上排
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""m\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""n\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""o\n"");
                        }
                    } else if (y == matrix_length - 1) { //最右排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            // System.out.printf(""p\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""q\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""r\n"");
                        }
                    } else if (x == matrix_length - 1) { //最下排
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""s\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""t\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""u\n"");
                        }
                    }

                    if (uf.connected(0, matrix_size - 1)) {
                        state = 0;
                        System.out.printf(pos[0] + "","" + pos[1]);
                        //System.out.printf(""\n"");
                        break;
                    } else {
                        state = -1;
                    }

                }
                if (state == -1) {
                    System.out.printf(""%d"", state);
                }
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@0330ea556a06da396c48097d09044615@"
"b01502105","5","0.91","105728","@53d1b0a0753961e23d13e7854a27c0e6@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
//                    System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
//                        System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}
@53d1b0a0753961e23d13e7854a27c0e6@"
"b02611026","8","1.11","124928","@52ee0e21f77af5c4cc6b852d3ff69ed3@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            if (matrix_length == 1) {
                String[] pos1;
                pos1 = br.readLine().split("","");

//                System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");
                if ((pos1[0].equals(""1"")) && (pos1[1].equals(""1""))) {
                    state = 2;
//                    System.out.printf(""%d\n"", matrix_length);
//                    System.out.printf(""%d\n"", state);
                    System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");

                } else {
                    state = -1;
//                    System.out.printf(""%d"", matrix_length);
                    System.out.printf(""%d"", state);

                }
            } else if (matrix_length <= 0) {
                state = -1;
                System.out.printf(""%d"", state);
            } else {
                //Union the upper row
                for (int i = 0; i < matrix_length; i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == matrix_length) {
                        break;
                    }
                }
                //Union the downner row
                for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == (matrix_size - 1)) {
                        break;
                    }
                }
                //Create a matrx in order to mark the cell
                String[][] markmatrix = new String[matrix_length][matrix_length];
                for (int i = 0; i < matrix_length; i++) {
                    for (int j = 0; j < matrix_length; j++) {
                        markmatrix[i][j] = ""0"";
                    }
                }

                String[] pos;
                while (br.ready()) {
                    pos = br.readLine().split("","");
                    if (pos == null) {
                        break;
                    }

//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");
                    //mark the opened position
                    int x = Integer.parseInt(pos[0]) - 1;
                    int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");
                    markmatrix[x][y] = ""1"";
                    int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                    if (x != 0 && y != 0 && x != (matrix_length - 1) && y != (matrix_length - 1)) {
                        //if up is opened
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""v\n"");
                        }
                        //if down is opened
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""w\n"");
                        }
                        //if left is opened
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""x\n"");
                        }
                        //if right is opened
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""y\n"");
                        }
                    } else if (x == 0 && y == 0) { // 左上角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""a\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""b\n"");
                        }

                    } else if (x == 0 && y == (matrix_length - 1)) { //右上角
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""c\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""d\n"");
                        }
                    } else if (y == 0 && x == (matrix_length - 1)) { //左下角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""e\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""f\n"");
                        }
                    } else if (x == matrix_length - 1 && y == (matrix_length - 1)) { //右下角
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""g\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""h\n"");
                        }
                    } else if (y == 0) { //最左排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""i\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""j\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""k\n"");
                        }
                    } else if (x == 0) { //最上排
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""m\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""n\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""o\n"");
                        }
                    } else if (y == (matrix_length - 1)) { //最右排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            // System.out.printf(""p\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""q\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""r\n"");
                        }
                    } else if (x == (matrix_length - 1)) { //最下排
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""s\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""t\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""u\n"");
                        }
                    }

                    if (uf.connected(0, matrix_size - 1)) {
                        state = 0;
                        System.out.printf(pos[0] + "","" + pos[1]);
                        //System.out.printf(""\n"");
                        break;
                    } else {
                        state = -1;
                    }

                }
                if (state == -1) {
                    System.out.printf(""%d"", state);
                }
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@52ee0e21f77af5c4cc6b852d3ff69ed3@"
"r04631025","9","3.22","139776","@e6f2614a84bcc25888954b478e068086@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    private int N;
    UF uf;

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        N=n;
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 0; i < a; i++) {
            id[i] = 1;
        }
        
    }

    public void open(int x, int y){
        id[matrix[x-1][y-1]]=0;
    }

    public void un(int x, int y) {
        
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 2][y - 1]);
            }
        }
        if (x != N) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1],matrix[x][y - 1] );
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 1][y - 2]);
            }
        }
        if (y != N) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        for(int i=1;i<=N;i++){
            for(int j=0;j<N;j++){
                if(uf.connected(matrix[N-1][N-i],matrix[0][j])){
                    return true;
                }
            }
        }
        return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                PL.open(x, y);
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@e6f2614a84bcc25888954b478e068086@"
"r04631026","10","0.1","128656","@cda9fb8906def9c2785718e1e736751b@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {
//        read size
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
//            UF basic setting
            UF uf = new UF(num * num + 2);
            for (int i = 1; i <= num; i++) {
                uf.union(0, i);
                uf.union(num * num + 1, num * num + 1 - i);
            }
//            record open/colse coordinate
            boolean[] dataMatrix = new boolean[num * num + 2];
            int position;
            while (br.ready()) {
//                read open coordinate
                String[] Open = br.readLine().split("","");
                position = (Integer.parseInt(Open[0]) - 1) * num + Integer.parseInt(Open[1]);
                dataMatrix[position] = true;
//                start union
//                upside
                if (position - num > 0) {
                    if (dataMatrix[position - num]) {
                        uf.union(position - num, position);
                    }
                }
//                left side
                if (position - 1 > 0) {
                    if (dataMatrix[position - 1]) {
                        uf.union(position - 1, position);
                    }
                }
//                right side
                if (position + 1 < num * num + 1) {
                    if (dataMatrix[position + 1]) {
                        uf.union(position + 1, position);
                    }
                }
//                lower side
                if (position + num < num * num + 1) {
                    if (dataMatrix[position + num]) {
                        uf.union(position + num, position);
                    }
                }
//                connect confirm
                if (uf.connected(0, num * num + 1)) {
                    System.out.printf(""%s,%s\n"", Open[0], Open[1]);
                    break;
                }
                
            }
//            false reaction
            if(uf.connected(0, num*num+1)==false){
                    System.out.println(-1);
                }
        }

    }
}

@cda9fb8906def9c2785718e1e736751b@"
"r04631031","10","0.104","123376","@86c22a40f2b249ed0d2df6954ba845e0@
//import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int NumOfmatrix = size * size + 2;

            //build checkmatrix which is bigger than old matrix and cover it
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(NumOfmatrix);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point matrixNum-1
            for (int i = NumOfmatrix - size-1; i <= NumOfmatrix - 2; i++) {
                uf.union(i, NumOfmatrix-1);
            }
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
            int matrixnum = 0;
            boolean endflag = false;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
//                    System.out.printf(""%d,%d\n"", row, column);
                    matrixnum = size * (row - 1) + column;
                    //mark the announced site
                     checkmatrix[row][column] = true;

                    //check up, down, left, right side of announced site
                    while (checkmatrix[row - 1][column]) {
                        uf.union(matrixnum, matrixnum - size);
                        break;
                    }
                    while (checkmatrix[row + 1][column]) {
                        uf.union(matrixnum, matrixnum + size);
                        break;
                    }
                    while (checkmatrix[row][column - 1]) {
                        uf.union(matrixnum, matrixnum - 1);
                        break;
                    }
                    while (checkmatrix[row][column + 1]) {
                        uf.union(matrixnum, matrixnum + 1);
                        break;
                    }
                    while(uf.connected(0, NumOfmatrix-1)){
                        endflag = true;
                        break;
                    }
                    if(endflag == true)
                        break;
            } 
            
            if(endflag != true){
                System.out.printf(""-1"");
            }
            else
                System.out.printf(""%d,%d"", row, column);
        }
    }
}

@86c22a40f2b249ed0d2df6954ba845e0@"
"b03611033","8","1","131120","@32596250431126e48cb89e77ce1b254b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {    
   public boolean[] matrix;
   public int[] self;  
    public Percolation(int n){
        matrix = new boolean[n*n];
        self = new int[n*n];
        for(int i=0;i<n;i++){
            self[i]=0;
        }
        for(int i=n;i<n*n;i++){
            self[i]=i;
        }
    }
    public void line(int n,int p,int q){
         matrix[p*n+q] = true;
         if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                self[p*n+q]=self[p*n+(q-1)];
            }
        }
        if(p>0){
            if(matrix[p*n+q] & matrix[(p-1)*n+q]){
                self[p*n+q]=self[(p-1)*n+q];
            }
            if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                self[p*n+(q-1)]=self[p*n+q];
            }
        }
        }
        if(p<n-1){
            if(matrix[p*n+q] & matrix[(p+1)*n+q]){
                self[(p+1)*n+q]=self[p*n+q];
            }
        }
        
        if(q<n-1){
            if(matrix[p*n+q] & matrix[p*n+(q+1)]){
                self[p*n+(q+1)]=self[p*n+q];
            }
        }
    }
    
    public boolean percolates(int n){
        for(int i=(n-1)*n;i<n*n;i++){
            if(self[i]==0){
                return true;
            }
        }
        return false;
        
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String data = br.readLine();
                int N = Integer.parseInt(data);
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    percolation.line(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
            }
        }        
    }


@32596250431126e48cb89e77ce1b254b@"
"f02631008","7","1.41","191360","@6d77b2276147d1858400ec3a2028bf4e@import java.io.*;
import java.io.IOException;
import java.util.Scanner;
import java.util.*;

/**
 *
 * @author philip
 */

public class Percolation {
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }
    }
    public Percolation(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        File file = new File(args[0]);
        try{
            
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_1);
            int[] TrueArr;
            int Flag = 1;
            
            int[][] IndexMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    IndexMat[i][j] = ArrNum*i+j+1;
                    //System.out.println(IndexMat[i][j]);
                }
                
            }
            
            int[][] TrueMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    TrueMat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }
            
            Percolation uf = new Percolation(ArrNum*ArrNum +1);
            for (int i = 1; i < ArrNum+1; i++){
                uf.union(0,i);
                //System.out.println(uf);
            }
            for (int i = ArrNum*ArrNum-1; i > ArrNum*(ArrNum-1); i--){
                uf.union(ArrNum*ArrNum,i);
                //System.out.println(uf);
            }
            
            //System.out.println(uf);
            
            while (File_in.hasNextLine() && Flag ==1 )
            {
                String line_2 = File_in.nextLine();
                String[] Nums = line_2.split("","");

                int Row = Integer.parseInt(Nums[0]);
                int Col = Integer.parseInt(Nums[1]);
                
                int NumIndex = ArrNum*(Row-1)+Col;
                
                TrueMat[Row-1][Col-1] = 1;
                
                
                if(Row-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-2][Col-1]){
                    uf.union(NumIndex,NumIndex-ArrNum);
                    //System.out.println(uf);
                }
                if(Row+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row][Col-1]){
                    uf.union(NumIndex,NumIndex+ArrNum);
                    //System.out.println(uf);
                }
                if(Col-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col-2]){
                    uf.union(NumIndex,NumIndex-1);
                    //System.out.println(uf);
                }
                if(Col+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col]){
                    uf.union(NumIndex,NumIndex+1);
                    //System.out.println(uf);
                }
                //System.out.println(uf);
                /*if(uf._rank[6] == 2){
                        System.out.println(line_2);
                        break;
                }*/
                for (int i = 0; i < ArrNum*ArrNum+1; i++){
                    if(uf._parent[0] == ArrNum*ArrNum){
                        System.out.println(line_2);
                        Flag = 0;
                        break;
                    }
                }
                if(!File_in.hasNextLine()){
                    System.out.println(-1);
                }
            }
            
            
            /*for (int i = 0; i < ArrNum*ArrNum+1; i++) {
                    //System.out.println(TrueArr[i]);
            }
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    //Mat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }*/
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@6d77b2276147d1858400ec3a2028bf4e@"
"f02631008","9","1.39","171664","@dba78cdc47bfa3cf0aa59ddef96692e0@import java.io.*;
import java.io.IOException;
import java.util.Scanner;
import java.util.*;

/**
 *
 * @author philip
 */

public class Percolation {
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }
    }
    public Percolation(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        File file = new File(args[0]);
        try{
            
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_1);
            int[] TrueArr;
            int Flag = 1;
            
            int[][] IndexMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    IndexMat[i][j] = ArrNum*i+j+1;
                    //System.out.println(IndexMat[i][j]);
                }
                
            }
            
            int[][] TrueMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    TrueMat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }
            
            Percolation uf = new Percolation(ArrNum*ArrNum +1);
            for (int i = 1; i < ArrNum+1; i++){
                uf.union(0,i);
                //System.out.println(uf);
            }
            for (int i = ArrNum*ArrNum-1; i > ArrNum*(ArrNum-1); i--){
                uf.union(ArrNum*ArrNum,i);
                //System.out.println(uf);
            }
            
            //System.out.println(uf);
            
            while (File_in.hasNextLine() && Flag ==1 )
            {
                String line_2 = File_in.nextLine();
                String[] Nums = line_2.split("","");

                int Row = Integer.parseInt(Nums[0]);
                int Col = Integer.parseInt(Nums[1]);
                
                int NumIndex = ArrNum*(Row-1)+Col;
                
                TrueMat[Row-1][Col-1] = 1;
                
                
                if(Row-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-2][Col-1]){
                    uf.union(NumIndex,NumIndex-ArrNum);
                    //System.out.println(uf);
                }
                if(Row+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row][Col-1]){
                    uf.union(NumIndex,NumIndex+ArrNum);
                    //System.out.println(uf);
                }
                if(Col-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col-2]){
                    uf.union(NumIndex,NumIndex-1);
                    //System.out.println(uf);
                }
                if(Col+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col]){
                    uf.union(NumIndex,NumIndex+1);
                    //System.out.println(uf);
                }
                //System.out.println(uf);
                /*if(uf._rank[6] == 2){
                        System.out.println(line_2);
                        break;
                }*/
                for (int i = 0; i < ArrNum*ArrNum+1; i++){
                    if(uf._parent[0] == uf._parent[ArrNum*ArrNum]){
                        System.out.println(line_2);
                        Flag = 0;
                        break;
                    }
                }
                if(!File_in.hasNextLine()){
                    System.out.println(-1);
                }
            }
            
            
            /*for (int i = 0; i < ArrNum*ArrNum+1; i++) {
                    //System.out.println(TrueArr[i]);
            }
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    //Mat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }*/
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@dba78cdc47bfa3cf0aa59ddef96692e0@"
"b03611035","3","0.55","105792","@6312e1a54e8777e8d94939e489d79d67@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(200);
         
        //數有幾個座標要開通，一個逗點一個坐標
         int count=0;
         int readd=br.read();
         while(readd!=-1){
            if(readd==44) {
                count++;
            }
            readd=br.read();
         }
         
         //reset
         br.reset();
         //不知道為什麼reset後會往前跑一行
        // br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][2];
         for(int i=0;i<count;i++) 
             ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}
@6312e1a54e8777e8d94939e489d79d67@"
"b03611035","2","0.28","104944","@9edd77f8a0f6cdb8cd4578f57f0392dc@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         int count=30;
         //不知道為什麼reset後會往前跑一行
        // br.readLine();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][2];
         for(int i=0;i<count;i++) 
             ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通
         int x,y,id;
         for(int i=0;i<count;i++){
             x=Integer.parseInt(ayaya[i][0]);
             y=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",x,y);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}
@9edd77f8a0f6cdb8cd4578f57f0392dc@"
"b03611035","5","0.55","105872","@db29b77ff99e0d0ef5f10691696de65f@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(200);
         
        //數有幾個座標要開通，一個逗點一個坐標
         int count=0;
         int readd=br.read();
         while(readd!=-1){
            if(readd==44) {
                count++;
            }
            readd=br.read();
         }
         
         //reset
         br.reset();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][2];
         for(int i=0;i<count;i++) 
             ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通，ayaya[n][0]為y坐標，ayaya[n][1]為x坐標
    
         int x,y,id;
         for(int i=0;i<count;i++){
             y=Integer.parseInt(ayaya[i][0]);
             x=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",y,x);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}

@db29b77ff99e0d0ef5f10691696de65f@"
"b03611035","5","0.54","105712","@4ee7f80e0d3e09e869cbf3e0786495dd@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(1000);
         
        //數有幾個座標要開通，一個逗點一個坐標
         int count=0;
         int readd=br.read();
         while(readd!=-1){
            if(readd==44) {
                count++;
            }
            readd=br.read();
         }
         
         //reset
         br.reset();
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][2];
         for(int i=0;i<count;i++) 
             ayaya[i]=br.readLine().split("","");
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通，ayaya[n][0]為y坐標，ayaya[n][1]為x坐標
    
         int x,y,id;
         for(int i=0;i<count;i++){
             y=Integer.parseInt(ayaya[i][0]);
             x=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",y,x);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}
@4ee7f80e0d3e09e869cbf3e0786495dd@"
"r04631025","9","3.28","139904","@2c4b8b45d417b3146791262ce23fce2a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    private int N;
    UF uf;

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        uf = new UF(n*n);
        N=n;
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;    
            }
        }
        
        for (int i = 0; i < a; i++) {
            id[i] = 1;
        }
        
    }

    public void open(int x, int y){
        id[matrix[x-1][y-1]]=0;
    }

    public void un(int x, int y) {
        
        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 2][y - 1]);
            }
        }
        if (x != N) {
            if (id[matrix[x][y - 1]] == 0) {
                uf.union(matrix[x - 1][y - 1],matrix[x][y - 1] );
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == 0) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 1][y - 2]);
            }
        }
        if (y != N) {
            if (id[matrix[x - 1][y]] == 0) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if(check()==true){
            System.out.printf(""%d,%d"", x,y);
        }
        
    }
    public boolean check(){
        if(N==1){
            if(id[matrix[0][0]]==0){
                return true;
            }
        }
        for(int i=1;i<=N;i++){
            for(int j=0;j<N;j++){
                if(uf.connected(matrix[N-1][N-i],matrix[0][j])){
                    return true;
                }
            }
        }
        return false;
    }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n=0;
            while (PL.check() == false){
                String coordinate = br.readLine();
                if(coordinate == null)
                    break;
                String[] place=coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                PL.open(x, y);
                PL.un(x, y);
            }
            if(PL.check()==false){
                System.out.printf(""-1"");
            }
        }
    }
}


@2c4b8b45d417b3146791262ce23fce2a@"
"b03611035","5","0.56","105824","@7b5e4c11cab4fbe0bae6851e7660a01c@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order);
         //MARK
         br.mark(870);
         
        //數有幾個座標要開通，一個逗點一個坐標
         int count=0;
         int readd=br.read();
         while(readd!=-1){
            if(readd==44) {
                count++;
            }
            readd=br.read();
         }
        if(count==0)
            System.out.printf(""-1"");
         
         //reset
        br.reset();
        // br.close();
         
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][2];
         for(int i=0;i<count;i++) {
             ayaya[i]=br.readLine().split("","");
             
                 
         }
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(i,0);
             gg.union(order*order-1-i,order*order-1);
         }
         
         //開始開通，ayaya[n][0]為y坐標，ayaya[n][1]為x坐標
    
         int x,y,id;
         for(int i=0;i<count;i++){
             
             y=Integer.parseInt(ayaya[i][0]);
             x=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }
             
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",y,x);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}

@7b5e4c11cab4fbe0bae6851e7660a01c@"
"r04631025","10","0.328","144112","@48633908e18c702e12e9fc4ab09e9ac0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private int[] id;
    private int[][] matrix;
    private int N;
    UF uf;

    Percolation(int n) {
        matrix = new int[n][n];
        id = new int[n * n];

        uf = new UF(n * n);
        N = n;
        int a = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = a;
                a++;
            }
        }

        for (int i = 0; i < a; i++) {
            id[i] = 1;
        }

    }

    public void open(int x, int y) {
        id[matrix[x - 1][y - 1]] = -1;
    }

    public void un(int x, int y) {

        if (x != 1) {
            if (id[matrix[x - 2][y - 1]] == -1) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 2][y - 1]);
            }
        }
        if (x != N) {
            if (id[matrix[x][y - 1]] == -1) {
                uf.union(matrix[x - 1][y - 1], matrix[x][y - 1]);
            }
        }
        if (y != 1) {
            if (id[matrix[x - 1][y - 2]] == -1) {
                uf.union(matrix[x - 1][y - 1], matrix[x - 1][y - 2]);
            }
        }
        if (y != N) {
            if (id[matrix[x - 1][y]] == -1) {
                uf.union(matrix[x - 1][y], matrix[x - 1][y - 1]);
            }
        }
        if (check() == true) {
            System.out.printf(""%d,%d"", x, y);
        }

    }

    public boolean check() {
        if (N == 1) {
            if (id[0] == -1) {
                return true;
            }
        } else {
            for (int i = 1; i <= N; i++) {

                for (int j = 0; j < N; j++) {
                    if (uf.connected(matrix[N - 1][N - i], matrix[0][j])) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            int number = Integer.parseInt(data);
            Percolation PL = new Percolation(number);
            int n = 0;
            while (PL.check() == false) {
                String coordinate = br.readLine();
                if (coordinate == null) {
                    break;
                }
                String[] place = coordinate.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                PL.open(x, y);
                PL.un(x, y);
            }
            if (PL.check() == false) {
                System.out.printf(""-1"");
            }
        }
    }
}

@48633908e18c702e12e9fc4ab09e9ac0@"
"b03611035","6","0.54","105760","@2d9517722779e495d1bb59f3aabb8804@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order+2);
         //MARK
         br.mark(870);
         
        //數有幾個座標要開通，一個逗點一個坐標
         int count=0;
         int readd=br.read();
         while(readd!=-1){
            if(readd==44) {
                count++;
            }
            readd=br.read();
         }
        if(count==0)
            System.out.printf(""-1"");
         
         //reset
        br.reset();         
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][2];
         for(int i=0;i<count;i++) {
             ayaya[i]=br.readLine().split("","");             
         }
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i+1;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(order*order,i);
             gg.union(order*order+1,order*order-1-i);
         }
         
         //開始開通，ayaya[n][0]為y坐標，ayaya[n][1]為x坐標
    
         int y,x,id;
         for(int i=0;i<count;i++){
             
             y=Integer.parseInt(ayaya[i][0]);
             x=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }            
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",y,x);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}

@2d9517722779e495d1bb59f3aabb8804@"
"b99611017","0","0.56","105824","@0c0584fe6dd60203326b2d0c93989b88@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
import edu.princeton.cs.algs4.UF;
import java.io.*;
import java.util.Scanner;
import java.io.FileReader;

public class Percolation {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            int size = Integer.parseInt(token[0]); //sieze the matrix size

            int holeNum = token.length - 1;  //Number of holes

            int[] hole = new int[holeNum];

            for (int i = 0; i < holeNum; i++) //transfer site into flags
            {
                String[] site = token[1 + i].split("","");  //hole[i] are flags

                int row = Integer.parseInt(site[0]);

                int column = Integer.parseInt(site[1]);

                hole[i] = (row - 1) * size + (column - 1);

                System.out.println(hole[i]);     //hole[i] refers to token[1+i]

            }

            int gridNum = size * size + 2;   // size=3 gridNum=11
            //flag=9: upper
            //flag=10 : buttom

            UF uf;
            uf = new UF(gridNum);    //flag : 0~10

            for (int i = 0; i < size; i++) {
                uf.union(gridNum - 2, i);     //flag 9
            }

            for (int i = gridNum - 2 - size; i < gridNum - 2; i++) {
                uf.union(i, gridNum - 1);     //flag 10
            }
            for (int i = 0; i < holeNum; i++) {
                if (hole[i] == 0) //left up
                {
                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                } else if (hole[i] == size - 1) //right up
                {
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                } else if (hole[i] == gridNum - 3) //right down
                {
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else if (hole[i] == gridNum - size - 2) //left down
                {
                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else if (hole[i] / size == 0 && hole[i] != 0 && hole[i] != size - 1) {

                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] / size == 2 && hole[i] != gridNum - 3 && hole[i] != gridNum - size - 2) {
                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else if (hole[i] % size == 0 && hole[i] != 0 && hole[i] != gridNum - size - 2) {

                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else if (hole[i] % size == size - 1 && hole[i] != size - 1 && hole[i] != gridNum - 3) {

                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else {

                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }

                }
                if (uf.connected(gridNum - 1, gridNum - 2)) {
                    System.out.println(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    break;
                }

            }
            if (uf.connected(gridNum - 1, gridNum - 2) == false) {
                System.out.println(-1);
            }

        } catch (RuntimeException e) {

            throw e;
        }
        // TODO code application logic here
        /*UF uf=new UF(10);
         uf.union(2, 5);
         uf.union(2, 6);
         System.out.println(uf.count());
         System.out.println(uf.connected(5, 6));*/
    }

}

@0c0584fe6dd60203326b2d0c93989b88@"
"b99611017","0","0.78","110448","@a3e32ae5b40d086b29d5d3ce863989c1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
//import edu.princeton.cs.algs4.UF;
import java.io.*;
import java.util.Scanner;
import java.io.FileReader;

public class Percolation {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            int size = Integer.parseInt(token[0]); //sieze the matrix size

            int holeNum = token.length - 1;  //Number of holes

            int[] hole = new int[holeNum];

            for (int i = 0; i < holeNum; i++) //transfer site into flags
            {
                String[] site = token[1 + i].split("","");  //hole[i] are flags

                int row = Integer.parseInt(site[0]);

                int column = Integer.parseInt(site[1]);

                hole[i] = (row - 1) * size + (column - 1);

                System.out.println(hole[i]);     //hole[i] refers to token[1+i]

            }

            int gridNum = size * size + 2;   // size=3 gridNum=11
            //flag=9: upper
            //flag=10 : buttom

            UF uf;
            uf = new UF(gridNum);    //flag : 0~10

            for (int i = 0; i < size; i++) {
                uf.union(gridNum - 2, i);     //flag 9
            }

            for (int i = gridNum - 2 - size; i < gridNum - 2; i++) {
                uf.union(i, gridNum - 1);     //flag 10
            }
            for (int i = 0; i < holeNum; i++) {
                if (hole[i] == 0) //left up
                {
                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                } else if (hole[i] == size - 1) //right up
                {
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                } else if (hole[i] == gridNum - 3) //right down
                {
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else if (hole[i] == gridNum - size - 2) //left down
                {
                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else if (hole[i] / size == 0 && hole[i] != 0 && hole[i] != size - 1) {

                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] / size == 2 && hole[i] != gridNum - 3 && hole[i] != gridNum - size - 2) {
                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else if (hole[i] % size == 0 && hole[i] != 0 && hole[i] != gridNum - size - 2) {

                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else if (hole[i] % size == size - 1 && hole[i] != size - 1 && hole[i] != gridNum - 3) {

                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }
                } else {

                    if (uf.connected(gridNum - 2, hole[i] + 1)) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - 1)) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (uf.connected(gridNum - 2, hole[i] + size)) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (uf.connected(gridNum - 2, hole[i] - size)) {
                        uf.union(hole[i], hole[i] - size);
                    }

                }
                if (uf.connected(gridNum - 1, gridNum - 2)) {
                    System.out.println(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    break;
                }

            }
            if (uf.connected(gridNum - 1, gridNum - 2) == false) {
                System.out.println(-1);
            }

        } catch (RuntimeException e) {

            throw e;
        }
        // TODO code application logic here
        /*UF uf=new UF(10);
         uf.union(2, 5);
         uf.union(2, 6);
         System.out.println(uf.count());
         System.out.println(uf.connected(5, 6));*/
    }

}

@a3e32ae5b40d086b29d5d3ce863989c1@"
"b01502105","0","0.54","105760","@36370d33a1ce8595cb04253eb994c66e@
import edu.princeton.cs.algs4.UF;
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
            //System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
                    //System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
                        for (int a = 0; a < num; a++) {
                            for (int b = 0; b < num; b++) {
                                //System.out.printf(matrix[a][b] + "" "");
                            }
                            //System.out.printf(""\n"");
                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
                            //System.out.printf(""Done!"" + ""\n"");
                            //System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
                        //System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
            //System.out.printf(""Done!"" + ""\n"");
        }
    }
}

@36370d33a1ce8595cb04253eb994c66e@"
"b01502105","0","0.54","105760","@4f882f5b981c6124447210d1901def16@
import edu.princeton.cs.algs4.UF;
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
            //System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
                    //System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
                        for (int a = 0; a < num; a++) {
                            for (int b = 0; b < num; b++) {
                                //System.out.printf(matrix[a][b] + "" "");
                            }
                            //System.out.printf(""\n"");
                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
                            //System.out.printf(""Done!"" + ""\n"");
                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
                        //System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
            //System.out.printf(""Done!"" + ""\n"");
        }
    }
}

@4f882f5b981c6124447210d1901def16@"
"b01502105","0","0.56","105824","@4f882f5b981c6124447210d1901def16@
import edu.princeton.cs.algs4.UF;
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
            //System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
                    //System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
                        for (int a = 0; a < num; a++) {
                            for (int b = 0; b < num; b++) {
                                //System.out.printf(matrix[a][b] + "" "");
                            }
                            //System.out.printf(""\n"");
                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
                            //System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
                            //System.out.printf(""Done!"" + ""\n"");
                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
                        //System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
            //System.out.printf(""Done!"" + ""\n"");
        }
    }
}

@4f882f5b981c6124447210d1901def16@"
"b01502105","5","0.92","105712","@53d1b0a0753961e23d13e7854a27c0e6@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
//                    System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
//                        System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}
@53d1b0a0753961e23d13e7854a27c0e6@"
"b01502105","5","0.9","105728","@3157f3fbfb6f9a77f860eb77c2ab0b37@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
//                    System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
//                          System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
//                        System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}

@3157f3fbfb6f9a77f860eb77c2ab0b37@"
"b01502105","5","0.9","105760","@d39756503a67feadb2135323ca7f6ba5@
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
//                    System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
//                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
//                        System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}

@d39756503a67feadb2135323ca7f6ba5@"
"b01502105","0","0.56","105824","@c1646026fb3efbc657f2d958e544c1cd@import edu.princeton.cs.algs4.UF;
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
//                    System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
//                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
//                        System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
//                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}

@c1646026fb3efbc657f2d958e544c1cd@"
"b01502105","0","0.84","105552","@62b3b0d2581e18917ed62d2133e4a0e0@
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
//                    System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
//                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
//                        System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
//                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}

@62b3b0d2581e18917ed62d2133e4a0e0@"
"b01502105","5","0.94","105728","@6a6e0528d6e5a020cfccb750b12a3825@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
//                    System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
                        int open = num * row + column + 1;
                        //down
                        if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                        if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
//                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                        }
//                        System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}

@6a6e0528d6e5a020cfccb750b12a3825@"
"b01502105","5","0.91","105648","@655a539ab1ca12d5fd07c022cd147bc6@import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
////                    String[] input = data[k].split("","");
////                    int row = Integer.parseInt(input[0]) - 1;
////                    int column = Integer.parseInt(input[1]) - 1;
//                    System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
////                    if (row >= 0 && row < num && column >= 0 && column < num) {
////                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
////                        int open = num * row + column + 1;
                        //down
//                        if (row + 1 < num && matrix[row + 1][column] == 1) {
//                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
//                        }
                        //up
//                       if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
//                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
//                        }
                        //left
 //                       if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
//                            uf.union(index[open], index[open -1 ]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
//                        }
                        //right
//                        if (column + 1 < num && matrix[row][column + 1] == 1) {
//                            uf.union(index[open], index[open + 1]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
//                        }
                        //checking connection
//                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
//                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
//                            break loop;
//                       }
//                        System.out.println("" "");
                    }
//                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}
@655a539ab1ca12d5fd07c022cd147bc6@"
"b01502105","10","0.102","130192","@9e9647f780e666ec7d681f5d5af90b35@
import java.io.BufferedReader;
import java.io.FileReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StringBuilder everything = new StringBuilder();
            String line;
            everything.append(br.readLine());
            while ((line = br.readLine()) != null) {
                everything.append("" "");
                everything.append(line);
            }
            String[] data = everything.toString().split("" "");           
            int num = Integer.parseInt(data[0]);  //matrix size
            int len = data.length;  //input 
//            System.out.printf(num+""\n"");
            int[][] matrix = new int[num][num];
            int element_num = num * num + 2;
            UF uf = new UF(element_num);
            int[] index = new int[element_num];
            int k;
            for (int i = 0; i < element_num; i++) {
                index[i] = i;
            }
            for (int j = 1; j <= num; j++) {
                uf.union(index[j], index[0]);
                uf.union(index[element_num - 1 - j], index[element_num - 1]);
            }
//            System.out.printf(""initial connected = ""+uf.connected(index[0], index[element_num-1])+""\n"");
            loop:
            {
                for (k = 1; k <= len - 1; k++) {
                    String[] input = data[k].split("","");
                    int row = Integer.parseInt(input[0]) - 1;
                    int column = Integer.parseInt(input[1]) - 1;
//                    System.out.printf(""input = ""+input[0]+"",""+input[1]+""\n"");
                    if (row >= 0 && row < num && column >= 0 && column < num) {
                        matrix[row][column] = 1;
//                        for (int a = 0; a < num; a++) {
//                            for (int b = 0; b < num; b++) {
//                                System.out.printf(matrix[a][b] + "" "");
//                            }
//                            System.out.printf(""\n"");
//                        }
                        int open = num * row + column + 1;
                        //down
                       if (row + 1 < num && matrix[row + 1][column] == 1) {
                            uf.union(index[open], index[open + num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 2) + "","" + (column + 1) + ""\n"");
                        }
                        //up
                       if (row - 1 >= 0 && matrix[row - 1][column] == 1) {
                            uf.union(index[open], index[open - num]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + row + "","" + (column + 1) + ""\n"");
                        }
                        //left
                        if (column - 1 >= 0 && matrix[row][column - 1] == 1) {
                            uf.union(index[open], index[open -1 ]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column) + ""\n"");
                        }
                        //right
                        if (column + 1 < num && matrix[row][column + 1] == 1) {
                            uf.union(index[open], index[open + 1]);
//                            System.out.printf(""union:"" + (row + 1) + "","" + (column + 1) + "" "" + (row + 1) + "","" + (column + 2) + ""\n"");
                        }
                        //checking connection
                        if (uf.connected(index[0], index[element_num - 1])) {
//                            System.out.printf(""Done!"" + ""\n"");
                            System.out.printf(input[0] + "","" + input[1] + ""\n"");
                            break loop;
                       }
//                        System.out.println("" "");
                    }
                }
            }
            if (k >= len) {
                System.out.printf(""-1""+""\n"");
            }
//            System.out.printf(""Done!"" + ""\n"");
        }
    }
}
@9e9647f780e666ec7d681f5d5af90b35@"
"r03525006","6","0.9","136336","@5b4b9742ac3618579d7ead9dc5910bbc@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int rowAns = 0;
            int colAns = 0;
            int i = 0;

            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                isPercolation = true;
                                rowAns = row[i];
                                colAns = col[i];
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()) {
                        i++;
                    } else {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
                System.out.println(rowAns + "","" + colAns);
            } else {
                System.out.println(-1);
            }
        }
    }
}

@5b4b9742ac3618579d7ead9dc5910bbc@"
"r03525006","6","0.9","140432","@5b4b9742ac3618579d7ead9dc5910bbc@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int rowAns = 0;
            int colAns = 0;
            int i = 0;

            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                isPercolation = true;
                                rowAns = row[i];
                                colAns = col[i];
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()) {
                        i++;
                    } else {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
                System.out.println(rowAns + "","" + colAns);
            } else {
                System.out.println(-1);
            }
        }
    }
}

@5b4b9742ac3618579d7ead9dc5910bbc@"
"r04945008","10","0.101","123072","@a43259b066d7e3b194519d358a11b15e@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {    
    public static boolean check(boolean[][] site, int i, int j) {
        int N = site.length;

        if (i < 0 || i >= N) return false;    // invalid row
        if (j < 0 || j >= N) return false;    // invalid column
        if (site[i][j] == false) return false;    // not an open site
        return true;
    }

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            // store the first integer in variable stringCount (number of announced strings)
            String line;
            String[] broken_line;
            int i = 0; int j = 0;
            boolean[][] site = new boolean[num][num];
            WeightedQuickUnionUF  uf = new WeightedQuickUnionUF (num*num+2);
            for (i = 0; i < num; i++) {
                uf.union(0, i+1);
                uf.union(num*num+1, num*num-i);
            }
//            System.out.println(uf.count());
//            System.out.println(uf.connected(1, 3));
            
            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = true;
                if (check(site, i+1, j)) uf.union(num*i+j+1, num*(i+1)+j+1);        //down
                if (check(site, i, j+1)) uf.union(num*i+j+1, num*i+j+2);            //right  
                if (check(site, i, j-1)) uf.union(num*i+j+1, num*i+j);              //left
                if (check(site, i-1, j)) uf.union(num*i+j+1, num*(i-1)+j+1);        //up
                if (uf.connected(0, num*num+1)){ 
                    System.out.printf(""%d,%d\n"",i+1,j+1);
                    break;
                }
            }
            if (!(uf.connected(0, num*num+1))) System.out.printf(""-1\n"");
        }
    }
}
@a43259b066d7e3b194519d358a11b15e@"
"f02631008","9","1.41","165472","@a32f3f161637fdb7eec78720cab19495@import java.io.*;
import java.io.IOException;
import java.util.Scanner;
import java.util.*;

/**
 *
 * @author philip
 */

public class Percolation {
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }
    }
    public Percolation(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        File file = new File(args[0]);
        try{
            
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_1);
            int[] TrueArr;
            int Flag = 1;
            
            int[][] IndexMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    IndexMat[i][j] = ArrNum*i+j+1;
                    //System.out.println(IndexMat[i][j]);
                }
                
            }
            
            int[][] TrueMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    TrueMat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }
            
            Percolation uf = new Percolation(ArrNum*ArrNum +1);
            for (int i = 1; i < ArrNum+1; i++){
                uf.union(0,i);
                //System.out.println(uf);
            }
            for (int i = ArrNum*ArrNum-1; i > ArrNum*(ArrNum-1); i--){
                uf.union(ArrNum*ArrNum,i);
                //System.out.println(uf);
            }
            
            //System.out.println(uf);
            
            while (File_in.hasNextLine() && Flag ==1 )
            {
                String line_2 = File_in.nextLine();
                String[] Nums = line_2.split("","");

                int Row = Integer.parseInt(Nums[0]);
                int Col = Integer.parseInt(Nums[1]);
                
                int NumIndex = ArrNum*(Row-1)+Col;
                
                TrueMat[Row-1][Col-1] = 1;
                
                
                if(Row-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-2][Col-1]){
                    uf.union(NumIndex,NumIndex-ArrNum);
                    //System.out.println(uf);
                }
                if(Row+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row][Col-1]){
                    uf.union(NumIndex,NumIndex+ArrNum);
                    //System.out.println(uf);
                }
                if(Col-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col-2]){
                    uf.union(NumIndex,NumIndex-1);
                    //System.out.println(uf);
                }
                if(Col+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col]){
                    uf.union(NumIndex,NumIndex+1);
                    //System.out.println(uf);
                }
                //System.out.println(uf);
                /*if(uf._rank[6] == 2){
                        System.out.println(line_2);
                        break;
                }*/
                for (int i = 0; i < ArrNum*ArrNum+1; i++){
                    if(uf._parent[0] == uf._parent[ArrNum*ArrNum]){
                        System.out.println(line_2);
                        Flag = 0;
                        break;
                    }
                }
                if(!File_in.hasNextLine()){
                    System.out.println(""-1"");
                }
            }
            
            
            /*for (int i = 0; i < ArrNum*ArrNum+1; i++) {
                    //System.out.println(TrueArr[i]);
            }
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    //Mat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }*/
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@a32f3f161637fdb7eec78720cab19495@"
"r03525006","8","1.59","137296","@4cc28583c95e55142cdee2510097015e@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int rowAns = 0;
            int colAns = 0;
            int i = 0;


            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                isPercolation = true;
                                rowAns = row[i];
                                colAns = col[i];
                                System.out.println(rowAns + "","" + colAns);
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()-1) {
                        i++;
                    } else {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }

            } else {
                System.out.println(-1);
            }
        }
    }
}

@4cc28583c95e55142cdee2510097015e@"
"r03525006","5","0.91","136000","@7a1a2ea7689309359005c99c378cc869@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int i = 0;
            boolean isStopLoop = false;
            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                isPercolation = true;
                                System.out.println(row[i] + "","" + col[i]);
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()) {
                        i++;
                    } else {
                        isStopLoop = true;
                    }

                    if (isStopLoop) {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
            } else {
                System.out.println(-1);
            }
        }
    }
}

@7a1a2ea7689309359005c99c378cc869@"
"r04631034","3","0.39","107904","@2f5ee358a1d389a3da2a6b134628afe0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.*;
import java.util.*;

/**
 *
 * @author user
 */
public class Percolation {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);

          int num = Integer.parseInt(in.readLine());
//          System.out.println(num);
          ArrayList<Integer> Row = new ArrayList<Integer>();
          ArrayList<Integer> Column = new ArrayList<Integer>();

          String line;
          while ((line = in.readLine()) != null) {
               Row.add(Integer.parseInt(line.split("","")[0]) - 1);
               Column.add(Integer.parseInt(line.split("","")[1]) - 1);
          }
//          for (int i = 0; i < Row.size(); i++) {
//               System.out.print(Row.get(i) + "","" + Column.get(i));
//               System.out.println("""");
//          }
          UF uf = new UF(num * num + 2);//   num*num+1  top  node   num*num+2 bottom node
          int[][] OpenSiteStorge = new int[Row.size()][Row.size()];
           
          if(num!=1){
                  
          
          
          
          for (int i = 0; i < Row.size(); i++) 
          {                       //Row.get(i) * num + Column.get(i) means ID index    /input coornate
                    if(Row.get(i)<num && Column.get(i)<num)
                    {
//               set open site up
               OpenSiteStorge[Row.get(i)][Column.get(i)] = 1;

//               top row connect to the top node
               if (Row.get(i) == 0) 
               {
                    uf.union(Row.get(i) * num + Column.get(i), num * num);
                    if (OpenSiteStorge[Row.get(i) + 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) + 1) * num + Column.get(i));
                    }
                         if (Column.get(i) == 0 && OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                         {
//                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
//                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
//                              }
                         } 
                         else if (Column.get(i) == num - 1 && OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                         {
//                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
//                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
//                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }
           }

//               last row connect to the bottom node
          else if (Row.get (i)   == num - 1)
          {
                    uf.union(Row.get(i) * num + Column.get(i), num * num + 1);
                     if (OpenSiteStorge[Row.get(i) - 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) - 1) * num + Column.get(i));
                        }  
                         if (Column.get(i) == 0 && OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                         {
//                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
//                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
//                              }
                         } 
                         else if (Column.get(i) == num - 1 && OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                         {
//                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
//                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
//                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }      
     }
          else if(Row.get (i)  != num - 1 && Row.get (i)   != 0)//middle row 
            {               
               if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
               else if (Column.get(i) == num-1) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                         } 
               else if (Column.get(i) != num-1 && Column.get(i) != 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
          }
     
     if(uf.connected(num*num, num*num+1) == true)
     {
//          System.out.println(""output:"");
          System.out.println((Row.get(i)+1)+"",""+(Column.get(i)+1));
          break;
     }
     if( i == Row.size() - 1 && uf.connected(num*num, num*num+1) == false )
     {           
               System.out.println(""-1"");
     }
     }
}
          }
          else{
          System.out.println((Row.get(0)+1)+"",""+(Column.get(0)+1));
          }
//for(int i = 0 ; i < num;i++){
//                    System.out.println(OpenSiteStorge[i][0]+"" ""+OpenSiteStorge[i][1]+"" ""+OpenSiteStorge[i][2]);
//          }
//          System.out.println(uf.connected(num*num, num*num+1));
//          System.out.println(uf.connected(0, 3));
//          System.out.println(uf.connected(0, num * num));
//          System.out.println(uf.connected(6, num * num + 1));
//          System.out.println(uf.connected(7, num * num + 1));
//          System.out.println(uf.connected(8, num * num + 1));
     }
}
@2f5ee358a1d389a3da2a6b134628afe0@"
"r03525006","5","0.9","136496","@19c1e6eb4502be8e095c02731cba4fbc@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int i = 0;
            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                isPercolation = true;
                                System.out.println(row[i] + "","" + col[i]);
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()) {
                        i++;
                    } else {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
            } else {
                System.out.println(-1);
            }
        }
    }
}

@19c1e6eb4502be8e095c02731cba4fbc@"
"r03525006","8","1.54","134912","@3ca27420002d1c497ecd0243d08eeb39@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int i = 0;
            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                isPercolation = true;
                                System.out.println(row[i] + "","" + col[i]);
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()-1) {
                        i++;
                    } else {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
            } else {
                System.out.println(-1);
            }
        }
    }
}

@3ca27420002d1c497ecd0243d08eeb39@"
"r03525006","5","0.77","134976","@4eadcbe1a9eab114e416f0dc054d9ac2@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int i = 0;
            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                isPercolation = true;
                                System.out.println(row[i] + "","" + col[i]);
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()-1) {
                        i++;
                    }
                    if (i == lines.size()) {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
            } else {
                System.out.println(-1);
            }
        }
    }
}

@4eadcbe1a9eab114e416f0dc054d9ac2@"
"r03525006","8","1.61","133408","@e4fbd62dfe0c31f231830f4bf12f84ab@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int i = 0;
            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""old i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                isPercolation = true;
                                System.out.println(row[i] + "","" + col[i]);
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()) {
                        i++;
                    }
                    if (i > lines.size()-1 && !isPercolation) {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
            } else {
                System.out.println(-1);
            }
        }
    }
}

@e4fbd62dfe0c31f231830f4bf12f84ab@"
"f02631008","10","0.137","166384","@1abe69e1658fcc4d35f1df33785bda24@import java.io.*;
import java.io.IOException;
import java.util.Scanner;
import java.util.*;

/**
 *
 * @author philip
 */

public class Percolation {
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }
    }
    public Percolation(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        File file = new File(args[0]);
        try{
            
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            int ArrNum = Integer.parseInt(line_1);
            int[] TrueArr;
            int Flag = 1;
            int LineCount = 0;
            
            int[][] IndexMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    IndexMat[i][j] = ArrNum*i+j+1;
                    //System.out.println(IndexMat[i][j]);
                }
                
            }
            
            int[][] TrueMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    TrueMat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }
            
            Percolation uf = new Percolation(ArrNum*ArrNum +1);
            for (int i = 1; i < ArrNum+1; i++){
                uf.union(0,i);
                //System.out.println(uf);
            }
            for (int i = ArrNum*ArrNum-1; i > ArrNum*(ArrNum-1); i--){
                uf.union(ArrNum*ArrNum,i);
                //System.out.println(uf);
            }
            
            //System.out.println(uf);
            
            while (File_in.hasNextLine() && Flag ==1 )
            {
                String line_2 = File_in.nextLine();
                String[] Nums = line_2.split("","");

                int Row = Integer.parseInt(Nums[0]);
                int Col = Integer.parseInt(Nums[1]);
                
                int NumIndex = ArrNum*(Row-1)+Col;
                
                TrueMat[Row-1][Col-1] = 1;
                LineCount++;
                
                if(Row-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-2][Col-1]){
                    uf.union(NumIndex,NumIndex-ArrNum);
                    //System.out.println(uf);
                }
                if(Row+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row][Col-1]){
                    uf.union(NumIndex,NumIndex+ArrNum);
                    //System.out.println(uf);
                }
                if(Col-2 >= 0 && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col-2]){
                    uf.union(NumIndex,NumIndex-1);
                    //System.out.println(uf);
                }
                if(Col+1 <= ArrNum && TrueMat[Row-1][Col-1] == TrueMat[Row-1][Col]){
                    uf.union(NumIndex,NumIndex+1);
                    //System.out.println(uf);
                }
                //System.out.println(uf);
                /*if(uf._rank[6] == 2){
                        System.out.println(line_2);
                        break;
                }*/
                for (int i = 0; i < ArrNum*ArrNum+1; i++){
                    if(uf._parent[0] == uf._parent[ArrNum*ArrNum]){
                        System.out.println(line_2);
                        Flag = 0;
                        break;
                    }
                }
                if(!File_in.hasNextLine() && LineCount > 1){
                    System.out.println(""-1"");
                }
            }
            
            
            /*for (int i = 0; i < ArrNum*ArrNum+1; i++) {
                    //System.out.println(TrueArr[i]);
            }
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    //Mat[i][j] = 0;
                    //System.out.println(TrueMat[i][j]);
                }
                
            }*/
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@1abe69e1658fcc4d35f1df33785bda24@"
"r04945022","0","1.11","157168","@c89c3fa902c922903063fae7c201dd59@import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1 && newside>1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while((data = br.readLine())!=null){
//            try{
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
//             data = br.readLine();
//             }catch(IOException ex){
//            err.println(ex.getMessage());
//        } 
        }
        
           if(!Perco1.percolates()){
               System.out.printf(""-1"");
           }
        
     
    }
    
}
@c89c3fa902c922903063fae7c201dd59@"
"r04945022","8","1.01","124528","@540e312a1048fe370aa83d1375ab3738@import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.Integer;
import static java.lang.System.err;
/**
 *
 * @author Daniel C
 */
public class Percolation {
    


/**
 *
 * @author Daniel
 */

     //0closed, 1open
  private int [] states;
  private int side;
  private WeightedQuickUnionUF cellStorage;
// create N-by-N grid, with all sites blocked
     public  void Percolate(int N){
       side=N;
        //+2 are for additional top and bottom cells
       cellStorage=new WeightedQuickUnionUF(N*N+2);      
       states=new int[N*N+2];
       for(int index=0;index<N*N;index++){
           states[index]=0;
       }
       states[N*N]=1;
       states[N*N+1]=1;            
     }  
   // open site (row i, column j)  
     public void open(int i, int j){ 
       checkRange(i,j);
       if(isOpen(i,j))return;       
       int cell=getCellIndex(i,j);
       states[cell]=1;
       //if not top row
       if(i!=1 && isOpen(i-1,j)){
          union(getCellIndex(i-1,j),cell);
       }else if(i==1 && side >1){
          //connect to virtual top cell
         union(cell,side*side);
       }
       //if not bottom row
       if(i!=side && isOpen(i+1,j)){       
         union(getCellIndex(i+1,j),cell);
       }else if (i==side){
          //connect to virtual bottom cell
          union(cell,side*side+1);
       }
       //if not left border
       if(j!=1 && isOpen(i,j-1)){
         union(getCellIndex(i,j-1),cell);
       }
       //if not right border
        if(j!=side && isOpen(i,j+1)){
         union(getCellIndex(i,j+1),cell);
       }
     }
     
     private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
     
     private void union(int a, int b){
         if (!cellStorage.connected(a,b)){
           cellStorage.union(a,b);
         }
     }
     
     // is site (row i, column j) open?
     public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
     
      // is site (row i, column j) full?
     public boolean isFull(int i, int j){
       checkRange(i,j);
       return cellStorage.connected(side*side,getCellIndex(i,j));
     }   
     
      // does the system percolate?
     public boolean percolates(){
       return cellStorage.connected(side*side,side*side+1);
     }           
     
     private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
     public static void main(String[] args) throws IOException {
        
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        Percolation Perco1 = new Percolation();
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int inputnumber1 = 0 , inputnumber2 = 0;
        int newside = Integer.parseInt(br.readLine());
        Perco1.Percolate(newside);
        String data = null;
        String[] inputarray;
        data = br.readLine();
        while((data = br.readLine())!=null){
//            try{
             inputarray = data.split("","");
             inputnumber1 = Integer.parseInt(inputarray[0]);
             inputnumber2 = Integer.parseInt(inputarray[1]); 
             Perco1.open(inputnumber1, inputnumber2);
             if(Perco1.percolates()){
               System.out.println(inputnumber1+"",""+inputnumber2);
               break;
           }
//             data = br.readLine();
//             }catch(IOException ex){
//            err.println(ex.getMessage());
//        } 
        }
        
           if(!Perco1.percolates()){
               System.out.printf(""-1"");
           }
        
     
    }
    
}
@540e312a1048fe370aa83d1375ab3738@"
"r04631021","9","1.51","185280","@dbb0e0be1343c849aba9393577127d0d@
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import java.util.ArrayList;
import java.util.*;

/**
 *
 * @author 林康維
 */
public class Percolation {
  private int[] _parent;
  private int[] _rank;


  public int find(int i) {

    int p = _parent[i];
    if (i == p) {
      return i;
    }
    return _parent[i] = find(p);

  }


  public void union(int i, int j) {

    int root1 = find(i);
    int root2 = find(j);
    int root3 = root1 ;
    int root4 = root2 ;

    if (root2 == root1) return;

    if (_rank[root1] > _rank[root2]) {
        for (int k = 0; k <_parent.length ; k++){
           if(_parent[k] ==_parent[root2] ){
               _parent[k] = root1 ;
           }
       }
       _parent[root2] = root1;
       
    } else if (_rank[root2] > _rank[root1]) {
        for(int k=0 ; k < _parent.length ; k++){
            if(_parent[k] == _parent[root1]){
                _parent[k] = root2 ;
            }
        }
      _parent[root1] = root2;
    } else {
         for(int k=0 ; k < _parent.length ; k++){
            if(_parent[k] == _parent[root2]){
                _parent[k] = root1 ;
            }
        }
      _parent[root2] = root1;
      _rank[root1]++;
    }
  }


  public Percolation(int max) {

    _parent = new int[max];
    _rank = new int[max];

    for (int i = 0; i < max; i++) {
      _parent[i] = i;
    }
  }


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
            File file = new File(args[0]);
            try{
            Scanner File_in = new Scanner(file);            
            String num = File_in.nextLine();
            //String num = data ;
            int RankOfData = Integer . parseInt (num) ;
            Percolation uf = new Percolation(RankOfData*RankOfData+2);
            for(int i=1 ; i<=RankOfData ; i++){
                //System.out.println(uf._parent[i]);
                uf.union(i,0) ;
                //System.out.println(uf._parent[i]);
            }
            for(int i=RankOfData*RankOfData ; i>=RankOfData*RankOfData-RankOfData+1 ; i--){
                //System.out.println(uf._parent[i]);
                uf.union(i, RankOfData*RankOfData+1 );
                //System.out.println(uf._parent[i]);
            }
            
            boolean matrix[] = new boolean [RankOfData*RankOfData+2] ;
            //ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>() ;
            //視情況可刪或不刪,N^2的演算法
            for (int i = 0 ; i < RankOfData*RankOfData+2 ; i++){
                
                matrix[i] = false ;
                
            }
            if (RankOfData !=1){
            while(true){
                String White = File_in.nextLine() ;
                String[] mat = White.split("","");
                int Drow = Integer . parseInt( mat[0] ) -1 ;
                int Dcol = Integer . parseInt( mat[1] ) -1 ;
               /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                matrix [Drow*RankOfData+Dcol+1] = true ;
                /*System.out.println(Drow
                        +Dcol);
                System.out.println(matrix[Drow*RankOfData-Dcol+1]);*/
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                //System.out.println(uf._parent[9]);
                if((Drow!=0)&&(Drow!=RankOfData-1)){
                //上             
                if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                }
                
                //下
                if(matrix[Drow*RankOfData+Dcol+RankOfData+1]){
                    uf.union(Drow*RankOfData+Dcol+RankOfData+1, Drow*RankOfData+Dcol+1);
                }
                
                //左
                if(matrix[Drow*RankOfData+Dcol]){
                    uf.union(Drow*RankOfData+Dcol, Drow*RankOfData+Dcol+1) ;
                  }
                
                //右
                if(matrix[Drow*RankOfData+Dcol+2]){
                    uf.union(Drow*RankOfData+Dcol+2, Drow*RankOfData+Dcol+1) ;
                }
                
                //System.out.println(uf._parent[Drow*RankOfData+Dcol+1]);
                
                if(uf._parent[1]==uf._parent[RankOfData*RankOfData-1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                }
                }
                else if(Drow == 0){
                    if(matrix[Dcol+RankOfData+1]){
                    uf.union(Dcol+RankOfData+1, Dcol+1);
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData-1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                else if(Drow == RankOfData -1){
                    if (matrix[Drow*RankOfData+Dcol-RankOfData+1]){
                    uf.union( Drow*RankOfData+Dcol-RankOfData+1, Drow*RankOfData+Dcol+1 ) ;
                    if(uf._parent[1]==uf._parent[RankOfData*RankOfData-1]){
                    
                    System.out.println((Drow+1)
                            +"",""
                            +(Dcol+1)) ;
                    break ;
                    }
                }
                }
                
                if(!(File_in.hasNextLine())){
                    System.out.println(-1);
                    break ;
                    
                }
                
            
            }
            }
            else if (RankOfData ==1 ){
                   if((File_in.hasNextLine())){
                    System.out.println(""1,1"");
                   }
                   else
                       System.out.println(""-1"");
                    }
            }
            catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
    
}

@dbb0e0be1343c849aba9393577127d0d@"
"r04921074","7","1.11","125872","@d04b67797dd61cb14185605916a62050@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);
                    
                   
                  
                 
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        //   System.out.print(axis1[counting]+"",""+axis2[counting]+""  ""+axis1[counting-i-1]+"",""+axis2[counting-i-1]+"" "");
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        //   System.out.print(axis1[counting]+"",""+axis2[counting]+""  ""+axis1[counting-i-1]+"",""+axis2[counting-i-1]+"" "");                                           
                        }//end of if (these is for check and connect) 
                       
                  
                  
                        
                     //  System.out.printf(metrix[axis1[counting-i-1]][axis2[counting-i-1]]+""\n"");
                      //  System.out.println(!uf.connected(metrix[axis1[counting]][axis1[counting]], metrix[axis1[counting-i-1]][axis1[counting-i-1]]));
                      //       System.out.println(axis1[counting]+"",""+axis2[counting]+""  ""+axis1[counting-i-1]+"",""+axis2[counting-i-1]+""\n""); 
                          
                                                               
                    }//end of for
                    
                    
                    
                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }
                                   
                    //check percolation
                    counting ++;      
                    
                }//end of while
         
             if(!uf.connected(0, scale*scale+1))
             {    
             System.out.println(""-1"");
             }
             
             if((axis1[0] == 0) && (scale == 1))
             {    
             System.out.println(""-1"");
             }
         

         //int
     }//end of try
    
    }
    
}

@d04b67797dd61cb14185605916a62050@"
"r04921074","7","1.09","128480","@8ac50ed2608df9d541ec658dc45b1509@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}
@8ac50ed2608df9d541ec658dc45b1509@"
"r04631009","0","1.43","180320","@f13bd46fd7eda4742e7d2807b7a69305@
/**
 *
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.QuickUnionUF;

public class text {

    private static int convert(int x, int y, int N) {
        int p = (x - 1) * N + y;
        return p;
    }

    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            //Read the First line to make matrix
            int N = Integer.parseInt(data[0]);
//----------------Set the matrix and initialized to be zero-------------------//            
            int[][] check = new int[N][N];
            //call API
            QuickUnionUF uf = new QuickUnionUF(N * N + 2);
            int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;

            String d = null;
            //while loop to  read input data
            while ((d = br.readLine()) != null) {

                String[] data1 = d.split("","");

                x = Integer.parseInt(data1[0]);
                y = Integer.parseInt(data1[1]);

                int inx = x - 1, iny = y - 1;

                // cheack function
                check[inx][iny] = 1;

                int p = convert(x, y, N);

                if (1 == x) {
                    uf.union(p, 0);
                }

                if (N == x) {
                    uf.union(p, N * N + 1);
                }

                if ((x - 1) > 0 && (x - 1) <= N) {
                    int pu = convert(x - 1, y, N);
                    if (1 == check[x - 2][y - 1]) {
                        uf.union(p, pu);
                    }
                }

                if ((x + 1) <= N && (x + 1) > 0) {
                    int pl = convert(x + 1, y, N);
                    if (1 == check[x][y - 1]) {
                        uf.union(p, pl);
                    }
                }

                if ((y - 1) > 0 && (y - 1) <= N) {
                    int pl = convert(x, y - 1, N);
                    if (1 == check[x - 1][y - 2]) {
                        uf.union(p, pl);
                    }
                }

                if ((y + 1) <= N && (y + 1) > 0) {
                    int pr = convert(x, y + 1, N);
                    if (1 == check[x - 1][y]) {
                        uf.union(p, pr);
                    }
                }

                if ((uf.connected(0, N * N + 1)) && (0 == end)) {
                    x1 = x;
                    y1 = y;
                    end = 1;
                    j = 2;
                }

            }
            switch (j) {
                case 1:
                    System.out.println(-1);
                    break;
                case 2:
                    System.out.println(x1 + "","" + y1);
                    break;
                default:
            }

        }
    }

}

@f13bd46fd7eda4742e7d2807b7a69305@"
"r04631009","0","0.104","148624","@f13bd46fd7eda4742e7d2807b7a69305@
/**
 *
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.QuickUnionUF;

public class text {

    private static int convert(int x, int y, int N) {
        int p = (x - 1) * N + y;
        return p;
    }

    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            //Read the First line to make matrix
            int N = Integer.parseInt(data[0]);
//----------------Set the matrix and initialized to be zero-------------------//            
            int[][] check = new int[N][N];
            //call API
            QuickUnionUF uf = new QuickUnionUF(N * N + 2);
            int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;

            String d = null;
            //while loop to  read input data
            while ((d = br.readLine()) != null) {

                String[] data1 = d.split("","");

                x = Integer.parseInt(data1[0]);
                y = Integer.parseInt(data1[1]);

                int inx = x - 1, iny = y - 1;

                // cheack function
                check[inx][iny] = 1;

                int p = convert(x, y, N);

                if (1 == x) {
                    uf.union(p, 0);
                }

                if (N == x) {
                    uf.union(p, N * N + 1);
                }

                if ((x - 1) > 0 && (x - 1) <= N) {
                    int pu = convert(x - 1, y, N);
                    if (1 == check[x - 2][y - 1]) {
                        uf.union(p, pu);
                    }
                }

                if ((x + 1) <= N && (x + 1) > 0) {
                    int pl = convert(x + 1, y, N);
                    if (1 == check[x][y - 1]) {
                        uf.union(p, pl);
                    }
                }

                if ((y - 1) > 0 && (y - 1) <= N) {
                    int pl = convert(x, y - 1, N);
                    if (1 == check[x - 1][y - 2]) {
                        uf.union(p, pl);
                    }
                }

                if ((y + 1) <= N && (y + 1) > 0) {
                    int pr = convert(x, y + 1, N);
                    if (1 == check[x - 1][y]) {
                        uf.union(p, pr);
                    }
                }

                if ((uf.connected(0, N * N + 1)) && (0 == end)) {
                    x1 = x;
                    y1 = y;
                    end = 1;
                    j = 2;
                }

            }
            switch (j) {
                case 1:
                    System.out.println(-1);
                    break;
                case 2:
                    System.out.println(x1 + "","" + y1);
                    break;
                default:
            }

        }
    }

}

@f13bd46fd7eda4742e7d2807b7a69305@"
"r04631009","0","0.103","148528","@f13bd46fd7eda4742e7d2807b7a69305@
/**
 *
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.QuickUnionUF;

public class text {

    private static int convert(int x, int y, int N) {
        int p = (x - 1) * N + y;
        return p;
    }

    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            //Read the First line to make matrix
            int N = Integer.parseInt(data[0]);
//----------------Set the matrix and initialized to be zero-------------------//            
            int[][] check = new int[N][N];
            //call API
            QuickUnionUF uf = new QuickUnionUF(N * N + 2);
            int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;

            String d = null;
            //while loop to  read input data
            while ((d = br.readLine()) != null) {

                String[] data1 = d.split("","");

                x = Integer.parseInt(data1[0]);
                y = Integer.parseInt(data1[1]);

                int inx = x - 1, iny = y - 1;

                // cheack function
                check[inx][iny] = 1;

                int p = convert(x, y, N);

                if (1 == x) {
                    uf.union(p, 0);
                }

                if (N == x) {
                    uf.union(p, N * N + 1);
                }

                if ((x - 1) > 0 && (x - 1) <= N) {
                    int pu = convert(x - 1, y, N);
                    if (1 == check[x - 2][y - 1]) {
                        uf.union(p, pu);
                    }
                }

                if ((x + 1) <= N && (x + 1) > 0) {
                    int pl = convert(x + 1, y, N);
                    if (1 == check[x][y - 1]) {
                        uf.union(p, pl);
                    }
                }

                if ((y - 1) > 0 && (y - 1) <= N) {
                    int pl = convert(x, y - 1, N);
                    if (1 == check[x - 1][y - 2]) {
                        uf.union(p, pl);
                    }
                }

                if ((y + 1) <= N && (y + 1) > 0) {
                    int pr = convert(x, y + 1, N);
                    if (1 == check[x - 1][y]) {
                        uf.union(p, pr);
                    }
                }

                if ((uf.connected(0, N * N + 1)) && (0 == end)) {
                    x1 = x;
                    y1 = y;
                    end = 1;
                    j = 2;
                }

            }
            switch (j) {
                case 1:
                    System.out.println(-1);
                    break;
                case 2:
                    System.out.println(x1 + "","" + y1);
                    break;
                default:
            }

        }
    }

}

@f13bd46fd7eda4742e7d2807b7a69305@"
"r04631009","0","1","148176","@70b5689adf159a6d145d0527ef14c036@
/**
 *
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.QuickUnionUF;

public class Percolation {

    private static int convert(int x, int y, int N) {
        int p = (x - 1) * N + y;
        return p;
    }

    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            //Read the First line to make matrix
            int N = Integer.parseInt(data[0]);
//----------------Set the matrix and initialized to be zero-------------------//            
            int[][] check = new int[N][N];
            //call API
            QuickUnionUF uf = new QuickUnionUF(N * N + 2);
            int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;

            String d = null;
            //while loop to  read input data
            while ((d = br.readLine()) != null) {
                d = d.replaceAll("" "", """");
                String[] data1 = d.split("","");
                x = Integer.parseInt(data1[0]);
                y = Integer.parseInt(data1[1]);
                int inx = x - 1, iny = y - 1;

                // cheack function
                check[inx][iny] = 1;

                int p = convert(x, y, N);

                if (1 == x) {
                    uf.union(p, 0);
                }

                if (N == x) {
                    uf.union(p, N * N + 1);
                }

                if ((x - 1) > 0 && (x - 1) <= N) {
                    int pu = convert(x - 1, y, N);
                    if (1 == check[x - 2][y - 1]) {
                        uf.union(p, pu);
                    }
                }

                if ((x + 1) <= N && (x + 1) > 0) {
                    int pl = convert(x + 1, y, N);
                    if (1 == check[x][y - 1]) {
                        uf.union(p, pl);
                    }
                }

                if ((y - 1) > 0 && (y - 1) <= N) {
                    int pl = convert(x, y - 1, N);
                    if (1 == check[x - 1][y - 2]) {
                        uf.union(p, pl);
                    }
                }

                if ((y + 1) <= N && (y + 1) > 0) {
                    int pr = convert(x, y + 1, N);
                    if (1 == check[x - 1][y]) {
                        uf.union(p, pr);
                    }
                }

                if ((uf.connected(0, N * N + 1)) && (0 == end)) {
                    x1 = x;
                    y1 = y;
                    end = 1;
                    j = 2;
                }

            }
            switch (j) {
                case 1:
                    System.out.println(-1);
                    break;
                case 2:
                    System.out.println(x1 + "","" + y1);
                    break;
                default:
            }

        }
    }

}

@70b5689adf159a6d145d0527ef14c036@"
"r04631009","0","1","148176","@77eac1216419ab7b6a043c1115c23ccf@
/**
 *
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class text {

    private static int convert(int x, int y, int N) {
        int p = (x - 1) * N + y;
        return p;
    }

    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            //Read the First line to make matrix
            int N = Integer.parseInt(data[0]);
//----------------Set the matrix and initialized to be zero-------------------//            
            int[][] check = new int[N][N];
            //call API
            QuickUnionUF uf = new QuickUnionUF(N * N + 2);
            int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;

            String d = null;
            //while loop to  read input data
            while ((d = br.readLine()) != null) {
                d = d.replaceAll("" "", """");
                String[] data1 = d.split("","");
                x = Integer.parseInt(data1[0]);
                y = Integer.parseInt(data1[1]);
                int inx = x - 1, iny = y - 1;

                // cheack function
                check[inx][iny] = 1;

                int p = convert(x, y, N);

                if (1 == x) {
                    uf.union(p, 0);
                }

                if (N == x) {
                    uf.union(p, N * N + 1);
                }

                if ((x - 1) > 0 && (x - 1) <= N) {
                    int pu = convert(x - 1, y, N);
                    if (1 == check[x - 2][y - 1]) {
                        uf.union(p, pu);
                    }
                }

                if ((x + 1) <= N && (x + 1) > 0) {
                    int pl = convert(x + 1, y, N);
                    if (1 == check[x][y - 1]) {
                        uf.union(p, pl);
                    }
                }

                if ((y - 1) > 0 && (y - 1) <= N) {
                    int pl = convert(x, y - 1, N);
                    if (1 == check[x - 1][y - 2]) {
                        uf.union(p, pl);
                    }
                }

                if ((y + 1) <= N && (y + 1) > 0) {
                    int pr = convert(x, y + 1, N);
                    if (1 == check[x - 1][y]) {
                        uf.union(p, pr);
                    }
                }

                if ((uf.connected(0, N * N + 1)) && (0 == end)) {
                    x1 = x;
                    y1 = y;
                    end = 1;
                    j = 2;
                }

            }
            switch (j) {
                case 1:
                    System.out.println(-1);
                    break;
                case 2:
                    System.out.println(x1 + "","" + y1);
                    break;
                default:
            }

        }
    }

}

@77eac1216419ab7b6a043c1115c23ccf@"
"r04631009","6","0.91","120592","@de2ca7824e8f2592a58e4811db855bfd@
/**
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//

            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top

                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }

                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }

                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }

                }
                if (matrix[x][y] == 2 && x == size - 1) {
                    System.out.println(Integer.parseInt(data[0]) + "","" + Integer.parseInt(data[1]));
                    System.exit(0);
                }
            }

            System.out.println(""-1"");
            //show for debug
            //for (int i = 0; i < size; i++) {
            //    for (int j = 0; j < size; j++) {
            //        System.out.print(matrix[i][j] + "" "");
            //   }
            //   System.out.println("""");
            // }

        }

    }

}
@de2ca7824e8f2592a58e4811db855bfd@"
"r04921074","7","1.08","126112","@ef1262b87f68fb41f7de57698998073d@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws Exception
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
            
            
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);
                    
                                        
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }
                                                
                        if((axis1[0] == 0) && (scale == 1) && (axis2[0] == 0))
                        {    
                         System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}

@ef1262b87f68fb41f7de57698998073d@"
"r04631009","1","1.13","172208","@2266082a63475e8729e0e81adc5fe459@
/**
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            int a = 0;
            int b = 0;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//

            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top

                if (x == 0) {
                    matrix[x][y] = 2;
                    //and it is on the left hand
                    if (y == 0) {
                        //test for right and downstair
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        //test for left and downstair
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                    //else test for right,left and downstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 1) {
                            matrix[x][y + 1] = 2;
                        }
                        if (matrix[x][y - 1] == 1) {
                            matrix[x][y - 1] = 2;
                        }
                        if (matrix[x + 1][y] == 1) {
                            matrix[x + 1][y] = 2;
                        }
                    }
                }

                //when site is on the bottom
                //it  needs to test for neighbor is 2 or block
                if (x == size - 1) {
                    //and it is on the left hand
                    if (y == 0) {
                        if (matrix[x][y + 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            //test for righthand and upstair
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }

                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                    //and it is on the right hand
                    if (y == size - 1) {
                        if (matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            ////test for lefthand and downstair
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //else test for right,left and upstair
                    if (y > 0 && y < size - 1) {
                        if (matrix[x][y + 1] == 2 || matrix[x][y - 1] == 2 || matrix[x - 1][y] == 2) {
                            matrix[x][y] = 2;
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }
                }

                //else row (not 0 and size-1)
                if (x > 0 && x < size - 1) {
                    //when it is on the lefthand
                    if (y == 0) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y + 1] == 2) {
                            matrix[x][y] = 2;
                            //test for left,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y + 1] == 1) {
                                matrix[x][y + 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }

                    }
                    //when it is on the righthand
                    if (y == size - 1) {
                        if (matrix[x - 1][y] == 2 || matrix[x + 1][y] == 2 || matrix[x][y - 1] == 2) {
                            matrix[x][y] = 2;
                            //test for right,upstair and downstair
                            if (matrix[x - 1][y] == 1) {
                                matrix[x - 1][y] = 2;
                            }
                            if (matrix[x + 1][y] == 1) {
                                matrix[x + 1][y] = 2;
                            }
                            if (matrix[x][y - 1] == 1) {
                                matrix[x][y - 1] = 2;
                            }
                        } else {
                            matrix[x][y] = 1;
                        }
                    }

                }
                // check the N row 
                for (int j = 0; j < size; j++) {
                    int i = size - 1;
                    if (matrix[i][j] == 2) {
                        System.out.println(Integer.parseInt(data[0]) + "","" + Integer.parseInt(data[1]));
                        System.exit(0);
                    }
                }
            }

            System.out.println(""-1"");
            //show for debug
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    System.out.print(matrix[i][j] + "" "");
                }
                System.out.println("""");
            }

        }

    }

}

@2266082a63475e8729e0e81adc5fe459@"
"r04631009","1","0.09","104720","@ec58ed3e0e83fe0928d647bcbff47946@
/**
 * @author Cyuan
 */
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    /**
     * @param args the command line arguments
     */
    private static int convert(int x, int y, int size) {
        int p = x * size + y - 1;
        return p;
    }

    public static void main(String[] args) throws Exception {
//----------------Read the first line and store the matrix size---------------//
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String FirstLine = br.readLine();
            int size = Integer.parseInt(FirstLine);
            QuickUnionUF uf = new QuickUnionUF(size * size + 2);
            int a = 0;
            int b = 0;
            int xold = 0;
            int yold = 0;
            int end = 0;
            int g =1 ;
//----------------Set the matrix and initialized to be zero-------------------//
            int[][] matrix = new int[size][size];
            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    matrix[i][j] = 0;
                }
            }
//----------------------------------------------------------------------------//

            String str = null;
            while ((str = br.readLine()) != null) {
                String[] data = str.split("","");

                int x = Integer.parseInt(data[0]) - 1; //matrix row
                int y = Integer.parseInt(data[1]) - 1; //matrix column

                //matrix[x-1][y-1]=0 (block), 1 (open) , 2 (full)
                //open the read site
                matrix[x][y] = 1;
                //test for neighbor
                //when the site is on the top

                int p = convert(x, y, size);

                // sudo node 0,size*size+1
                //TOP
                if (x == 0) {
                    uf.union(p, 0);
                }
                //Bottom
                if (x == size - 1) {
                    uf.union(p, size * size + 1);
                }
                //
                if (x > 0 && x <= size) {
                    int pu = convert(x, y + 1, size);
                    if (1 == matrix[x - 1][y]) {
                        uf.union(p, pu);
                    }
                }
                //
                if ((x + 2) <= size && (x + 2) > 0) {
                    int pl = convert(x + 2, y + 1, size);
                    if (1 == matrix[x + 1][y]) {
                        uf.union(p, pl);
                    }
                }

                if ((y) > 0 && (y) <= size) {
                    int pl = convert(x + 1, y, size);
                    if (1 == matrix[x][y - 1]) {
                        uf.union(p, pl);
                    }
                }

                if ((y + 2) <= size && (y + 2) > 0) {
                    int pr = convert(x + 1, y + 2, size);
                    if (1 == matrix[x][y + 1]) {
                        uf.union(p, pr);
                    }
                }

                if ((uf.connected(0, size * size + 1)) && (0 == end)) {
                    xold = x;
                    yold = y;
                    end = 1;
                     g = 2;
                }

                // check the N row 
                //for (int j = 0; j < size; j++) {
                //    int i = size - 1;
                //   if (matrix[i][j] == 2) {
                //       System.out.println(Integer.parseInt(data[0]) + "","" + Integer.parseInt(data[1]));
                //System.exit(0);
                //}
                //}
            }
            
            switch(g){
                 case 1:
                     System.out.println(-1);
                     break;
                 case 2:
                     System.out.println(xold+"",""+yold);
                     break;
                 default:
             }

            //System.out.println(""-1"");
            //show for debug

            //for (int i = 0; i < size; i++) {
            //    for (int j = 0; j < size; j++) {
            //        System.out.print(matrix[i][j] + "" "");
            //    }
            //    System.out.println("""");
            //}

        }

    }

}

@ec58ed3e0e83fe0928d647bcbff47946@"
"r04921074","7","1.09","123952","@abaa43fe5f03fa731b5e5e11841213c2@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws Exception
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale+1]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale+1]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
            
            
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);
                    
                    
                    
                                        
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }
                                                
                        if((axis1[0] == 0) && (scale == 1) && (axis2[0] == 0))
                        {    
                         System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
}
@abaa43fe5f03fa731b5e5e11841213c2@"
"r04631039","10","0.109","121856","@c4419060c00dc1e7fe267f5950903a08@import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author Eric
 */
public class Percolation {
    
    private static int[] idd;
    public static void construct(int N, int n){
        idd = new int[N+2*n+2];
        for (int i=0; i<N+2*n+2; i++)
            idd[i]=i;
        for (int i=1; i<=n; i++){
            union(i,0);
            union(N+2*n+1-i, N+2*n+2-1);
            }
    }

    public static boolean connected(int p, int q) {
        return idd[p] == idd[q];
    }
    public static void union(int p, int q) {
        int pid = idd[p];
        int qid = idd[q];
        for (int i=0; i<idd.length; i++)
            if (idd[i] == pid) idd[i] = qid;
    }

    
    public static void check_union(int[][] m,int n,int x_axis,int y_axis){
        int nx = x_axis-1;
        int ny = y_axis-1;
        if (x_axis == 1) 
            union(y_axis+n, y_axis);
        if (x_axis == n)
            union(nx*n+ny+n+1, nx*n+ny+2*n+1);
        if (m[x_axis+1][y_axis] == 1)
           union(n*(nx+1)+ny+n+1, nx*n+ny+n+1);
        if (m[x_axis-1][y_axis] == 1)
           union(n*(nx-1)+ny+n+1, nx*n+ny+n+1);  
        if (m[x_axis][y_axis+1] == 1)
           union(nx*n+ny+1+n+1, nx*n+ny+n+1);
        if (m[x_axis][y_axis-1] == 1)
            union(nx*n+ny-1+n+1, nx*n+ny+n+1); 
    }
    
    public static boolean percolation(int N, int n) {
        if (idd[0] == idd[N+2*n+1])
            return (true);
        else
            return (false);
    }

    
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            // read first line (matrix size)
            String[] data = br.readLine().split("","");
            int sz = Integer.parseInt(data[0]);
            
            // initilization of a coordinate array in Java
            int[][] coord = new int[sz+2][sz+2];
            for (int i=0; i<sz+2; i++)
                for (int j=0; j<sz+2; j++) 
                    coord[i][j] = 0;

            // Initialize the number to id
            int N = sz*sz;
            construct(N, sz);
            
            String str = null;
            while ((str = br.readLine())!=null){
                String[] data2 = str.split("","");
                int x_crd = Integer.parseInt(data2[0]);
                int y_crd = Integer.parseInt(data2[1]);
                coord[x_crd][y_crd] = 1;
                check_union(coord, sz, x_crd, y_crd);
                if (percolation(N, sz)==true){
                    System.out.println(x_crd + "","" + y_crd);
                    break;
                }
            }

            if ((str=br.readLine())==null && percolation(N,sz)==false)
                System.out.println(""-1"");
            
        }
    }
}
@c4419060c00dc1e7fe267f5950903a08@"
"r04921074","7","1.09","122880","@d8f067b6a749e3c47c76223727e8547f@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws Exception
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      

           
            //union and check part
            int[] axis1 = new int[scale*scale+1]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale+1]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
            
            
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);
                    
                    
                    
                                        
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }
                                                
                        if((axis1[0] == 0) && (scale == 1) && (axis2[0] == 0))
                        {    
                         System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
}
@d8f067b6a749e3c47c76223727e8547f@"
"b03611035","6","0.55","105712","@7c8459f99990709482e86fb5ae3458e6@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order+2);
         //MARK
         br.mark(87);
         
        //數有幾個座標要開通，一個逗點一個坐標
         int count=0;
         int readd=br.read();
         while(readd!=-1){
            if(readd==44) {
                count++;
            }
            readd=br.read();
         }
        if(count==0)
            System.out.printf(""-1"");
         
         //reset
        br.reset();         
         
         //做字串陣列來存要開通的格子
         String ayaya[][]=new String[count][2];
         for(int i=0;i<count;i++) {
             ayaya[i]=br.readLine().split("","");             
         }
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i+1;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(order*order,i);
             gg.union(order*order+1,order*order-1-i);
         }
         
         //開始開通，ayaya[n][0]為y坐標，ayaya[n][1]為x坐標
    
         int y,x,id;
         for(int i=0;i<count;i++){
             
             y=Integer.parseInt(ayaya[i][0]);
             x=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }            
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",y,x);
                 break;
             }else if(i==count-1)
                 System.out.print(-1);
         } 
        }
    }
}
@7c8459f99990709482e86fb5ae3458e6@"
"r04921074","4","0.93","107184","@1be3758453a19e80d133ee8d8040e412@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws Exception
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale+1]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale+1]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
            
            
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);
                    
                    
                    
                                        
                for(int i=0; i<counting; i++){
                    if (!uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])){    
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1)                                
                           )
                        {
                        }    
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                    
                    if (!uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])){
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                    }  
   
                }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }
                                                
                        if((axis1[0] == 0) && (scale == 1) && (axis2[0] == 0))
                        {    
                         System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
}

@1be3758453a19e80d133ee8d8040e412@"
"r04921074","4","0.92","108416","@edd0b7211bfdde388edbe4c340599ea9@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws Exception
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale+1]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale+1]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
            
            
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);
                    
                    
                    
                                        
                for(int i=0; i<counting; i++){
                    if (!uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])){    
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1)                                
                           )
                        {
                        }    
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                    
                    if (!uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])){
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                    }  
   
                }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1) || ((axis2[0] == 0) && (axis1[0] == 0)))
                        {    
                        System.out.println(""-1"");
                        }
                                                
                      

         //int
     }//end of try
    
    }
}
@edd0b7211bfdde388edbe4c340599ea9@"
"b03611035","9","0.93","149424","@798168652f67f5ab9d8888ae50b4908a@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order+2);
        
         /*/MARK
         br.mark(870);        
         //數有幾個座標要開通，一個逗點一個坐標
         int count=0;
         int readd=br.read();
         while(readd!=-1){
            if(readd==44) {
                count++;
            }
            readd=br.read();
         }
        if(count==0)
            System.out.printf(""-1"");
         //reset
        br.reset();         
        */ 
         
         //直接開讀
         String ayaya[][]=new String[order*order][2];
         //qq別再搞我了好嗎
         int qq=0,count=0;
         String[] readd = br.readLine().split("","");
         while(readd!=null){
             ayaya[qq][0]=readd[0];
             ayaya[qq][1]=readd[1];
             count++;
             qq++;
             br.mark(10);
             if(br.readLine()==null)
                 break;
             br.reset();
             readd = br.readLine().split("","");             
         }
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i+1;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(order*order,i);
             gg.union(order*order+1,order*order-1-i);
         }
         
         //開始開通，ayaya[n][0]為y坐標，ayaya[n][1]為x坐標
         int y,x,id;
         for(int i=0;i<count;i++){
             
             y=Integer.parseInt(ayaya[i][0]);
             x=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }            
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",y,x);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}

@798168652f67f5ab9d8888ae50b4908a@"
"r04921074","4","0.91","107136","@08a7573fa381a078365461f0bd4fcca3@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws Exception
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale+1]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale+1]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
            
            
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);
                    
                    
                    
                                        
                for(int i=0; i<counting; i++){
                    if (!uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])){    
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1)                                
                           )
                        {
                        }    
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                    
                    if (!uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])){
                        if ( (axis2[counting]==axis2[counting-i-1]) 
                           )
                           if(Math.abs(axis1[counting]-axis1[counting-i-1])==1){
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }
                           }//end of if (these is for check and connect) 
                    }  
   
                }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1) || ((axis2[0] == 0) && (axis1[0] == 0)))
                        {    
                        System.out.println(""-1"");
                        }
                                                
                      

         //int
     }//end of try
    
    }
}

@08a7573fa381a078365461f0bd4fcca3@"
"b03611035","9","0.96","143184","@08a5d0ebb49a625a6e2ddbd194908118@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order+2);
         //直接開讀
         String ayaya[][]=new String[order*order][2];
         //qq別再搞我了好嗎
         int qq=0,count=0;
         String[] readd = br.readLine().split("","");
         while(readd!=null){
             ayaya[qq][0]=readd[0];
             ayaya[qq][1]=readd[1];
             count++;
             qq++;
             
             br.mark(10);
             if(br.readLine()==null)
                 break;
             br.reset();
             readd = br.readLine().split("","");             
         }
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i+1;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(order*order,i);
             gg.union(order*order+1,order*order-1-i);
         }
         
         //開始開通，ayaya[n][0]為y坐標，ayaya[n][1]為x坐標
         int y,x,id;
         for(int i=0;i<count;i++){
             
             y=Integer.parseInt(ayaya[i][0]);
             x=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }            
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",y,x);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}

@08a5d0ebb49a625a6e2ddbd194908118@"
"b03611035","9","0.92","147200","@4fe1f2fe19ab8216fad2ad9353d228a0@import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.WeightedQuickUnionUF;

public class Percolation {
    

    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         //讀檔，要幾階>order
         String order1=br.readLine();
         int order=Integer.parseInt(order1);
         
         //建立UF物件，名為gg
         WeightedQuickUnionUF gg=new WeightedQuickUnionUF(order*order+2);
         //直接開讀
         String ayaya[][]=new String[order*order][2];
         //qq別再搞我了好嗎
         int qq=0,count=0;
         String[] readd;
         while(br.ready()){
             readd = br.readLine().split("","");
             ayaya[qq][0]=readd[0];
             ayaya[qq][1]=readd[1];
             count++;
             qq++;
         }
         
         //mark用，UF物件裡存父子關係，opcl裡存是否開通        
         int opcl[]=new int[order*order];
         for(int i=0; i<order*order; i++) opcl[i]=i+1;         
             
         //先將頂排全體相連，底排亦然
         for(int i=0;i<order;i++){
             gg.union(order*order,i);
             gg.union(order*order+1,order*order-1-i);
         }
         
         //開始開通，ayaya[n][0]為y坐標，ayaya[n][1]為x坐標
         int y,x,id;
         for(int i=0;i<count;i++){
             
             y=Integer.parseInt(ayaya[i][0]);
             x=Integer.parseInt(ayaya[i][1]);
             //化二維坐標為一維坐標
             id=order*(y-1)+x-1;
             //開通
             opcl[id]=0;
             //檢查四周格子是否為0，有就union
             //先檢查是四周還是三周還是上下排
             //先排除上下排
             if(y!=1&&y!=order){
                 //中心
                 if(x!=1&&x!=order){
                     if(opcl[id+1]==0) gg.union(id, id+1);
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //左排
                 else if(x==1){
                     if(opcl[id+1]==0) gg.union(id,id+1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 //右排
                 else if(x==order){
                     if(opcl[id-1]==0) gg.union(id, id-1);
                     if(opcl[id+order]==0) gg.union(id, id+order);
                     if(opcl[id-order]==0) gg.union(id, id-order);
                 }
                 }//再來看下排，再來看上排
             else if (y==order){
                 if(opcl[id-order]==0) gg.union(id, id-order);
             }else if (y==1){
                 if(opcl[id+order]==0) gg.union(id, id+order);
             }            
             
             //上下列恰好連起來了嗎?若有輸出當下座標，若無且i又走到盡頭輸出-1
             if(gg.connected(0,order*order-1)){
                 System.out.printf(""%d,%d"",y,x);
                 break;
             }else if(i==count-1)
                 System.out.printf(""-1"");
         } 
        }
    }
}

@4fe1f2fe19ab8216fad2ad9353d228a0@"
"r04525016","10","0.143","163488","@926230540a7b680a20858f7c0813ee20@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;


public class Percolation {
    public static void main(String args[]) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("" "");

            int num = Integer.parseInt(data[0]);

            ArrayList<Integer> row = new ArrayList<>();
            ArrayList<Integer> column = new ArrayList<>();
            ArrayList<Integer> father = new ArrayList<>();
            ArrayList<Integer> bottom = new ArrayList<>();
            row.add(0, 0);
            column.add(0, 0);
            father.add(0, 0);

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowTemp = Integer.parseInt(temp[0]);
                int columnTemp = Integer.parseInt(temp[1]);
                row.add(rowTemp);
                column.add(columnTemp);
            }
            br.close();

            boolean communication = false;
            for (int i = 1; i < row.size(); i++) {
                father.add(i, i);
                if (row.get(i) == 1) father.set(i, 0);
                if (row.get(i) == num) bottom.add(i);
                for (int j = 0; j < i; j++) {
                    if (isConnected(row, column, i, j)) {
                        int root = getRoot(father, j);
                        int root2 = getRoot(father, i);

                        if (row.get(root2) == row.get(root)) {
                            if (root < root2) father.set(root2, root);
                            else father.set(root, root2);
                        } else if (row.get(root) < row.get(root2)) {
                            father.set(root2, root);
                        } else {
                            father.set(root, root2);
                        }
                    }
                }


                if (checkBottom(bottom, father)) {
                    System.out.println(row.get(i) + "","" + column.get(i));
                    communication = true;
                    break;
                }

                if (communication) break;

            }
//                System.out.println(bottom);


            if (!communication) System.out.println(-1);
        }
    }

    //透過爸爸往上找祖先
    public static int getRoot(ArrayList<Integer> father, int index2) {
        while (index2 != father.get(index2)) index2 = father.get(index2);
        return index2;
    }

    //判斷是否相鄰
    public static boolean isConnected(ArrayList<Integer> row, ArrayList<Integer> column, int index1, int index2) {
        if (row.get(index1) == row.get(index2)) {
            if (column.get(index1) - column.get(index2) == 1 || column.get(index1) - column.get(index2) == -1)
                return true;
        }
        if (column.get(index1) == column.get(index2)) {
            if (row.get(index1) - row.get(index2) == 1 || row.get(index1) - row.get(index2) == -1) return true;
        }
        return false;
    }

    //檢查有沒有bottom


    //檢查bottom祖先跟祖先0是否相等
    public static boolean checkBottom(ArrayList<Integer> bottom, ArrayList<Integer> father) {
        for (int eachBottom : bottom) {
            int bottomRoot = getRoot(father, eachBottom);
            if (bottomRoot == father.get(0)) return true;
        }
        return false;
    }

}
@926230540a7b680a20858f7c0813ee20@"
"r04631013","0","2.04","162384","@3eefd4c0bac82390e64d20cdb0edac03@import java.io.FileReader;
import java.io.BufferedReader;

public class HW2 {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {

            String[] data = br.readLine().split("","");

            int num = Integer.parseInt(data[0]);

            int[][] matrix = new int[num][num];
            // give ID = 0 for all the components in the matrix
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    matrix[i][j] = 0;
                }
            }
//            the first row connected to head
//            the last row connected to foot
            int head = num * num + 1;
            int foot = num * num + 2;
            UF uf = new UF(num * num + 4);
//            for (int i = 0; i < num; i++) {
//                int p = matrix[0][i];
//                int q = matrix[num - 1][i];
//                uf.union(p, head);
//                uf.union(q, foot);
//            }

            String line;
            int initial = 0;
            while ((line = br.readLine()) != null) {
//            the first input

                String[] readnum = line.split("","");
                int row = Integer.parseInt(readnum[0]) - 1;
                int col = Integer.parseInt(readnum[1]) - 1;
                initial = initial + 1;
                matrix[row][col] = initial;
                if (row == 0) {
                    uf.union(matrix[row][col], head);
                }
                if (row == num - 1) {
                    uf.union(matrix[row][col], foot);
                }
                //  up sides
                if (row - 1 >= 0) {
                    if (matrix[row - 1][col] != 0) {
                        uf.union(matrix[row][col], matrix[row - 1][col]);
                    }
                }
                //  down sides
                if (row + 1 <= num - 1) {
                    if (matrix[row + 1][col] != 0) {
                        uf.union(matrix[row][col], matrix[row + 1][col]);
                    }
                }
                //  left sides
                if (col - 1 >= 0) {
                    if (matrix[row][col - 1] != 0) {
                        uf.union(matrix[row][col], matrix[row][col - 1]);
                    }
                }
                //  right sides
                if (col + 1 <= num - 1) {
                    if (matrix[row][col + 1] != 0) {
                        uf.union(matrix[row][col], matrix[row][col + 1]);
                    }
                }

                if (uf.connected(head, foot)) {
                    System.out.printf(""%d %d\n"", row + 1, col + 1);
                    break;
                }
            }
            if (!uf.connected(head, foot)) {
                System.out.print(""-1"");
            }
        }

//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.printf(""%d"", matrix[i][j]);
//
//                }
//                System.out.printf(""\n"");
//            }
    }
}

@3eefd4c0bac82390e64d20cdb0edac03@"
"r04631013","5","1.01","124368","@83024a071e225461ccab44d95b3b6ab4@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {

            String[] data = br.readLine().split("","");

            int num = Integer.parseInt(data[0]);

            int[][] matrix = new int[num][num];
            // give ID = 0 for all the components in the matrix
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    matrix[i][j] = 0;
                }
            }
//            the first row connected to head
//            the last row connected to foot
            int head = num * num + 1;
            int foot = num * num + 2;
            UF uf = new UF(num * num + 4);
//            for (int i = 0; i < num; i++) {
//                int p = matrix[0][i];
//                int q = matrix[num - 1][i];
//                uf.union(p, head);
//                uf.union(q, foot);
//            }

            String line;
            int initial = 0;
            while ((line = br.readLine()) != null) {
//            the first input

                String[] readnum = line.split("","");
                int row = Integer.parseInt(readnum[0]) - 1;
                int col = Integer.parseInt(readnum[1]) - 1;
                initial = initial + 1;
                matrix[row][col] = initial;
                if (row == 0) {
                    uf.union(matrix[row][col], head);
                }
                if (row == num - 1) {
                    uf.union(matrix[row][col], foot);
                }
                //  up sides
                if (row - 1 >= 0) {
                    if (matrix[row - 1][col] != 0) {
                        uf.union(matrix[row][col], matrix[row - 1][col]);
                    }
                }
                //  down sides
                if (row + 1 <= num - 1) {
                    if (matrix[row + 1][col] != 0) {
                        uf.union(matrix[row][col], matrix[row + 1][col]);
                    }
                }
                //  left sides
                if (col - 1 >= 0) {
                    if (matrix[row][col - 1] != 0) {
                        uf.union(matrix[row][col], matrix[row][col - 1]);
                    }
                }
                //  right sides
                if (col + 1 <= num - 1) {
                    if (matrix[row][col + 1] != 0) {
                        uf.union(matrix[row][col], matrix[row][col + 1]);
                    }
                }

                if (uf.connected(head, foot)) {
                    System.out.printf(""%d %d\n"", row + 1, col + 1);
                    break;
                }
            }
            if (!uf.connected(head, foot)) {
                System.out.print(""-1"");
            }
        }

//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.printf(""%d"", matrix[i][j]);
//
//                }
//                System.out.printf(""\n"");
//            }
    }
}

@83024a071e225461ccab44d95b3b6ab4@"
"r04631013","5","1.02","127120","@dd1e750c91c5674c66d0d48ce8a42431@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {

            String[] data = br.readLine().split("","");

            int num = Integer.parseInt(data[0]);

            int[][] matrix = new int[num][num];
            // give ID = 0 for all the components in the matrix
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    matrix[i][j] = 0;
                }
            }
//            the first row connected to head
//            the last row connected to foot
            int head = num * num + 1;
            int foot = num * num + 2;
            UF uf = new UF(num * num + 4);

            String line;
            int initial = 0;

            while (br.ready()) {
                line = br.readLine();
                String[] readnum = line.split("","");
                int row = Integer.parseInt(readnum[0]) - 1;
                int col = Integer.parseInt(readnum[1]) - 1;
                initial = initial + 1;
                matrix[row][col] = initial;
                if (row == 0) {
                    uf.union(matrix[row][col], head);
                }
                if (row == num - 1) {
                    uf.union(matrix[row][col], foot);
                }
                //  up sides
                if (row - 1 >= 0) {
                    if (matrix[row - 1][col] != 0) {
                        uf.union(matrix[row][col], matrix[row - 1][col]);
                    }
                }
                //  down sides
                if (row + 1 <= num - 1) {
                    if (matrix[row + 1][col] != 0) {
                        uf.union(matrix[row][col], matrix[row + 1][col]);
                    }
                }
                //  left sides
                if (col - 1 >= 0) {
                    if (matrix[row][col - 1] != 0) {
                        uf.union(matrix[row][col], matrix[row][col - 1]);
                    }
                }
                //  right sides
                if (col + 1 <= num - 1) {
                    if (matrix[row][col + 1] != 0) {
                        uf.union(matrix[row][col], matrix[row][col + 1]);
                    }
                }

                if (uf.connected(head, foot)) {
                    System.out.printf(""%d %d\n"", row + 1, col + 1);
                    break;
                }
            }
            if (!uf.connected(head, foot)) {
                System.out.print(""-1"");
            }
        }
    }
}
@dd1e750c91c5674c66d0d48ce8a42431@"
"r04921074","0","1.03","140448","@5f843aa68537ae22de272a08b5c6059d@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws Exception
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale+1]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale+1]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
            
            
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);
                    
                    
                    
                                        
                for(int i=0; i<counting; i++){
                    if (!uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])){    
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1)                                
                           )
                        {
                        }    
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                    
                    if (!uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])){
                        if ( (axis2[counting]==axis2[counting-i-1]) 
                           )
                           if(Math.abs(axis1[counting]-axis1[counting-i-1])==1){
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }
                           }//end of if (these is for check and connect) 
                    }  
                        System.out.print(axis1[counting]+"",""+axis2[counting]+""  "");
                        System.out.print(axis1[counting-i-1]+"",""+axis2[counting-i-1]+""  "");
                        System.out.println(!uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]));
                        
                }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                              //      System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1) || ((axis2[0] == 0) && (axis1[0] == 0)))
                        {    
                        System.out.println(""-1"");
                        }
                                                
                      

         //int
     }//end of try
    
    }
}

@5f843aa68537ae22de272a08b5c6059d@"
"r04921074","0","1.04","139760","@5f843aa68537ae22de272a08b5c6059d@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws Exception
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale+1]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale+1]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
            
            
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);
                    
                    
                    
                                        
                for(int i=0; i<counting; i++){
                    if (!uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])){    
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1)                                
                           )
                        {
                        }    
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                    
                    if (!uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])){
                        if ( (axis2[counting]==axis2[counting-i-1]) 
                           )
                           if(Math.abs(axis1[counting]-axis1[counting-i-1])==1){
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }
                           }//end of if (these is for check and connect) 
                    }  
                        System.out.print(axis1[counting]+"",""+axis2[counting]+""  "");
                        System.out.print(axis1[counting-i-1]+"",""+axis2[counting-i-1]+""  "");
                        System.out.println(!uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]));
                        
                }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                              //      System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1) || ((axis2[0] == 0) && (axis1[0] == 0)))
                        {    
                        System.out.println(""-1"");
                        }
                                                
                      

         //int
     }//end of try
    
    }
}

@5f843aa68537ae22de272a08b5c6059d@"
"b02611016","0","1.01","124368","@a2c28ffe2ca2e6f67b62703c41d0fabb@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=num+1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            UF uf=new UF(num*num) ;
            //Date date = new Date();
            search: 
            
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break ;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break ;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               {  uf.union((row-1)+cloumn-1,1*num+cloumn-1);
                  
               }
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {uf.union((row-1)*num+cloumn-1,(row-2)*num+cloumn-1);
                   if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   { 
                     uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {
                     uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { 
                    uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {uf.union((row-1)*num+cloumn-1,(row-1)*num+cloumn-2);
               
                   if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-2);
                     
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-2);
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-2);
                     uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-2);
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {uf.union((row-1)*num+cloumn-1,(row-1)*num+cloumn);
                 if(matrix[row][cloumn]==1)
                 { uf.union((row)*num+cloumn-1,(row-1)*num+cloumn);
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {uf.union((row-1)*num+cloumn-1,row*num+cloumn-1);
               }
               
           }
           /*for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           if(num==1&&row==1&&cloumn==1)
           {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
               
           }}
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(uf.connected(n,(num-1)*num+p))
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@a2c28ffe2ca2e6f67b62703c41d0fabb@"
"b02611016","9","1.96","217472","@84d70af6a10104f5a7d09595c1ac8b2b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=num+1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            UF uf=new UF(num*num) ;
            //Date date = new Date();
            search: 
            
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break ;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break ;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               {  uf.union((row-1)+cloumn-1,1*num+cloumn-1);
                  
               }
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {uf.union((row-1)*num+cloumn-1,(row-2)*num+cloumn-1);
                   if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   { 
                     uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {
                     uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { 
                    uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {uf.union((row-1)*num+cloumn-1,(row-1)*num+cloumn-2);
               
                   if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-2);
                     
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-2);
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-2);
                     uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-2);
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {uf.union((row-1)*num+cloumn-1,(row-1)*num+cloumn);
                 if(matrix[row][cloumn]==1)
                 { uf.union((row)*num+cloumn-1,(row-1)*num+cloumn);
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {uf.union((row-1)*num+cloumn-1,row*num+cloumn-1);
               }
               
           }
           /*for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", id[q] );
           }
           System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           if(num==1&&row==1&&cloumn==1)
           {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
               
           }}
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(uf.connected(n,(num-1)*num+p))
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@84d70af6a10104f5a7d09595c1ac8b2b@"
"b02611026","8","1.12","127376","@9bc592494a2418d9562968b7ad36c582@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            if (matrix_length == 1) {
                String[] pos1;
                pos1 = br.readLine().split("","");

//                System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");
                if ((pos1[0].equals(""1"")) && (pos1[1].equals(""1""))) {
                    state = 2;
//                    System.out.printf(""%d\n"", matrix_length);
//                    System.out.printf(""%d\n"", state);
                    System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");

                } else {
                    state = -1;
//                    System.out.printf(""%d"", matrix_length);
                    System.out.printf(""%d"", state);

                }
            } else if (matrix_length <= 0) {
                state = -1;
                System.out.printf(""%d"", state);
            } else {
                //Union the upper row
                for (int i = 0; i < matrix_length; i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == matrix_length) {
                        break;
                    }
                }
                //Union the downner row
                for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == (matrix_size - 1)) {
                        break;
                    }
                }
                //Create a matrx in order to mark the cell
                String[][] markmatrix = new String[matrix_length][matrix_length];
                for (int i = 0; i < matrix_length; i++) {
                    for (int j = 0; j < matrix_length; j++) {
                        markmatrix[i][j] = ""0"";
                    }
                }

                String[] pos;
                while (br.ready()) {
                    pos = br.readLine().split("","");
                    if (pos == null) {
                        break;
                    }

//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");
                    //mark the opened position
                    int x = Integer.parseInt(pos[0]) - 1;
                    int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");
                    markmatrix[x][y] = ""1"";
                    int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                    if (x != 0 && y != 0 && x != (matrix_length - 1) && y != (matrix_length - 1)) {
                        //if up is opened
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""v\n"");
                        }
                        //if down is opened
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""w\n"");
                        }
                        //if left is opened
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""x\n"");
                        }
                        //if right is opened
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""y\n"");
                        }
                    } else if (x == 0 && y == 0) { // 左上角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""a\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""b\n"");
                        }

                    } else if (x == 0 && y == (matrix_length - 1)) { //右上角
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""c\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""d\n"");
                        }
                    } else if (y == 0 && x == (matrix_length - 1)) { //左下角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""e\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""f\n"");
                        }
                    } else if (x == matrix_length - 1 && y == (matrix_length - 1)) { //右下角
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""g\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""h\n"");
                        }
                    } else if (y == 0) { //最左排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""i\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""j\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""k\n"");
                        }
                    } else if (x == 0) { //最上排
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""m\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""n\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""o\n"");
                        }
                    } else if (y == (matrix_length - 1)) { //最右排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            // System.out.printf(""p\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""q\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""r\n"");
                        }
                    } else if (x == (matrix_length - 1)) { //最下排
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""s\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""t\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""u\n"");
                        }
                    }

                    if (uf.connected(0, matrix_size - 1)) {
                        state = 0;
                        System.out.printf(pos[0] + "","" + pos[1]);
                        //System.out.printf(""\n"");
                        break;
                    } else {
                        state = -1;
                    }

                }
                if (state == -1) {
                    System.out.printf(""%d"", state);
                }
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@9bc592494a2418d9562968b7ad36c582@"
"b02611016","9","2.3","228464","@02e67254cc54820100b8402223f50135@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=num+1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            UF uf=new UF(num*num) ;
            //Date date = new Date();
            search: 
            
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break ;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break ;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               {  uf.union((row-1)+cloumn-1,1*num+cloumn-1);
                  
               }
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {uf.union((row-1)*num+cloumn-1,(row-2)*num+cloumn-1);
                   if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   { 
                     uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {
                     uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { 
                    uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {uf.union((row-1)*num+cloumn-1,(row-1)*num+cloumn-2);
               
                   if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-2);
                     
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-2);
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-2);
                     uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-2);
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {uf.union((row-1)*num+cloumn-1,(row-1)*num+cloumn);
                 if(matrix[row][cloumn]==1)
                 { uf.union((row)*num+cloumn-1,(row-1)*num+cloumn);
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {uf.union((row-1)*num+cloumn-1,row*num+cloumn-1);
               }
               
           }
           }
               
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", uf.find(q));
           }
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           if(num==1&&row==1&&cloumn==1)
           {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
               
           }
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(uf.connected(n,(num-1)*num+p))
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@02e67254cc54820100b8402223f50135@"
"r04631013","10","0.101","122928","@47be11a24ab4ec424ed17a9c2b62deb1@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {

            String[] data = br.readLine().split("","");

            int num = Integer.parseInt(data[0]);

            int[][] matrix = new int[num][num];
            // give ID = 0 for all the components in the matrix
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    matrix[i][j] = 0;
                }
            }
//            the first row connected to head
//            the last row connected to foot
            int head = num * num + 1;
            int foot = num * num + 2;
            UF uf = new UF(num * num + 4);

            String line;
            int initial = 0;

            while ((line = br.readLine()) != null) {
                if (line.isEmpty()) {
                    System.out.print(""-1"");
                    break;
                }
//                line = br.readLine();
                String[] readnum = line.split("","");
                int row = Integer.parseInt(readnum[0]) - 1;
                int col = Integer.parseInt(readnum[1]) - 1;
                initial = initial + 1;
                matrix[row][col] = initial;
                if (row == 0) {
                    uf.union(matrix[row][col], head);
                }
                if (row == num - 1) {
                    uf.union(matrix[row][col], foot);
                }
                //  up sides
                if (row - 1 >= 0) {
                    if (matrix[row - 1][col] != 0) {
                        uf.union(matrix[row][col], matrix[row - 1][col]);
                    }
                }
                //  down sides
                if (row + 1 <= num - 1) {
                    if (matrix[row + 1][col] != 0) {
                        uf.union(matrix[row][col], matrix[row + 1][col]);
                    }
                }
                //  left sides
                if (col - 1 >= 0) {
                    if (matrix[row][col - 1] != 0) {
                        uf.union(matrix[row][col], matrix[row][col - 1]);
                    }
                }
                //  right sides
                if (col + 1 <= num - 1) {
                    if (matrix[row][col + 1] != 0) {
                        uf.union(matrix[row][col], matrix[row][col + 1]);
                    }
                }

                if (uf.connected(head, foot)) {
                    System.out.printf(""%d"", row + 1);
                    System.out.print("","");
                    System.out.printf(""%d"", col + 1);
                    break;
                }
            }
            if (!uf.connected(head, foot)) {
                System.out.print(""-1"");
            }
        }

    }
}

@47be11a24ab4ec424ed17a9c2b62deb1@"
"b02611016","10","0.232","227824","@a3c29ab118fb49400ed7eea37dd79c12@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class Percolation {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=num+1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            UF uf=new UF(num*num) ;
            //Date date = new Date();
            search: 
            
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            System.out.println(""-1"");
            break ;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break ;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=1;
           if (row==1){ count[cloumn-1]=1;
               if(matrix[1][cloumn]==1)
               {  uf.union((row-1)+cloumn-1,1*num+cloumn-1);
                  
               }
           }
           else{
               if(matrix[row-2][cloumn]==1)
               {uf.union((row-1)*num+cloumn-1,(row-2)*num+cloumn-1);
                   if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   { 
                     uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {
                     uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { 
                    uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   uf.union((row-1)*num+cloumn-2,(row-1)*num+cloumn-1);
                      uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-1);
                      uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-1);
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {uf.union((row-1)*num+cloumn-1,(row-1)*num+cloumn-2);
               
                   if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-2);
                     
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-2);
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { uf.union((row-1)*num+cloumn,(row-1)*num+cloumn-2);
                     uf.union((row)*num+cloumn-1,(row-1)*num+cloumn-2);
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {uf.union((row-1)*num+cloumn-1,(row-1)*num+cloumn);
                 if(matrix[row][cloumn]==1)
                 { uf.union((row)*num+cloumn-1,(row-1)*num+cloumn);
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {uf.union(row*num+cloumn-1,(row-1)*num+cloumn-1);
               }
               
           
           }
               
          /* for(int q=0;q<num*num;q++){
           System.out.printf(""data %d,  "", uf.find(q));
           }
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
           System.out.println("""");*/
           
           if(num==1&&row==1&&cloumn==1)
           {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
               
           }
           for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(uf.connected(n,(num-1)*num+p))
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                       /* for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");*/
                      break search;
                      }
                  }
              }
           }
           
           
     }
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@a3c29ab118fb49400ed7eea37dd79c12@"
"r03525006","9","1.6","138832","@fab777dffa4869415299758b9b939160@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

            int rowCount = 0;
            for (int i = 0; i < num; i++)
                rowCount = rowCount + isRowOpen[i];

            int i = 0;
            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""old i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                j = 0;
                                isPercolation = true;
                                System.out.println(row[i] + "","" + col[i]);
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()) {
                        i++;
                    }
                    if (i > lines.size()-1 && !isPercolation) {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
            } else {
                System.out.println(-1);
            }
        }
    }
}


@fab777dffa4869415299758b9b939160@"
"r02b48003","0","0","0","@caa8735946a2306902d577b461f1d8dc@public class Percolation {
    private int[] board;
    private boolean[] openGrid;
    private final int dim; 
    
    public Percolation(int n) {
        dim = n;
        board = new int[n*n];
        openGrid = new boolean[n*n];
        reset();
    } // end constructor
        
    public int[] getBoard() { 
        return board.clone(); 
    } // end func getBoard
        
    public int getDim() { 
        return dim; 
    } // end func getDim
     
    public int getBoardItem(int row, int col) {
        assert row > 0 & row <= dim;
        assert col > 0 & col <= dim;
        return board[(row-1) * dim + (col-1)];
    } // end func getBoardItem
    
    public boolean isOpen(int row, int col){
        return openGrid[(row-1) * dim + (col-1)];
    }
    public Bag getBoardNeighbor(int row, int col) {
        assert row > 0 & row <= dim;
        assert col > 0 & col <= dim;
        
        Bag<Integer> neighbor = new Bag<>();
        
        if (row > 1) {
            //StdOut.println(getBoardItem(row-1, col));
            if (isOpen(row-1, col)) {
                neighbor.add(getBoardItem(row-1, col));
            }
        }
        if (row < dim) {
            //StdOut.println(getBoardItem(row+1, col));
            if (isOpen(row+1, col)) {
                neighbor.add(getBoardItem(row+1, col));
            }
        }
        if (col > 1) {
            //StdOut.println();
            if (isOpen(row, col-1)) {
                neighbor.add(getBoardItem(row, col-1));
            }
        }
        if (col < dim) {
            //StdOut.println(getBoardItem(row, col+1));
            if (isOpen(row, col+1)) {
                neighbor.add(getBoardItem(row, col+1));
            }
        }
        return neighbor;
    } // end func getBoardNeighbor
        
    public void openBoardItem(int row, int col) {
        assert row > 1 & row <= dim;
        assert col > 1 & col <= dim;
        openGrid[(row-1) * dim + (col-1)] = true;
    } // end func setBoardItem
        
    public void reset(){
        for (int idx = 0; idx < dim*dim; idx++) {
            board[idx] = idx;
            openGrid[idx] = false;
        } // end loop
    } // end func reset
        
    public void display() {
        System.out.println(""--------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.printf(""%d "", getBoardItem(row, col));
            } // end inner for
            System.out.println();
        } // end outer for
        System.out.println(""--------------------------"");
    } // end display
    
    public static void main(String[] args) {
        // initialization
        String[] readLines = In.readStrings(""input01.txt"");
        int n = Integer.valueOf(readLines[0]);
        Percolation percolate = new Percolation(n);
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(n*n+2);
        int nodeUP = n*n;
        int nodeDW = n*n+1;               
        
        //
        for (int idx = 0; idx < n; idx++){
            //System.out.println(uf.connected(nodeUP, idx));
            uf.union(nodeUP, idx);
            //System.out.println(uf.connected(nodeUP, idx));
        } 
        for (int idx = n*(n-1); idx < n*n; idx++){
            uf.union(nodeDW, idx);
        }
        
        //
        boolean flag = false;
        for (int idx = 1; idx < readLines.length; idx++){
            String[] line = readLines[idx].split("","");
            int row = Integer.valueOf(line[0]);
            int col = Integer.valueOf(line[1]);
            int node = percolate.getBoardItem(row, col);
            
            //
            percolate.openBoardItem(row, col);
            
            //
            Bag<Integer> neighbors = percolate.getBoardNeighbor(row, col);
            //System.out.printf(""%d %d\n"", row, col);
            
            //
            for (Integer t : neighbors) {  
                //StdOut.println(t);
                uf.union(node, t);
            //    StdOut.print("" "");
            }
            if(uf.connected(nodeUP, nodeDW)){
                StdOut.printf(""%d,%d"", row, col);
                flag = true;
                break;
            }
            //StdOut.println(uf.connected(nodeUP, nodeDW));
            //StdOut.println();
                    
        } // end loop for
        if (!flag){
            StdOut.print(-1);
        }
    } // end main
} // end class Percolation
@caa8735946a2306902d577b461f1d8dc@"
"r02b48003","10","0.137","156400","@8d9205f0459b6f1b1c5e03164e64342e@public class Percolation {
    private int[] board;
    private boolean[] openGrid;
    private final int dim; 
    
    public Percolation(int n) {
        dim = n;
        board = new int[n*n];
        openGrid = new boolean[n*n];
        reset();
    } // end constructor
        
    public int[] getBoard() { 
        return board.clone(); 
    } // end func getBoard
        
    public int getDim() { 
        return dim; 
    } // end func getDim
     
    public int getBoardItem(int row, int col) {
        assert row > 0 & row <= dim;
        assert col > 0 & col <= dim;
        return board[(row-1) * dim + (col-1)];
    } // end func getBoardItem
    
    public boolean isOpen(int row, int col){
        return openGrid[(row-1) * dim + (col-1)];
    }
    public Bag getBoardNeighbor(int row, int col) {
        assert row > 0 & row <= dim;
        assert col > 0 & col <= dim;
        
        Bag<Integer> neighbor = new Bag<>();
        
        if (row > 1) {
            //StdOut.println(getBoardItem(row-1, col));
            if (isOpen(row-1, col)) {
                neighbor.add(getBoardItem(row-1, col));
            }
        }
        if (row < dim) {
            //StdOut.println(getBoardItem(row+1, col));
            if (isOpen(row+1, col)) {
                neighbor.add(getBoardItem(row+1, col));
            }
        }
        if (col > 1) {
            //StdOut.println();
            if (isOpen(row, col-1)) {
                neighbor.add(getBoardItem(row, col-1));
            }
        }
        if (col < dim) {
            //StdOut.println(getBoardItem(row, col+1));
            if (isOpen(row, col+1)) {
                neighbor.add(getBoardItem(row, col+1));
            }
        }
        return neighbor;
    } // end func getBoardNeighbor
        
    public void openBoardItem(int row, int col) {
        assert row > 1 & row <= dim;
        assert col > 1 & col <= dim;
        openGrid[(row-1) * dim + (col-1)] = true;
    } // end func setBoardItem
        
    public void reset(){
        for (int idx = 0; idx < dim*dim; idx++) {
            board[idx] = idx;
            openGrid[idx] = false;
        } // end loop
    } // end func reset
        
    public void display() {
        System.out.println(""--------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.printf(""%d "", getBoardItem(row, col));
            } // end inner for
            System.out.println();
        } // end outer for
        System.out.println(""--------------------------"");
    } // end display
    
    public static void main(String[] args) {
        // initialization
        //String[] readLines = In.readStrings(""input01.txt"");
        //StdOut.println(args[0]);
        
        String[] readLines = In.readStrings(args[0]);
        
        int n = Integer.valueOf(readLines[0]);
        Percolation percolate = new Percolation(n);
        WeightedQuickUnionUF uf = new WeightedQuickUnionUF(n*n+2);
        int nodeUP = n*n;
        int nodeDW = n*n+1;               
        
        //
        for (int idx = 0; idx < n; idx++){
            //System.out.println(uf.connected(nodeUP, idx));
            uf.union(nodeUP, idx);
            //System.out.println(uf.connected(nodeUP, idx));
        } 
        for (int idx = n*(n-1); idx < n*n; idx++){
            uf.union(nodeDW, idx);
        }
        ///*
        //
        boolean flag = false;
        for (int idx = 1; idx < readLines.length; idx++){
            String[] line = readLines[idx].split("","");
            int row = Integer.valueOf(line[0]);
            int col = Integer.valueOf(line[1]);
            int node = percolate.getBoardItem(row, col);
            
            //
            percolate.openBoardItem(row, col);
            
            //
            Bag<Integer> neighbors = percolate.getBoardNeighbor(row, col);
            //System.out.printf(""%d %d\n"", row, col);
            
            //
            for (Integer t : neighbors) {  
                //StdOut.println(t);
                uf.union(node, t);
            //    StdOut.print("" "");
            }
            if(uf.connected(nodeUP, nodeDW)){
                StdOut.printf(""%d,%d"", row, col);
                flag = true;
                break;
            }
            //StdOut.println(uf.connected(nodeUP, nodeDW));
            //StdOut.println();
                    
        } // end loop for
        if (!flag){
            StdOut.print(-1);
        }
        //*/
    } // end main
} // end class Percolation

@8d9205f0459b6f1b1c5e03164e64342e@"
"r03525006","9","1.56","133120","@2161b80ea26137a064540029ae7f5e6b@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[] isRowOpen = new int[num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                isRowOpen[row[i]-1] = 1;
                col[i] = Integer.parseInt(coordinates[1]);
            }

//            int rowCount = 0;
//            for (int i = 0; i < num; i++)
//                rowCount = rowCount + isRowOpen[i];

            int i = 0;
//            if (rowCount == num) {
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i]-1][col[i]-1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""old i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                j = 0;
                                isPercolation = true;
                                System.out.println(row[i] + "","" + col[i]);
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()) {
                        i++;
                    }
                    if (i > lines.size()-1 && !isPercolation) {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
//            } else {
//                System.out.println(-1);
//            }
        }
    }
}


@2161b80ea26137a064540029ae7f5e6b@"
"b03611015","0","0","0","@251adb816167f05b2d2c1ecb41d2f1f8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package percolation;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Steven
 */
public class Percolation {

    /**
     * @param args the command line arguments
     *
     *
     * by union!!!!!!!!!!!!!!
     *
     *
     *
     *
     */
    private static int[] id;
    private static int[] matrix;
//    0 as black, 1 as white
    static int N;
    static int site;

    public Percolation(int N) {
//        initial the id&bw of the mitrix
        id = new int[N * N + 2];
        matrix = new int[N * N + 2];
//       [0] is top, [N+1] is bottom
        for (int i = 0; i < N * N + 2; i++) {
            id[i] = i;
            matrix[i] = 0;
        }
//       martix begin from 1 end at N
        matrix[0] = 1;
        matrix[N * N + 1] = 1;
    }

    public static void open(int row, int col) {
//        open a new site and check the connection
        site = (row - 1) * N + col;
        matrix[site] = 1;

        if (site <= N) {
            union(site, 0);
//          connect the top     

            if (matrix[site + N] == 1) {
                union(site, site + N);
            }
//            connect the one below

        } else if (site > N * N - N) {
            union(site, N * N + 1);
//          connect the bottom 

            if (matrix[site - N] == 1) {
                union(site, site - N);
            }
//            connect the one above

        } else {
//          the sites between
            if (matrix[site - N] == 1) {
                union(site, site - N);
            }
            if (matrix[site - 1] == 1) {
                union(site, site - 1);
            }
            if (matrix[site + 1] == 1) {
                union(site, site + 1);
            }
            if (matrix[site + N] == 1) {
                union(site, site + N);
            }
        }

    }

    public static void union(int A, int B) {
//        把id 設成最小的位子
        int a = root(A);
        int b = root(B);

        if (a < b) {
            id[b] = a;
        } else {
            id[a] = b;
        }
    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static boolean connection(int A, int B) {
        return root(A) == root(B);
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            N = Integer.parseInt(data);

            Percolation matrix = new Percolation(N);

            String[] randc = new String[2];
            int row = 0;
            int col = 0;
            String brs;
            
            while (Boolean.TRUE) {

                brs = br.readLine();
                if(connection(0, N * N + 1)){
                     System.out.print(row + "","" + col);
                     break;
                }
                if (brs == null) {
                    System.out.print(-1);
                    break;
                }
                randc = brs.split("","");
                row = Integer.parseInt(randc[0]);
                col = Integer.parseInt(randc[1]);

                open(row, col);
            }

//            if (br.readLine() != null) {
//                System.out.print(row + "","" + col);
//            }

        }
    }

}
@251adb816167f05b2d2c1ecb41d2f1f8@"
"b03611015","10","0.098","119104","@7c05669aaf5066b2f9855ff6c13c0d94@

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Steven
 */
public class Percolation {

    /**
     * @param args the command line arguments
     *
     *
     * by union!!!!!!!!!!!!!!
     *
     *
     *
     *
     */
    private static int[] id;
    private static int[] matrix;
//    0 as black, 1 as white
    static int N;
    static int site;

    public Percolation(int N) {
//        initial the id&bw of the mitrix
        id = new int[N * N + 2];
        matrix = new int[N * N + 2];
//       [0] is top, [N+1] is bottom
        for (int i = 0; i < N * N + 2; i++) {
            id[i] = i;
            matrix[i] = 0;
        }
//       martix begin from 1 end at N
        matrix[0] = 1;
        matrix[N * N + 1] = 1;
    }

    public static void open(int row, int col) {
//        open a new site and check the connection
        site = (row - 1) * N + col;
        matrix[site] = 1;

        if (site <= N) {
            union(site, 0);
//          connect the top     

            if (matrix[site + N] == 1) {
                union(site, site + N);
            }
//            connect the one below

        } else if (site > N * N - N) {
            union(site, N * N + 1);
//          connect the bottom 

            if (matrix[site - N] == 1) {
                union(site, site - N);
            }
//            connect the one above

        } else {
//          the sites between
            if (matrix[site - N] == 1) {
                union(site, site - N);
            }
            if (matrix[site - 1] == 1) {
                union(site, site - 1);
            }
            if (matrix[site + 1] == 1) {
                union(site, site + 1);
            }
            if (matrix[site + N] == 1) {
                union(site, site + N);
            }
        }

    }

    public static void union(int A, int B) {
//        把id 設成最小的位子
        int a = root(A);
        int b = root(B);

        if (a < b) {
            id[b] = a;
        } else {
            id[a] = b;
        }
    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static boolean connection(int A, int B) {
        return root(A) == root(B);
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            N = Integer.parseInt(data);

            Percolation matrix = new Percolation(N);

            String[] randc = new String[2];
            int row = 0;
            int col = 0;
            String brs;
            
            while (Boolean.TRUE) {

                brs = br.readLine();
                if(connection(0, N * N + 1)){
                     System.out.print(row + "","" + col);
                     break;
                }
                if (brs == null) {
                    System.out.print(-1);
                    break;
                }
                randc = brs.split("","");
                row = Integer.parseInt(randc[0]);
                col = Integer.parseInt(randc[1]);

                open(row, col);
            }

//            if (br.readLine() != null) {
//                System.out.print(row + "","" + col);
//            }

        }
    }

}
@7c05669aaf5066b2f9855ff6c13c0d94@"
"r03525006","10","0.158","135088","@a8a6076a9b91e876b3bfe581911847f1@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;

public class Percolation {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int num = Integer.parseInt(br.readLine());

            ArrayList<String> lines = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            int[] row = new int[num*num];
            int[] col = new int[num*num];
            int[][] id = new int[num][num];

            for (int i = 0; i < lines.size(); i++) {
                String[] coordinates = lines.get(i).split("","");
                row[i] = Integer.parseInt(coordinates[0]);
                col[i] = Integer.parseInt(coordinates[1]);
            }

            if (num < 3) {
                if (num == 1) {
                    if (lines.size() != 0)
                        System.out.println(1 + "","" + 1);
                    else
                        System.out.println(-1);
                } else {
                    int colCount1 = 0;
                    int colCount2 = 0;
                    for (int j = 0; j < lines.size(); j++) {
                        if (col[j] == 1)
                            colCount1++;
                        else
                            colCount2++;

                        if (colCount1 == 2 || colCount2 == 2) {
                            System.out.println(row[j] + "","" + col[j]);
                            j = lines.size();
                        }

                        if (j == lines.size()-1 && !(colCount1 == 2 || colCount2 == 2))
                            System.out.println(-1);
                    }
                }
            } else {
                int i = 0;
                boolean isPercolation = false;
                while (!isPercolation) {
                    id[row[i] - 1][col[i] - 1] = row[i];
                    for (int j = i; j >= 0; j--) {
//                        System.out.println(""old i = "" + i);
//                        System.out.println(""pos = "" + row[j] + "","" + col[j]);
//                        System.out.println(""old id = "" + id[row[j] - 1][col[j] - 1]);
//                        System.out.println(""---------"");
                        if (row[j] != 1 && row[j] != num) {
                            // up
                            int upBlock = id[row[j] - 2][col[j] - 1];
                            // down
                            int downBlock = id[row[j]][col[j] - 1];
                            // left
                            int leftBlock;
                            if (col[j] == 1)
                                leftBlock = 0;
                            else
                                leftBlock = id[row[j] - 1][col[j] - 2];

                            // right
                            int rightBlock;
                            if (col[j] == num)
                                rightBlock = 0;
                            else
                                rightBlock = id[row[j] - 1][col[j]];

                            boolean firstRow = (upBlock == 1 || downBlock == 1 || leftBlock == 1 || rightBlock == 1);
                            boolean lastRow = (upBlock == num || downBlock == num || leftBlock == num || rightBlock == num);

                            if (firstRow) {
                                id[row[j] - 1][col[j] - 1] = 1;
                            } else if (lastRow) {
                                id[row[j] - 1][col[j] - 1] = num;
                            }

                            if (firstRow && lastRow) {
                                j = 0;
                                isPercolation = true;
                                System.out.println(row[i] + "","" + col[i]);
                            }
//                            System.out.println(""u_d_l_r = "" + upBlock + "","" + downBlock + "","" + leftBlock + "","" + rightBlock);
//                            System.out.println(""new id = "" + id[row[j] - 1][col[j] - 1]);
//                            System.out.println(""---------"");
                        }
                    }
                    if (i < lines.size()) {
                        i++;
                    }
                    if (i > lines.size() - 1 && !isPercolation) {
                        isPercolation = true;
                        System.out.println(-1);
                    }
                }
            }
        }
    }
}


@a8a6076a9b91e876b3bfe581911847f1@"
"b03106003","5","1.02","142432","@bf1ca60c54d71f2f248e47bb30d56b1d@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        
        //for(int i = 0; i<data.length; i++){
        //    System.out.print(data[i]+"" "");
        //}
        int n = Integer.valueOf(data[0]);
        QuickUnionUF uf = new QuickUnionUF(n*n+2);
        int top = 0;
        int botten = n*n+1;
        for(int i = 1; i<=n; i++){
             uf.union(top,i);
        }
        for(int i = n*n; i> n*(n-1); i--){
             uf.union(botten,i);
        }
        
        int flag[][] = new int [n][n];
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = 0;            
            }
        }
        
        int point[] = {0,0};
        for(int i = 1 ; i < data.length ; i++ ){
            point = taker(data[i]);
            flag[point[0]][point[1]] = 1;
            //top
            if(point[1] > 0){
                if(flag[point[0]][point[1]-1] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = point[0]*n + (point[1]-1) +1;
                    uf.union(p, q);
                
                }
                
                
            }
            //down
            if(point[1] < (n-1)){
            if(flag[point[0]][point[1]+1] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = point[0]*n + (point[1]+1) +1;
                    uf.union(p, q);
                
                }
            }
            //left
            if(point[0] > 0){
                if(flag[point[0]-1][point[1]] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = (point[0]-1)*n +point[1] +1;
                    uf.union(p, q);

                    }
            
            }
            
            if(point[0] < (n-1)){
                 if(flag[point[0]+1][point[1]] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = (point[0]+1)*n +point[1] +1;
                    uf.union(p, q);

                    }
            
            }
            if(uf.connected(top, botten)){
                System.out.print((point[0]+1) + "","" + ((point[1])+1));
                break;
            }            
            
            
        }

        
        
        
        
        
        
    }
    static int[] taker(String s){
        String temp [] = s.split("","");
        int ans[] = new int[2];
        ans[0] = Integer.valueOf(temp[0])-1;
        ans[1] = Integer.valueOf(temp[1])-1;
        return ans;
    }
    
    
}
@bf1ca60c54d71f2f248e47bb30d56b1d@"
"b03106003","0","1.02","142432","@17b522a0e2117f3949f0edba30407b0f@
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        
        //for(int i = 0; i<data.length; i++){
        //    System.out.print(data[i]+"" "");
        //}
        int n = Integer.valueOf(data[0]);
        QuickUnionUF uf = new QuickUnionUF(n*n+2);
        int top = 0;
        int botten = n*n+1;
        for(int i = 1; i<=n; i++){
             uf.union(top,i);
        }
        for(int i = n*n; i> n*(n-1); i--){
             uf.union(botten,i);
        }
        
        int flag[][] = new int [n][n];
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = 0;            
            }
        }
        
        int point[] = {0,0};
        for(int i = 1 ; i < data.length ; i++ ){
            point = taker(data[i]);
            flag[point[0]][point[1]] = 1;
            //top
            if(point[1] > 0){
                if(flag[point[0]][point[1]-1] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = point[0]*n + (point[1]-1) +1;
                    uf.union(p, q);
                
                }
                
                
            }
            //down
            if(point[1] < (n-1)){
            if(flag[point[0]][point[1]+1] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = point[0]*n + (point[1]+1) +1;
                    uf.union(p, q);
                
                }
            }
            //left
            if(point[0] > 0){
                if(flag[point[0]-1][point[1]] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = (point[0]-1)*n +point[1] +1;
                    uf.union(p, q);

                    }
            
            }
            
            if(point[0] < (n-1)){
                 if(flag[point[0]+1][point[1]] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = (point[0]+1)*n +point[1] +1;
                    uf.union(p, q);

                    }
            
            }
            if(uf.connected(top, botten)){
                System.out.println((point[0]+1) + "","" + ((point[1])+1));
                break;
            }            
            
            
        }
@17b522a0e2117f3949f0edba30407b0f@"
"b03106003","5","1.03","142032","@23f8d080d881bccd100b16057d7fbbe9@
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        
        //for(int i = 0; i<data.length; i++){
        //    System.out.print(data[i]+"" "");
        //}
        int n = Integer.valueOf(data[0]);
        QuickUnionUF uf = new QuickUnionUF(n*n+2);
        int top = 0;
        int botten = n*n+1;
        for(int i = 1; i<=n; i++){
             uf.union(top,i);
        }
        for(int i = n*n; i> n*(n-1); i--){
             uf.union(botten,i);
        }
        
        int flag[][] = new int [n][n];
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = 0;            
            }
        }
        
        int point[] = {0,0};
        for(int i = 1 ; i < data.length ; i++ ){
            point = taker(data[i]);
            flag[point[0]][point[1]] = 1;
            //top
            if(point[1] > 0){
                if(flag[point[0]][point[1]-1] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = point[0]*n + (point[1]-1) +1;
                    uf.union(p, q);
                
                }
                
                
            }
            //down
            if(point[1] < (n-1)){
            if(flag[point[0]][point[1]+1] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = point[0]*n + (point[1]+1) +1;
                    uf.union(p, q);
                
                }
            }
            //left
            if(point[0] > 0){
                if(flag[point[0]-1][point[1]] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = (point[0]-1)*n +point[1] +1;
                    uf.union(p, q);

                    }
            
            }
            
            if(point[0] < (n-1)){
                 if(flag[point[0]+1][point[1]] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = (point[0]+1)*n +point[1] +1;
                    uf.union(p, q);

                    }
            
            }
            if(uf.connected(top, botten)){
                System.out.println((point[0]+1) + "","" + ((point[1])+1));
                break;
            }            
            
            
        }

        
        
        
        
        
        
    }
    static int[] taker(String s){
        String temp [] = s.split("","");
        int ans[] = new int[2];
        ans[0] = Integer.valueOf(temp[0])-1;
        ans[1] = Integer.valueOf(temp[1])-1;
        return ans;
    }
    
    
}

@23f8d080d881bccd100b16057d7fbbe9@"
"b03106003","10","0.102","142832","@620a7b1cc2f740a9598f219367424a5d@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        
        //for(int i = 0; i<data.length; i++){
        //    System.out.print(data[i]+"" "");
        //}
        int n = Integer.valueOf(data[0]);
        QuickUnionUF uf = new QuickUnionUF(n*n+2);
        int top = 0;
        int botten = n*n+1;
        for(int i = 1; i<=n; i++){
             uf.union(top,i);
        }
        for(int i = n*n; i> n*(n-1); i--){
             uf.union(botten,i);
        }
        
        int flag[][] = new int [n][n];
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = 0;            
            }
        }
        
        int point[] = {0,0};
        for(int i = 1 ; i < data.length ; i++ ){
            point = taker(data[i]);
            flag[point[0]][point[1]] = 1;
            //top
            if(point[1] > 0){
                if(flag[point[0]][point[1]-1] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = point[0]*n + (point[1]-1) +1;
                    uf.union(p, q);
                
                }
                
                
            }
            //down
            if(point[1] < (n-1)){
            if(flag[point[0]][point[1]+1] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = point[0]*n + (point[1]+1) +1;
                    uf.union(p, q);
                
                }
            }
            //left
            if(point[0] > 0){
                if(flag[point[0]-1][point[1]] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = (point[0]-1)*n +point[1] +1;
                    uf.union(p, q);

                    }
            
            }
            
            if(point[0] < (n-1)){
                 if(flag[point[0]+1][point[1]] == 1){
                    int p = point[0]*n + point[1] +1;
                    int q = (point[0]+1)*n +point[1] +1;
                    uf.union(p, q);

                    }
            
            }
            if(uf.connected(top, botten)){
                System.out.println((point[0]+1) + "","" + ((point[1])+1));
                break;
            }            
            
            
        }
           if(uf.connected(top, botten) != true){
               System.out.println(-1);
           }

    }
    static int[] taker(String s){
        String temp [] = s.split("","");
        int ans[] = new int[2];
        ans[0] = Integer.valueOf(temp[0])-1;
        ans[1] = Integer.valueOf(temp[1])-1;
        return ans;
    }
    
    
}

@620a7b1cc2f740a9598f219367424a5d@"
"b99611017","6","1.3","192336","@e9b930126e0108d5cee45e6ab1528170@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
//import edu.princeton.cs.algs4.UF;
import java.io.*;
import java.util.Scanner;
import java.io.FileReader;

public class Percolation {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            int size = Integer.parseInt(token[0]); //sieze the matrix size

            int holeNum = token.length - 1;  //Number of holes

            int[] hole = new int[holeNum];

            for (int i = 0; i < holeNum; i++) //transfer site into flags
            {
                String[] site = token[1 + i].split("","");  //hole[i] are flags

                int row = Integer.parseInt(site[0]);

                int column = Integer.parseInt(site[1]);

                hole[i] = (row - 1) * size + (column - 1);

                //System.out.println(hole[i]);     //hole[i] refers to token[1+i]
            }

            int gridNum = size * size + 2;   // size=3 gridNum=11
            //flag=9: upper
            //flag=10 : buttom

            UF uf;
            uf = new UF(gridNum);    //flag : 0~10

            for (int i = 0; i < holeNum; i++) {
                if (hole[i] == 0) //left up
                {
                    uf.union(hole[i], gridNum - 2);

                } else if (hole[i] == size - 1) //right up
                {
                    uf.union(hole[i], gridNum - 2);

                } else if (hole[i] == gridNum - 3) //right down
                {
                    uf.union(hole[i], gridNum - 1);

                    uf.union(hole[i], hole[i] - 1);

                    uf.union(hole[i], hole[i] - size);

                } else if (hole[i] == gridNum - size - 2) //left down
                {
                    uf.union(hole[i], gridNum - 1);

                    uf.union(hole[i] + 1, hole[i]);

                    uf.union(hole[i], hole[i] - size);

                } else if (hole[i] / size == 0 && hole[i] != 0 && hole[i] != size - 1) { //upper

                    uf.union(hole[i], gridNum - 2);

                } else if (hole[i] / size == 2 && hole[i] != gridNum - 3 && hole[i] != gridNum - size - 2) {//buttom

                    uf.union(hole[i], gridNum - 1);

                    uf.union(hole[i] - 1, hole[i]);

                    uf.union(hole[i] - size, hole[i]);

                } else if (hole[i] % size == 0 && hole[i] != 0 && hole[i] != gridNum - size - 2) {//left side

                    uf.union(hole[i] - size, hole[i]);

                } else if (hole[i] % size == size - 1 && hole[i] != size - 1 && hole[i] != gridNum - 3) {//right side

                    uf.union(hole[i] - 1, hole[i]);

                    uf.union(hole[i] - size, hole[i]);

                } else {

                    uf.union(hole[i] - size, hole[i]);

                    uf.union(hole[i] - 1, hole[i]);

                }
                if (uf.connected(gridNum - 1, gridNum - 2)) {
                    System.out.println(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    break;
                }

            }
            if (uf.connected(gridNum - 1, gridNum - 2) == false) {
                System.out.println(-1);
            }

        } catch (RuntimeException e) {

            throw e;
        }
        // TODO code application logic here
        /*UF uf=new UF(10);
         uf.union(2, 5);
         uf.union(2, 6);
         System.out.println(uf.count());
         System.out.println(uf.connected(5, 6));*/
    }

}

@e9b930126e0108d5cee45e6ab1528170@"
"r04921105","10","0.103","124064","@20b5497a5f72988510595a8efe361361@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String data = br.readLine();
            
            // store the first integer in variable stringCount (number of announced strings)
            int dim = Integer.parseInt(data);
            String[] open_str;
            int[][] matrix = new int[dim][dim];
            UF uf = new UF(dim*dim+2);
            //unuion the top to uf[dimension*dimension]
            for(int i = 0; i < dim; i++){
                uf.union(i, dim*dim);
            }            
            //unuion the buttom to uf[dimension*dimension+1]
            for(int i = 0; i < dim; i++){
                uf.union(dim*(dim-1) + i, dim*dim+1);
            }      
            int x,y;
            
            boolean flag = false;

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                
                matrix[x][y] = 1;     
                
                //up
                if((x-1 >= 0) && (matrix[x-1][y]==1))
                   uf.union(dim*x + y, dim*(x-1) + y); 
                
                //down
                if((x+1 < dim) && (matrix[x+1][y]==1))
                   uf.union(dim*x + y, dim*(x+1) + y);
                
                //left
                if((y-1 >= 0) && (matrix[x][y-1]==1))
                   uf.union(dim*x + y, dim*x + y-1);
                
                //up
                if((y+1 < dim) && (matrix[x][y+1]==1))
                   uf.union(dim*x + y, dim*x + y+1); 
                
                if(uf.connected(dim*dim,dim*dim+1)){
                    System.out.printf(""%d,%d"",x+1,y+1);
                    flag = true;
                    break;
                }
                
            }
            if (flag == false){
                System.out.printf(""%d"",-1);
            }
                }            
            
    }
    
    
    public static void print(int dim,int matrix[][]){
                for(int i =0; i < dim; i++){

                for(int j=0; j < dim; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@20b5497a5f72988510595a8efe361361@"
"r04921105","10","0.101","126080","@c83d19256ce303847e0124c9f3fe4176@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String data = br.readLine();
            
            // store the first integer in variable stringCount (number of announced strings)
            int dim = Integer.parseInt(data);
            String[] open_str;
            int[][] matrix = new int[dim][dim];
            UF uf = new UF(dim*dim+2);
            //unuion the top to uf[dimension*dimension]
            for(int i = 0; i < dim; i++){
                uf.union(i, dim*dim);
            }            
            //unuion the buttom to uf[dimension*dimension+1]
            for(int i = 0; i < dim; i++){
                uf.union(dim*(dim-1) + i, dim*dim+1);
            }      
            int x,y;
            
            boolean flag = false;

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                
                matrix[x][y] = 1;     
                
                
                if((x-1 >= 0) && (matrix[x-1][y]==1))
                   uf.union(dim*x + y, dim*(x-1) + y); 
                
                
                if((x+1 < dim) && (matrix[x+1][y]==1))
                   uf.union(dim*x + y, dim*(x+1) + y);
                
                
                if((y-1 >= 0) && (matrix[x][y-1]==1))
                   uf.union(dim*x + y, dim*x + y-1);
                
                
                if((y+1 < dim) && (matrix[x][y+1]==1))
                   uf.union(dim*x + y, dim*x + y+1); 
                
                if(uf.connected(dim*dim,dim*dim+1)){
                    System.out.printf(""%d,%d"",x+1,y+1);
                    flag = true;
                    break;
                }
                
            }
            if (flag == false){
                System.out.printf(""%d"",-1);
            }
                }            
            
    }
    
    
    public static void print(int dim,int matrix[][]){
                for(int i =0; i < dim; i++){

                for(int j=0; j < dim; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@c83d19256ce303847e0124c9f3fe4176@"
"b03611033","9","2.45","136208","@3675f2b8f552bbf4a6a37d45edd831e1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {    
   public boolean[] matrix;
   public int[] self;
    public Percolation(int n){
        matrix = new boolean[n*n];
        self = new int[n*n];
        for(int i=0;i<n;i++){
            self[i]=0;
        }
        for(int i=n;i<n*n;i++){
            self[i]=i;
        }
    }
    public void open(int n,int p,int q){
        matrix[p*n+q] = true;
        line(n,p,q);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(matrix[i*n+j]){
                    line(n,i,j);
                }
            }
        }
    }
    
    public void line(int n,int p,int q){
         if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                root(p*n+q,p*n+(q-1));
            }
        }
        if(p>0){
            if(matrix[p*n+q] & matrix[(p-1)*n+q]){
                root(p*n+q,(p-1)*n+q);
            }
        }
        if(p<n-1){
            if(matrix[p*n+q] & matrix[(p+1)*n+q]){
                root((p+1)*n+q,p*n+q);
            }
        }
        
        if(q<n-1){
            if(matrix[p*n+q] & matrix[p*n+(q+1)]){
                root(p*n+(q+1),p*n+q);
            }
        }
    }
    public void root(int m,int n){
        if(self[m]<self[n]){
            self[n]=self[m];
        }
        else{
            self[m]=self[n];
        }
    }
    
    
    public boolean percolates(int n){
        for(int i=(n-1)*n;i<n*n;i++){
            if(self[i]==0){
                return true;
            }
        }
        return false;
        
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String data = br.readLine();
                int N = Integer.parseInt(data);
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    percolation.open(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
            }
        }        
    }


@3675f2b8f552bbf4a6a37d45edd831e1@"
"b03611033","9","2.56","137120","@c22bcc31df962fa043f2e54642e337d9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {    
   public boolean[] matrix;
   public int[] self;
   public static int count=0;
   public int counted;
    public Percolation(int n){
        matrix = new boolean[n*n];
        self = new int[n*n];
        for(int i=0;i<n;i++){
            self[i]=0;
        }
        for(int i=n;i<n*n;i++){
            self[i]=i;
        }
    }
    public void open(int n,int p,int q){
       matrix[p*n+q] = true;
        count++;
        counted=count;
        line(n,p,q);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(matrix[i*n+j] & counted !=0){
                    line(n,i,j);
                    counted--;
                }
            }
        }
    }
    
    public void line(int n,int p,int q){
         if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                root(p*n+q,p*n+(q-1));
            }
        }
        if(p>0){
            if(matrix[p*n+q] & matrix[(p-1)*n+q]){
                root(p*n+q,(p-1)*n+q);
            }
        }
        if(p<n-1){
            if(matrix[p*n+q] & matrix[(p+1)*n+q]){
                root((p+1)*n+q,p*n+q);
            }
        }
        
        if(q<n-1){
            if(matrix[p*n+q] & matrix[p*n+(q+1)]){
                root(p*n+(q+1),p*n+q);
            }
        }
    }
    public void root(int m,int n){
        if(self[m]<self[n]){
            self[n]=self[m];
        }
        else{
            self[m]=self[n];
        }
    }
    
    
    public boolean percolates(int n){
        for(int i=(n-1)*n;i<n*n;i++){
            if(self[i]==0){
                return true;
            }
        }
        return false;
        
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String data = br.readLine();
                int N = Integer.parseInt(data);
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    percolation.open(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
            }
        }        
    }


@c22bcc31df962fa043f2e54642e337d9@"
"r04631027","0","1.03","173456","@664d98815cc75a7019178be010194a18@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            int[][] ver;
            ver = new int[dimention - 1][dimention];
            int[][] hor;
            hor = new int[dimention][dimention - 1];
            int[] union;
            union = new int[dimention-1];
            int[] oh;
            oh = new int[dimention-1];
            int[] connect;
            connect = new int[dimention-1];
            int sum =0;
            int finalc=0;
            int ok=0;
            
            while (/*(line = br.readLine())!=null*/ok!=100) {
                finalc=0;
                line = br.readLine();
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                
                
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if(union[x-2]==0)
                    {union[x-2]=1;
                    sum++;
                    }
                    if(oh[x-2]==0)
                        oh[x-2]=y-1;
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if(union[x-1]==0)
                    {union[x-1]=1;
                    sum++;
                    }
                    if(oh[x-1]==0)
                        oh[x-1]=y-1;
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }
                
                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];
                        
                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i]-j] == 1) {
                                    count++;
                                }
                            }
                            if(count==cross)
                            { connect[i]=1;
                            if(i + 1==(union.length)-1)
                                connect[i+1]=1;
                            }
                        }
                         if (cross <0) {
                             int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i]+j] == 1) {
                                    count++;
                                }
                            }
                            if(count==(-cross))
                            {connect[i]=1;
                            if(i + 1==(union.length)-1)
                                connect[i+1]=1;
                            }
                        }
                    }
                }
               
                for(int i=0;i<connect.length;i++)
                {finalc+=connect[i];}
                if(finalc==2)
                    ok=100;
                System.out.print(finalc);
            }
            
            //print 
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention - 1; j++) {
                    System.out.print(hor[i][j] + "" "");
                }
                System.out.println("" "");
            }
            for (int i = 0; i < dimention - 1; i++) {
                for (int j = 0; j < dimention; j++) {
                    System.out.print(ver[i][j] + "" "");
                }
                System.out.println("" "");
            }
            for (int j = 0; j < dimention-1; j++) {
                    System.out.println(""oh""+connect[j]);
                }
            System.out.println(sum);

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@664d98815cc75a7019178be010194a18@"
"r04631027","3","0.63","114608","@43cca1766f7727bde596cf47c8bf5736@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            int[][] ver;
            ver = new int[dimention - 1][dimention];
            int[][] hor;
            hor = new int[dimention][dimention - 1];
            int[] union;
            union = new int[dimention-1];
            int[] oh;
            oh = new int[dimention-1];
            int[] connect;
            connect = new int[dimention-1];
            int sum =0;
            int finalc=0;
            int ok=0;
            
            while (/*(line = br.readLine())!=null*/ok!=100) {
                finalc=0;
                line = br.readLine();
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                
                
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if(union[x-2]==0)
                    {union[x-2]=1;
                    sum++;
                    }
                    if(oh[x-2]==0)
                        oh[x-2]=y-1;
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if(union[x-1]==0)
                    {union[x-1]=1;
                    sum++;
                    }
                    if(oh[x-1]==0)
                        oh[x-1]=y-1;
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }
                
                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];
                        
                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i]-j] == 1) {
                                    count++;
                                }
                            }
                            if(count==cross)
                            { connect[i]=1;
                            if(i + 1==(union.length)-1)
                                connect[i+1]=1;
                            }
                        }
                         if (cross <0) {
                             int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i]+j] == 1) {
                                    count++;
                                }
                            }
                            if(count==(-cross))
                            {connect[i]=1;
                            if(i + 1==(union.length)-1)
                                connect[i+1]=1;
                            }
                        }
                    }
                }
               
                for(int i=0;i<connect.length;i++)
                {finalc+=connect[i];}
                if(finalc==2)
                    ok=100;
                //System.out.print(finalc);
            }
            
            //print 
//            for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention - 1; j++) {
//                    System.out.print(hor[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int i = 0; i < dimention - 1; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(ver[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int j = 0; j < dimention-1; j++) {
//                    System.out.println(""oh""+connect[j]);
//                }
            System.out.println(line);

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@43cca1766f7727bde596cf47c8bf5736@"
"r04631027","4","0.34","105216","@91c368e98760fb90556fa202cc54145b@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            int[][] ver;
            ver = new int[dimention - 1][dimention];
            int[][] hor;
            hor = new int[dimention][dimention - 1];
            int[] union;
            union = new int[dimention-1];
            int[] oh;
            oh = new int[dimention-1];
            int[] connect;
            connect = new int[dimention-1];
            int sum =0;
            int finalc=0;
            int ok=0;
            
            while (/*(line = br.readLine())!=null*/ok!=100) {
                finalc=0;
                line = br.readLine();
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                
                
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if(union[x-2]==0)
                    {union[x-2]=1;
                    sum++;
                    }
                    if(oh[x-2]==0)
                        oh[x-2]=y-1;
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if(union[x-1]==0)
                    {union[x-1]=1;
                    sum++;
                    }
                    if(oh[x-1]==0)
                        oh[x-1]=y-1;
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }
                
                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];
                        
                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i]-j] == 1) {
                                    count++;
                                }
                            }
                            if(count==cross)
                            { connect[i]=1;
                            if(i + 1==(union.length)-1)
                                connect[i+1]=1;
                            }
                        }
                         if (cross <0) {
                             int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i]+j] == 1) {
                                    count++;
                                }
                            }
                            if(count==(-cross))
                            {connect[i]=1;
                            if(i + 1==(union.length)-1)
                                connect[i+1]=1;
                            }
                        }
                    }
                }
               
                for(int i=0;i<connect.length;i++)
                {finalc+=connect[i];}
                if(finalc==dimention-1)
                    ok=100;
                //System.out.print(finalc);
            }
            
            //print 
//            for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention - 1; j++) {
//                    System.out.print(hor[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int i = 0; i < dimention - 1; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(ver[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int j = 0; j < dimention-1; j++) {
//                    System.out.println(""oh""+connect[j]);
//                }
            System.out.println(line);

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@91c368e98760fb90556fa202cc54145b@"
"r04631027","4","0.34","105200","@119f193de8e883652b0c483ee13a78e6@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            int[][] ver;
            ver = new int[dimention - 1][dimention];
            int[][] hor;
            hor = new int[dimention][dimention - 1];
            int[] union;
            union = new int[dimention - 1];
            int[] oh;
            oh = new int[dimention - 1];
            int[] connect;
            connect = new int[dimention - 1];
            int sum = 0;
            int finalc = 0;
            int ok = 0;

            while (/*(line = br.readLine())!=null*/ok != 100) {
                
                finalc = 0;
                line = br.readLine();
                if(line==null)
                    System.out.print(""-1"");
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if (union[x - 2] == 0) {
                        union[x - 2] = 1;
                        sum++;
                    }
                    if (oh[x - 2] == 0) {
                        oh[x - 2] = y - 1;
                    }
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if (union[x - 1] == 0) {
                        union[x - 1] = 1;
                        sum++;
                    }
                    if (oh[x - 1] == 0) {
                        oh[x - 1] = y - 1;
                    }
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }

                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];

                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i] - j] == 1) {
                                    count++;
                                }
                            }
                            if (count == cross) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                        if (cross < 0) {
                            int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i] + j] == 1) {
                                    count++;
                                }
                            }
                            if (count == (-cross)) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                    }
                }

                for (int i = 0; i < connect.length; i++) {
                    finalc += connect[i];
                }
                if (finalc == dimention - 1) {
                    ok = 100;
                }
                //System.out.print(finalc);
            }

            //print 
//            for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention - 1; j++) {
//                    System.out.print(hor[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int i = 0; i < dimention - 1; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(ver[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int j = 0; j < dimention-1; j++) {
//                    System.out.println(""oh""+connect[j]);
//                }
            System.out.println(line);

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@119f193de8e883652b0c483ee13a78e6@"
"r04631027","4","1.21","161056","@ca462f08db2d6b05f2c0567109162033@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            int[][] ver;
            ver = new int[dimention - 1][dimention];
            int[][] hor;
            hor = new int[dimention][dimention - 1];
            int[] union;
            union = new int[dimention - 1];
            int[] oh;
            oh = new int[dimention - 1];
            int[] connect;
            connect = new int[dimention - 1];
            int sum = 0;
            int finalc = 0;
            int ok = 0;

            while (/*(line = br.readLine())!=null*/ok != 100) {
                
                finalc = 0;
                line = br.readLine();
                if(line==null)
                { System.out.print(""-1"");
                break;
                }
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if (union[x - 2] == 0) {
                        union[x - 2] = 1;
                        sum++;
                    }
                    if (oh[x - 2] == 0) {
                        oh[x - 2] = y - 1;
                    }
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if (union[x - 1] == 0) {
                        union[x - 1] = 1;
                        sum++;
                    }
                    if (oh[x - 1] == 0) {
                        oh[x - 1] = y - 1;
                    }
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }

                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];

                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i] - j] == 1) {
                                    count++;
                                }
                            }
                            if (count == cross) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                        if (cross < 0) {
                            int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i] + j] == 1) {
                                    count++;
                                }
                            }
                            if (count == (-cross)) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                    }
                }

                for (int i = 0; i < connect.length; i++) {
                    finalc += connect[i];
                }
                if (finalc == dimention - 1) {
                    ok = 100;
                }
                //System.out.print(finalc);
            }

            //print 
//            for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention - 1; j++) {
//                    System.out.print(hor[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int i = 0; i < dimention - 1; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(ver[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int j = 0; j < dimention-1; j++) {
//                    System.out.println(""oh""+connect[j]);
//                }
            System.out.println(line);

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@ca462f08db2d6b05f2c0567109162033@"
"r04631027","9","1.28","162176","@876153701cb82ef1561739274ef31816@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            int[][] ver;
            ver = new int[dimention - 1][dimention];
            int[][] hor;
            hor = new int[dimention][dimention - 1];
            int[] union;
            union = new int[dimention - 1];
            int[] oh;
            oh = new int[dimention - 1];
            int[] connect;
            connect = new int[dimention - 1];
            int sum = 0;
            int finalc = 0;
            int ok = 0;

            while (/*(line = br.readLine())!=null*/ok != 100) {
                
                finalc = 0;
                line = br.readLine();
                if(line==null)
                { 
                break;
                }
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if (union[x - 2] == 0) {
                        union[x - 2] = 1;
                        sum++;
                    }
                    if (oh[x - 2] == 0) {
                        oh[x - 2] = y - 1;
                    }
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if (union[x - 1] == 0) {
                        union[x - 1] = 1;
                        sum++;
                    }
                    if (oh[x - 1] == 0) {
                        oh[x - 1] = y - 1;
                    }
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }

                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];

                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i] - j] == 1) {
                                    count++;
                                }
                            }
                            if (count == cross) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                        if (cross < 0) {
                            int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i] + j] == 1) {
                                    count++;
                                }
                            }
                            if (count == (-cross)) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                    }
                }

                for (int i = 0; i < connect.length; i++) {
                    finalc += connect[i];
                }
                if (finalc == dimention - 1) {
                    ok = 100;
                }
                //System.out.print(finalc);
            }

            //print 
//            for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention - 1; j++) {
//                    System.out.print(hor[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int i = 0; i < dimention - 1; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(ver[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
//            for (int j = 0; j < dimention-1; j++) {
//                    System.out.println(""oh""+connect[j]);
//                }
            if(line!=null)
            System.out.println(line);
            else
                System.out.println(""-1"");
                

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@876153701cb82ef1561739274ef31816@"
"r04631027","9","1.23","158080","@dcfc94636b4c8c92d97029e37a8f2cc8@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            int[][] ver;
            ver = new int[dimention - 1][dimention];
            int[][] hor;
            hor = new int[dimention][dimention - 1];
            int[] union;
            union = new int[dimention - 1];
            int[] oh;
            oh = new int[dimention - 1];
            int[] connect;
            connect = new int[dimention - 1];
            int sum = 0;
            int finalc = 0;
            int ok = 0;

            while (/*(line = br.readLine())!=null*/ok != 100) {
                finalc = 0;
                line = br.readLine();
                if (line == null) {
                    break;
                }
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if (union[x - 2] == 0) {
                        union[x - 2] = 1;
                        sum++;
                    }
                    if (oh[x - 2] == 0) {
                        oh[x - 2] = y - 1;
                    }
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if (union[x - 1] == 0) {
                        union[x - 1] = 1;
                        sum++;
                    }
                    if (oh[x - 1] == 0) {
                        oh[x - 1] = y - 1;
                    }
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }

                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];

                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i] - j] == 1) {
                                    count++;
                                }
                            }
                            if (count == cross) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                        if (cross < 0) {
                            int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i] + j] == 1) {
                                    count++;
                                }
                            }
                            if (count == (-cross)) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                    }
                }
                for (int i = 0; i < connect.length; i++) {
                    finalc += connect[i];
                }
                if (finalc == dimention - 1) {
                    ok = 100;
                }
            }
            if (line != null) {
                System.out.println(line);
            } else {
                System.out.println(""-1"");
            }

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@dcfc94636b4c8c92d97029e37a8f2cc8@"
"r04631027","9","1.09","156000","@9359c556e111d9d5580f702d2dd156b5@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            int[][] ver;
            ver = new int[dimention - 1][dimention];
            int[][] hor;
            hor = new int[dimention][dimention - 1];
            int[] union;
            union = new int[dimention - 1];
            int[] oh;
            oh = new int[dimention - 1];
            int[] connect;
            connect = new int[dimention - 1];
            int finalc = 0;
            boolean ok = true;

            while (ok) {
                finalc = 0;
                line = br.readLine();
                if (line == null) {
                    break;
                }
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if (union[x - 2] == 0) {
                        union[x - 2] = 1;
                    }
                    if (oh[x - 2] == 0) {
                        oh[x - 2] = y - 1;
                    }
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if (union[x - 1] == 0) {
                        union[x - 1] = 1;
                    }
                    if (oh[x - 1] == 0) {
                        oh[x - 1] = y - 1;
                    }
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }

                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];

                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i] - j] == 1) {
                                    count++;
                                }
                            }
                            if (count == cross) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                        if (cross < 0) {
                            int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i] + j] == 1) {
                                    count++;
                                }
                            }
                            if (count == (-cross)) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                    }
                }
                for (int i = 0; i < connect.length; i++) {
                    finalc += connect[i];
                }
                if (finalc == dimention - 1) {
                    ok = false;
                }
            }
            if (line != null) {
                System.out.println(line);
            } else {
                System.out.println(""-1"");
            }

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@9359c556e111d9d5580f702d2dd156b5@"
"b99611017","6","1.35","185920","@3e9d5cc36b228b66d4dc839efe7de3fc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
//import edu.princeton.cs.algs4.UF;
import java.io.*;
import java.util.Scanner;
import java.io.FileReader;

public class Percolation {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            int size = Integer.parseInt(token[0]); //sieze the matrix size

            int holeNum = token.length - 1;  //Number of holes

            int[] hole = new int[holeNum];

            for (int i = 0; i < holeNum; i++) //transfer site into flags
            {
                String[] site = token[1 + i].split("","");  //hole[i] are flags

                int row = Integer.parseInt(site[0]);

                int column = Integer.parseInt(site[1]);

                hole[i] = (row - 1) * size + (column - 1);

                //System.out.println(hole[i]);     //hole[i] refers to token[1+i]
            }

            int gridNum = size * size + 2;   // size=3 gridNum=11
            //flag=9: upper
            //flag=10 : buttom

            UF uf;
            uf = new UF(gridNum);    //flag : 0~10

            for (int i = 0; i < holeNum; i++) {
                if (hole[i] == 0) //left up
                {
                    uf.union(hole[i], gridNum - 2);

                } else if (hole[i] == size - 1) //right up
                {
                    uf.union(hole[i], gridNum - 2);

                } else if (hole[i] == gridNum - 3) //right down
                {
                    uf.union(hole[i], gridNum - 1);

                    uf.union(hole[i], hole[i] - 1);

                    uf.union(hole[i], hole[i] - size);

                } else if (hole[i] == gridNum - size - 2) //left down
                {
                    uf.union(hole[i], gridNum - 1);

                    //uf.union(hole[i] + 1, hole[i]);

                    uf.union(hole[i], hole[i] - size);

                } else if (hole[i] / size == 0 && hole[i] != 0 && hole[i] != size - 1) { //upper

                    uf.union(hole[i], gridNum - 2);

                } else if (hole[i] / size == 2 && hole[i] != gridNum - 3 && hole[i] != gridNum - size - 2) {//buttom

                    uf.union(hole[i], gridNum - 1);

                    uf.union(hole[i] - 1, hole[i]);

                    uf.union(hole[i] - size, hole[i]);

                } else if (hole[i] % size == 0 && hole[i] != 0 && hole[i] != gridNum - size - 2) {//left side

                    uf.union(hole[i] - size, hole[i]);

                } else if (hole[i] % size == size - 1 && hole[i] != size - 1 && hole[i] != gridNum - 3) {//right side

                    uf.union(hole[i] - 1, hole[i]);

                    uf.union(hole[i] - size, hole[i]);

                } else {

                    uf.union(hole[i] - size, hole[i]);

                    uf.union(hole[i] - 1, hole[i]);

                }
                if (uf.connected(gridNum - 1, gridNum - 2)) {
                    System.out.println(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    break;
                }

            }
            if (uf.connected(gridNum - 1, gridNum - 2) == false) {
                System.out.println(-1);
            }

        } catch (RuntimeException e) {

            throw e;
        }
        // TODO code application logic here
        /*UF uf=new UF(10);
         uf.union(2, 5);
         uf.union(2, 6);
         System.out.println(uf.count());
         System.out.println(uf.connected(5, 6));*/
    }

}

@3e9d5cc36b228b66d4dc839efe7de3fc@"
"r04631027","0","1.24","160816","@2877bc5d8e82bb97a8d6b20b7f32f707@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            //double dimention = Double.parseDouble(line)
            System.out.println(dimention);
            short[][] metrix;
            metrix = new short[dimention][dimention];
            short[][] ver;
            ver = new short[dimention - 1][dimention];
            short[][] hor;
            hor = new short[dimention][dimention - 1];
            short[] union;
            union = new short[dimention - 1];
            short[] oh;
            oh = new short[dimention - 1];
            short[] connect;
            connect = new short[dimention - 1];
            int finalc;
            boolean ok = true;

            while (ok) {
                finalc = 0;
                line = br.readLine();
                if (line == null) {
                    break;
                }
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if (union[x - 2] == 0) {
                        union[x - 2] = 1;
                    }
                    if (oh[x - 2] == 0) {
                        oh[x - 2] = (short) (y - 1);
                    }
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if (union[x - 1] == 0) {
                        union[x - 1] = 1;
                    }
                    if (oh[x - 1] == 0) {
                        oh[x - 1] = (short) (y - 1);
                    }
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }

                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];

                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i] - j] == 1) {
                                    count++;
                                }
                            }
                            if (count == cross) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                        if (cross < 0) {
                            int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i] + j] == 1) {
                                    count++;
                                }
                            }
                            if (count == (-cross)) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                    }
                }
                for (int i = 0; i < connect.length; i++) {
                    finalc += connect[i];
                }
                if (finalc == dimention - 1) {
                    ok = false;
                }
            }
            if (line != null) {
                System.out.println(line);
            } else {
                System.out.println(""-1"");
            }

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@2877bc5d8e82bb97a8d6b20b7f32f707@"
"r04631027","9","1.18","151648","@7c922ffc49f0913e90daac02ca03660c@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            short[][] metrix;
            metrix = new short[dimention][dimention];
            short[][] ver;
            ver = new short[dimention - 1][dimention];
            int[][] hor;
            hor = new int[dimention][dimention - 1];
            int[] union;
            union = new int[dimention - 1];
            int[] oh;
            oh = new int[dimention - 1];
            int[] connect;
            connect = new int[dimention - 1];
            int finalc ;
            boolean ok = true;

            while (ok) {
                finalc = 0;
                line = br.readLine();
                if (line == null) {
                    break;
                }
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if (union[x - 2] == 0) {
                        union[x - 2] = 1;
                    }
                    if (oh[x - 2] == 0) {
                        oh[x - 2] = y - 1;
                    }
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if (union[x - 1] == 0) {
                        union[x - 1] = 1;
                    }
                    if (oh[x - 1] == 0) {
                        oh[x - 1] = y - 1;
                    }
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }

                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];

                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i] - j] == 1) {
                                    count++;
                                }
                            }
                            if (count == cross) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                        if (cross < 0) {
                            int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i] + j] == 1) {
                                    count++;
                                }
                            }
                            if (count == (-cross)) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                    }
                }
                for (int i = 0; i < connect.length; i++) {
                    finalc += connect[i];
                }
                if (finalc == dimention - 1) {
                    ok = false;
                }
            }
            if (line != null) {
                System.out.println(line);
            } else {
                System.out.println(""-1"");
            }

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@7c922ffc49f0913e90daac02ca03660c@"
"r04631027","9","1.21","159472","@b73c57c61a11b26f9302f26bc20654c3@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            short[][] metrix;
            metrix = new short[dimention][dimention];
            short[][] ver;
            ver = new short[dimention - 1][dimention];
            short[][] hor;
            hor = new short[dimention][dimention - 1];
            int[] union;
            union = new int[dimention - 1];
            int[] oh;
            oh = new int[dimention - 1];
            int[] connect;
            connect = new int[dimention - 1];
            int finalc ;
            boolean ok = true;

            while (ok) {
                finalc = 0;
                line = br.readLine();
                if (line == null) {
                    break;
                }
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if (union[x - 2] == 0) {
                        union[x - 2] = 1;
                    }
                    if (oh[x - 2] == 0) {
                        oh[x - 2] = y - 1;
                    }
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if (union[x - 1] == 0) {
                        union[x - 1] = 1;
                    }
                    if (oh[x - 1] == 0) {
                        oh[x - 1] = y - 1;
                    }
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }

                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];

                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i] - j] == 1) {
                                    count++;
                                }
                            }
                            if (count == cross) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                        if (cross < 0) {
                            int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i] + j] == 1) {
                                    count++;
                                }
                            }
                            if (count == (-cross)) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                    }
                }
                for (int i = 0; i < connect.length; i++) {
                    finalc += connect[i];
                }
                if (finalc == dimention - 1) {
                    ok = false;
                }
            }
            if (line != null) {
                System.out.println(line);
            } else {
                System.out.println(""-1"");
            }

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@b73c57c61a11b26f9302f26bc20654c3@"
"b02611026","8","1.13","128928","@b9d38a6918cb2293734b951987268710@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            if (matrix_length == 1) {
                String[] pos1;
                pos1 = br.readLine().split("","");

//                System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");
                if ((pos1[0].equals(""1"")) && (pos1[1].equals(""1""))) {
                    state = 2;
//                    System.out.printf(""%d\n"", matrix_length);
//                    System.out.printf(""%d\n"", state);
                    System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");

                } else {
                    state = -1;
//                    System.out.printf(""%d"", matrix_length);
                    System.out.printf(""%d"", state);

                }
            } else if (matrix_length <= 0) {
                state = -1;
                System.out.printf(""%d"", state);
            } else {
                //Union the upper row
                for (int i = 0; i < matrix_length; i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == matrix_length) {
                        break;
                    }
                }
                //Union the downner row
                for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == (matrix_size - 1)) {
                        break;
                    }
                }
                //Create a matrx in order to mark the cell
                String[][] markmatrix = new String[matrix_length][matrix_length];
                for (int i = 0; i < matrix_length; i++) {
                    for (int j = 0; j < matrix_length; j++) {
                        markmatrix[i][j] = ""0"";
                    }
                }

                String[] pos;
                while (br.ready()) {
                    pos = br.readLine().split("","");
                    if (pos == null) {
                        break;
                    }

//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");
                    //mark the opened position
                    int x = Integer.parseInt(pos[0]) - 1;
                    int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");
                    markmatrix[x][y] = ""1"";
                    int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");

                    if (x != 0 && y != 0 && x != (matrix_length - 1) && y != (matrix_length - 1)) {
                        //if up is opened
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""v\n"");
                        }
                        //if down is opened
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""w\n"");
                        }
                        //if left is opened
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""x\n"");
                        }
                        //if right is opened
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""y\n"");
                        }
                    } else if (x == 0 && y == 0) { // 左上角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""a\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""b\n"");
                        }

                    } else if (x == 0 && y == (matrix_length - 1)) { //右上角
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""c\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""d\n"");
                        }
                    } else if (y == 0 && x == (matrix_length - 1)) { //左下角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""e\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""f\n"");
                        }
                    } else if (x == matrix_length - 1 && y == (matrix_length - 1)) { //右下角
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""g\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""h\n"");
                        }
                    } else if (y == 0) { //最左排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""i\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""j\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""k\n"");
                        }
                    } else if (x == 0) { //最上排
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""m\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""n\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""o\n"");
                        }
                    } else if (y == (matrix_length - 1)) { //最右排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            // System.out.printf(""p\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""q\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""r\n"");
                        }
                    } else if (x == (matrix_length - 1)) { //最下排
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""s\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""t\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""u\n"");
                        }
                    }

                    if (uf.connected(0, matrix_size - 1)) {
                        state = 0;
                        System.out.printf(pos[0] + "","" + pos[1]);
                        //System.out.printf(""\n"");
                        break;
                    } else {
                        state = -1;
                    }

                }
                if (state == -1) {
                    System.out.printf(""%d"", state);
                }
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@b9d38a6918cb2293734b951987268710@"
"r04631027","9","1.18","157824","@053a81052a9b7e092d5a096c19aed4d1@

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention = Integer.parseInt(line);
            short[][] metrix;
            metrix = new short[dimention][dimention];
            short[][] ver;
            ver = new short[dimention - 1][dimention];
            short[][] hor;
            hor = new short[dimention][dimention - 1];
            short[] union;
            union = new short[dimention - 1];
            int[] oh;
            oh = new int[dimention - 1];
            short[] connect;
            connect = new short[dimention - 1];
            short finalc ;
            boolean ok = true;

            while (ok) {
                finalc = 0;
                line = br.readLine();
                if (line == null) {
                    break;
                }
                String[] buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 1;
                //垂直向上
                if (x != 1 && metrix[x - 2][y - 1] > 0) {
                    ver[x - 2][y - 1] = 1;
                    if (union[x - 2] == 0) {
                        union[x - 2] = 1;
                    }
                    if (oh[x - 2] == 0) {
                        oh[x - 2] = y - 1;
                    }
                }
                //垂直向下
                if (x != dimention && metrix[x][y - 1] > 0) {
                    ver[x - 1][y - 1] = 1;
                    if (union[x - 1] == 0) {
                        union[x - 1] = 1;
                    }
                    if (oh[x - 1] == 0) {
                        oh[x - 1] = y - 1;
                    }
                }
                //left
                if (y != 1 && metrix[x - 1][y - 2] > 0) {
                    hor[x - 1][y - 2] = 1;
                }
                //right
                if (y != dimention && metrix[x - 1][y] > 0) {
                    hor[x - 1][y - 1] = 1;
                }

                for (int i = 0; i < (union.length) - 1; i++) {
                    if (union[i] == union[i + 1]) {
                        int cross = oh[i] - oh[i + 1];

                        if (cross > 0) {
                            int count = 0;
                            for (int j = cross; j > 0; j--) {
                                if (hor[i + 1][oh[i] - j] == 1) {
                                    count++;
                                }
                            }
                            if (count == cross) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                        if (cross < 0) {
                            int count = 0;
                            for (int j = 0; j < -cross; j++) {
                                if (hor[i + 1][oh[i] + j] == 1) {
                                    count++;
                                }
                            }
                            if (count == (-cross)) {
                                connect[i] = 1;
                                if (i + 1 == (union.length) - 1) {
                                    connect[i + 1] = 1;
                                }
                            }
                        }
                    }
                }
                for (int i = 0; i < connect.length; i++) {
                    finalc += connect[i];
                }
                if (finalc == dimention - 1) {
                    ok = false;
                }
            }
            if (line != null) {
                System.out.println(line);
            } else {
                System.out.println(""-1"");
            }

        } catch (IOException e) {
            System.out.println(e);
        }
    }

}

@053a81052a9b7e092d5a096c19aed4d1@"
"b02611026","5","0.99","107648","@1958dd618b59a76303b728efa4fdf29c@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            if (matrix_length == 1) {
                String[] pos1;
                pos1 = br.readLine().split("","");

//                System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");
                if ((pos1[0].equals(""1"")) && (pos1[1].equals(""1""))) {
                    state = 2;
//                    System.out.printf(""%d\n"", matrix_length);
//                    System.out.printf(""%d\n"", state);
                    System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");

                } else {
                    state = -1;
//                    System.out.printf(""%d"", matrix_length);
                    System.out.printf(""%d"", state);

                }
            } else if (matrix_length <= 0) {
                state = -1;
                System.out.printf(""%d"", state);
            } else {
                //Union the upper row
                for (int i = 0; i < matrix_length; i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == matrix_length) {
                        break;
                    }
                }
                //Union the downner row
                for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == (matrix_size - 1)) {
                        break;
                    }
                }
                //Create a matrx in order to mark the cell
                String[][] markmatrix = new String[matrix_length][matrix_length];
                for (int i = 0; i < matrix_length; i++) {
                    for (int j = 0; j < matrix_length; j++) {
                        markmatrix[i][j] = ""0"";
                    }
                }

                String[] pos;
                while (br.ready()) {
                    pos = br.readLine().split("","");
                    if (pos == null) {
                        break;
                    }

//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");
                    //mark the opened position
                    int x = Integer.parseInt(pos[0]) - 1;
                    int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");
                    markmatrix[x][y] = ""1"";
                    int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");
                    if (x > matrix_length - 1 || y > matrix_length - 1 || x < 1 || y < 1) {
                        state = -1;
                        break;
                    } else if (x != 0 && y != 0 && x != (matrix_length - 1) && y != (matrix_length - 1)) {
                        //if up is opened
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""v\n"");
                        }
                        //if down is opened
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""w\n"");
                        }
                        //if left is opened
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""x\n"");
                        }
                        //if right is opened
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""y\n"");
                        }
                    } else if (x == 0 && y == 0) { // 左上角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""a\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""b\n"");
                        }

                    } else if (x == 0 && y == (matrix_length - 1)) { //右上角
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""c\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""d\n"");
                        }
                    } else if (y == 0 && x == (matrix_length - 1)) { //左下角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""e\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""f\n"");
                        }
                    } else if (x == matrix_length - 1 && y == (matrix_length - 1)) { //右下角
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""g\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""h\n"");
                        }
                    } else if (y == 0) { //最左排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""i\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""j\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""k\n"");
                        }
                    } else if (x == 0) { //最上排
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""m\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""n\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""o\n"");
                        }
                    } else if (y == (matrix_length - 1)) { //最右排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            // System.out.printf(""p\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""q\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""r\n"");
                        }
                    } else if (x == (matrix_length - 1)) { //最下排
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""s\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""t\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""u\n"");
                        }
                    }

                    if (uf.connected(0, matrix_size - 1)) {
                        state = 0;
                        System.out.printf(pos[0] + "","" + pos[1]);
                        //System.out.printf(""\n"");
                        break;
                    } else {
                        state = -1;
                    }

                }
                if (state == -1) {
                    System.out.printf(""%d"", state);
                }
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@1958dd618b59a76303b728efa4fdf29c@"
"b02611026","8","1.1","128400","@a3b8bae2ed6094e175f2d3fc5b0fd843@
import java.io.IOException;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.StringReader;
import java.io.*;

/**
 *
 * @author asus
 */
public class Percolation {

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            int state = 0;
            int matrix_length = Integer.parseInt(br.readLine());
            int matrix_size = matrix_length * matrix_length;
            QuickFindUF uf = new QuickFindUF(matrix_size);

            if (matrix_length == 1) {
                String[] pos1;
                pos1 = br.readLine().split("","");

//                System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");
                if ((pos1[0].equals(""1"")) && (pos1[1].equals(""1""))) {
                    state = 2;
//                    System.out.printf(""%d\n"", matrix_length);
//                    System.out.printf(""%d\n"", state);
                    System.out.printf(pos1[0] + "" , "" + pos1[1] + ""\n"");

                } else {
                    state = -1;
//                    System.out.printf(""%d"", matrix_length);
                    System.out.printf(""%d"", state);

                }
            } else if (matrix_length <= 0) {
                state = -1;
                System.out.printf(""%d"", state);
            } else {
                //Union the upper row
                for (int i = 0; i < matrix_length; i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == matrix_length) {
                        break;
                    }
                }
                //Union the downner row
                for (int i = (matrix_size - matrix_length); i < (matrix_size); i++) {
                    uf.union(i, i + 1);
                    if ((i + 1) == (matrix_size - 1)) {
                        break;
                    }
                }
                //Create a matrx in order to mark the cell
                String[][] markmatrix = new String[matrix_length][matrix_length];
                for (int i = 0; i < matrix_length; i++) {
                    for (int j = 0; j < matrix_length; j++) {
                        markmatrix[i][j] = ""0"";
                    }
                }

                String[] pos;
                while (br.ready()) {
                    pos = br.readLine().split("","");
                    if (pos == null) {
                        break;
                    }

//                System.out.printf(""position："" + pos[0]);
//                System.out.printf("" "");
//                System.out.printf(pos[1]);
//                System.out.printf(""\n"");
                    //mark the opened position
                    int x = Integer.parseInt(pos[0]) - 1;
                    int y = Integer.parseInt(pos[1]) - 1;

//                System.out.printf(""x : "" + ""%d  "", x);
//                System.out.printf("" "");
//                System.out.printf(""y : "" + ""%d"", y);
//                System.out.printf(""\n"");
                    markmatrix[x][y] = ""1"";
                    int num = x * matrix_length + y;
//                System.out.printf(""num = "" + ""%d   "", num);
//                System.out.printf(""\n"");
                    if (x > matrix_length - 1 || y > matrix_length - 1 || x < 0 || y < 0) {
                        state = -1;
                        break;
                    } else if (x != 0 && y != 0 && x != (matrix_length - 1) && y != (matrix_length - 1)) {
                        //if up is opened
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""v\n"");
                        }
                        //if down is opened
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""w\n"");
                        }
                        //if left is opened
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""x\n"");
                        }
                        //if right is opened
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""y\n"");
                        }
                    } else if (x == 0 && y == 0) { // 左上角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""a\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""b\n"");
                        }

                    } else if (x == 0 && y == (matrix_length - 1)) { //右上角
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""c\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""d\n"");
                        }
                    } else if (y == 0 && x == (matrix_length - 1)) { //左下角
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""e\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""f\n"");
                        }
                    } else if (x == matrix_length - 1 && y == (matrix_length - 1)) { //右下角
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""g\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""h\n"");
                        }
                    } else if (y == 0) { //最左排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            //System.out.printf(""i\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""j\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""k\n"");
                        }
                    } else if (x == 0) { //最上排
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num + matrix_length, num);
                            //System.out.printf(""m\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""n\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""o\n"");
                        }
                    } else if (y == (matrix_length - 1)) { //最右排
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num, num - matrix_length);
                            // System.out.printf(""p\n"");
                        }
                        if (markmatrix[x + 1][y].equals(""1"")) {
                            uf.union(num, num + matrix_length);
                            //System.out.printf(""q\n"");
                        }
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""r\n"");
                        }
                    } else if (x == (matrix_length - 1)) { //最下排
                        if (markmatrix[x][y - 1].equals(""1"")) {
                            uf.union(num, num - 1);
                            //System.out.printf(""s\n"");
                        }
                        if (markmatrix[x][y + 1].equals(""1"")) {
                            uf.union(num, num + 1);
                            //System.out.printf(""t\n"");
                        }
                        if (markmatrix[x - 1][y].equals(""1"")) {
                            uf.union(num - matrix_length, num);
                            //System.out.printf(""u\n"");
                        }
                    }

                    if (uf.connected(0, matrix_size - 1)) {
                        state = 0;
                        System.out.printf(pos[0] + "","" + pos[1]);
                        //System.out.printf(""\n"");
                        break;
                    } else {
                        state = -1;
                    }

                }
                if (state == -1) {
                    System.out.printf(""%d"", state);
                }
            }
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@a3b8bae2ed6094e175f2d3fc5b0fd843@"
"r03525008","0","1.01","126016","@282e411ec71386029143dae54e0ec3ab@package com.example.helloworld;

/**
 * Created by User on 2016/3/10.
 */
public class Percolation {

    public int dimension;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(arg[0]))){
            int dimension=Integer.parseInt(br.readLine());
            Percolation percolation=new Percolation(dimension);


            String line;
            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                percolation.open_point(x,y);
                if(percolation.isConnect()) {
                    System.out.println(data[0] + "","" + data[1]);
                    break;
                }

                //System.out.println(data[0]+"",""+data[1]);
            }
/*            for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public Percolation(int dimension){
        this.dimension=dimension;
        this.nodes=new Node[dimension][dimension];
        topnode=new Node(0,0,true,1);
        buttonnode=new Node(dimension+1,dimension+1,true,1);
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
    }

    public void open_point(int x,int y){


        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        nodes[x][y]=new Node(x+1,y+1,true,1);


        if(!(y>=dimension-1)){
            if(nodes[x][y+1]!=null){
                this.Union(nodes[x][y],nodes[x][y+1]);
            }
        }
        else{

                this.Union(nodes[x][y],topnode);

        }
        if(!(y<=0)) {
            if (nodes[x][y - 1]!=null) {
                this.Union(nodes[x][y], nodes[x][y - 1]);
            }
        }
        else{
            this.Union(nodes[x][y],buttonnode);
        }
        if(!(x<=0)) {
            if (nodes[x - 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x-1][y]);
            }
        }
        if(!(x>=dimension-1)) {
            if (nodes[x + 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x+1][y]);
            }
        }

    }
    public boolean isConnect(){
/*
        for(int i=0;i<dimension;i++){
            if(nodes[i][0]!=null){
                Union(topnode,nodes[i][0]);

            }
        }
        for(int i=0;i<dimension;i++){
            if(nodes[i][dimension-1]!=null){
                Union(buttonnode,nodes[i][dimension-1]);

            }
        }*/

        if(topnode.root()==buttonnode.root())
            return true;

        else
            return false;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;


        public Node(int x,int y,boolean open,int numberOfnode){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode));
        }

    }


}

@282e411ec71386029143dae54e0ec3ab@"
"r03525008","0","1.23","159008","@04dd762f83c8fb12d0f0486c7b49051b@
import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/10.
 */
public class Percolation {

    public int dimension;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(arg[0]))){
            int dimension=Integer.parseInt(br.readLine());
            Percolation percolation=new Percolation(dimension);


            String line;
            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                percolation.open_point(x,y);
                if(percolation.isConnect()) {
                    System.out.println(data[0] + "","" + data[1]);
                    break;
                }

                //System.out.println(data[0]+"",""+data[1]);
            }
/*            for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public Percolation(int dimension){
        this.dimension=dimension;
        this.nodes=new Node[dimension][dimension];
        topnode=new Node(0,0,true,1);
        buttonnode=new Node(dimension+1,dimension+1,true,1);
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
    }

    public void open_point(int x,int y){


        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        nodes[x][y]=new Node(x+1,y+1,true,1);


        if(!(y>=dimension-1)){
            if(nodes[x][y+1]!=null){
                this.Union(nodes[x][y],nodes[x][y+1]);
            }
        }
        else{

                this.Union(nodes[x][y],topnode);

        }
        if(!(y<=0)) {
            if (nodes[x][y - 1]!=null) {
                this.Union(nodes[x][y], nodes[x][y - 1]);
            }
        }
        else{
            this.Union(nodes[x][y],buttonnode);
        }
        if(!(x<=0)) {
            if (nodes[x - 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x-1][y]);
            }
        }
        if(!(x>=dimension-1)) {
            if (nodes[x + 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x+1][y]);
            }
        }

    }
    public boolean isConnect(){
/*
        for(int i=0;i<dimension;i++){
            if(nodes[i][0]!=null){
                Union(topnode,nodes[i][0]);

            }
        }
        for(int i=0;i<dimension;i++){
            if(nodes[i][dimension-1]!=null){
                Union(buttonnode,nodes[i][dimension-1]);

            }
        }*/

        if(topnode.root()==buttonnode.root())
            return true;

        else
            return false;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;


        public Node(int x,int y,boolean open,int numberOfnode){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode));
        }

    }


}

@04dd762f83c8fb12d0f0486c7b49051b@"
"r03525008","1","0.96","126976","@a108e89ebc8482e4a6f6089b0ad72164@
import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/10.
 */
public class Percolation {

    public int dimension;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int dimension=Integer.parseInt(br.readLine());
            Percolation percolation=new Percolation(dimension);


            String line;
            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                percolation.open_point(x,y);
                if(percolation.isConnect()) {
                    System.out.println(data[0] + "","" + data[1]);
                    break;
                }

                //System.out.println(data[0]+"",""+data[1]);
            }
/*            for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public Percolation(int dimension){
        this.dimension=dimension;
        this.nodes=new Node[dimension][dimension];
        topnode=new Node(0,0,true,1);
        buttonnode=new Node(dimension+1,dimension+1,true,1);
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
    }

    public void open_point(int x,int y){


        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        nodes[x][y]=new Node(x+1,y+1,true,1);


        if(!(y>=dimension-1)){
            if(nodes[x][y+1]!=null){
                this.Union(nodes[x][y],nodes[x][y+1]);
            }
        }
        else{

                this.Union(nodes[x][y],topnode);

        }
        if(!(y<=0)) {
            if (nodes[x][y - 1]!=null) {
                this.Union(nodes[x][y], nodes[x][y - 1]);
            }
        }
        else{
            this.Union(nodes[x][y],buttonnode);
        }
        if(!(x<=0)) {
            if (nodes[x - 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x-1][y]);
            }
        }
        if(!(x>=dimension-1)) {
            if (nodes[x + 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x+1][y]);
            }
        }

    }
    public boolean isConnect(){
/*
        for(int i=0;i<dimension;i++){
            if(nodes[i][0]!=null){
                Union(topnode,nodes[i][0]);

            }
        }
        for(int i=0;i<dimension;i++){
            if(nodes[i][dimension-1]!=null){
                Union(buttonnode,nodes[i][dimension-1]);

            }
        }*/

        if(topnode.root()==buttonnode.root())
            return true;

        else
            return false;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;


        public Node(int x,int y,boolean open,int numberOfnode){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode));
        }

    }


}

@a108e89ebc8482e4a6f6089b0ad72164@"
"r03525008","4","1.01","125152","@e426668ed08f918c8729ebb6cedd93f3@
import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/10.
 */
public class Percolation {

    public int dimension;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
            int dimension=Integer.parseInt(br.readLine());
            Percolation percolation=new Percolation(dimension);


            String line;
            boolean connect=false;
            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                percolation.open_point(x,y);
                if(percolation.isConnect()) {
                    System.out.println(data[0] + "","" + data[1]);
                    break;
                }

                //System.out.println(data[0]+"",""+data[1]);
            }
            if(!connect)
                System.out.println(-1);

/*            for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public Percolation(int dimension){
        this.dimension=dimension;
        this.nodes=new Node[dimension][dimension];
        topnode=new Node(0,0,true,1);
        buttonnode=new Node(dimension+1,dimension+1,true,1);
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
    }

    public void open_point(int x,int y){


        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        nodes[x][y]=new Node(x+1,y+1,true,1);


        if(!(y>=dimension-1)){
            if(nodes[x][y+1]!=null){
                this.Union(nodes[x][y],nodes[x][y+1]);
            }
        }
        else{

            this.Union(nodes[x][y],topnode);

        }
        if(!(y<=0)) {
            if (nodes[x][y - 1]!=null) {
                this.Union(nodes[x][y], nodes[x][y - 1]);
            }
        }
        else{
            this.Union(nodes[x][y],buttonnode);
        }
        if(!(x<=0)) {
            if (nodes[x - 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x-1][y]);
            }
        }
        if(!(x>=dimension-1)) {
            if (nodes[x + 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x+1][y]);
            }
        }

    }
    public boolean isConnect(){
/*
        for(int i=0;i<dimension;i++){
            if(nodes[i][0]!=null){
                Union(topnode,nodes[i][0]);

            }
        }
        for(int i=0;i<dimension;i++){
            if(nodes[i][dimension-1]!=null){
                Union(buttonnode,nodes[i][dimension-1]);

            }
        }*/

        if(topnode.root()==buttonnode.root())
            return true;

        else
            return false;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;


        public Node(int x,int y,boolean open,int numberOfnode){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode));
        }

    }


}

@e426668ed08f918c8729ebb6cedd93f3@"
"r03525008","0","0","0","@b24ffa3043e3860ce63ef5ba764f604c@
import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/10.
 */
public class Percolation {

    public int dimension;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;

    public static void main(String[] args) throws Exception {
        //try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
            int dimension=Integer.parseInt(br.readLine());
            Percolation percolation=new Percolation(dimension);


            String line;
            boolean connect=false;
            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                percolation.open_point(x,y);
                if(percolation.isConnect()) {
                    connect=true;
                    System.out.println(data[0] + "","" + data[1]);
                    break;
                }

                //System.out.println(data[0]+"",""+data[1]);
            }
            if(!connect)
                System.out.println(-1);

            for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public Percolation(int dimension){
        this.dimension=dimension;
        this.nodes=new Node[dimension][dimension];
        topnode=new Node(0,0,true,1);
        buttonnode=new Node(dimension+1,dimension+1,true,1);
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
    }

    public void open_point(int x,int y){


        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        nodes[x][y]=new Node(x+1,y+1,true,1);


        if(!(y>=dimension-1)){
            if(nodes[x][y+1]!=null){
                this.Union(nodes[x][y],nodes[x][y+1]);
            }
        }
        else{

            this.Union(nodes[x][y],topnode);

        }
        if(!(y<=0)) {
            if (nodes[x][y - 1]!=null) {
                this.Union(nodes[x][y], nodes[x][y - 1]);
            }
        }
        else{
            this.Union(nodes[x][y],buttonnode);
        }
        if(!(x<=0)) {
            if (nodes[x - 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x-1][y]);
            }
        }
        if(!(x>=dimension-1)) {
            if (nodes[x + 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x+1][y]);
            }
        }

    }
    public boolean isConnect(){
/*
        for(int i=0;i<dimension;i++){
            if(nodes[i][0]!=null){
                Union(topnode,nodes[i][0]);

            }
        }
        for(int i=0;i<dimension;i++){
            if(nodes[i][dimension-1]!=null){
                Union(buttonnode,nodes[i][dimension-1]);

            }
        }*/

        if(topnode.root()==buttonnode.root())
            return true;

        else
            return false;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;


        public Node(int x,int y,boolean open,int numberOfnode){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode));
        }

    }


}

@b24ffa3043e3860ce63ef5ba764f604c@"
"r03525008","0","0","0","@48165073a7bad82e026245337085676c@
import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/10.
 */
public class Percolation {

    public int dimension;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;

    public static void main(String[] args) throws Exception {
        //try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
            int dimension=Integer.parseInt(br.readLine());
            Percolation percolation=new Percolation(dimension);


            String line;
            boolean connect=false;
            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                percolation.open_point(x,y);
                if(percolation.isConnect()) {
                    connect=true;
                    System.out.println(data[0] + "","" + data[1]);
                    break;
                }

                //System.out.println(data[0]+"",""+data[1]);
            }
            if(!connect)
                System.out.println(-1);

          /*  for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public Percolation(int dimension){
        this.dimension=dimension;
        this.nodes=new Node[dimension][dimension];
        topnode=new Node(0,0,true,1);
        buttonnode=new Node(dimension+1,dimension+1,true,1);
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
    }

    public void open_point(int x,int y){


        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        nodes[x][y]=new Node(x+1,y+1,true,1);


        if(!(y>=dimension-1)){
            if(nodes[x][y+1]!=null){
                this.Union(nodes[x][y],nodes[x][y+1]);
            }
        }
        else{

            this.Union(nodes[x][y],topnode);

        }
        if(!(y<=0)) {
            if (nodes[x][y - 1]!=null) {
                this.Union(nodes[x][y], nodes[x][y - 1]);
            }
        }
        else{
            this.Union(nodes[x][y],buttonnode);
        }
        if(!(x<=0)) {
            if (nodes[x - 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x-1][y]);
            }
        }
        if(!(x>=dimension-1)) {
            if (nodes[x + 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x+1][y]);
            }
        }

    }
    public boolean isConnect(){
/*
        for(int i=0;i<dimension;i++){
            if(nodes[i][0]!=null){
                Union(topnode,nodes[i][0]);

            }
        }
        for(int i=0;i<dimension;i++){
            if(nodes[i][dimension-1]!=null){
                Union(buttonnode,nodes[i][dimension-1]);

            }
        }*/

        if(topnode.root()==buttonnode.root())
            return true;

        else
            return false;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;


        public Node(int x,int y,boolean open,int numberOfnode){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode));
        }

    }


}

@48165073a7bad82e026245337085676c@"
"r03525008","5","1","126320","@5dd34210ba675cd3ce8ea532c3a68378@
import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/10.
 */
public class Percolation {

    public int dimension;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
            int dimension=Integer.parseInt(br.readLine());
            Percolation percolation=new Percolation(dimension);


            String line;
            boolean connect=false;
            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                percolation.open_point(x,y);
                if(percolation.isConnect()) {
                    connect=true;
                    System.out.println(data[0] + "","" + data[1]);
                    break;
                }

                //System.out.println(data[0]+"",""+data[1]);
            }
            if(!connect)
                System.out.println(-1);

          /*  for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public Percolation(int dimension){
        this.dimension=dimension;
        this.nodes=new Node[dimension][dimension];
        topnode=new Node(0,0,true,1);
        buttonnode=new Node(dimension+1,dimension+1,true,1);
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
    }

    public void open_point(int x,int y){


        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        nodes[x][y]=new Node(x+1,y+1,true,1);


        if(!(y>=dimension-1)){
            if(nodes[x][y+1]!=null){
                this.Union(nodes[x][y],nodes[x][y+1]);
            }
        }
        else{

            this.Union(nodes[x][y],topnode);

        }
        if(!(y<=0)) {
            if (nodes[x][y - 1]!=null) {
                this.Union(nodes[x][y], nodes[x][y - 1]);
            }
        }
        else{
            this.Union(nodes[x][y],buttonnode);
        }
        if(!(x<=0)) {
            if (nodes[x - 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x-1][y]);
            }
        }
        if(!(x>=dimension-1)) {
            if (nodes[x + 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x+1][y]);
            }
        }

    }
    public boolean isConnect(){
/*
        for(int i=0;i<dimension;i++){
            if(nodes[i][0]!=null){
                Union(topnode,nodes[i][0]);

            }
        }
        for(int i=0;i<dimension;i++){
            if(nodes[i][dimension-1]!=null){
                Union(buttonnode,nodes[i][dimension-1]);

            }
        }*/

        if(topnode.root()==buttonnode.root())
            return true;

        else
            return false;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;


        public Node(int x,int y,boolean open,int numberOfnode){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode));
        }

    }


}

@5dd34210ba675cd3ce8ea532c3a68378@"
"b03611033","9","2.59","132128","@b9272b81b0a4a2dc835249a50b613cbe@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {    
   public boolean[] matrix;
   public int[] self;
   public static int count=0;
   public int counted;
    public Percolation(int n){
        matrix = new boolean[n*n];
        self = new int[n*n];
        for(int i=0;i<n;i++){
            self[i]=0;
        }
        for(int i=n;i<n*n;i++){
            self[i]=i;
        }
    }
    public void open(int n,int p,int q){
       matrix[p*n+q] = true;
        count++;
        counted=count;
        line(n,p,q);
        if(counted==1)return;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(matrix[i*n+j]){
                    line(n,i,j);
                    counted--;
                }
                if(counted==0){
                    return;
                }
            }
        }
    }
    
    public void line(int n,int p,int q){
         if(q>0){
            if(matrix[p*n+q] & matrix[p*n+(q-1)]){
                root(p*n+q,p*n+(q-1));
            }
        }
        if(p>0){
            if(matrix[p*n+q] & matrix[(p-1)*n+q]){
                root(p*n+q,(p-1)*n+q);
            }
        }
        if(p<n-1){
            if(matrix[p*n+q] & matrix[(p+1)*n+q]){
                root((p+1)*n+q,p*n+q);
            }
        }
        
        if(q<n-1){
            if(matrix[p*n+q] & matrix[p*n+(q+1)]){
                root(p*n+(q+1),p*n+q);
            }
        }
    }
    public void root(int m,int n){
        if(self[m]<self[n]){
            self[n]=self[m];
        }
        else{
            self[m]=self[n];
        }
    }
    
    
    public boolean percolates(int n){
        for(int i=(n-1)*n;i<n*n;i++){
            if(self[i]==0){
                return true;
            }
        }
        return false;
        
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String data = br.readLine();
                int N = Integer.parseInt(data);
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    percolation.open(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
            }
        }        
    }


@b9272b81b0a4a2dc835249a50b613cbe@"
"r03525008","10","0.098","122704","@a79a0c901b8b325fce4a54ed49bd10ca@
import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/10.
 */
public class Percolation {

    public int dimension;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
            int dimension=Integer.parseInt(br.readLine());
            Percolation percolation=new Percolation(dimension);


            String line;
            boolean connect=false;
            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                percolation.open_point(x,y);
                if(percolation.isConnect()) {
                    connect=true;
                    System.out.println(data[0] + "","" + data[1]);
                    break;
                }

                //System.out.println(data[0]+"",""+data[1]);
            }
            if(!connect)
                System.out.println(-1);

          /*  for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public Percolation(int dimension){
        this.dimension=dimension;
        this.nodes=new Node[dimension][dimension];
        topnode=new Node(0,0,true,1);
        buttonnode=new Node(dimension+1,dimension+1,true,1);
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
    }

    public void open_point(int x,int y){


        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        nodes[x][y]=new Node(x+1,y+1,true,1);


        if(!(y>=dimension-1)){
            if(nodes[x][y+1]!=null){
                this.Union(nodes[x][y],nodes[x][y+1]);
            }
        }

        if(!(y<=0)) {
            if (nodes[x][y - 1]!=null) {
                this.Union(nodes[x][y], nodes[x][y - 1]);
            }
        }

        if(!(x<=0)) {
            if (nodes[x - 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x-1][y]);
            }
        }
        else{

            this.Union(nodes[x][y],topnode);

        }
        if(!(x>=dimension-1)) {
            if (nodes[x + 1][y]!=null) {
                this.Union(nodes[x][y], nodes[x+1][y]);
            }
        }
        else{
            this.Union(nodes[x][y],buttonnode);
        }

    }
    public boolean isConnect(){
/*
        for(int i=0;i<dimension;i++){
            if(nodes[i][0]!=null){
                Union(topnode,nodes[i][0]);

            }
        }
        for(int i=0;i<dimension;i++){
            if(nodes[i][dimension-1]!=null){
                Union(buttonnode,nodes[i][dimension-1]);

            }
        }*/

        if(topnode.root()==buttonnode.root())
            return true;

        else
            return false;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;


        public Node(int x,int y,boolean open,int numberOfnode){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode));
        }

    }


}

@a79a0c901b8b325fce4a54ed49bd10ca@"
"b03611033","9","2.58","138896","@e19bb61fb7e0d6c8c17d09eb82e703b9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {    
   //public boolean[] matrix;
   public int[] self;
   public static int count=0;
   public int counted;
    public Percolation(int n){
        self = new int[n*n];
        for(int i=0;i<n;i++){
            self[i]=-2;
        }
        for(int i=n;i<n*n;i++){
            self[i]=-1;
        }
    }
    public void open(int n,int p,int q){
        if(self[p*n+q]==-2){
            self[p*n+q]=0;
        }
        else{
            self[p*n+q]=p*n+q;
        }
        count++;
        counted=count;
        if(counted==1)return;
        line(n,p,q);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(self[i*n+j]>=0){
                    line(n,i,j);
                    counted--;
                }
                if(counted==0){
                    return;
                }
            }
        }
    }
    
    public void line(int n,int p,int q){
         if(q>0){
            if(self[p*n+q]>=0 & self[p*n+(q-1)]>=0 & self[p*n+q]!=self[p*n+(q-1)]){
                root(p*n+q,p*n+(q-1));
            }
        }
        if(p>0){
            if(self[p*n+q]>=0 & self[(p-1)*n+q]>=0 & self[p*n+q]!=self[(p-1)*n+q]){
                root(p*n+q,(p-1)*n+q);
            }
        }
        if(p<n-1){
            if(self[p*n+q]>=0 & self[(p+1)*n+q]>=0 & self[p*n+q]!=self[(p+1)*n+q]){
                root((p+1)*n+q,p*n+q);
            }
        }
        
        if(q<n-1){
            if(self[p*n+q]>=0 & self[p*n+(q+1)]>=0 & self[p*n+q]!=self[p*n+(q+1)]){
                root(p*n+(q+1),p*n+q);
            }
        }
    }
    public void root(int m,int n){
        if(self[m]<self[n]){
            self[n]=self[m];
        }
        else{
            self[m]=self[n];
        }
    }
    
    
    public boolean percolates(int n){
        for(int i=(n-1)*n;i<n*n;i++){
            if(self[i]==0){
                return true;
            }
        }
        return false;
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String data = br.readLine();
                int N = Integer.parseInt(data);
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    percolation.open(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
            }
        }        
    }


@e19bb61fb7e0d6c8c17d09eb82e703b9@"
"b03611033","9","2.68","131104","@a76ffe1dd5ff9c549ef12aac318e2005@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {    
   //public boolean[] matrix;
   public int[] self;
   public static int count=0;
   public int counted;
    public Percolation(int n){
        self = new int[n*n];
        for(int i=0;i<n;i++){
            self[i]=-2;
        }
        for(int i=n;i<n*n;i++){
            self[i]=-1;
        }
    }
    public void open(int n,int p,int q){
        if(self[p*n+q]==-2){
            self[p*n+q]=0;
        }
        else if(self[p*n+q]==-1){
            self[p*n+q]=p*n+q;
        }
        else{}
        count++;
        counted=count;
        if(counted==1)return;
        line(n,p,q);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(self[i*n+j]>=0){
                    line(n,i,j);
                    counted--;
                }
                if(counted==0){
                    return;
                }
            }
        }
    }
    
    public void line(int n,int p,int q){
         if(q>0){
            if(self[p*n+q]>=0 & self[p*n+(q-1)]>=0 & self[p*n+q]!=self[p*n+(q-1)]){
                root(p*n+q,p*n+(q-1));
            }
        }
        if(p>0){
            if(self[p*n+q]>=0 & self[(p-1)*n+q]>=0 & self[p*n+q]!=self[(p-1)*n+q]){
                root(p*n+q,(p-1)*n+q);
            }
        }
        if(p<n-1){
            if(self[p*n+q]>=0 & self[(p+1)*n+q]>=0 & self[p*n+q]!=self[(p+1)*n+q]){
                root((p+1)*n+q,p*n+q);
            }
        }
        
        if(q<n-1){
            if(self[p*n+q]>=0 & self[p*n+(q+1)]>=0 & self[p*n+q]!=self[p*n+(q+1)]){
                root(p*n+(q+1),p*n+q);
            }
        }
    }
    public void root(int m,int n){
        if(self[m]<self[n]){
            self[n]=self[m];
        }
        else{
            self[m]=self[n];
        }
    }
    
    
    public boolean percolates(int n){
        for(int i=(n-1)*n;i<n*n;i++){
            if(self[i]==0){
                return true;
            }
        }
        return false;
    }

        
    public static void main(String[] args) throws Exception {
            // read file from args[0] in Java 7 style
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
                String data = br.readLine();
                int N = Integer.parseInt(data);
                Percolation percolation = new Percolation(N);
                
                int row;
                int column;
                String datacut[];
                while((data = br.readLine()) != null){
                    datacut = data.split("","");
                    row = Integer.parseInt(datacut[0]);
                    column = Integer.parseInt(datacut[1]);
                    percolation.open(N,row-1,column-1);
                    if(percolation.percolates(N)){
                        StdOut.println(row+"",""+column);
                        break;
                    }
                }
                if(data == null){
                   StdOut.println(""-1"");
                }
            }
        }        
    }


@a76ffe1dd5ff9c549ef12aac318e2005@"
"b02611002","5","0.51","127408","@0d3771ac9cd546d82492516a099ae56b@import java.io.FileReader;
import java.io.BufferedReader;

/**
 * Created by zhouyuda on 3/6/16.
 */

public class Percolation {



    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String[] data = br.readLine().split("","");

            int dim = Integer.parseInt(data[0]);
            int matrixSize = dim*dim;
            boolean[] opened = new boolean[matrixSize+1];
            int stop =0;

//            System.out.printf(""dimension of matrix: %d x %d\n"", dim, dim);

            WeightedQuickUnionUF ROCK = new WeightedQuickUnionUF(matrixSize+2);
//            System.out.printf(""a.count(): %d\n"", (ROCK.count()));

            // 連結0,1
            ROCK.union(0,1);
//            System.out.printf(""connected? %s\n"", Boolean.toString(ROCK.connected(0,1)));

            // 連結與 0 與上排 ; 連結與 (matrixSize+1) 與下排
            for(int i=1; i<=dim; i++){
//                System.out.println(i);
                ROCK.union(0,i);
//                System.out.println(matrixSize-i+1);
                ROCK.union(matrixSize+1,matrixSize-i+1);
            }

            // 開始一行行讀座標
            while(br!= null) {
                String[] currentCoordinate = br.readLine().split("","");
                int currentBoxID = Integer.parseInt(currentCoordinate[1])+dim*((Integer.parseInt(currentCoordinate[0]))-1);
//                System.out.printf(""currentLine:[%s,%s]; currentBoxID:%d\n"",currentCoordinate[0],currentCoordinate[1],currentBoxID);

                opened[currentBoxID]=true;

                //開始用currentBoxID來union
                if (currentBoxID-dim>=1){
                    if (opened[currentBoxID-dim]){
                        ROCK.union(currentBoxID,currentBoxID-dim);
//                        System.out.print(""上"");
                    }
                }

                if (currentBoxID+dim <= matrixSize){
                   if (opened[currentBoxID+dim]) {
                       ROCK.union(currentBoxID, currentBoxID + dim);
//                       System.out.print(""下"");
                   }
                }

                if (currentBoxID%dim!=0){
                    if (opened[currentBoxID+1]) {
                        ROCK.union(currentBoxID, currentBoxID + 1);
//                        System.out.print(""右"");
                    }
                }

                if (currentBoxID%dim!=1){
                    if (opened[currentBoxID-1]) {
                        ROCK.union(currentBoxID, currentBoxID-1);
//                        System.out.print(""左"");
                    }
                }

                //每次union完都用find檢查是否已滲透
//                System.out.printf(""Percolated? %s\n"", Boolean.toString(ROCK.connected(0,matrixSize+1)));
                if(ROCK.connected(0,matrixSize+1)){
                    System.out.printf(""%s,%s"", currentCoordinate[0],currentCoordinate[1]);
                    break;
                }
            }


          /*String[] ex = new String[1];
           ex[0] = ""input.txt"";
           Bingo.main(ex);*/
        }
    }





}

@0d3771ac9cd546d82492516a099ae56b@"
"b02611002","5","0.51","122928","@0d3771ac9cd546d82492516a099ae56b@import java.io.FileReader;
import java.io.BufferedReader;

/**
 * Created by zhouyuda on 3/6/16.
 */

public class Percolation {



    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String[] data = br.readLine().split("","");

            int dim = Integer.parseInt(data[0]);
            int matrixSize = dim*dim;
            boolean[] opened = new boolean[matrixSize+1];
            int stop =0;

//            System.out.printf(""dimension of matrix: %d x %d\n"", dim, dim);

            WeightedQuickUnionUF ROCK = new WeightedQuickUnionUF(matrixSize+2);
//            System.out.printf(""a.count(): %d\n"", (ROCK.count()));

            // 連結0,1
            ROCK.union(0,1);
//            System.out.printf(""connected? %s\n"", Boolean.toString(ROCK.connected(0,1)));

            // 連結與 0 與上排 ; 連結與 (matrixSize+1) 與下排
            for(int i=1; i<=dim; i++){
//                System.out.println(i);
                ROCK.union(0,i);
//                System.out.println(matrixSize-i+1);
                ROCK.union(matrixSize+1,matrixSize-i+1);
            }

            // 開始一行行讀座標
            while(br!= null) {
                String[] currentCoordinate = br.readLine().split("","");
                int currentBoxID = Integer.parseInt(currentCoordinate[1])+dim*((Integer.parseInt(currentCoordinate[0]))-1);
//                System.out.printf(""currentLine:[%s,%s]; currentBoxID:%d\n"",currentCoordinate[0],currentCoordinate[1],currentBoxID);

                opened[currentBoxID]=true;

                //開始用currentBoxID來union
                if (currentBoxID-dim>=1){
                    if (opened[currentBoxID-dim]){
                        ROCK.union(currentBoxID,currentBoxID-dim);
//                        System.out.print(""上"");
                    }
                }

                if (currentBoxID+dim <= matrixSize){
                   if (opened[currentBoxID+dim]) {
                       ROCK.union(currentBoxID, currentBoxID + dim);
//                       System.out.print(""下"");
                   }
                }

                if (currentBoxID%dim!=0){
                    if (opened[currentBoxID+1]) {
                        ROCK.union(currentBoxID, currentBoxID + 1);
//                        System.out.print(""右"");
                    }
                }

                if (currentBoxID%dim!=1){
                    if (opened[currentBoxID-1]) {
                        ROCK.union(currentBoxID, currentBoxID-1);
//                        System.out.print(""左"");
                    }
                }

                //每次union完都用find檢查是否已滲透
//                System.out.printf(""Percolated? %s\n"", Boolean.toString(ROCK.connected(0,matrixSize+1)));
                if(ROCK.connected(0,matrixSize+1)){
                    System.out.printf(""%s,%s"", currentCoordinate[0],currentCoordinate[1]);
                    break;
                }
            }


          /*String[] ex = new String[1];
           ex[0] = ""input.txt"";
           Bingo.main(ex);*/
        }
    }





}

@0d3771ac9cd546d82492516a099ae56b@"
"b02611002","6","0.86","105536","@4d0c0be59641f099d2d6da424af40233@import java.io.FileReader;
import java.io.BufferedReader;

/**
 * Created by zhouyuda on 3/6/16.
 */

public class Percolation {



    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String[] data = br.readLine().split("","");

            int dim = Integer.parseInt(data[0]);
            int matrixSize = dim*dim;
            boolean[] opened = new boolean[matrixSize+1];
            int stop =0;

//            System.out.printf(""dimension of matrix: %d x %d\n"", dim, dim);

            WeightedQuickUnionUF ROCK = new WeightedQuickUnionUF(matrixSize+2);
//            System.out.printf(""a.count(): %d\n"", (ROCK.count()));

            // 連結0,1
            ROCK.union(0,1);
//            System.out.printf(""connected? %s\n"", Boolean.toString(ROCK.connected(0,1)));

            // 連結與 0 與上排 ; 連結與 (matrixSize+1) 與下排
            for(int i=1; i<=dim; i++){
//                System.out.println(i);
                ROCK.union(0,i);
//                System.out.println(matrixSize-i+1);
                ROCK.union(matrixSize+1,matrixSize-i+1);
            }

            // 開始一行行讀座標
            if(br!= null){
                String[] currentCoordinate = br.readLine().split("","");
                int currentBoxID = Integer.parseInt(currentCoordinate[1])+dim*((Integer.parseInt(currentCoordinate[0]))-1);
//                System.out.printf(""currentLine:[%s,%s]; currentBoxID:%d\n"",currentCoordinate[0],currentCoordinate[1],currentBoxID);

                opened[currentBoxID]=true;

                //開始用currentBoxID來union
                if (currentBoxID-dim>=1){
                    if (opened[currentBoxID-dim]){
                        ROCK.union(currentBoxID,currentBoxID-dim);
//                        System.out.print(""上"");
                    }
                }

                if (currentBoxID+dim <= matrixSize){
                   if (opened[currentBoxID+dim]) {
                       ROCK.union(currentBoxID, currentBoxID + dim);
//                       System.out.print(""下"");
                   }
                }

                if (currentBoxID%dim!=0){
                    if (opened[currentBoxID+1]) {
                        ROCK.union(currentBoxID, currentBoxID + 1);
//                        System.out.print(""右"");
                    }
                }

                if (currentBoxID%dim!=1){
                    if (opened[currentBoxID-1]) {
                        ROCK.union(currentBoxID, currentBoxID-1);
//                        System.out.print(""左"");
                    }
                }

                //每次union完都用find檢查是否已滲透
//                System.out.printf(""Percolated? %s\n"", Boolean.toString(ROCK.connected(0,matrixSize+1)));
                if(ROCK.connected(0,matrixSize+1)){
                    System.out.printf(""%s,%s"", currentCoordinate[0],currentCoordinate[1]);
                    stop++;
                }
            }

            if(stop==0){
                System.out.print(-1);
            }

        }
    }





}

@4d0c0be59641f099d2d6da424af40233@"
"r04921074","7","1.06","128512","@5023e546ca5d6d623b85c035aafe5b81@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //initial metrix content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}
@5023e546ca5d6d623b85c035aafe5b81@"
"b02611002","5","0.99","126848","@a012019e0d49a82e608de5c701b29ca3@import java.io.FileReader;
import java.io.BufferedReader;

/**
 * Created by zhouyuda on 3/6/16.
 */

public class Percolation {



    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int dim = Integer.parseInt(data[0]);
            int matrixSize = dim*dim;
            boolean[] opened = new boolean[matrixSize+1];
            int stop =0;

//            System.out.printf(""dimension of matrix: %d x %d\n"", dim, dim);

            WeightedQuickUnionUF ROCK = new WeightedQuickUnionUF(matrixSize+2);
//            System.out.printf(""a.count(): %d\n"", (ROCK.count()));

            // 連結0,1
            ROCK.union(0,1);
//            System.out.printf(""connected? %s\n"", Boolean.toString(ROCK.connected(0,1)));

            // 連結與 0 與上排 ; 連結與 (matrixSize+1) 與下排
            for(int i=1; i<=dim; i++){
//                System.out.println(i);
                ROCK.union(0,i);
//                System.out.println(matrixSize-i+1);
                ROCK.union(matrixSize+1,matrixSize-i+1);
            }

            // 開始一行行讀座標
            while(br.ready()){
                String[] currentCoordinate = br.readLine().split("","");
                int currentBoxID = Integer.parseInt(currentCoordinate[1])+dim*((Integer.parseInt(currentCoordinate[0]))-1);


                opened[currentBoxID]=true;

                //開始用currentBoxID來union
                if (currentBoxID-dim>=1){
                    if (opened[currentBoxID-dim]){
                        ROCK.union(currentBoxID,currentBoxID-dim);
//                        System.out.print(""上"");
                    }
                }

                if (currentBoxID+dim <= matrixSize){
                   if (opened[currentBoxID+dim]) {
                       ROCK.union(currentBoxID, currentBoxID + dim);
//                       System.out.print(""下"");
                   }
                }

                if (currentBoxID%dim!=0){
                    if (opened[currentBoxID+1]) {
                        ROCK.union(currentBoxID, currentBoxID + 1);
//                        System.out.print(""右"");
                    }
                }

                if (currentBoxID%dim!=1){
                    if (opened[currentBoxID-1]) {
                        ROCK.union(currentBoxID, currentBoxID-1);
//                        System.out.print(""左"");
                    }
                }


                //每次union完都用find檢查是否已滲透
//                System.out.printf(""currentLine:[%s,%s]; currentBoxID:%d\n"",currentCoordinate[0],currentCoordinate[1],currentBoxID);
//                System.out.printf(""Percolated? %s\n"", Boolean.toString(ROCK.connected(0,matrixSize+1)));

                if(ROCK.connected(0,matrixSize+1)){
                    System.out.printf(""%s,%s"", currentCoordinate[0],currentCoordinate[1]);

                    break;
                }

            }

                System.out.print(-1);


        }
    }





}

@a012019e0d49a82e608de5c701b29ca3@"
"b02611002","10","0.099","123904","@24ebc7526900de5299c591b62399208a@import java.io.FileReader;
import java.io.BufferedReader;

/**
 * Created by zhouyuda on 3/6/16.
 */

public class Percolation {



    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int dim = Integer.parseInt(data[0]);
            int matrixSize = dim*dim;
            boolean[] opened = new boolean[matrixSize+1];
            int stop =0;

//            System.out.printf(""dimension of matrix: %d x %d\n"", dim, dim);

            WeightedQuickUnionUF ROCK = new WeightedQuickUnionUF(matrixSize+2);
//            System.out.printf(""a.count(): %d\n"", (ROCK.count()));

            // 連結0,1
            ROCK.union(0,1);
//            System.out.printf(""connected? %s\n"", Boolean.toString(ROCK.connected(0,1)));

            // 連結與 0 與上排 ; 連結與 (matrixSize+1) 與下排
            for(int i=1; i<=dim; i++){
//                System.out.println(i);
                ROCK.union(0,i);
//                System.out.println(matrixSize-i+1);
                ROCK.union(matrixSize+1,matrixSize-i+1);
            }

            // 開始一行行讀座標
            while(br.ready()){
                String[] currentCoordinate = br.readLine().split("","");
                int currentBoxID = Integer.parseInt(currentCoordinate[1])+dim*((Integer.parseInt(currentCoordinate[0]))-1);


                opened[currentBoxID]=true;

                //開始用currentBoxID來union
                if (currentBoxID-dim>=1){
                    if (opened[currentBoxID-dim]){
                        ROCK.union(currentBoxID,currentBoxID-dim);
//                        System.out.print(""上"");
                    }
                }

                if (currentBoxID+dim <= matrixSize){
                   if (opened[currentBoxID+dim]) {
                       ROCK.union(currentBoxID, currentBoxID + dim);
//                       System.out.print(""下"");
                   }
                }

                if (currentBoxID%dim!=0){
                    if (opened[currentBoxID+1]) {
                        ROCK.union(currentBoxID, currentBoxID + 1);
//                        System.out.print(""右"");
                    }
                }

                if (currentBoxID%dim!=1){
                    if (opened[currentBoxID-1]) {
                        ROCK.union(currentBoxID, currentBoxID-1);
//                        System.out.print(""左"");
                    }
                }


                //每次union完都用find檢查是否已滲透
//                System.out.printf(""currentLine:[%s,%s]; currentBoxID:%d\n"",currentCoordinate[0],currentCoordinate[1],currentBoxID);
//                System.out.printf(""Percolated? %s\n"", Boolean.toString(ROCK.connected(0,matrixSize+1)));

                if(ROCK.connected(0,matrixSize+1)){
                    System.out.printf(""%s,%s"", currentCoordinate[0],currentCoordinate[1]);
                    stop++;
                    break;
                }

            }
            if(stop==0) {
                System.out.print(-1);
            }
        }
    }





}

@24ebc7526900de5299c591b62399208a@"
"r04921074","7","1.09","126960","@294767407372b0e3db329c614952aa80@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);

             int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int[][] metrix = new int[scale][scale];
            
            //build a metrix with pure value content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
           
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis1[counting]-1], metrix[axis1[counting-i-1]-1][axis1[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}
@294767407372b0e3db329c614952aa80@"
"r04921074","5","1.35","180704","@0d8d28c984a0847a25438274bb531d93@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //build a metrix with pure value content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}
@0d8d28c984a0847a25438274bb531d93@"
"r04921074","0","1.08","127392","@0ded1c952719f5540ea8dfd30a31a8eb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //build a metrix with pure value content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(0,metrix[0][x]);
                 uf.union(scale*scale+1,metrix[scale-1][x]);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
@0ded1c952719f5540ea8dfd30a31a8eb@"
"r03945012","9","1.26","181712","@58a028c3fcd5c6e3a77f6d3f48b7a41d@
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.ArrayList;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Robert
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        InputStream is = null;
        InputStreamReader isr = null;
        BufferedReader br = null;

        try {
            is = new FileInputStream(args[0]);
            isr = new InputStreamReader(is, StandardCharsets.UTF_8);
            br = new BufferedReader(isr);
            
            
            // initialize output = false
            boolean output = false;
            // read file.txt
            Scanner inputdata = new Scanner(br);
            String data = inputdata.nextLine();

            // num is matrix size(num*num)
            // matrix starts from 1
            // label = 00
            int num = Integer.parseInt(data);
            int[][] label = new int[num][num];
            for (int[] row : label) {
                java.util.Arrays.fill(row, 0);
            }
            // what is myList...??
            // myList are input data (x,y)
            ArrayList<String> myList = new ArrayList<String>();
            while(inputdata.hasNextLine()){
                String[] tmp = inputdata.nextLine().split("","");
                    myList.add(tmp[0]);
                    myList.add(tmp[1]);
            }
            // nextLine(point) and totaline
            
            int k = myList.size()/2;
            int count = 0;
            int[][] point = new int[k][2];            
            for (int i=0; i< k; i++){
                point[i][0] = Integer.parseInt((String) myList.get(count)) - 1;
                point[i][1] = Integer.parseInt((String) myList.get(count+1)) - 1;
                count = count+2;
            }
                
            // create class uf (0 to num*num+1)
            // 0 = virtual top
            // num*num+1 = virtual bottom
            UF uf = new UF(num * num + 2);

            // start 1 (using for)
            for (int i = 0; i < point.length; i++) {
                int x = point[i][0];
                int y = point[i][1];
                label[x][y] = 1;
                int index = x * num + y + 1;

                // matrix union
                // union top
                if (x == 0) {
                    uf.union(index, 0);
                    // down
                    if (label[x + 1][y] == 1)
                        uf.union(index, index + num);
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } 
                    else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } 
                    else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                } 
                //union bottom
                else if (x == num - 1) {
                    uf.union(index, num * num + 1);
                    // top
                    if (label[x - 1][y] == 1)
                        uf.union(index, index - num);
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } 
                    else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } 
                    else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                } 
                // union the rest
                else {
                    // union to top one
                    if (label[x - 1][y] == 1)
                        uf.union(index, index - num);
                    // union to down one
                    if (label[x + 1][y] == 1)
                        uf.union(index, index + num);                    
                    if (y == 0) {
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    } 
                    else if (y == num-1) {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                    } 
                    else {
                        if (label[x][y - 1] == 1)
                            uf.union(index, index - 1);
                        if (label[x][y + 1] == 1)
                            uf.union(index, index + 1);
                    }
                }
                output = uf.connected(0, num * num + 1);
                if (output == true) {
                    System.out.print((x+1)+"",""+(y+1));
                    break;
                }
            }
            if (output == false)
                System.out.print(""-1""); 
        } 
        catch (FileNotFoundException | NumberFormatException e) {
        } 
        finally {
            // releases resources associated with the streams
            if (is != null)
                is.close();
            if (isr != null)
                isr.close();
            if (br != null)
                br.close();
        }
    }
}

@58a028c3fcd5c6e3a77f6d3f48b7a41d@"
"r04921074","2","1.62","185872","@d49afe6b0602ec9ce03d7584499a8908@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //build a metrix with pure value content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(0, metrix[x][0]);
                 uf.union(scale*scale+1, metrix[x][scale-1]);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                          System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                          System.out.println(""cc"");
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                                
                           )
                        {
                        uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);                                      
                        System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                        System.out.println(""cc"");
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}
@d49afe6b0602ec9ce03d7584499a8908@"
"r04921074","5","1.42","138672","@03f276751be50d695f6b29c17ba886b0@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);

             int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int[][] metrix = new int[scale][scale];
            
            //build a metrix with pure value content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
      
/********************************************************************************************************************/            
            //union and check part
           
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                           )
                        {
                            
                           uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);                                      
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}
@03f276751be50d695f6b29c17ba886b0@"
"r04631034","9","1.51","177696","@1bc96c17666c519b5da04ef9c912f60e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.*;
import java.util.*;

/**
 *
 * @author user
 */
public class Percolation {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);

          int num = Integer.parseInt(in.readLine());
//          System.out.println(num);
          ArrayList<Integer> Row = new ArrayList<Integer>();
          ArrayList<Integer> Column = new ArrayList<Integer>();

                    UF uf = new UF(num * num + 2);//   num*num+1  top  node   num*num+2 bottom node
          int[][] OpenSiteStorge = new int[num][num];
           
          
          int i =0;
          String line;
          while ((line = in.readLine()) != null) {
               Row.add(Integer.parseInt(line.split("","")[0]) - 1);
               Column.add(Integer.parseInt(line.split("","")[1]) - 1);
//          for (int i = 0; i < Row.size(); i++) {
//               System.out.print(Row.get(i) + "","" + Column.get(i));
//               System.out.println("""");
//          }

          if(num!=1){
                  
          
          
          
//          for (int i = 0; i < Row.size(); i++) 
//          {                       //Row.get(i) * num + Column.get(i) means ID index    /input coornate
                    if(Row.get(i)<num && Column.get(i)<num)
                    {
//               set open site up
               OpenSiteStorge[Row.get(i)][Column.get(i)] = 1;

//               top row connect to the top node
               if (Row.get(i) == 0) 
               {
                    uf.union(Row.get(i) * num + Column.get(i), num * num);
                    if (OpenSiteStorge[Row.get(i) + 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) + 1) * num + Column.get(i));
                    }
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }
           }

//               last row connect to the bottom node
          else if (Row.get (i)   == num - 1)
          {
                    uf.union(Row.get(i) * num + Column.get(i), num * num + 1);
                     if (OpenSiteStorge[Row.get(i) - 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) - 1) * num + Column.get(i));
                         }  
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }      
     }
          else if(Row.get (i)  != num - 1 && Row.get (i)   != 0)//middle row 
            {               
               if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
               else if (Column.get(i) == num-1) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                         } 
               else if (Column.get(i) != num-1 && Column.get(i) != 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
          }
     
     if(uf.connected(num*num, num*num+1) == true)
     {
//          System.out.println(""output:"");
          System.out.println((Row.get(i)+1)+"",""+(Column.get(i)+1));
          break;
     }
  
     }
//}
          }
          else{
          System.out.println((Row.get(0)+1)+"",""+(Column.get(0)+1));
          }
//for(int i = 0 ; i < num;i++){
//                    System.out.println(OpenSiteStorge[i][0]+"" ""+OpenSiteStorge[i][1]+"" ""+OpenSiteStorge[i][2]);
//          }
//          System.out.println(uf.connected(num*num, num*num+1));
//          System.out.println(uf.connected(0, 3));
//          System.out.println(uf.connected(0, num * num));
//          System.out.println(uf.connected(6, num * num + 1));
//          System.out.println(uf.connected(7, num * num + 1));
//          System.out.println(uf.connected(8, num * num + 1));
          i++;
          }
             if(  uf.connected(num*num, num*num+1) == false )
     {           
               System.out.println(""-1"");
     }
     }
}
@1bc96c17666c519b5da04ef9c912f60e@"
"r04631034","10","0.146","170864","@75c8bc7af6c2d4f794b0f07323fadbf1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

//import edu.princeton.cs.algs4.*;
import java.util.*;

/**
 *
 * @author user
 */
public class Percolation {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here

          In in = new In(args[0]);

          int num = Integer.parseInt(in.readLine());
//          System.out.println(num);
          ArrayList<Integer> Row = new ArrayList<Integer>();
          ArrayList<Integer> Column = new ArrayList<Integer>();

                    UF uf = new UF(num * num + 2);//   num*num+1  top  node   num*num+2 bottom node
          int[][] OpenSiteStorge = new int[num][num];
           
          
          int i =0;
          String line;
          while ((line = in.readLine()) != null) {
               Row.add(Integer.parseInt(line.split("","")[0]) - 1);
               Column.add(Integer.parseInt(line.split("","")[1]) - 1);
//          for (int i = 0; i < Row.size(); i++) {
//               System.out.print(Row.get(i) + "","" + Column.get(i));
//               System.out.println("""");
//          }

          if(num!=1){
                  
          
          
          
//          for (int i = 0; i < Row.size(); i++) 
//          {                       //Row.get(i) * num + Column.get(i) means ID index    /input coornate
                    if(Row.get(i)<num && Column.get(i)<num)
                    {
//               set open site up
               OpenSiteStorge[Row.get(i)][Column.get(i)] = 1;

//               top row connect to the top node
               if (Row.get(i) == 0) 
               {
                    uf.union(Row.get(i) * num + Column.get(i), num * num);
                    if (OpenSiteStorge[Row.get(i) + 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) + 1) * num + Column.get(i));
                    }
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }
           }

//               last row connect to the bottom node
          else if (Row.get (i)   == num - 1)
          {
                    uf.union(Row.get(i) * num + Column.get(i), num * num + 1);
                     if (OpenSiteStorge[Row.get(i) - 1][Column.get(i)] == 1) 
                    { //connect to second row  if second row with the same column is open site
                         uf.union(Row.get(i) * num + Column.get(i), (Row.get(i) - 1) * num + Column.get(i));
                         }  
                         if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
                         else if (Column.get(i) == num - 1)
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i) * num + Column.get(i)-1);
                              }
                         } 
                         else 
                         {
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)+1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1)
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)* num + Column.get(i)-1);
                              }                              
                         }      
     }
          else if(Row.get (i)  != num - 1 && Row.get (i)   != 0)//middle row 
            {               
               if (Column.get(i) == 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
               else if (Column.get(i) == num-1) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                         } 
               else if (Column.get(i) != num-1 && Column.get(i) != 0) 
                         {
                              if (OpenSiteStorge[Row.get(i)-1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)-1)  * num + Column.get(i));
                              }
                               if (OpenSiteStorge[Row.get(i)+1][Column.get(i) ] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), (Row.get(i)+1) * num + Column.get(i));
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) - 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)-1);
                              }
                              if (OpenSiteStorge[Row.get(i)][Column.get(i) + 1] == 1) 
                              {
                                   uf.union(Row.get(i) * num + Column.get(i), Row.get(i)  * num + Column.get(i)+1);
                              }
                         } 
          }
     
     if(uf.connected(num*num, num*num+1) == true)
     {
//          System.out.println(""output:"");
          System.out.println((Row.get(i)+1)+"",""+(Column.get(i)+1));
          break;
     }
  
     }
//}
          }
          else{
          System.out.println((Row.get(0)+1)+"",""+(Column.get(0)+1));
          }
//for(int i = 0 ; i < num;i++){
//                    System.out.println(OpenSiteStorge[i][0]+"" ""+OpenSiteStorge[i][1]+"" ""+OpenSiteStorge[i][2]);
//          }
//          System.out.println(uf.connected(num*num, num*num+1));
//          System.out.println(uf.connected(0, 3));
//          System.out.println(uf.connected(0, num * num));
//          System.out.println(uf.connected(6, num * num + 1));
//          System.out.println(uf.connected(7, num * num + 1));
//          System.out.println(uf.connected(8, num * num + 1));
          i++;
          }
             if( num!=1 && uf.connected(num*num, num*num+1) == false )
     {           
               System.out.println(""-1"");
     }
     }
}
@75c8bc7af6c2d4f794b0f07323fadbf1@"
"b99611017","7","1.33","190448","@d8578add4dcad363a8ac644d93c8990d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
//import edu.princeton.cs.algs4.UF;
import java.io.*;
import java.util.Scanner;
import java.io.FileReader;

public class Percolation {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            int size = Integer.parseInt(token[0]); //sieze the matrix size

            int holeNum = token.length - 1;  //Number of holes

            int[] hole = new int[holeNum];

            

            
            for (int i = 0; i < holeNum; i++) //transfer site into flags
            {
                String[] site = token[1 + i].split("","");  //hole[i] are flags

                int row = Integer.parseInt(site[0]);

                int column = Integer.parseInt(site[1]);

                hole[i] = (row - 1) * size + (column - 1);

                //System.out.println(hole[i]);     //hole[i] refers to token[1+i]
            }

            int gridNum = size * size + 2;   // size=3 gridNum=11
            
            int[] brick = new int[gridNum];
            
            for (int i = 0; i < holeNum; i++) {
                brick[i] = 0;
            }
            //flag=9: upper
            //flag=10 : buttom

            UF uf;
            uf = new UF(gridNum);    //flag : 0~10

            for (int i = 0; i < holeNum; i++) {
                
                brick[hole[i]]=1;
                
                if (hole[i] == 0) //left up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] == size - 1) //right up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                } else if (hole[i] == gridNum - 3) //right down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] == gridNum - size - 2) //left down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                } else if (hole[i] / size == 0 && hole[i] != 0 && hole[i] != size - 1) { //upper
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] / size == (size-1) && hole[i] != gridNum - 3 && hole[i] != gridNum - size - 2) {//buttom

                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] % size == 0 && hole[i] != 0 && hole[i] != gridNum - size - 2) {//left side

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] % size == size - 1 && hole[i] != size - 1 && hole[i] != gridNum - 3) {//right side

                    

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } /*else {

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }
                }*/
                if (uf.connected(gridNum - 1, gridNum - 2)) {
                    System.out.println(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    break;
                }

            }
            if (uf.connected(gridNum - 1, gridNum - 2) == false) {
                System.out.println(-1);
            }

        } catch (RuntimeException e) {

            throw e;
        }
        // TODO code application logic here
        /*UF uf=new UF(10);
         uf.union(2, 5);
         uf.union(2, 6);
         System.out.println(uf.count());
         System.out.println(uf.connected(5, 6));*/
    }

}

@d8578add4dcad363a8ac644d93c8990d@"
"b99611017","7","1.21","193248","@644d2be1a6a843ea820a99a85447305d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
//import edu.princeton.cs.algs4.UF;
import java.io.*;
import java.util.Scanner;
import java.io.FileReader;

public class Percolation {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            int size = Integer.parseInt(token[0]); //sieze the matrix size

            int holeNum = token.length - 1;  //Number of holes

            int[] hole = new int[holeNum];

            

            
            for (int i = 0; i < holeNum; i++) //transfer site into flags
            {
                String[] site = token[1 + i].split("","");  //hole[i] are flags

                int row = Integer.parseInt(site[0]);

                int column = Integer.parseInt(site[1]);

                hole[i] = (row - 1) * size + (column - 1);

                //System.out.println(hole[i]);     //hole[i] refers to token[1+i]
            }

            int gridNum = size * size + 2;   // size=3 gridNum=11
            
            int[] brick = new int[gridNum-2];
            
            for (int i = 0; i < holeNum; i++) {
                brick[i] = 0;
            }
            //flag=9: upper
            //flag=10 : buttom

            UF uf;
            uf = new UF(gridNum);    //flag : 0~10

            for (int i = 0; i < holeNum; i++) {
                
                brick[hole[i]]=1;
                
                if (hole[i] == 0) //left up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] == size - 1) //right up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                } else if (hole[i] == gridNum - 3) //right down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] == gridNum - size - 2) //left down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                } else if (hole[i] / size == 0 && hole[i] != 0 && hole[i] != size - 1) { //upper
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] / size == (size-1) && hole[i] != gridNum - 3 && hole[i] != gridNum - size - 2) {//buttom

                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] % size == 0 && hole[i] != 0 && hole[i] != gridNum - size - 2) {//left side

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] % size == size - 1 && hole[i] != size - 1 && hole[i] != gridNum - 3) {//right side

                    

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } /*else {

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }
                }*/
                if (uf.connected(gridNum - 1, gridNum - 2)) {
                    System.out.println(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    break;
                }

            }
            if (uf.connected(gridNum - 1, gridNum - 2) == false) {
                System.out.println(-1);
            }

        } catch (RuntimeException e) {

            throw e;
        }
        // TODO code application logic here
        /*UF uf=new UF(10);
         uf.union(2, 5);
         uf.union(2, 6);
         System.out.println(uf.count());
         System.out.println(uf.connected(5, 6));*/
    }

}

@644d2be1a6a843ea820a99a85447305d@"
"b99611017","9","1.21","194736","@dd191db297c2d81fc98311b674b20114@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
//import edu.princeton.cs.algs4.UF;
import java.io.*;
import java.util.Scanner;
import java.io.FileReader;

public class Percolation {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            int size = Integer.parseInt(token[0]); //sieze the matrix size

            int holeNum = token.length - 1;  //Number of holes

            int[] hole = new int[holeNum];

            

            
            for (int i = 0; i < holeNum; i++) //transfer site into flags
            {
                String[] site = token[1 + i].split("","");  //hole[i] are flags

                int row = Integer.parseInt(site[0]);

                int column = Integer.parseInt(site[1]);

                hole[i] = (row - 1) * size + (column - 1);

                //System.out.println(hole[i]);     //hole[i] refers to token[1+i]
            }

            int gridNum = size * size + 2;   // size=3 gridNum=11
            
            int[] brick = new int[gridNum-2];
            
            for (int i = 0; i < holeNum; i++) {
                brick[i] = 0;
            }
            //flag=9: upper
            //flag=10 : buttom

            UF uf;
            uf = new UF(gridNum);    //flag : 0~10

            for (int i = 0; i < holeNum; i++) {
                
                brick[hole[i]]=1;
                
                if (hole[i] == 0) //left up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] == size - 1) //right up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                } else if (hole[i] == gridNum - 3) //right down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] == gridNum - size - 2) //left down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                } else if (hole[i] / size == 0 && hole[i] != 0 && hole[i] != size - 1) { //upper
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] / size == (size-1) && hole[i] != gridNum - 3 && hole[i] != gridNum - size - 2) {//buttom

                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] % size == 0 && hole[i] != 0 && hole[i] != gridNum - size - 2) {//left side

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] % size == size - 1 && hole[i] != size - 1 && hole[i] != gridNum - 3) {//right side

                    

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else {

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }
                }
                if (uf.connected(gridNum - 1, gridNum - 2)) {
                    System.out.println(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    break;
                }

            }
            if (uf.connected(gridNum - 1, gridNum - 2) == false) {
                System.out.println(-1);
            }

        } catch (RuntimeException e) {

            throw e;
        }
        // TODO code application logic here
        /*UF uf=new UF(10);
         uf.union(2, 5);
         uf.union(2, 6);
         System.out.println(uf.count());
         System.out.println(uf.connected(5, 6));*/
    }

}

@dd191db297c2d81fc98311b674b20114@"
"r04921074","5","1.34","178416","@528fbd49105b79e13e9553876314d7ff@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //build a metrix with pure value content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(0, metrix[x][0]);
                 uf.union(scale*scale+1, metrix[x][scale-1]);
            }
      
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    //if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                    //      System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                    //      System.out.println(""cc"");
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                                
                           )
                        {
                        uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);                                      
                    //    System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                    //    System.out.println(""cc"");
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}

@528fbd49105b79e13e9553876314d7ff@"
"r04921074","5","1.43","142800","@97455316c42b27dceb365a6a7a075b4c@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //build a metrix with pure value content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    //if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                    //      System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                    //      System.out.println(""cc"");
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)
                               && !uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1])
                                
                           )
                        {
                        uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);                                      
                    //    System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                    //    System.out.println(""cc"");
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}

@97455316c42b27dceb365a6a7a075b4c@"
"b99611017","9","1.22","190432","@73321378cafb801d8156ea82564948d0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
//import edu.princeton.cs.algs4.UF;
import java.io.*;
import java.util.Scanner;
import java.io.FileReader;

public class Percolation {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            int size = Integer.parseInt(token[0]); //sieze the matrix size

            int holeNum = token.length - 1;  //Number of holes

            int[] hole = new int[holeNum];

            

            
            for (int i = 0; i < holeNum; i++) //transfer site into flags
            {
                String[] site = token[1 + i].split("","");  //hole[i] are flags

                int row = Integer.parseInt(site[0]);

                int column = Integer.parseInt(site[1]);

                hole[i] = (row - 1) * size + (column - 1);

                //System.out.println(hole[i]);     //hole[i] refers to token[1+i]
            }

            int gridNum = size * size + 2;   // size=3 gridNum=11
            
            int[] brick = new int[gridNum-2];
            
            for (int i = 0; i < holeNum; i++) {
                brick[i] = 0;
            }
            //flag=9: upper
            //flag=10 : buttom

            UF uf;
            uf = new UF(gridNum);    //flag : 0~10

            if(size==1)
            {
                for(int i=0;i<holeNum;i++)
                {
                    if(hole[i]==0)
                    {
                        System.out.print(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    }
                }
            }
            
            for (int i = 0; i < holeNum; i++) {
                
                brick[hole[i]]=1;
                
                if (hole[i] == 0) //left up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] == size - 1) //right up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                } else if (hole[i] == gridNum - 3) //right down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] == gridNum - size - 2) //left down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                } else if (hole[i] / size == 0 && hole[i] != 0 && hole[i] != size - 1) { //upper
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] / size == (size-1) && hole[i] != gridNum - 3 && hole[i] != gridNum - size - 2) {//buttom

                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] % size == 0 && hole[i] != 0 && hole[i] != gridNum - size - 2) {//left side

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] % size == size - 1 && hole[i] != size - 1 && hole[i] != gridNum - 3) {//right side

                    

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else {

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }
                }
                if (uf.connected(gridNum - 1, gridNum - 2)) {
                    System.out.println(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    break;
                }

            }
            if (uf.connected(gridNum - 1, gridNum - 2) == false) {
                System.out.println(-1);
            }

        } catch (RuntimeException e) {

            throw e;
        }
        // TODO code application logic here
        /*UF uf=new UF(10);
         uf.union(2, 5);
         uf.union(2, 6);
         System.out.println(uf.count());
         System.out.println(uf.connected(5, 6));*/
    }

}

@73321378cafb801d8156ea82564948d0@"
"r04921074","5","1.41","148144","@53f1dd254fdcf37a16edadbdcf755665@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //build a metrix with pure value content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 0;
                   
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    //if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                (!uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]))
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                    //      System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                    //      System.out.println(""cc"");
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)  && 
                                (!uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]))
                                
                           )
                        {
                        uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);                                      
                    //    System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                    //    System.out.println(""cc"");
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
                    
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}

@53f1dd254fdcf37a16edadbdcf755665@"
"b99611017","9","1.2","188864","@d6513cfc0e1581eb90f531b41a33de0b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
//import edu.princeton.cs.algs4.UF;
import java.io.*;
import java.util.Scanner;
import java.io.FileReader;

public class Percolation {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            int size = Integer.parseInt(token[0]); //sieze the matrix size

            int holeNum = token.length - 1;  //Number of holes

            int[] hole = new int[holeNum];

            

            
            for (int i = 0; i < holeNum; i++) //transfer site into flags
            {
                String[] site = token[1 + i].split("","");  //hole[i] are flags

                int row = Integer.parseInt(site[0]);

                int column = Integer.parseInt(site[1]);

                hole[i] = (row - 1) * size + (column - 1);

                //System.out.println(hole[i]);     //hole[i] refers to token[1+i]
            }

            int gridNum = size * size + 2;   // size=3 gridNum=11
            
            int[] brick = new int[gridNum-2];
            
            for (int i = 0; i < holeNum; i++) {
                brick[i] = 0;
            }
            //flag=9: upper
            //flag=10 : buttom

            UF uf;
            uf = new UF(gridNum);    //flag : 0~10

            if(size==1)
            {
                for(int i=0;i<holeNum;i++)
                {
                    if(hole[i]==0)
                    {
                        uf.union(hole[i], gridNum-2);
                        uf.union(hole[i], gridNum-1);
                        
                        
                    }
                    if(uf.connected(gridNum-2, gridNum-1))
                    {
                        System.out.print(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    }
                }
                
            }
            
            for (int i = 0; i < holeNum; i++) {
                
                brick[hole[i]]=1;
                
                if (hole[i] == 0) //left up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] == size - 1) //right up
                {
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                } else if (hole[i] == gridNum - 3) //right down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] == gridNum - size - 2) //left down
                {
                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                } else if (hole[i] / size == 0 && hole[i] != 0 && hole[i] != size - 1) { //upper
                    

                    uf.union(hole[i], gridNum - 2);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] / size == (size-1) && hole[i] != gridNum - 3 && hole[i] != gridNum - size - 2) {//buttom

                    

                    uf.union(hole[i], gridNum - 1);

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else if (hole[i] % size == 0 && hole[i] != 0 && hole[i] != gridNum - size - 2) {//left side

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                } else if (hole[i] % size == size - 1 && hole[i] != size - 1 && hole[i] != gridNum - 3) {//right side

                    

                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }

                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }

                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }

                } else {

                    

                    if (brick[hole[i] + 1] == 1) {
                        uf.union(hole[i], hole[i] + 1);
                    }
                    if (brick[hole[i] - 1] == 1) {
                        uf.union(hole[i], hole[i] - 1);
                    }
                    if (brick[hole[i] + size] == 1) {
                        uf.union(hole[i], hole[i] + size);
                    }
                    if (brick[hole[i] - size] == 1) {
                        uf.union(hole[i], hole[i] - size);
                    }
                }
                if (uf.connected(gridNum - 1, gridNum - 2)) {
                    System.out.println(hole[i] / size + 1 + "","" + (hole[i] % size + 1));
                    break;
                }

            }
            if (uf.connected(gridNum - 1, gridNum - 2) == false) {
                System.out.println(-1);
            }

        } catch (RuntimeException e) {

            throw e;
        }
        // TODO code application logic here
        /*UF uf=new UF(10);
         uf.union(2, 5);
         uf.union(2, 6);
         System.out.println(uf.count());
         System.out.println(uf.connected(5, 6));*/
    }

}

@d6513cfc0e1581eb90f531b41a33de0b@"
"r04921074","4","1.38","146368","@e8b68d308288de5e2d571027927b31d7@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class Percolation {
    public static void main(String[] args) throws IOException
    {
    
     try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
         
            
            //read scale of grids            
            String data = br.readLine();            
            int scale = Integer.parseInt(data);
            UF uf = new UF(scale*scale+2);
            
            int[][] metrix = new int[scale][scale];
            
            //build a metrix with pure value content
            for(int y=0; y<scale; y++){
                for(int x=0; x<scale; x++){
                                        
                    metrix[x][y] = x+scale*y+1;
            //      System.out.println(mertix[x][y]);
                }
            }
            
            //conect first row & last row with symbol 0 & n*n+1
            for(int x=0; x<scale; x++){
                 uf.union(x, x+1);
                 uf.union(scale*scale-scale+x+1,scale*scale-scale+x+2);
            }
/********************************************************************************************************************/            
            //union and check part
            int[] axis1 = new int[scale*scale]; //max of element is n*n  // store for input X-axis in order of [i]
            int[] axis2 = new int[scale*scale]; //max of element is n*n  // store for input Y-axis in order of [i]
            int counting = 1;
                   
                    String[] num1 = br.readLine().split("","");
                    
                    //if(num[0].equals("" "")){break;}
                    
                    axis1[0] = Integer.parseInt(num1[0]);
                    axis2[0] = Integer.parseInt(num1[1]);
            
            while (br.ready())
                {
                    String[] num = br.readLine().split("","");
                    
                    //if(num[0].equals("" "")){break;}
                    
                    axis1[counting] = Integer.parseInt(num[0]);
                    axis2[counting] = Integer.parseInt(num[1]);

                    
                    
                    for(int i=0; i<counting; i++){
                        
                        if ( (axis1[counting]==axis1[counting-i-1]) && (Math.abs(axis2[counting]-axis2[counting-i-1])==1) && 
                                (!uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]))
                           )
                        {
                            
                          uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);
                    //      System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                    //      System.out.println(""cc"");
                        }//end of if (these is for check and connect)
                        
                        if ( (axis2[counting]==axis2[counting-i-1]) && (Math.abs(axis1[counting]-axis1[counting-i-1])==1)  && 
                                (!uf.connected(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]))
                                
                           )
                        {
                        uf.union(metrix[axis1[counting]-1][axis2[counting]-1], metrix[axis1[counting-i-1]-1][axis2[counting-i-1]-1]);                                      
                    //    System.out.println(axis1[counting]+"",""+axis2[counting]+""~""+axis1[counting-i-1]+"",""+axis2[counting-i-1]);
                    //    System.out.println(""cc"");
                        }//end of if (these is for check and connect) 
                       
   
                    }//end of for

                                    if (uf.connected(0, scale*scale+1))
                                    {
                                    System.out.println(axis1[counting]+"",""+axis2[counting]);
                                    break;
                                    }//check percolation
                    counting ++;      
              //      System.out.printf(""hello\n"");
                }//end of while
         
                        if(!uf.connected(0, scale*scale+1))
                        {    
                        System.out.println(""-1"");
                        }

                        if((axis1[0] == 0) && (scale == 1))
                        {    
                        System.out.println(""-1"");
                        }
         

         //int
     }//end of try
    
    }
    
}

@e8b68d308288de5e2d571027927b31d7@"
"r03945012","10","0.133","177280","@1eedd479886d9133f2a635fe79a6e76a@
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import java.util.ArrayList;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Robert
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        InputStream is = null;
        InputStreamReader isr = null;
        BufferedReader br = null;

        try {
            is = new FileInputStream(args[0]);
            isr = new InputStreamReader(is, StandardCharsets.UTF_8);
            br = new BufferedReader(isr);

            // initialize output = false
            boolean output = false;
            // read file.txt
            Scanner inputdata = new Scanner(br);
            String data = inputdata.nextLine();

            // num is matrix size(num*num)
            // matrix starts from 1
            // label = 00
            int num = Integer.parseInt(data);
            int[][] label = new int[num][num];
            for (int[] row : label) {
                java.util.Arrays.fill(row, 0);
            }
            // what is myList...??
            // myList are input data (x,y)
            ArrayList<String> myList = new ArrayList<String>();
            while (inputdata.hasNextLine()) {
                String[] tmp = inputdata.nextLine().split("","");
                for (int i = 0; i < tmp.length; i++) {
                    myList.add(tmp[i]);
                }
            }
            // nextLine(point) and totaline

            int k = myList.size() / 2;
            int count = 0;
            int[][] point = new int[k][2];
            for (int i = 0; i < k; i++) {
                point[i][0] = Integer.parseInt((String) myList.get(count)) - 1;
                point[i][1] = Integer.parseInt((String) myList.get(count + 1)) - 1;
                count = count + 2;
            }

            // create class uf (0 to num*num+1)
            // 0 = virtual top
            // num*num+1 = virtual bottom
            UF uf = new UF(num * num + 2);

            // start 1 (using for)
            if (num == 1) {
                for (int[] point1: point){
                    int x = point1[0];
                    int y = point1[1];
                    if (x==0 && y==0){
                        output = true;
                        System.out.print((x + 1) + "","" + (y + 1));
                    }
                }
            } 
            else {
                for (int[] point1 : point) {
                    int x = point1[0];
                    int y = point1[1];
                    label[x][y] = 1;
                    int index = x * num + y + 1;
                    // matrix union
                    // union top
                    if (x == 0) {
                        uf.union(index, 0);
                        // down
                        if (label[x + 1][y] == 1) {
                            uf.union(index, index + num);
                        }
                        if (y == 0) {
                            if (label[x][y + 1] == 1) {
                                uf.union(index, index + 1);
                            }
                        } else if (y == num - 1) {
                            if (label[x][y - 1] == 1) {
                                uf.union(index, index - 1);
                            }
                        } else {
                            if (label[x][y - 1] == 1) {
                                uf.union(index, index - 1);
                            }
                            if (label[x][y + 1] == 1) {
                                uf.union(index, index + 1);
                            }
                        }
                    } //union bottom
                    else if (x == num - 1) {
                        uf.union(index, num * num + 1);
                        // top
                        if (label[x - 1][y] == 1) {
                            uf.union(index, index - num);
                        }
                        if (y == 0) {
                            if (label[x][y + 1] == 1) {
                                uf.union(index, index + 1);
                            }
                        } else if (y == num - 1) {
                            if (label[x][y - 1] == 1) {
                                uf.union(index, index - 1);
                            }
                        } else {
                            if (label[x][y - 1] == 1) {
                                uf.union(index, index - 1);
                            }
                            if (label[x][y + 1] == 1) {
                                uf.union(index, index + 1);
                            }
                        }
                    } // union the rest
                    else {
                        // union to top one
                        if (label[x - 1][y] == 1) {
                            uf.union(index, index - num);
                        }
                        // union to down one
                        if (label[x + 1][y] == 1) {
                            uf.union(index, index + num);
                        }
                        if (y == 0) {
                            if (label[x][y + 1] == 1) {
                                uf.union(index, index + 1);
                            }
                        } else if (y == num - 1) {
                            if (label[x][y - 1] == 1) {
                                uf.union(index, index - 1);
                            }
                        } else {
                            if (label[x][y - 1] == 1) {
                                uf.union(index, index - 1);
                            }
                            if (label[x][y + 1] == 1) {
                                uf.union(index, index + 1);
                            }
                        }
                    }
                    output = uf.connected(0, num * num + 1);
                    if (output == true) {
                        System.out.print((x + 1) + "","" + (y + 1));
                        break;
                    }
                }
            }
            if (output == false) {
                System.out.print(""-1"");
            }
        }catch (FileNotFoundException | NumberFormatException e) {
        }
            finally {
            // releases resources associated with the streams
            if (is != null) {
            is.close();
        }
        if (isr != null) {
            isr.close();
        }
        if (br != null) {
            br.close();
        }
    }
}
}

@1eedd479886d9133f2a635fe79a6e76a@"
"r03631015","0","1.03","175952","@00c5210a32afd50a518d1d54ee2d53b1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author wayne17
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
     public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // read a line and split by ','
            String[] initial = br.readLine().split("","");
            int size = Integer.parseInt(initial[0]);
            
            //declare two matrix, default false
            boolean[][] input  = new boolean[size][size];
            boolean[][] result  = new boolean[size][size];
            
            String[] anounce;
            int x, y;
            while (br.ready()) {
                //read anounce
                anounce = br.readLine().split("","");
                x = Integer.parseInt(anounce[0])-1;
                y = Integer.parseInt(anounce[1])-1;
                input[y][x] = true;
                if (y > 0) {
                    for (int i = y; i < size; i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                else {
                    result[y]=input[y];
                    for (int i =y+1;i<size;i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                //is_percolation
                if(is_percolation(result[size-1])){
                    System.out.printf(""%d,%d"", x, y);
                    break;
                }
            }
            if(!is_percolation(result[size-1])){
                System.out.printf(""false"");
            }
        }
    }
     public static boolean[] compare(boolean[] upper,boolean[] lower) {
         int size = upper.length;
         int left_index,right_index;
         boolean[] compared  = new boolean[size];
//         for(int j = 0; j<size; j++) {
//                    System.out.printf(""%b,%b;"",upper[j],lower[j]);
//                 }
//                 System.out.printf(""\n"");
         for (int i = 0; i < size; i++) {
             if (upper[i] & lower[i]) {
                 compared[i] = true;
                 //left_flow
                left_index= i-1;
                while(left_index > 0 & lower[left_index]) {
                    compared[left_index] = true;
                    left_index = left_index-1;
                }
//                 right_flow
                while(i<size) {
                    if (lower[i]) {
                        compared[i] =true;
                    }
                    i++;
                }
             }
         }
         return compared;
     }
     public static boolean is_percolation(boolean[] bottom) {
         int length = bottom.length;
         boolean contain = false;
         for (int i= 0; i < length; i++) {
             if (bottom[i]) {
                 contain = true;
                 break;
             }
         }
         return contain;
     }
}

@00c5210a32afd50a518d1d54ee2d53b1@"
"r03631015","1","1.01","175648","@d92c71beefe4272a97d26c1ee664c143@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author wayne17
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
     public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // read a line and split by ','
            String[] initial = br.readLine().split("","");
            int size = Integer.parseInt(initial[0]);
            
            //declare two matrix, default false
            boolean[][] input  = new boolean[size][size];
            boolean[][] result  = new boolean[size][size];
            
            String[] anounce;
            int x, y;
            while (br.ready()) {
                //read anounce
                anounce = br.readLine().split("","");
                x = Integer.parseInt(anounce[0])-1;
                y = Integer.parseInt(anounce[1])-1;
                input[y][x] = true;
                if (y > 0) {
                    for (int i = y; i < size; i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                else {
                    result[y]=input[y];
                    for (int i =y+1;i<size;i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                //is_percolation
                if(is_percolation(result[size-1])){
                    System.out.printf(""%d,%d"", x+1, y+1);
                    break;
                }
            }
            if(!is_percolation(result[size-1])){
                System.out.printf(""false"");
            }
        }
    }
     public static boolean[] compare(boolean[] upper,boolean[] lower) {
         int size = upper.length;
         int left_index,right_index;
         boolean[] compared  = new boolean[size];
//         for(int j = 0; j<size; j++) {
//                    System.out.printf(""%b,%b;"",upper[j],lower[j]);
//                 }
//                 System.out.printf(""\n"");
         for (int i = 0; i < size; i++) {
             if (upper[i] & lower[i]) {
                 compared[i] = true;
                 //left_flow
                left_index= i-1;
                while(left_index > 0 & lower[left_index]) {
                    compared[left_index] = true;
                    left_index = left_index-1;
                }
//                 right_flow
                while(i<size) {
                    if (lower[i]) {
                        compared[i] =true;
                    }
                    i++;
                }
             }
         }
         return compared;
     }
     public static boolean is_percolation(boolean[] bottom) {
         int length = bottom.length;
         boolean contain = false;
         for (int i= 0; i < length; i++) {
             if (bottom[i]) {
                 contain = true;
                 break;
             }
         }
         return contain;
     }
}

@d92c71beefe4272a97d26c1ee664c143@"
"r03631015","1","1.08","157056","@6b12136e1d2f2898caaf3a692da0bb0e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author wayne17
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
     public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // read a line and split by ','
            String[] initial = br.readLine().split("","");
            int size = Integer.parseInt(initial[0]);
            
            //declare two matrix, default false
            boolean[][] input  = new boolean[size][size];
            boolean[][] result  = new boolean[size][size];
            
            String[] anounce;
            int x, y;
            while (br.ready()) {
                //read anounce
                anounce = br.readLine().split("","");
                x = Integer.parseInt(anounce[0])-1;
                y = Integer.parseInt(anounce[1])-1;
                input[y][x] = true;
                if (y > 0) {
                    for (int i = y; i < size; i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                else {
                    result[y]=input[y];
                    for (int i =y+1;i<size;i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                //is_percolation
                if(is_percolation(result[size-1])){
                    System.out.printf(""%d,%d"", x+1, y+1);
                    break;
                }
            }
            if(!is_percolation(result[size-1])){
                System.out.printf(""false"");
            }
        }
    }
     public static boolean[] compare(boolean[] upper,boolean[] lower) {
         int size = upper.length;
         int left_index,right_index;
         boolean[] compared  = new boolean[size];
//         for(int j = 0; j<size; j++) {
//                    System.out.printf(""%b,%b;"",upper[j],lower[j]);
//                 }
//                 System.out.printf(""\n"");
         for (int i = 0; i < size; i++) {
             if (upper[i] & lower[i]) {
                 compared[i] = true;
                 //left_flow
                left_index= i-1;
                while(left_index >= 0) {
                    if (lower[left_index]){
                        compared[left_index] = true;
                    }
                    left_index = left_index-1;  
                }
//                 right_flow
                while(i<size) {
                    if (lower[i]) {
                        compared[i] =true;
                    }
                    i++;
                }
             }
         }
         return compared;
     }
     public static boolean is_percolation(boolean[] bottom) {
         int length = bottom.length;
         boolean contain = false;
         for (int i= 0; i < length; i++) {
             if (bottom[i]) {
                 contain = true;
                 break;
             }
         }
         return contain;
     }
}

@6b12136e1d2f2898caaf3a692da0bb0e@"
"r03522831","10","0.112","177488","@3d061640fe2db818a0525348b503cf9c@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

     private static int convert(int x, int y, int N){
       int p = (x-1)*N + y;
       return p;
    }
     
     
    
    
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           
           String [] data = br.readLine().split("","");
           int N = Integer.parseInt(data[0]);
           int [][] check = new int [N][N];
           QuickUnionUF uf = new QuickUnionUF(N*N+2);
           int x = 0, y = 0, x1 = 0, y1 = 0, j = 1, end = 0;
           String d;

          while((d = br.readLine())!= null){
           
            d = d.replaceAll("" "", """");
            String [] data1 = d.split("","");
           
            x =  Integer.parseInt(data1[0]);
            y =  Integer.parseInt(data1[1]);
           
            
           int inx = x -1, iny = y -1 ;
             check[inx][iny] = 1;
             
             int p = convert(x,y,N);
             
             if(1 == x){
                 uf.union(p,0);
             }
             
             if(N == x){
                 uf.union(p,N*N+1);
             }
             
             if((x-1)>0 && (x-1)<=N){
                int pu = convert(x-1,y,N);
                if( 1 == check[x-2][y-1]){
                uf.union(p,pu);
                }
             }
             
             if((x+1)<=N && (x+1)>0){
                int pl = convert(x+1,y,N);
                if( 1 == check[x][y-1]){
                uf.union(p,pl);
                }
             }
            
              if((y-1)>0 && (y-1)<=N){
                int pl = convert(x,y-1,N);
                if(1 == check[x-1][y-2]){
                uf.union(p,pl);
                }
             }
              
             if((y+1)<=N && (y+1)>0){
                int pr = convert(x,y+1,N);
                if(1 == check[x-1][y]){
                uf.union(p,pr);
                }
             }
             
           if((uf.connected(0, N*N+1))&&(0 == end)){
               x1 = x;
               y1 = y;
               end = 1;
               j = 2;
           }
             
                 
          }
         switch(j){
                 case 1:
                     System.out.println(-1);
                     break;
                 case 2:
                     System.out.println(x1+"",""+y1);
                     break;
                 default:
             }
//            System.out.println(j);
//            System.out.println(end);
//          System.out.println(check[0][0]);
//          System.out.println(check[0][1]);
//          System.out.println(check[0][2]);
//          System.out.println(check[1][0]);
//          System.out.println(check[1][1]);
//          System.out.println(check[1][2]);
//          System.out.println(check[2][0]);
//          System.out.println(check[2][1]);
//          System.out.println(check[2][2]);
        }
    }
    
}
@3d061640fe2db818a0525348b503cf9c@"
"r03631015","1","1.25","172000","@77dc89b63c471d2d22cc1e3f5ae8237b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author wayne17
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
     public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // read a line and split by ','
            String[] initial = br.readLine().split("","");
            int size = Integer.parseInt(initial[0]);
            
            //declare two matrix, default false
            boolean[][] input  = new boolean[size][size];
            boolean[][] result  = new boolean[size][size];
            
            String[] anounce;
            int x, y;
            while (br.ready()) {
                //read anounce
                anounce = br.readLine().split("","");
                x = Integer.parseInt(anounce[0])-1;
                y = Integer.parseInt(anounce[1])-1;
                input[y][x] = true;
                if (y > 0) {
                    for (int i = y; i < size; i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                else {
                    result[y]=input[y];
                    for (int i =y+1;i<size;i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                //is_percolation
                if(is_percolation(result[size-1])){
                    System.out.printf(""%d,%d"", x+1, y+1);
                    break;
                }
            }
            if(!is_percolation(result[size-1])){
                System.out.printf(""false"");
            }
        }
    }
     public static boolean[] compare(boolean[] upper,boolean[] lower) {
         int size = upper.length;
         int left_index,right_index;
         boolean[] compared  = new boolean[size];
//         for(int j = 0; j<size; j++) {
//                    System.out.printf(""%b,%b;"",upper[j],lower[j]);
//                 }
//                 System.out.printf(""\n"");
         for (int i = 0; i < size; i++) {
             if (upper[i] & lower[i]) {
                 compared[i] = true;
                 //left_flow
                left_index= i-1;
                while(left_index >= 0) {
                    if (lower[left_index]){
                        compared[left_index] = true;
                    }
                    left_index = left_index-1;  
                }
//                 right_flow
                while(i<size) {
                    if (lower[i]) {
                        compared[i] =true;
                        i++;
                    }
                    else {
                        break;
                    }
                }
             }
         }
         return compared;
     }
     public static boolean is_percolation(boolean[] bottom) {
         int length = bottom.length;
         boolean contain = false;
         for (int i= 0; i < length; i++) {
             if (bottom[i]) {
                 contain = true;
                 break;
             }
         }
         return contain;
     }
}

@77dc89b63c471d2d22cc1e3f5ae8237b@"
"r03631015","1","0.76","104288","@86eaf2bc8892149cb355d64b514663e4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author wayne17
 */
public class Percolation {

    /**
     * @param args the command line arguments
     */
     public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // read a line and split by ','
            String[] initial = br.readLine().split("","");
            int size = Integer.parseInt(initial[0]);
            
            //declare two matrix, default false
            boolean[][] input  = new boolean[size][size];
            boolean[][] result  = new boolean[size][size];
            
            String[] anounce;
            int x, y;
            while (br.ready()) {
                //read anounce
                anounce = br.readLine().split("","");
                x = Integer.parseInt(anounce[0])-1;
                y = Integer.parseInt(anounce[1])-1;
                input[y][x] = true;
                if (y > 0) {
                    for (int i = y; i < size; i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                else {
                    result[y]=input[y];
                    for (int i =y+1;i<size;i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                //is_percolation
                if(is_percolation(result[size-1])){
                    System.out.printf(""%d,%d"", x+1, y+1);
                    break;
                }
            }
            if(!is_percolation(result[size-1])){
                System.out.printf(""false"");
            }
        }
    }
     public static boolean[] compare(boolean[] upper,boolean[] lower) {
         int size = upper.length;
         int left_index,right_index;
         boolean[] compared  = new boolean[size];
         /////
         System.out.printf(""upper:"");
         for(int j = 0; j<size; j++) {
                    System.out.printf(""%b,"",upper[j]);
                 }
                 System.out.printf(""\n"");
         System.out.printf(""lower:"");
         for(int j = 0; j<size; j++) {
                    System.out.printf(""%b,"",lower[j]);
                 }
                 System.out.printf(""\n"");
         /////
         for (int i = 0; i < size; i++) {
             if (upper[i] & lower[i]) {
                 compared[i] = true;
                 //left_flow
                left_index= i-1;
                while(left_index >= 0) {
                    if (lower[left_index]){
                        compared[left_index] = true;
                    }
                    else {
                        break;
                    }
                    left_index = left_index-1;  
                }
//                 right_flow
                while(i<size) {
                    if (lower[i]) {
                        compared[i] =true;
                        i++;
                    }
                    else {
                        break;
                    }
                }
             }
         }
         /////
         System.out.printf(""result:"");
         for(int j = 0; j<size; j++) {
                    System.out.printf(""%b,"",compared[j]);
                 }
                 System.out.printf(""\n"");
         /////
         return compared;
     }
     public static boolean is_percolation(boolean[] bottom) {
         int length = bottom.length;
         boolean contain = false;
         for (int i= 0; i < length; i++) {
             if (bottom[i]) {
                 contain = true;
                 break;
             }
         }
         return contain;
     }
}

@86eaf2bc8892149cb355d64b514663e4@"
"d04631001","9","1.11","150352","@9a17cd9485fe06b4a04082c75d932d91@//import edu.princeton.cs.algs4.UF; // mask
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) { //args[0]
            String[] data = br.readLine().split("","");
            //int stringCount = Integer.parseInt(data[0]);
            int num = Integer.parseInt(data[0]);
            int[][] matrix = new int[num][num];
            //for (int x = 0; x < matrix.length; x++) {
            //    for (int y = 0; y < matrix[0].length; y++) {
            //        System.out.print(matrix[x][y] + "" "");
            //    }
            //    System.out.print(""\n"");
            //}
            String announce = new String();
            UF uf = new UF(num * num + 2);
            String perco = new String();

            for (int i = 0; i < num * num; i++) {
                if ((announce = br.readLine()) == null) {
                    break;
                }
                String[] a = announce.split("","");
                int a_v = Integer.parseInt(a[0]);
                int a_h = Integer.parseInt(a[1]);
                matrix[a_v - 1][a_h - 1] = 1;
                //for (int x = 0; x < matrix.length; x++) {
                //    for (int y = 0; y < matrix[0].length; y++) {
                //        System.out.print(matrix[x][y] + "" "");
                //    }
                //    System.out.print(""\n"");
                //}
                
                if (num > 1) {
                    for (int u = 0; u < num; u++) {
                        if (!uf.connected(u, num * num + 1 - 1)) {
                            uf.union(u, num * num + 1 - 1);
                        }
                        if (!uf.connected((u + (num - 1) * num), num * num + 2 - 1)) {
                            uf.union((u + (num - 1) * num), num * num + 2 - 1);
                        }

                    }
                    if (a_v - 1 > 0) {
                        if (matrix[a_v - 1][a_h - 1] == matrix[a_v - 1 - 1][a_h - 1]) {
                            if (!uf.connected((a_v * num) - num + a_h - 1, (a_v * num) - (num * 2) + a_h - 1)) {
                                uf.union((a_v * num) - num + a_h - 1, (a_v * num) - (num * 2) + a_h - 1);
                                //System.out.println(""up"");
                            }
                        }
                    }
                    if (a_v + 1 <= num) {
                        if (matrix[a_v - 1][a_h - 1] == matrix[a_v - 1 + 1][a_h - 1]) {
                            if (!uf.connected((a_v * num) - num + a_h - 1, (a_v * num) + a_h - 1)) {
                                uf.union((a_v * num) - num + a_h - 1, (a_v * num) + a_h - 1);
                                //System.out.println(""down"");
                            }
                        }
                    }
                    if (a_h - 1 > 0) {
                        if (matrix[a_v - 1][a_h - 1] == matrix[a_v - 1][a_h - 1 - 1]) {
                            if (!uf.connected((a_v * num) - num + a_h - 1, (a_v * num) - num + a_h - 1 - 1)) {
                                uf.union((a_v * num) - num + a_h - 1, (a_v * num) - num + a_h - 1 - 1);
                                //System.out.println(""left"");
                            }
                        }
                    }
                    if (a_h + 1 <= num) {
                        if (matrix[a_v - 1][a_h - 1] == matrix[a_v - 1][a_h - 1 + 1]) {
                            if (!uf.connected((a_v * num) - num + a_h - 1, (a_v * num) - num + a_h)) {
                                uf.union((a_v * num) - num + a_h - 1, (a_v * num) - num + a_h);
                                //System.out.println(""right"");
                            }
                        }
                    }
                    if (uf.connected(num * num + 1 - 1, num * num + 2 - 1)) {
                        perco = announce;
                        System.out.printf(""%s\n"", perco);
                        return;
                    //} else {
                        //    perco = ""-1"";
                        //    System.out.printf(""%s\n"", perco);
                        //}
                    }
                    
                    //uf.find(2) ;
                    if (num == 1) {
                        if (a_v == 1 && a_h == 1) {
                            perco = announce;
                            System.out.printf(""%s\n"", perco);
                            
                        }   
                    }
                }
                //System.out.printf(""%s\n"", uf.find(a_v*num-num+a_h-1));
                // TODO code application logic here
            }
            
            System.out.printf(""%s\n"", ""-1"");
            
            //System.out.printf(""%s\n"", uf.find(9));
            //System.out.printf(""%s\n"", uf.find(10));
        }
    }
}

@9a17cd9485fe06b4a04082c75d932d91@"
"d04631001","10","0.11","148368","@47c5069b334cc2f9c432a6bf4d86a17d@
//import edu.princeton.cs.algs4.UF; // mask
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) { //args[0]
            String[] data = br.readLine().split("","");
            //int stringCount = Integer.parseInt(data[0]);
            int num = Integer.parseInt(data[0]);
            int[][] matrix = new int[num][num];
            //for (int x = 0; x < matrix.length; x++) {
            //    for (int y = 0; y < matrix[0].length; y++) {
            //        System.out.print(matrix[x][y] + "" "");
            //   }
            //    System.out.print(""\n"");
            //}
            String announce = new String();
            UF uf = new UF(num * num + 2);
            String perco = new String();

            for (int i = 0; i < num * num; i++) {
                if ((announce = br.readLine()) == null) {
                    break;
                }
                String[] a = announce.split("","");
                int a_v = Integer.parseInt(a[0]);
                int a_h = Integer.parseInt(a[1]);
                matrix[a_v - 1][a_h - 1] = 1;
                //for (int x = 0; x < matrix.length; x++) {
                //    for (int y = 0; y < matrix[0].length; y++) {
                //        System.out.print(matrix[x][y] + "" "");
                //    }
                //    System.out.print(""\n"");
                //}
                if (num == 1) {
                    if (a_v == 1 && a_h == 1) {
                        perco = ""1,1"";
                        System.out.printf(""%s\n"", perco);
                        return;
                    }
                }
                if (num > 1) {
                    for (int u = 0; u < num; u++) {
                        if (!uf.connected(u, num * num + 1 - 1)) {
                            uf.union(u, num * num + 1 - 1);
                        }
                        if (!uf.connected((u + (num - 1) * num), num * num + 2 - 1)) {
                            uf.union((u + (num - 1) * num), num * num + 2 - 1);
                        }

                    }
                    if (a_v - 1 > 0) {
                        if (matrix[a_v - 1][a_h - 1] == matrix[a_v - 1 - 1][a_h - 1]) {
                            if (!uf.connected((a_v * num) - num + a_h - 1, (a_v * num) - (num * 2) + a_h - 1)) {
                                uf.union((a_v * num) - num + a_h - 1, (a_v * num) - (num * 2) + a_h - 1);
                                //System.out.println(""up"");
                            }
                        }
                    }
                    if (a_v + 1 <= num) {
                        if (matrix[a_v - 1][a_h - 1] == matrix[a_v - 1 + 1][a_h - 1]) {
                            if (!uf.connected((a_v * num) - num + a_h - 1, (a_v * num) + a_h - 1)) {
                                uf.union((a_v * num) - num + a_h - 1, (a_v * num) + a_h - 1);
                                //System.out.println(""down"");
                            }
                        }
                    }
                    if (a_h - 1 > 0) {
                        if (matrix[a_v - 1][a_h - 1] == matrix[a_v - 1][a_h - 1 - 1]) {
                            if (!uf.connected((a_v * num) - num + a_h - 1, (a_v * num) - num + a_h - 1 - 1)) {
                                uf.union((a_v * num) - num + a_h - 1, (a_v * num) - num + a_h - 1 - 1);
                                //System.out.println(""left"");
                            }
                        }
                    }
                    if (a_h + 1 <= num) {
                        if (matrix[a_v - 1][a_h - 1] == matrix[a_v - 1][a_h - 1 + 1]) {
                            if (!uf.connected((a_v * num) - num + a_h - 1, (a_v * num) - num + a_h)) {
                                uf.union((a_v * num) - num + a_h - 1, (a_v * num) - num + a_h);
                                //System.out.println(""right"");
                            }
                        }
                    }
                    if (uf.connected(num * num + 1 - 1, num * num + 2 - 1)) {
                        perco = announce;
                        System.out.printf(""%s\n"", perco);
                        return;
                        //} else {
                        //    perco = ""-1"";
                        //    System.out.printf(""%s\n"", perco);
                        //}
                    }
                    //uf.find(2) ;
                }
                //System.out.printf(""%s\n"", uf.find(a_v*num-num+a_h-1));
                // TODO code application logic here
            }
            System.out.printf(""%s\n"", ""-1"");
            //System.out.printf(""%s\n"", uf.find(9));
            //System.out.printf(""%s\n"", uf.find(10));
        }
    }
}

@47c5069b334cc2f9c432a6bf4d86a17d@"
"b01705003","0","1.11","136352","@8aec52fffcaed0bd6c33ffd9da81d87e@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.Array;
public class Bingo {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
			int K ;
			K = (int)(Math.random()*N+1) ;
			System.out.printf(""%d"", K , ""%d"", N);
			 
    }
}

@8aec52fffcaed0bd6c33ffd9da81d87e@"
"b01705003","0","1.09","138192","@5d7789d15a1c090240083cc078d23ba6@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.Array;
public class Bingo {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int N = Integer.parseInt(data[0]);
			System.out.printf( 1, ""%d"", N);
			 
    }
}

@5d7789d15a1c090240083cc078d23ba6@"
"b01705003","0","0.11","148368","@14d8175962959c1d7f5011044e9637e9@public class HelloWorld {
    public static void main(String[] args) {
        System.out.println(""-1"");
    }
}
@14d8175962959c1d7f5011044e9637e9@"
"b01705003","0","0.11","148368","@309b7abfae86f694c7ff651b49fa4b96@public class hw1 {
    public static void main(String[] args) {
        System.out.println(""-1"");
    }
}
@309b7abfae86f694c7ff651b49fa4b96@"
"b01705003","5","0.9","105120","@dde371ee614b0938d53717ac65dbfd4f@public class Percolation {
    public static void main(String[] args) {
        System.out.println(""-1"");
    }
}
@dde371ee614b0938d53717ac65dbfd4f@"
"b03611011","8","0.97","121840","@4430c4040bed00b3598620946118f4bf@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = (p - 1) / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num - 1) {
            switch (tep) {
                case 1:
                    for (int i = 1; i <= num - quotient&&id[p+i]!=0; i++) {
                        if (id[p + i] == 2) {
                            id[p + i] = 1;
                        }
                    }
                    break;
                case 0:
                    for (int i = 1; i <= quotient - 1&&id[p-i]!=0; i++) {
                        if (id[p - 1] == 2) {
                            id[p - 1] = 1;
                        }
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }

            if (id[p + num] == 2) {
                id[p + num] = 1;
            }
        }
        //check connective
        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@4430c4040bed00b3598620946118f4bf@"
"b03611011","8","1.01","122032","@5203a9a6168c1e743e444c14ec800fcb@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = (p - 1) / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num - 1) {
            switch (tep) {
                case 1:
                    for (int i = 1; i <= num - quotient && id[p + i] != 0; i++) {
                        if (id[p + i] == 2) {
                            id[p + i] = 1;
                        }
                    }
                    if (id[p + num] == 2) {
                        id[p + num] = 1;
                    }
                    break;
                case 0:
                    for (int i = 1; i <= quotient - 1 && id[p - i] != 0; i++) {
                        if (id[p - 1] == 2) {
                            id[p - 1] = 1;
                        }
                        if (id[p + num] == 2) {
                            id[p + num] = 1;
                        }
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
        }
        //check connective
        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@5203a9a6168c1e743e444c14ec800fcb@"
"b03611011","8","0.98","129376","@d1bb5a4230cf8800711ce38334aa9df5@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = (p - 1) / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num - 1) {
            switch (tep) {
                case 1:
                    for (int i = 1; i <= num - quotient && id[p + i] != 0; i++) {
                        if (id[p + i] == 2) {
                            id[p + i] = 1;
                        }
                    }
                    for (int i = 1; i <= num-1-i && id[p + num*i] != 0; i++) {
                        if (id[p + num*i] == 2) {
                            id[p + num*i] = 1;
                        }
                    }
                    break;
                case 0:
                    for (int i = 1; i <= quotient - 1 && id[p - i] != 0; i++) {
                        if (id[p - 1] == 2) {
                            id[p - 1] = 1;
                        }
                        if (id[p + num] == 2) {
                            id[p + num] = 1;
                        }
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
        }
        //check connective
        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@d1bb5a4230cf8800711ce38334aa9df5@"
"r04631035","0","1.36","152384","@f337a7a08684409bc6fd95f2d70ca6f0@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
import edu.princeton.cs.algs4.*;

public class Percolation {

    public static void main(String[] args) {

        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
//                    System.out.println(target);
        String[] numbersArray = target.split("" "");
        for (int i = 0; i < numbersArray.length; i++) {
//                              System.out.println(numbersArray[i]);
        }

        String[] num = numbersArray[0].split("",""); //維度
        int stringCount = Integer.parseInt(num[0]); //轉數字
        int[][] matrix = new int[stringCount][stringCount]; //建立空矩陣

//                    String[] num2 = numbersArray[1].split("","");                    
//                    System.out.println(numbersArray.length);     
        UF uf = new UF(stringCount * stringCount + 2);  //開List
        //                   ArrayList<Integer> Column = new ArrayList<Integer>();

        String[] data = numbersArray[2].split("",""); //讀取input
        int[] List_con = new int[numbersArray.length];

        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);

            matrix[input1 - 1][input2 - 1] = 1; //位置從0,0開始
            List_con[i - 1] = (input1 - 1) * stringCount + (input2 - 1); //放入白點(編號)

//                        System.out.println(List_con);
            //連結上點
            if ((input1 - 1) == 0) {
                uf.union(List_con[i - 1], stringCount * stringCount);
                //左上
                if (List_con[i - 1] == 0) {
                    if (matrix[0][1] == 1) {
                        uf.union(List_con[i - 1], 1);
                    }
                    if (matrix[1][0] == 1) {
                        uf.union(List_con[i - 1], stringCount);
                    }
                }
                //右上
                if (List_con[i - 1] == stringCount - 1) {
                    if (matrix[0][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount - 2);
                    }
                    if (matrix[1][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * 2 - 1);
                    }
                }
                //上排
                if (List_con[i - 1] > 0 && List_con[i - 1] < stringCount - 1) {
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
            } //連結下點
            else if ((input1 - 1) == stringCount - 1) {
                uf.union(List_con[i - 1], stringCount * stringCount + 1);
                //右下
                if (List_con[i - 1] == stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * (stringCount - 1) - 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], stringCount * stringCount - 2);
                    }
                }
                //左下
                if (List_con[i - 1] == stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * (stringCount - 1));
                    }
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                }

                //下排
                if (List_con[i - 1] > stringCount * (stringCount - 1) && List_con[i - 1] < stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }

            } else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1) {
                //左排
                if (List_con[i - 1] % stringCount == 0 && List_con[i - 1] != 0 && List_con[i - 1] != stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                }
                //右排
                if (List_con[i - 1] % stringCount == stringCount - 1 && List_con[i - 1] != stringCount - 1 && List_con[i - 1] != stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                } //中間
                else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1 && input2 - 1 != 0 && input2 - 1 != stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }

            }

            //判斷是否連接
            if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == true) {
 //               System.out.println(""output:"");
                System.out.println((input1) + "","" + (input2));
                break;
            }

        }
        if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == false) {
            System.out.println(""-1"");

        }
        //                   System.out.println(numbersArray.length);
    }
}
//

@f337a7a08684409bc6fd95f2d70ca6f0@"
"r04631035","8","2.19","168592","@616434db8a11dec24e75cd2190c34fc8@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;

public class Percolation {

    public static void main(String[] args) {

        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
//                    System.out.println(target);
        String[] numbersArray = target.split("" "");
        for (int i = 0; i < numbersArray.length; i++) {
//                              System.out.println(numbersArray[i]);
        }

        String[] num = numbersArray[0].split("",""); //維度
        int stringCount = Integer.parseInt(num[0]); //轉數字
        int[][] matrix = new int[stringCount][stringCount]; //建立空矩陣

//                    String[] num2 = numbersArray[1].split("","");                    
//                    System.out.println(numbersArray.length);     
        UF uf = new UF(stringCount * stringCount + 2);  //開List
        //                   ArrayList<Integer> Column = new ArrayList<Integer>();

        String[] data = numbersArray[2].split("",""); //讀取input
        int[] List_con = new int[numbersArray.length];

        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);

            matrix[input1 - 1][input2 - 1] = 1; //位置從0,0開始
            List_con[i - 1] = (input1 - 1) * stringCount + (input2 - 1); //放入白點(編號)

//                        System.out.println(List_con);
            //連結上點
            if ((input1 - 1) == 0) {
                uf.union(List_con[i - 1], stringCount * stringCount);
                //左上
                if (List_con[i - 1] == 0) {
                    if (matrix[0][1] == 1) {
                        uf.union(List_con[i - 1], 1);
                    }
                    if (matrix[1][0] == 1) {
                        uf.union(List_con[i - 1], stringCount);
                    }
                }
                //右上
                if (List_con[i - 1] == stringCount - 1) {
                    if (matrix[0][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount - 2);
                    }
                    if (matrix[1][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * 2 - 1);
                    }
                }
                //上排
                if (List_con[i - 1] > 0 && List_con[i - 1] < stringCount - 1) {
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
            } //連結下點
            else if ((input1 - 1) == stringCount - 1) {
                uf.union(List_con[i - 1], stringCount * stringCount + 1);
                //右下
                if (List_con[i - 1] == stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * (stringCount - 1) - 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], stringCount * stringCount - 2);
                    }
                }
                //左下
                if (List_con[i - 1] == stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * (stringCount - 1));
                    }
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                }

                //下排
                if (List_con[i - 1] > stringCount * (stringCount - 1) && List_con[i - 1] < stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }

            } else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1) {
                //左排
                if (List_con[i - 1] % stringCount == 0 && List_con[i - 1] != 0 && List_con[i - 1] != stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                }
                //右排
                if (List_con[i - 1] % stringCount == stringCount - 1 && List_con[i - 1] != stringCount - 1 && List_con[i - 1] != stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                } //中間
                else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1 && input2 - 1 != 0 && input2 - 1 != stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }

            }

            //判斷是否連接
            if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == true) {
 //               System.out.println(""output:"");
                System.out.println((input1) + "","" + (input2));
                break;
            }

        }
        if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == false) {
            System.out.println(""-1"");

        }
        //                   System.out.println(numbersArray.length);
    }
}
//

@616434db8a11dec24e75cd2190c34fc8@"
"r04631035","8","2.23","175504","@616434db8a11dec24e75cd2190c34fc8@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;

public class Percolation {

    public static void main(String[] args) {

        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
//                    System.out.println(target);
        String[] numbersArray = target.split("" "");
        for (int i = 0; i < numbersArray.length; i++) {
//                              System.out.println(numbersArray[i]);
        }

        String[] num = numbersArray[0].split("",""); //維度
        int stringCount = Integer.parseInt(num[0]); //轉數字
        int[][] matrix = new int[stringCount][stringCount]; //建立空矩陣

//                    String[] num2 = numbersArray[1].split("","");                    
//                    System.out.println(numbersArray.length);     
        UF uf = new UF(stringCount * stringCount + 2);  //開List
        //                   ArrayList<Integer> Column = new ArrayList<Integer>();

        String[] data = numbersArray[2].split("",""); //讀取input
        int[] List_con = new int[numbersArray.length];

        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);

            matrix[input1 - 1][input2 - 1] = 1; //位置從0,0開始
            List_con[i - 1] = (input1 - 1) * stringCount + (input2 - 1); //放入白點(編號)

//                        System.out.println(List_con);
            //連結上點
            if ((input1 - 1) == 0) {
                uf.union(List_con[i - 1], stringCount * stringCount);
                //左上
                if (List_con[i - 1] == 0) {
                    if (matrix[0][1] == 1) {
                        uf.union(List_con[i - 1], 1);
                    }
                    if (matrix[1][0] == 1) {
                        uf.union(List_con[i - 1], stringCount);
                    }
                }
                //右上
                if (List_con[i - 1] == stringCount - 1) {
                    if (matrix[0][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount - 2);
                    }
                    if (matrix[1][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * 2 - 1);
                    }
                }
                //上排
                if (List_con[i - 1] > 0 && List_con[i - 1] < stringCount - 1) {
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
            } //連結下點
            else if ((input1 - 1) == stringCount - 1) {
                uf.union(List_con[i - 1], stringCount * stringCount + 1);
                //右下
                if (List_con[i - 1] == stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * (stringCount - 1) - 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], stringCount * stringCount - 2);
                    }
                }
                //左下
                if (List_con[i - 1] == stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * (stringCount - 1));
                    }
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                }

                //下排
                if (List_con[i - 1] > stringCount * (stringCount - 1) && List_con[i - 1] < stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }

            } else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1) {
                //左排
                if (List_con[i - 1] % stringCount == 0 && List_con[i - 1] != 0 && List_con[i - 1] != stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                }
                //右排
                if (List_con[i - 1] % stringCount == stringCount - 1 && List_con[i - 1] != stringCount - 1 && List_con[i - 1] != stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                } //中間
                else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1 && input2 - 1 != 0 && input2 - 1 != stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }

            }

            //判斷是否連接
            if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == true) {
 //               System.out.println(""output:"");
                System.out.println((input1) + "","" + (input2));
                break;
            }

        }
        if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == false) {
            System.out.println(""-1"");

        }
        //                   System.out.println(numbersArray.length);
    }
}
//

@616434db8a11dec24e75cd2190c34fc8@"
"r03631015","0","1.56","178416","@066a582410528b9780ab1a83d8322337@
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int NumOfmatrix = size * size + 2;

            //build checkmatrix which is bigger than old matrix and cover it
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(NumOfmatrix);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point matrixNum-1
            for (int i = NumOfmatrix - size-1; i <= NumOfmatrix - 2; i++) {
                uf.union(i, NumOfmatrix-1);
            }
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
            int matrixnum = 0;
            boolean endflag = false;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
//                    System.out.printf(""%d,%d\n"", row, column);
                    matrixnum = size * (row - 1) + column;
                    //mark the announced site
                     checkmatrix[row][column] = true;

                    //check up, down, left, right side of announced site
                    while (checkmatrix[row - 1][column]) {
                        uf.union(matrixnum, matrixnum - size);
                        break;
                    }
                    while (checkmatrix[row + 1][column]) {
                        uf.union(matrixnum, matrixnum + size);
                        break;
                    }
                    while (checkmatrix[row][column - 1]) {
                        uf.union(matrixnum, matrixnum - 1);
                        break;
                    }
                    while (checkmatrix[row][column + 1]) {
                        uf.union(matrixnum, matrixnum + 1);
                        break;
                    }
                    while(uf.connected(0, NumOfmatrix-1)){
                        endflag = true;
                        break;
                    }
                    if(endflag == true)
                        break;
            } 
            
            if(endflag != true){
                System.out.printf(""-1"");
            }
            else
                System.out.printf(""%d,%d"", row, column);
        }
    }
}

@066a582410528b9780ab1a83d8322337@"
"b03611011","7","0.91","122048","@fb7dd6756717db6e1e943febf2d20121@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = (p - 1) / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                    tf = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num - 1) {
            switch (tep) {
                case 1:
                    for (int i = 1; i <= num - quotient && id[p + i] != 0; i++) {
                        if (id[p + i] == 2) {
                            id[p + i] = 1;
                        }
                    }
                    for (int i = 1; i <= num - 1 && id[p + num * i] != 0; i++) {
                        if (id[p + num * i] == 2) {
                            id[p + num * i] = 1;
                        }
                    }
                    break;
                case 0:
                    for (int i = 1; i <= quotient - 1 && id[p - i] != 0; i++) {
                        if (id[p - 1] == 2) {
                            id[p - 1] = 1;
                        }
                    }
                    for (int i = 1;
                            i <= num - 1 && id[p + num * i] != 0; i++) {
                        if (id[p + num * i] == 2) {
                            id[p + num * i] = 1;
                        }
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
        }
        //check connective
        for (int i = 1; i < num; i++) {
            for (int j = 2; j < num; j++) {
                int g = num * (i) + j;
                if (id[j * num + 1] == 1) {
                    if (id[j * num + 2] == 2) {
                        id[j * num + 2] = 1;
                    }
                }
                if (id[g] == 1) {
                    if (id[g + 1] == 2) {
                        id[g + 1] = 1;
                    }
                    if (id[g - 1] == 2) {
                        id[g - 1] = 1;
                    }
                    if (id[g + num] == 2) {
                        id[g + num] = 1;
                    }
                    if (id[g - num] == 2) {
                        id[g - num] = 1;
                        i--;
                        j--;
                    }
                }
            }
            if (id[i * num] == 1) {
                if (id[i * num + num] == 2) {
                    id[i * num + num] =1;
                }
            }
        }

        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@fb7dd6756717db6e1e943febf2d20121@"
"r03631015","0","1.37","156048","@7b2d86171b6e64f1829e1e2adfdda718@import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {
//        read size
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
//            UF basic setting
            UF uf = new UF(num * num + 2);
            for (int i = 1; i <= num; i++) {
                uf.union(0, i);
                uf.union(num * num + 1, num * num + 1 - i);
            }
//            record open/colse coordinate
            boolean[] dataMatrix = new boolean[num * num + 2];
            int position;
            while (br.ready()) {
//                read open coordinate
                String[] Open = br.readLine().split("","");
                position = (Integer.parseInt(Open[0]) - 1) * num + Integer.parseInt(Open[1]);
                dataMatrix[position] = true;
//                start union
//                upside
                if (position - num > 0) {
                    if (dataMatrix[position - num]) {
                        uf.union(position - num, position);
                    }
                }
//                left side
                if (position - 1 > 0) {
                    if (dataMatrix[position - 1]) {
                        uf.union(position - 1, position);
                    }
                }
//                right side
                if (position + 1 < num * num + 1) {
                    if (dataMatrix[position + 1]) {
                        uf.union(position + 1, position);
                    }
                }
//                lower side
                if (position + num < num * num + 1) {
                    if (dataMatrix[position + num]) {
                        uf.union(position + num, position);
                    }
                }
//                connect confirm
                if (uf.connected(0, num * num + 1)) {
                    System.out.printf(""%s,%s\n"", Open[0], Open[1]);
                    break;
                }
                
            }
//            false reaction
            if(uf.connected(0, num*num+1)==false){
                    System.out.println(-1);
                }
        }

    }
}

@7b2d86171b6e64f1829e1e2adfdda718@"
"r03631015","0","0.91","122048","@713345a32dbe038f1675d0d95c41a357@import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {
//        read size
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
//            UF basic setting
            UF uf = new UF(num * num + 2);
            for (int i = 1; i <= num; i++) {
                uf.union(0, i);
                uf.union(num * num + 1, num * num + 1 - i);
            }
//            record open/colse coordinate
            boolean[] dataMatrix = new boolean[num * num + 2];
            int position;
            while (br.ready()) {
//                read open coordinate
                String[] Open = br.readLine().split("","");
                position = (Integer.parseInt(Open[0]) - 1) * num + Integer.parseInt(Open[1]);
                dataMatrix[position] = true;
//                start union
//                upside
                if (position - num > 0) {
                    if (dataMatrix[position - num]) {
                        uf.union(position - num, position);
                    }
                }

//                left side
                if (position - 1 > 0) {
                    if (dataMatrix[position - 1]) {
                        uf.union(position - 1, position);
                    }
                }
//                right side
                if (position + 1 < num * num + 1) {
                    if (dataMatrix[position + 1]) {
                        uf.union(position + 1, position);
                    }
                }

//                lower side
                if (position + num < num * num + 1) {
                    if (dataMatrix[position + num]) {
                        uf.union(position + num, position);
                    }
                }
//                connect confirm
                if (uf.connected(0, num * num + 1)) {
                    System.out.printf(""%s,%s\n"", Open[0], Open[1]);
                    break;
                }
                
            }
//            false reaction
            if(uf.connected(0, num*num+1)==false){
                    System.out.println(-1);
                }
        }

    }
}

@713345a32dbe038f1675d0d95c41a357@"
"r03631015","0","0.74","107328","@c3ceedc5a9d2a14c9fd0cde55ba739f5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author wayne17
 */
public class Percolation {
    /**
     * @param args the command line arguments
     */
     public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            // read a line and split by ','
            String[] initial = br.readLine().split("","");
            int size = Integer.parseInt(initial[0]);
            
            //declare two matrix, default false
            boolean[][] input  = new boolean[size][size];
            boolean[][] result  = new boolean[size][size];
            
            String[] anounce;
            int x, y;
            while (br.ready()) {
                //read anounce
                anounce = br.readLine().split("","");
                x = Integer.parseInt(anounce[0])-1;
                y = Integer.parseInt(anounce[1])-1;
                input[y][x] = true;
                System.out.printf(""(%d,%d)\n"",x,y);
                if (y > 0) {
                    for (int i = y; i < size; i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                else {
                    result[y]=input[y];
                    for (int i =y+1;i<size;i++){
                        result[i] = compare(result[i-1], input[i]);
                    }
                }
                //is_percolation
                if(is_percolation(result[size-1])){
                    System.out.printf(""%d,%d"", x+1, y+1);
                    break;
                }
            }
            if(!is_percolation(result[size-1])){
                System.out.printf(""false"");
            }
        }
    }
     public static boolean[] compare(boolean[] upper,boolean[] lower) {
         int size = upper.length;
         int left_index;
         boolean[] compared  = new boolean[size];
         /////
         System.out.printf(""upper :"");
         for(int j = 0; j<size; j++) {
                    System.out.printf(""%b,"",upper[j]);
                 }
                 System.out.printf(""\n"");
         System.out.printf(""lower :"");
         for(int j = 0; j<size; j++) {
                    System.out.printf(""%b,"",lower[j]);
                 }
                 System.out.printf(""\n"");
         /////
         for (int i = 0; i < size; i++) {
             if (upper[i] & lower[i]) {
                 compared[i] = true;
                 //left_flow
                left_index= i-1;
                while(left_index >= 0) {
                    if (lower[left_index]){
                        compared[left_index] = true;
                    }
                    else {
                        break;
                    }
                    left_index = left_index-1;  
                }
//                 right_flow
                while(i<size) {
                    if (lower[i]) {
                        compared[i] =true;
                        i++;
                    }
                    else {
                        break;
                    }
                }
             }
         }
         /////
         System.out.printf(""result:"");
         for(int j = 0; j<size; j++) {
                    System.out.printf(""%b,"",compared[j]);
                 }
                 System.out.printf(""\n\n"");
         /////
         return compared;
     }
     public static boolean is_percolation(boolean[] bottom) {
         int length = bottom.length;
         boolean contain = false;
         for (int i= 0; i < length; i++) {
             if (bottom[i]) {
                 contain = true;
                 break;
             }
         }
         return contain;
     }
}
@c3ceedc5a9d2a14c9fd0cde55ba739f5@"
"r04631012","0","0.91","122048","@3e777d06c732344491120971022fb3e8@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }

    public static void main(String[] args) throws Exception {
        Percolation Pe = new Percolation();

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int MatrixSize = Integer.parseInt(data[0]);
            Pe.Percolation(MatrixSize);

            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                }while (br.readLine() != null);
                if (!Pe.percolates()) {
                    System.out.println(""-1"");
                }
            }
            
            
        }

    
}

@3e777d06c732344491120971022fb3e8@"
"r03631015","0","0.91","122048","@066a582410528b9780ab1a83d8322337@
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 * @author huangchienpeng
 */
public class Percolation {

    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(data[0]);
            // 0 ~ n*n+1 for one start point and end point
            int NumOfmatrix = size * size + 2;

            //build checkmatrix which is bigger than old matrix and cover it
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i < size+2; i++) {
                for (int j = 0; j < size+2; j++) {
                    checkmatrix[i][j] = false;
                }
            }

            UF uf = new UF(NumOfmatrix);
            //connect first row to start point 0
            for (int i = 1; i <= size; i++) {
                uf.union(i, 0);
            }
            //connect last row to end point matrixNum-1
            for (int i = NumOfmatrix - size-1; i <= NumOfmatrix - 2; i++) {
                uf.union(i, NumOfmatrix-1);
            }
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
            int matrixnum = 0;
            boolean endflag = false;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
//                    System.out.printf(""%d,%d\n"", row, column);
                    matrixnum = size * (row - 1) + column;
                    //mark the announced site
                     checkmatrix[row][column] = true;

                    //check up, down, left, right side of announced site
                    while (checkmatrix[row - 1][column]) {
                        uf.union(matrixnum, matrixnum - size);
                        break;
                    }
                    while (checkmatrix[row + 1][column]) {
                        uf.union(matrixnum, matrixnum + size);
                        break;
                    }
                    while (checkmatrix[row][column - 1]) {
                        uf.union(matrixnum, matrixnum - 1);
                        break;
                    }
                    while (checkmatrix[row][column + 1]) {
                        uf.union(matrixnum, matrixnum + 1);
                        break;
                    }
                    while(uf.connected(0, NumOfmatrix-1)){
                        endflag = true;
                        break;
                    }
                    if(endflag == true)
                        break;
            } 
            
            if(endflag != true){
                System.out.printf(""-1"");
            }
            else
                System.out.printf(""%d,%d"", row, column);
        }
    }
}

@066a582410528b9780ab1a83d8322337@"
"r04631012","0","1.37","156048","@78419bd5af706ca3a01f0c01c2cde800@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }

    public static void main(String[] args) throws Exception {
        Percolation Pe = new Percolation();

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int MatrixSize = Integer.parseInt(data[0]);
            Pe.Percolation(MatrixSize);

            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                }
                }while (br.readLine() != null);
                    if (!Pe.percolates()) {
                    System.out.println(""-1"");
                }
                       
        }

    
}

@78419bd5af706ca3a01f0c01c2cde800@"
"r03631015","10","0.102","124720","@cda9fb8906def9c2785718e1e736751b@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    public static void main(String[] args) throws Exception {
//        read size
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
//            UF basic setting
            UF uf = new UF(num * num + 2);
            for (int i = 1; i <= num; i++) {
                uf.union(0, i);
                uf.union(num * num + 1, num * num + 1 - i);
            }
//            record open/colse coordinate
            boolean[] dataMatrix = new boolean[num * num + 2];
            int position;
            while (br.ready()) {
//                read open coordinate
                String[] Open = br.readLine().split("","");
                position = (Integer.parseInt(Open[0]) - 1) * num + Integer.parseInt(Open[1]);
                dataMatrix[position] = true;
//                start union
//                upside
                if (position - num > 0) {
                    if (dataMatrix[position - num]) {
                        uf.union(position - num, position);
                    }
                }
//                left side
                if (position - 1 > 0) {
                    if (dataMatrix[position - 1]) {
                        uf.union(position - 1, position);
                    }
                }
//                right side
                if (position + 1 < num * num + 1) {
                    if (dataMatrix[position + 1]) {
                        uf.union(position + 1, position);
                    }
                }
//                lower side
                if (position + num < num * num + 1) {
                    if (dataMatrix[position + num]) {
                        uf.union(position + num, position);
                    }
                }
//                connect confirm
                if (uf.connected(0, num * num + 1)) {
                    System.out.printf(""%s,%s\n"", Open[0], Open[1]);
                    break;
                }
                
            }
//            false reaction
            if(uf.connected(0, num*num+1)==false){
                    System.out.println(-1);
                }
        }

    }
}

@cda9fb8906def9c2785718e1e736751b@"
"r04631012","0","0.74","107328","@46d5fb7d9effd9decd49e62dc1e75dac@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }

    public static void main(String[] args) throws Exception {
        Percolation Pe = new Percolation();

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int MatrixSize = Integer.parseInt(data[0]);
            Pe.Percolation(MatrixSize);

            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                    }
                }while (br.readLine() != null);
                    if (!Pe.percolates()) {
                    System.out.println(""-1"");
                    }
                       
        }
    
    }
@46d5fb7d9effd9decd49e62dc1e75dac@"
"r04631012","0","0.91","122048","@f98d372e0db1d5e020bc0cfaf911ee1b@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }

    public static void main(String[] args) throws Exception {
        Percolation Pe = new Percolation();

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int MatrixSize = Integer.parseInt(data[0]);
            Pe.Percolation(MatrixSize);

            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                    }
                }while (br.readLine() != null);
                    if (!Pe.percolates()) {
                    System.out.println(""-1"");
                    }
                       
        }
    
    }
@f98d372e0db1d5e020bc0cfaf911ee1b@"
"b03611038","10","0.145","155376","@23c13d962ba66b9788da1391a9425bff@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
      
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            String buffer ;
            String data = """";
            int n = Integer.parseInt(N[0]);
            
            int[][] matrix = new int[n+2][n+2];
            
            
             UF uf = new UF(n*n+2);
            int i = 0;
        
           buffer = br.readLine();
           while(buffer!=null){
           data = data.concat(buffer);
           data = data.concat("","");
           i++;
           buffer = br.readLine();
           }
            int q = 0;
           String[] newdata =  data.split("","");    
           
            int[] Data = new int[2*i];
            for(q = 0;q<2*i;q++){
             Data[q] = Integer.parseInt(newdata[q]);
            }
            for(q = 0; q<2*i ; q+=2){
                int a = Data[q];
                int b =Data[q+1];
                matrix[a][b] = 1;
            if(a == 1){
                uf.union(n*n, b-1);
                //System.out.print(uf.find((a-1)*n+b-1));
            }    
            if(a == n){
            uf.union(n*n+1, (a-1)*n+b-1);
            //System.out.print(uf.find((a-1)*n+b-1));
            }
           if(a<n+1 && b<n+1 && matrix[a][b+1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b);
           }  
           if(a<n+1 && b<n+1 && matrix[a][b-1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b-2);
           } 
           if(a<n+1 && b<n+1 && matrix[a+1][b] == 1){
           uf.union((a-1)*n+b-1, a*n+b-1);
           } 
           if(a<n+1 && b<n+1 && matrix[a-1][b] == 1){
           uf.union((a-1)*n+b-1, (a-2)*n+b-1);
           } 
            if(uf.connected(n*n, n*n+1)){
            System.out.print(a);
            System.out.print("","");
            System.out.print(b);
            break;            
            }
            }
            if(!uf.connected(n*n, n*n+1)){
            System.out.print(-1);
            }
            
            
           
            
                
            }
            
                      
    }   
}

@23c13d962ba66b9788da1391a9425bff@"
"b03611011","8","0.78","129680","@6605bd200b0c4ef44abf1ced0c9bd4a8@
import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static int id[], count[];
    private static int num, tf = 0, tep;
    private static int number;
    private static final int v = 2;

    public static void union(int p) {
        int quotient;
        int pid = id[p];
        tf = 0;
        tep = (p - 1) / num;
        quotient = p % num;
        switch (tep) {
            case 0:
                id[p] = 1;
                if (id[p + num] > 0) {
                    id[p + num] = 1;
                    tf = 1;
                }
                break;
            default:
                switch (quotient) {
                    case 1:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    case 0:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                    default:
                        if (id[p - num] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p + 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (id[p - 1] == 1) {
                            id[p] = 1;
                            tf = 1;
                        }
                        if (tep >= num - 1) {
                            break;
                        } else {
                            if (id[p + num] == 1) {
                                id[p] = 1;
                                tf = 1;
                            }
                        }
                        break;
                }
        }
//左右同步
        if (tf == 1 && quotient < num - 1) {
            switch (tep) {
                case 1:
                    for (int i = 1; i <= num - quotient && id[p + i] != 0; i++) {
                        if (id[p + i] == 2) {
                            id[p + i] = 1;
                        }
                    }
                    for (int i = 1;
                            i <= num - 1 && id[p + num ] != 0;
                            i++) {
                        if (id[p + num ] == 2) {
                            id[p + num ] = 1;
                        }
                    }
                    break;
                case 0:
                    for (int i = 1; i <= quotient - 1 && id[p - i] != 0; i++) {
                        if (id[p - 1] == 2) {
                            id[p - 1] = 1;
                        }
                    }
                    for (int i = 1;
                            i <= num - 1 && id[p + num * i] != 0; i++) {
                        if (id[p + num * i] == 2) {
                            id[p + num * i] = 1;
                        }
                    }
                    break;
                default:
                    if (id[p + 1] == 2) {
                        id[p + 1] = 1;
                    }
                    if (id[p - 1] == 2) {
                        id[p - 1] = 1;
                    }
                    break;
            }
        }
        //check connective
        if(tf==1){
        for (int i = 1; i < num; i++) {
            for (int j = 2; j < num; j++) {
                int g = num * (i) + j;
                if (id[j * num + 1] == 1) {
                    if (id[j * num + 2] == 2) {
                        id[j * num + 2] = 1;
                    }
                }
                if (id[g] == 1) {
                    if (id[g + 1] == 2) {
                        id[g + 1] = 1;
                    }
                    if (id[g - 1] == 2) {
                        id[g - 1] = 1;
                    }
                    if (id[g + num] == 2) {
                        id[g + num] = 1;
                    }
                    if (id[g - num] == 2) {
                        id[g - num] = 1;
                        i--;
                        j--;
                    }
                }
            }
            
            if (id[i * num] == 1) {
                if (id[i * num + num] == 2) {
                    id[i * num + num] =1;
                }
            }
        }
        }
        for (int i = 0; i < num; i++) {
            if (id[num * (num - 1) + 1 + i] == 1) {
                tf = -1;
                return;
            }
        }
    }

    public static void point(int x, int y) {
        number = 0;
        number = (x - 1) * num + y;
    }

    public static void main(String[] args) throws Exception {
        String data;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] sum = br.readLine().split("","");
            num = Integer.parseInt(sum[0]);
            int cube[] = new int[num * num + 2];
            id = cube.clone();
            for (int i = 0; i < cube.length; i++) {
                cube[i] = i;
                id[i] = 0;
            }
            id[0] = 1;
            String[] data1;
            int j = 1;
            count = new int[2];
            number = 0;
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 2;
                union(number);
                if (tf == -1) {
                    System.out.println(count[0] + "","" + count[1]);
                    break;
                }
            }
            if (data == null) {
                System.out.println(-1);
            }
        }
    }
}

@6605bd200b0c4ef44abf1ced0c9bd4a8@"
"r04631012","0","0.74","107328","@bb609ee48bee32b2b4cc226d2f5b0aaf@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }

    public static void main(String[] args) throws Exception {
        Percolation Pe = new Percolation();

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int MatrixSize = Integer.parseInt(data[0]);
            Pe.Percolation(MatrixSize);

            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                    }
                }while (br.readLine() != null);
                    if (!Pe.percolates()) {
                    System.out.println(""-1"");
                    }
                       
        }
    }
}
@bb609ee48bee32b2b4cc226d2f5b0aaf@"
"r04631012","0","0.145","155376","@c2f5224aa681d32e98b0cf9f2b037f24@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    
    public static void main(String[] args) throws Exception {
        Percolation Pe = new Percolation();

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int MatrixSize = Integer.parseInt(data[0]);
            Pe.Percolation(MatrixSize);

            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                    }
                }while (br.readLine() != null);
                    if (!Pe.percolates()) {
                    System.out.println(""-1"");
                    }
                       
        }
    }
}
@c2f5224aa681d32e98b0cf9f2b037f24@"
"r04631012","0","0.78","129680","@f161d478163265fd3c809c34d5762929@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    }
    public static void main(String[] args) throws Exception {
        Percolation Pe = new Percolation();

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int MatrixSize = Integer.parseInt(data[0]);
            Pe.Percolation(MatrixSize);

            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                    }
                }while (br.readLine() != null);
                    if (!Pe.percolates()) {
                    System.out.println(""-1"");
                    }
                       
        }
    }
}
@f161d478163265fd3c809c34d5762929@"
"r04631012","2","0.45","105568","@1eb0d799fc947f306ba838bd84b506f2@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            
            int MatrixSize = Integer.parseInt(data[0]);
            Percolation Pe = new Percolation(MatrixSize);

            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                    }
                }while (br.readLine() != null);
                    if (!Pe.percolates()) {
                    System.out.println(""-1"");
                    }
                       
        }
    }
}
@1eb0d799fc947f306ba838bd84b506f2@"
"r04631035","9","2.22","172240","@b121daf2d003b5c7ecaa5daf468f8209@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;

public class Percolation {

    public static void main(String[] args) {

        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
//                    System.out.println(target);
        String[] numbersArray = target.split("" "");
        for (int i = 0; i < numbersArray.length; i++) {
//                              System.out.println(numbersArray[i]);
        }

        String[] num = numbersArray[0].split("",""); //維度
        int stringCount = Integer.parseInt(num[0]); //轉數字
        int[][] matrix = new int[stringCount][stringCount]; //建立空矩陣

//                    String[] num2 = numbersArray[1].split("","");                    
//                    System.out.println(numbersArray.length);     
        UF uf = new UF(stringCount * stringCount + 2);  //開List
        //                   ArrayList<Integer> Column = new ArrayList<Integer>();

        String[] data = numbersArray[2].split("",""); //讀取input
        int[] List_con = new int[numbersArray.length];

        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);

            matrix[input1 - 1][input2 - 1] = 1; //位置從0,0開始
            List_con[i - 1] = (input1 - 1) * stringCount + (input2 - 1); //放入白點(編號)

//          System.out.println(List_con);
            //連結上點
            if ((input1 - 1) == 0) {
                uf.union(List_con[i - 1], stringCount * stringCount);
                //左上
                if (List_con[i - 1] == 0) {
                    if (matrix[0][1] == 1) {
                        uf.union(List_con[i - 1], 1);
                    }
                    if (matrix[1][0] == 1) {
                        uf.union(List_con[i - 1], stringCount);
                    }
                }
                //右上
                if (List_con[i - 1] == stringCount - 1) {
                    if (matrix[0][stringCount - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1 );
                    }
                    if (matrix[1][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
                //上排
                if (List_con[i - 1] > 0 && List_con[i - 1] < stringCount - 1) {
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
            } //連結下點
            else if ((input1 - 1) == stringCount - 1) {
                uf.union(List_con[i - 1], stringCount * stringCount + 1);
                //右下
                if (List_con[i - 1] == stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], stringCount * (stringCount - 1) - 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], stringCount * stringCount - 2);
                    }
                }
                //左下
                if (List_con[i - 1] == stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                }

                //下排
                if (List_con[i - 1] > stringCount * (stringCount - 1) && List_con[i - 1] < stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }

            } else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1) {
                //左排
                if (List_con[i - 1] % stringCount == 0 && List_con[i - 1] != 0 && List_con[i - 1] != stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                }
                //右排
                if (List_con[i - 1] % stringCount == stringCount - 1 && List_con[i - 1] != stringCount - 1 && List_con[i - 1] != stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                } //中間
                else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1 && input2 - 1 != 0 && input2 - 1 != stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }

            }

            //判斷是否連接
            if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == true) {
 //               System.out.println(""output:"");
                System.out.println((input1) + "","" + (input2));
                break;
            }

        }
        if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == false) {
            System.out.println(""-1"");

        }
        //                   System.out.println(numbersArray.length);
    }
}
//

@b121daf2d003b5c7ecaa5daf468f8209@"
"r04631012","2","0.45","105536","@6694285ec6fc5417fd28dabc800ccd48@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            
            int MatrixSize = Integer.parseInt(data[0]);
            Percolation Pe = new Percolation(MatrixSize);

            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                    }
                }while (br.readLine() != null);
                    System.out.println(""-1"");
                       
        }
    }
}
@6694285ec6fc5417fd28dabc800ccd48@"
"r04631035","9","2.21","172192","@e9cbb7703565e1179301b8fbc1315c2b@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;

public class Percolation {

    public static void main(String[] args) {

        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
//                    System.out.println(target);
        String[] numbersArray = target.split("" "");
        for (int i = 0; i < numbersArray.length; i++) {
//                              System.out.println(numbersArray[i]);
        }

        String[] num = numbersArray[0].split("",""); //維度
        int stringCount = Integer.parseInt(num[0]); //轉數字
        int[][] matrix = new int[stringCount][stringCount]; //建立空矩陣

//                    String[] num2 = numbersArray[1].split("","");                    
//                    System.out.println(numbersArray.length);     
        UF uf = new UF(stringCount * stringCount + 2);  //開List
        //                   ArrayList<Integer> Column = new ArrayList<Integer>();

        String[] data = numbersArray[2].split("",""); //讀取input
        int[] List_con = new int[numbersArray.length];

        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);

            matrix[input1 - 1][input2 - 1] = 1; //位置從0,0開始
            List_con[i - 1] = (input1 - 1) * stringCount + (input2 - 1); //放入白點(編號)

//          System.out.println(List_con);
            //連結上點
            if ((input1 - 1) == 0) {
                uf.union(List_con[i - 1], stringCount * stringCount);
                //左上
                if (List_con[i - 1] == 0) {
                    if (matrix[0][1] == 1) {
                        uf.union(List_con[i - 1], 1);
                    }
                    if (matrix[1][0] == 1) {
                        uf.union(List_con[i - 1], stringCount);
                    }
                }
                //右上
                if (List_con[i - 1] == stringCount - 1) {
                    if (matrix[0][stringCount - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1 );
                    }
                    if (matrix[1][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
                //上排
                if (List_con[i - 1] > 0 && List_con[i - 1] < stringCount - 1) {
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
            } //連結下點
            else if ((input1 - 1) == stringCount - 1) {
                uf.union(List_con[i - 1], stringCount * stringCount + 1);
                //右下
                if (List_con[i - 1] == stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }
                //左下
                if (List_con[i - 1] == stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                }

                //下排
                if (List_con[i - 1] > stringCount * (stringCount - 1) && List_con[i - 1] < stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }

            } else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1) {
                //左排
                if (List_con[i - 1] % stringCount == 0 && List_con[i - 1] != 0 && List_con[i - 1] != stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                }
                //右排
                if (List_con[i - 1] % stringCount == stringCount - 1 && List_con[i - 1] != stringCount - 1 && List_con[i - 1] != stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                } //中間
                else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1 && input2 - 1 != 0 && input2 - 1 != stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }

            }

            //判斷是否連接
            if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == true) {
 //               System.out.println(""output:"");
                System.out.println((input1) + "","" + (input2));
                break;
            }

        }
        if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == false) {
            System.out.println(""-1"");

        }
        //                   System.out.println(numbersArray.length);
    }
}
//

@e9cbb7703565e1179301b8fbc1315c2b@"
"r04631012","0","0","0","@5667a13a6916156990c0507efbadfe97@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            
            int MatrixSize = Integer.parseInt(data[0]);
            Percolation Pe = new Percolation(MatrixSize);
            
            String line;
            String target = """";
            while ((line = br.readLine()) != null) {
            target += line + "" "";
             }
             //     System.out.println(target);
        String[] numbersArray = target.split("" "");
            do {
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    break;
                    }
                }while (br.readLine() != null);
                    System.out.println(""-1"");
                       
        }
    }
}
@5667a13a6916156990c0507efbadfe97@"
"r04631035","9","2.22","169904","@4420f0c06c7ebfe6af9607699de04177@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;

public class Percolation {

    public static void main(String[] args) {

        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
//                    System.out.println(target);
        String[] numbersArray = target.split("" "");

        String[] num = numbersArray[0].split("",""); //維度
        int stringCount = Integer.parseInt(num[0]); //轉數字
        int[][] matrix = new int[stringCount][stringCount]; //建立空矩陣
 
        UF uf = new UF(stringCount * stringCount + 2);  //開List
        //                   ArrayList<Integer> Column = new ArrayList<Integer>();

        String[] data = numbersArray[2].split("",""); //讀取input
        int[] List_con = new int[numbersArray.length];

        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);

            matrix[input1 - 1][input2 - 1] = 1; //位置從0,0開始
            List_con[i - 1] = (input1 - 1) * stringCount + (input2 - 1); //放入白點(編號)

//          System.out.println(List_con);
            //連結上點
            if ((input1 - 1) == 0) {
                uf.union(List_con[i - 1], stringCount * stringCount);
                //左上
                if (List_con[i - 1] == 0) {
                    if (matrix[0][1] == 1) {
                        uf.union(List_con[i - 1], 1);
                    }
                    if (matrix[1][0] == 1) {
                        uf.union(List_con[i - 1], stringCount);
                    }
                }
                //右上
                if (List_con[i - 1] == stringCount - 1) {
                    if (matrix[0][stringCount - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1 );
                    }
                    if (matrix[1][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
                //上排
                if (List_con[i - 1] > 0 && List_con[i - 1] < stringCount - 1) {
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
            } //連結下點
            else if ((input1 - 1) == stringCount - 1) {
                uf.union(List_con[i - 1], stringCount * stringCount + 1);
                //右下
                if (List_con[i - 1] == stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }
                //左下
                if (List_con[i - 1] == stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                }

                //下排
                if (List_con[i - 1] > stringCount * (stringCount - 1) && List_con[i - 1] < stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }

            } else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1) {
                //左排
                if (List_con[i - 1] % stringCount == 0 && List_con[i - 1] != 0 && List_con[i - 1] != stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                }
                //右排
                if (List_con[i - 1] % stringCount == stringCount - 1 && List_con[i - 1] != stringCount - 1 && List_con[i - 1] != stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                } //中間
                else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1 && input2 - 1 != 0 && input2 - 1 != stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }

            }

            //判斷是否連接
            if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == true) {
 //               System.out.println(""output:"");
                System.out.println((input1) + "","" + (input2));
                break;
            }

        }
        if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == false) {
            System.out.println(""-1"");

        }
        //                   System.out.println(numbersArray.length);
    }
}
//

@4420f0c06c7ebfe6af9607699de04177@"
"r04631012","0","0","0","@ff2d102f35add3ed5225a367cae38e8d@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            
            int MatrixSize = Integer.parseInt(data[0]);
            Percolation Pe = new Percolation(MatrixSize);
            
            String line;
            String target = """";
            while ((line = br.readLine()) != null) {
            target += line + "" "";
             }
             //     System.out.println(target);
            String[] numbersArray = target.split("" "");
                
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    }
                while (br.readLine() != null);
                    System.out.println(""-1"");
                       
        }
    }
}
@ff2d102f35add3ed5225a367cae38e8d@"
"r04631012","0","0","0","@e3f90f7de26b473b7ff169e73a62dd39@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            
            int MatrixSize = Integer.parseInt(data[0]);
            Percolation Pe = new Percolation(MatrixSize);
            
            String line;
            String target = """";
            while ((line = br.readLine()) != null) {
            target += line + "" "";
             }
             //     System.out.println(target);
            String[] numbersArray = target.split("" "");
                
                int row = 0, column = 0;
                String[] data2 = br.readLine().split("","");
                row = Integer.parseInt(data2[0]);
                column = Integer.parseInt(data2[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    }
                while (br.readLine() != null);
                    if(!Pe.percolates()){
                    System.out.println(""-1"");
                    }
        }
    }
}
@e3f90f7de26b473b7ff169e73a62dd39@"
"r04631012","0","0","0","@aa95c58de8fee9662a689a004ce9ea65@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            
            int MatrixSize = Integer.parseInt(data[0]);
            Percolation Pe = new Percolation(MatrixSize);
            
            String line;
            String target = """";
            while ((line = br.readLine()) != null) {
            target += line + "" "";
             }
             //     System.out.println(target);
            String[] numbersArray = target.split("" "");
                
                int row = 0, column = 0;
                row = Integer.parseInt(numbersArray[0]);
                column = Integer.parseInt(numbersArray[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    }
                while (br.readLine() != null);
                    System.out.println(""-1"");
                       
        }
    }
}
@aa95c58de8fee9662a689a004ce9ea65@"
"r04631035","9","2.26","167008","@b66b036e464f361a55e288337b9dd1a1@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;

public class Percolation {

    public static void main(String[] args) {

        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
//                    System.out.println(target);
        String[] numbersArray = target.split("" "");

        String[] num = numbersArray[0].split("",""); //維度
        int stringCount = Integer.parseInt(num[0]); //轉數字
        int[][] matrix = new int[stringCount][stringCount]; //建立空矩陣
 
        UF uf = new UF(stringCount * stringCount + 2);  //開List
        //                   ArrayList<Integer> Column = new ArrayList<Integer>();

        String[] data = numbersArray[2].split("",""); //讀取input
        int[] List_con = new int[numbersArray.length];

        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);

            matrix[input1 - 1][input2 - 1] = 1; //位置從0,0開始
            List_con[i - 1] = (input1 - 1) * stringCount + (input2 - 1); //放入白點(編號)

//          System.out.println(List_con);
            //連結上點
            if ((input1 - 1) == 0) {
                uf.union(List_con[i - 1], stringCount * stringCount);
                //左上
                if (List_con[i - 1] == 0) {
                    if (matrix[0][1] == 1) {
                        uf.union(List_con[i - 1], 1);
                    }
                    if (matrix[1][0] == 1) {
                        uf.union(List_con[i - 1], stringCount);
                    }
                }
                //右上
                if (List_con[i - 1] == stringCount - 1) {
                    if (matrix[0][stringCount - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1 );
                    }
                    if (matrix[1][stringCount - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
                //上排
                if (List_con[i - 1] > 0 && List_con[i - 1] < stringCount - 1) {
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }
            } //連結下點
            else if ((input1 - 1) == stringCount - 1) {
                uf.union(List_con[i - 1], stringCount * stringCount + 1);
                //右下
                if (List_con[i - 1] == stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }
                //左下
                if (List_con[i - 1] == stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) {
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                }

                //下排
                if (List_con[i - 1] > stringCount * (stringCount - 1) && List_con[i - 1] < stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                }

            } else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1) {
                //左排
                if (List_con[i - 1] % stringCount == 0 && List_con[i - 1] != 0 && List_con[i - 1] != stringCount * (stringCount - 1)) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                }
                //右排
                if (List_con[i - 1] % stringCount == stringCount - 1 && List_con[i - 1] != stringCount - 1 && List_con[i - 1] != stringCount * stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }

                } //中間
                else if ((input1 - 1) != 0 && (input1 - 1) != stringCount - 1 && input2 - 1 != 0 && input2 - 1 != stringCount - 1) {
                    if (matrix[input1 - 2][input2 - 1] == 1) { //上
                        uf.union(List_con[i - 1], List_con[i - 1] - stringCount);
                    }
                    if (matrix[input1 - 1][input2 - 2] == 1) { //左
                        uf.union(List_con[i - 1], List_con[i - 1] - 1);
                    }
                    if (matrix[input1 - 1][input2] == 1) { //右
                        uf.union(List_con[i - 1], List_con[i - 1] + 1);
                    }
                    if (matrix[input1][input2 - 1] == 1) { //下
                        uf.union(List_con[i - 1], List_con[i - 1] + stringCount);
                    }
                }

            }

            //判斷是否連接
            if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == true) {
 //               System.out.println(""output:"");
                System.out.println((input1) + "","" + (input2));
                break;
            }

        }
        if (uf.connected(stringCount * stringCount, stringCount * stringCount + 1) == false) {
            System.out.println(-1);

        }
        //                   System.out.println(numbersArray.length);
    }
}
//

@b66b036e464f361a55e288337b9dd1a1@"
"r04631012","0","0","0","@52f3dbeb27ee09b01710727aa87af19b@import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            
            int MatrixSize = Integer.parseInt(data[0]);
            Percolation Pe = new Percolation(MatrixSize);
            
            String line;
            String target = """";
            while ((line = br.readLine()) != null) {
            target += line + "" "";
            
            //     System.out.println(target);
            String[] numbersArray = target.split("" "");
                
                int row = 0, column = 0;
                row = Integer.parseInt(numbersArray[0]);
                column = Integer.parseInt(numbersArray[1]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    }
                while (br.readLine() != null);
                    System.out.println(""-1"");
            }       
        }
    }
}
@52f3dbeb27ee09b01710727aa87af19b@"
"r04228027","0","0","0","@d1cb093a71f9a8ae105524adbe95b965@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import edu.princeton.cs.algs4.UF;

public class Percolation {

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();

        try {
            br = new BufferedReader(new FileReader(args[0]));

            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[][] pairlist = new int[info.size() - 1][2];
        for (int i = 0; i < info.size() - 1; i++) {
            pairlist[i][0] = Integer.parseInt(info.get(i + 1)[0]);
            pairlist[i][1] = Integer.parseInt(info.get(i + 1)[1]);
            //System.out.println(pairlist[i][0]+ "" "" +pairlist[i][1]);
        }

        boolean[][] openloc = new boolean[size][size];
        //System.out.print(openloc[8]);

        UF uf = new UF(size * size + 2);
        for (int k = 0; k < size; k++) {
            uf.union(k, size * size);                //top row connect to visual top point
            uf.union(size * (size - 1) + k, size * size + 1);//bottom row connect to visual bottom point
        }

        search:
        {
            for (int i = 0; i < pairlist.length; i++) {
                openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1)] = true;
                //System.out.println((pairlist[i][0]-1) +"" ""+ (pairlist[i][1]-1));

                try {
                    if (openloc[(pairlist[i][0] - 1) - 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) - 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1) + 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) + 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) - 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) + 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) + 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }

                if (uf.connected(size * size, size * size + 1)) {
                    System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                    break search;
                }

                /*
                 for (int frc = 0; frc < size; frc++) {
                 if (openloc[0][frc]) {
                 for (int lrc = 0; lrc < size; lrc++) {
                 if (openloc[size - 1][lrc]) {
                 if (uf.connected(frc, (size - 1) * size + lrc)) {
                 System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                 break search;
                 }
                 }
                 }
                 }
                 }
                 */
            }
            System.out.println(-1);
        }

    }

}

@d1cb093a71f9a8ae105524adbe95b965@"
"r04228027","10","0.103","158080","@ecd0f6ee9c63a63777f7f6169597a450@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author daf
 */
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;

public class Percolation {

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();

        try {
            br = new BufferedReader(new FileReader(args[0]));

            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[][] pairlist = new int[info.size() - 1][2];
        for (int i = 0; i < info.size() - 1; i++) {
            pairlist[i][0] = Integer.parseInt(info.get(i + 1)[0]);
            pairlist[i][1] = Integer.parseInt(info.get(i + 1)[1]);
            //System.out.println(pairlist[i][0]+ "" "" +pairlist[i][1]);
        }

        boolean[][] openloc = new boolean[size][size];
        //System.out.print(openloc[8]);

        UF uf = new UF(size * size + 2);
        for (int k = 0; k < size; k++) {
            uf.union(k, size * size);                //top row connect to visual top point
            uf.union(size * (size - 1) + k, size * size + 1);//bottom row connect to visual bottom point
        }

        search:
        {
            for (int i = 0; i < pairlist.length; i++) {
                openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1)] = true;
                //System.out.println((pairlist[i][0]-1) +"" ""+ (pairlist[i][1]-1));

                try {
                    if (openloc[(pairlist[i][0] - 1) - 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) - 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1) + 1][(pairlist[i][1] - 1)] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), ((pairlist[i][0] - 1) + 1) * size + (pairlist[i][1] - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) - 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) - 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }
                try {
                    if (openloc[(pairlist[i][0] - 1)][(pairlist[i][1] - 1) + 1] == true) {
                        uf.union((pairlist[i][0] - 1) * size + (pairlist[i][1] - 1), (pairlist[i][0] - 1) * size + ((pairlist[i][1] - 1) + 1));
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    //e.printStackTrace();
                }

                if (uf.connected(size * size, size * size + 1)) {
                    System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                    break search;
                }

                /*
                 for (int frc = 0; frc < size; frc++) {
                 if (openloc[0][frc]) {
                 for (int lrc = 0; lrc < size; lrc++) {
                 if (openloc[size - 1][lrc]) {
                 if (uf.connected(frc, (size - 1) * size + lrc)) {
                 System.out.println(info.get(i + 1)[0] + "","" + info.get(i + 1)[1]);
                 break search;
                 }
                 }
                 }
                 }
                 }
                 */
            }
            System.out.println(-1);
        }

    }

}

@ecd0f6ee9c63a63777f7f6169597a450@"
"r04631012","0","0","0","@9b8ed6406ae00a30007439ef6acac86d@import java.io.FileReader;
import java.io.BufferedReader;

public class Percolation {

    private static final int FULL = 0;     // Makes it easier to keep track of the
    private static final int OPEN = 1;     // status of the sites in the grid.

    private int N;          // Dimensions of the N by N grid used in the simulation.
    private int[][] grid;   // Keeps track of which sites are open or full.
    // Begins with default initialization: FULL (0)

    private UF ufHelper; // Class supplied by course instructor.
    // We use union(), find(), connected(),
    // and count() in this program.

    /**
     * Constructor initializes two dimensional array of integers with default
     * values: all sites set to CLOSED (0).
     *
     * The WeightedQuickUnionUF object is initialized to a size that will
     * contain one element for each site in the grid (N*N), plus two more to
     * represent ""imaginary"" sites at the top and bottom of the grid that will
     * make it easier to test the grid for percolation.
     *
     * @param n the number of rows and column in the grid
     */
    public Percolation(int n) {
        N = n;
        grid = new int[N][N];
        ufHelper = new UF((N * N) + 2);
    } // end constructor

    /**
     * Open site (row i, column j) by setting site to OPEN and calling the union
     * method in the union-find object for any open adjacent sites.
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public void open(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        grid[row][col] = OPEN;
        if (row == 0) { // If it's on the top row, connect to imaginary site at 0.
            ufHelper.union(0, xyTo1D(row, col));
        }
        if (row == N - 1) { // If it's on the bottom row, connect to imaginary
            // site at (N*N) + 1.
            ufHelper.union((N * N) + 1, xyTo1D(row, col));
        }
        if ((row + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row + 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row + 1, col));
            }
        }
        if ((row - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row - 1][col] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row - 1, col));
            }
        }
        if ((col + 1) < N) { // Make sure we don't fall off the grid
            if (grid[row][col + 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col + 1));
            }
        }
        if ((col - 1) >= 0) { // Make sure we don't fall off the grid
            if (grid[row][col - 1] == OPEN) {
                ufHelper.union(xyTo1D(row, col), xyTo1D(row, col - 1));
            }
        }
    } // end open()

    /**
     * Is site (row i, column j) open?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is OPEN
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isOpen(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == OPEN;
    } // end isOpen()

    /**
     * Is site (row i, column j) full?
     *
     * @param i the integer representing the site location on the x axis
     * @param j the integer representing the site location on the y axis
     * @return true if the site at (i, j) is FULL
     * @throws IndexOutOfBoundsException if the values for i and j are off the
     * grid
     */
    public boolean isFull(int i, int j) {
        int row = i - 1;
        int col = j - 1;
        if (row < 0 || row > N || col < 0 || col > N) {
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
        }
        return grid[row][col] == FULL;
    } // end isFull()

    /**
     * Does the system percolate? Checks to see if the imaginary site at
     * location 0 in the union-find object is in the same set as the imaginary
     * site at location N*N+1 in the union-find object. These two sites are
     * imaginary; they are not actually represented in the grid, although they
     * are represented in the union-find object. They are ""located"" at the top
     * and the bottom of the grid, and each connects to all the sites
     * above/below it.
     *
     * @return true if open path from the bottom of the grid to the top exists
     */
    public boolean percolates() {
        return ufHelper.connected(0, (N * N) + 1);
    }
    
    private int xyTo1D(int i, int j) {
        if (i < 0 || i > N || j < 0 || j > N)
            throw new IndexOutOfBoundsException(""Illegal parameter value."");
            return ((i*N) + j) + 1;
    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            
            int MatrixSize = Integer.parseInt(data[0]);
            Percolation Pe = new Percolation(MatrixSize);
            
            String line;
            String target = """";
            while ((line = br.readLine()) != null) {
            target += line + "" "";
            }
            //     System.out.println(target);
            String[] numbersArray = target.split("" "");
                
                int row = 0, column = 0;
                row = Integer.parseInt(numbersArray[0]);
                column = Integer.parseInt(numbersArray[2]);
                Pe.open(row, column);
                if (Pe.percolates()) {
                    System.out.println(""row"" + "","" + ""column"");
                    }
                while (br.readLine() != null);
                    System.out.println(""-1"");
                   
        }
    }
}
@9b8ed6406ae00a30007439ef6acac86d@"
"b03611038","10","0.145","157312","@23c13d962ba66b9788da1391a9425bff@
import java.io.FileReader;
import java.io.BufferedReader;


public class Percolation {
      
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            String buffer ;
            String data = """";
            int n = Integer.parseInt(N[0]);
            
            int[][] matrix = new int[n+2][n+2];
            
            
             UF uf = new UF(n*n+2);
            int i = 0;
        
           buffer = br.readLine();
           while(buffer!=null){
           data = data.concat(buffer);
           data = data.concat("","");
           i++;
           buffer = br.readLine();
           }
            int q = 0;
           String[] newdata =  data.split("","");    
           
            int[] Data = new int[2*i];
            for(q = 0;q<2*i;q++){
             Data[q] = Integer.parseInt(newdata[q]);
            }
            for(q = 0; q<2*i ; q+=2){
                int a = Data[q];
                int b =Data[q+1];
                matrix[a][b] = 1;
            if(a == 1){
                uf.union(n*n, b-1);
                //System.out.print(uf.find((a-1)*n+b-1));
            }    
            if(a == n){
            uf.union(n*n+1, (a-1)*n+b-1);
            //System.out.print(uf.find((a-1)*n+b-1));
            }
           if(a<n+1 && b<n+1 && matrix[a][b+1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b);
           }  
           if(a<n+1 && b<n+1 && matrix[a][b-1] == 1){
           uf.union((a-1)*n+b-1, (a-1)*n+b-2);
           } 
           if(a<n+1 && b<n+1 && matrix[a+1][b] == 1){
           uf.union((a-1)*n+b-1, a*n+b-1);
           } 
           if(a<n+1 && b<n+1 && matrix[a-1][b] == 1){
           uf.union((a-1)*n+b-1, (a-2)*n+b-1);
           } 
            if(uf.connected(n*n, n*n+1)){
            System.out.print(a);
            System.out.print("","");
            System.out.print(b);
            break;            
            }
            }
            if(!uf.connected(n*n, n*n+1)){
            System.out.print(-1);
            }
            
            
           
            
                
            }
            
                      
    }   
}

@23c13d962ba66b9788da1391a9425bff@"
"r04228027","0","0","0","@558a1bd2fe0812bdc0d61128995971b5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package percolation;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.PrintStream;


/**
 *
 * @author chinweihsu
 */



public  class Percolation {
    
    public static class UF {
        private int size;
        private boolean[] points;
        private int[] id;
        private int[] rank;
        
        
        public UF(int N){
            size = N;
            id = new int[N*N];
            points = new boolean[N*N];
            rank = new int[N*N];
            
            for(int i=0; i<N*N; i++){
                id[i] = i;
                points[i] = false;
                rank[i] = 0;
            }
            for(int i=0; i<N; i++){
                id[i] = 0;
                rank[i] = size;
                //id[size*size-1-i] = size*size;
            }
            
        }
        
        public int Root(int p){
            while(p != id[p]){
                id[p] = id[id[p]];
                p = id[p];
            }
            return p;
        }
        
        public boolean connected(int p, int q){
            return Root(p) == Root(q);
        }
        
        public void union(int p, int q){
            int i = Root(p);
            int j = Root(q);
            if( i==j) return;
            
            if (rank[i] < rank[j]) id[i] = j;
            else if (rank[i] > rank[j]) id[j] = i;
            else{
                id[j] = i;
                rank[i]++;
            }
            //System.out.printf(""union %d and %d\n"",p,q);
        }
        
        public int getid(int x, int y){
            return y+size * x;
        }
        public void show(){
            for(int i=0;i<size*size;i++)
                System.out.printf(""%d : %b rank = %d union = %d \n"",i,points[i],rank[i],id[i]);
        }
        public void open(int x, int y){
            int p = getid(x,y);
            //System.out.printf(""open %d\n"",p);
            points[p] = true;
            //this.show();
            if (0<y && points[getid(x,y-1)]){
                //left has open
                //System.out.printf(""left has opened\n"");
                this.union(p,id[getid(x,y-1)]);
            }
             if (y<2 && points[getid(x,y+1)]){
                //right has open
                //System.out.printf(""right has opened\n"");
                this.union(p,id[getid(x,y+1)]);
            }
            if(0<x && points[getid(x-1,y)]){
                //top has open
                //System.out.printf(""top has opened\n"");
                this.union(p,id[getid(x-1,y)]);
            }
            if (x<2 && points[getid(x+1,y)]){
                //down has open
                //System.out.printf(""down has opened\n"");
                this.union(p,id[getid(x+1,y)]);
            }
            //this.show();
        }
        
        public boolean perCheck(){
            for(int i=0; i<size; i++){
                if(points[size*size-1-i] && id[size*size-1-i] == 0){
                    return true;
                }
            }
            return false;
        }
    }

    
    
    
    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int gridSize = Integer.parseInt(data[0]);
            UF Grid = new UF(gridSize); 
            boolean check = false;
            int[] result = new int[2];
            while(br.ready()){
                String[] point = br.readLine().split("","");
                //System.out.printf(""input =""+point[0]+"",""+point[1]+""\n"");
                Grid.open(Integer.parseInt(point[0])-1, Integer.parseInt(point[1])-1);
                if(Grid.perCheck()){
                    //System.out.printf(""Grid.perCheck() is true\n"");
                    check = true;
                    result[0] = Integer.parseInt(point[0]);
                    result[1] = Integer.parseInt(point[1]);
                    break;
                }
            }
            if(check){
                System.out.printf(""%d,%d"",result[0],result[1]);
            }else{
                System.out.printf(""-1"");
            }
        }
    }
    
    
}

@558a1bd2fe0812bdc0d61128995971b5@"
"r04228027","0","0","0","@b84fbbf3b4986c1c44386aba5d17ba8d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package percolation;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.PrintStream;


/**
 *
 * @author chinweihsu
 */



public  class Percolation {
    
    public static class UF {
        private int size;
        private boolean[] points;
        private int[] id;
        private int[] rank;
        
        
        public UF(int N){
            size = N;
            id = new int[N*N];
            points = new boolean[N*N];
            rank = new int[N*N];
            
            for(int i=0; i<N*N; i++){
                id[i] = i;
                points[i] = false;
                rank[i] = 0;
            }
            for(int i=0; i<N; i++){
                id[i] = 0;
                rank[i] = size;
                //id[size*size-1-i] = size*size;
            }
            
        }
        
        public int Root(int p){
            while(p != id[p]){
                id[p] = id[id[p]];
                p = id[p];
            }
            return p;
        }
        
        public boolean connected(int p, int q){
            return Root(p) == Root(q);
        }
        
        public void union(int p, int q){
            int i = Root(p);
            int j = Root(q);
            if( i==j) return;
            
            if (rank[i] < rank[j]) id[i] = j;
            else if (rank[i] > rank[j]) id[j] = i;
            else{
                id[j] = i;
                rank[i]++;
            }
            //System.out.printf(""union %d and %d\n"",p,q);
        }
        
        public int getid(int x, int y){
            return y+size * x;
        }
        public void show(){
            for(int i=0;i<size*size;i++)
                System.out.printf(""%d : %b rank = %d union = %d \n"",i,points[i],rank[i],id[i]);
        }
        public void open(int x, int y){
            int p = getid(x,y);
            //System.out.printf(""open %d\n"",p);
            points[p] = true;
            //this.show();
            if (0<y && points[getid(x,y-1)]){
                //left has open
                //System.out.printf(""left has opened\n"");
                this.union(p,id[getid(x,y-1)]);
            }
             if (y<2 && points[getid(x,y+1)]){
                //right has open
                //System.out.printf(""right has opened\n"");
                this.union(p,id[getid(x,y+1)]);
            }
            if(0<x && points[getid(x-1,y)]){
                //top has open
                //System.out.printf(""top has opened\n"");
                this.union(p,id[getid(x-1,y)]);
            }
            if (x<2 && points[getid(x+1,y)]){
                //down has open
                //System.out.printf(""down has opened\n"");
                this.union(p,id[getid(x+1,y)]);
            }
            //this.show();
        }
        
        public boolean perCheck(){
            for(int i=0; i<size; i++){
                if(points[size*size-1-i] && id[size*size-1-i] == 0){
                    return true;
                }
            }
            return false;
        }
    }

    
    
    
    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int gridSize = Integer.parseInt(data[0]);
            UF Grid = new UF(gridSize); 
            boolean check = false;
            int[] result = new int[2];
            while(br.ready()){
                String[] point = br.readLine().split("","");
                //System.out.printf(""input =""+point[0]+"",""+point[1]+""\n"");
                Grid.open(Integer.parseInt(point[0])-1, Integer.parseInt(point[1])-1);
                if(Grid.perCheck()){
                    //System.out.printf(""Grid.perCheck() is true\n"");
                    check = true;
                    result[0] = Integer.parseInt(point[0]);
                    result[1] = Integer.parseInt(point[1]);
                    break;
                }
            }
            if(check){
                System.out.printf(""%d,%d\n"",result[0],result[1]);
            }else{
                System.out.printf(""-1\n"");
            }
        }
    }
    
    
}

@b84fbbf3b4986c1c44386aba5d17ba8d@"
"r04228027","0","0","0","@d3971418abadd698391a1dfe07cfc4b9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package percolation;
import java.io.FileReader;
import java.io.BufferedReader;


/**
 *
 * @author chinweihsu
 */



public  class Percolation {
    
    public static class UF {
        private int size;
        private boolean[] points;
        private int[] id;
        private int[] rank;
        
        
        public UF(int N){
            size = N;
            id = new int[N*N];
            points = new boolean[N*N];
            rank = new int[N*N];
            
            for(int i=0; i<N*N; i++){
                id[i] = i;
                points[i] = false;
                rank[i] = 0;
            }
            for(int i=0; i<N; i++){
                id[i] = 0;
                rank[i] = size;
                //id[size*size-1-i] = size*size;
            }
            
        }
        
        public int Root(int p){
            while(p != id[p]){
                id[p] = id[id[p]];
                p = id[p];
            }
            return p;
        }
        
        public boolean connected(int p, int q){
            return Root(p) == Root(q);
        }
        
        public void union(int p, int q){
            int i = Root(p);
            int j = Root(q);
            if( i==j) return;
            
            if (rank[i] < rank[j]) id[i] = j;
            else if (rank[i] > rank[j]) id[j] = i;
            else{
                id[j] = i;
                rank[i]++;
            }
            //System.out.printf(""union %d and %d\n"",p,q);
        }
        
        public int getid(int x, int y){
            return y+size * x;
        }
        public void show(){
            for(int i=0;i<size*size;i++)
                System.out.printf(""%d : %b rank = %d union = %d \n"",i,points[i],rank[i],id[i]);
        }
        public void open(int x, int y){
            int p = getid(x,y);
            //System.out.printf(""open %d\n"",p);
            points[p] = true;
            //this.show();
            if (0<y && points[getid(x,y-1)]){
                //left has open
                //System.out.printf(""left has opened\n"");
                this.union(p,id[getid(x,y-1)]);
            }
             if (y<2 && points[getid(x,y+1)]){
                //right has open
                //System.out.printf(""right has opened\n"");
                this.union(p,id[getid(x,y+1)]);
            }
            if(0<x && points[getid(x-1,y)]){
                //top has open
                //System.out.printf(""top has opened\n"");
                this.union(p,id[getid(x-1,y)]);
            }
            if (x<2 && points[getid(x+1,y)]){
                //down has open
                //System.out.printf(""down has opened\n"");
                this.union(p,id[getid(x+1,y)]);
            }
            //this.show();
        }
        
        public boolean perCheck(){
            for(int i=0; i<size; i++){
                if(points[size*size-1-i] && id[size*size-1-i] == 0){
                    return true;
                }
            }
            return false;
        }
    }

    
    
    
    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int gridSize = Integer.parseInt(data[0]);
            UF Grid = new UF(gridSize); 
            boolean check = false;
            int[] result = new int[2];
            while(br.ready()){
                String[] point = br.readLine().split("","");
                //System.out.printf(""input =""+point[0]+"",""+point[1]+""\n"");
                Grid.open(Integer.parseInt(point[0])-1, Integer.parseInt(point[1])-1);
                if(Grid.perCheck()){
                    //System.out.printf(""Grid.perCheck() is true\n"");
                    check = true;
                    result[0] = Integer.parseInt(point[0]);
                    result[1] = Integer.parseInt(point[1]);
                    break;
                }
            }
            if(check){
                System.out.printf(""%d,%d\n"",result[0],result[1]);
            }else{
                System.out.printf(""-1\n"");
            }
        }
    }
    
    
}

@d3971418abadd698391a1dfe07cfc4b9@"
"b03611003","9","1","122352","@196581bf5f6ce7e11b7708d414e5a4fb@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 */
public class Percolation {

    /**
     * @param args the command line arguments
     *
     *
     * by union!!!!!!!!!!!!!!
     *
     *
     *
     *
     */
    private static int[] id;
    private static int[] bw;
//    0 as black, 1 as white
    static int N;
    static int siteid;

    public Percolation(int N) {
//        initial the id&bw of the mitrix
        id = new int[N * N + 2];
        bw = new int[N * N + 2];
//       [0] is top, [N+1] is bottom
        for (int i = 0; i < N * N + 2; i++) {
            id[i] = i;
            bw[i] = 0;
        }
//       martix begin from 1 end at N
        bw[0] = 1;
        bw[N * N + 1] = 1;
    }

    public static void open(int row, int col) {
//        open a new site and check the connection
        siteid = (row - 1) * N + col;
        bw[siteid] = 1;

        if (siteid <= N) {
            union(siteid, 0);
//          connect the top     

            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
//            connect the one below

        } else if (siteid > N * N - N) {
            union(siteid, N * N + 1);
//          connect the bottom 

            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
//            connect the one above

        } else if (siteid % N == 1) {

            if (bw[siteid + 1] == 1) {
                union(siteid, siteid + 1);
            }
//            connect the one on the right

        } else if (siteid % N == 0) {

            if (bw[siteid - 1] == 1) {
                union(siteid, siteid - 1);
            }
//            connect the one on the left

        } else {
//          the sites between
            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
            if (bw[siteid - 1] == 1) {
                union(siteid, siteid - 1);
            }
            if (bw[siteid + 1] == 1) {
                union(siteid, siteid + 1);
            }
            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
        }

    }

    public static void union(int A, int B) {
//        把id 設成最小的位子
        int a = root(A);
        int b = root(B);

        if (a < b) {
            id[b] = a;
        } else {
            id[a] = b;
        }
    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static boolean connection(int A, int B) {
        return root(A) == root(B);
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            N = Integer.parseInt(data);

            Percolation matrix = new Percolation(N);

            String[] randc = new String[2];
            int row = 0;
            int col = 0;
            String brs;

            while (Boolean.TRUE) {

                brs = br.readLine();
                if (connection(0, N * N + 1)) {
                    System.out.print(row + "","" + col);
                    break;
                }
                if (brs == null) {
                    System.out.print(-1);
                    break;
                }
                randc = brs.split("","");
                row = Integer.parseInt(randc[0]);
                col = Integer.parseInt(randc[1]);

                open(row, col);
            }

//            if (br.readLine() != null) {
//                System.out.print(row + "","" + col);
//            }
        }
    }

}

@196581bf5f6ce7e11b7708d414e5a4fb@"
"b03611003","9","0.99","123936","@579437aecc38e370740e5586e16684d8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
// package percolation;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 */
public class Percolation {

    /**
     * @param args the command line arguments
     *
     *
     * by union!!!!!!!!!!!!!!
     *
     *
     *
     *
     */
    private static int[] id;
    private static int[] bw;
//    0 as black, 1 as white
    static int N;
    static int siteid;

    public Percolation(int N) {
//        initial the id&bw of the mitrix
        id = new int[N * N + 2];
        bw = new int[N * N + 2];
//       [0] is top, [N+1] is bottom
        for (int i = 0; i < N * N + 2; i++) {
            id[i] = i;
            bw[i] = 0;
        }
//       martix begin from 1 end at N
        bw[0] = 1;
        bw[N * N + 1] = 1;
    }

    public static void open(int row, int col) {
//        open a new site and check the connection
        siteid = (row - 1) * N + col;
        bw[siteid] = 1;

        if (siteid <= N) {
            union(siteid, 0);
//          connect the top     

            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
//            connect the one below

        } else if (siteid > N * N - N) {
            union(siteid, N * N + 1);
//          connect the bottom 

            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
//            connect the one above

        } else if (siteid % N == 1) {

            if (bw[siteid + 1] == 1) {
                union(siteid, siteid + 1);
            }
//            connect the one on the right

        } else if ((siteid-N) % N == 0) {

            if (bw[siteid - 1] == 1) {
                union(siteid, siteid - 1);
            }
//            connect the one on the left

        } else {
//          the sites between
            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
            if (bw[siteid - 1] == 1) {
                union(siteid, siteid - 1);
            }
            if (bw[siteid + 1] == 1) {
                union(siteid, siteid + 1);
            }
            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
        }

    }

    public static void union(int A, int B) {
//        把id 設成最小的位子
        int a = root(A);
        int b = root(B);

        if (a < b) {
            id[b] = a;
        } else {
            id[a] = b;
        }
    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static boolean connection(int A, int B) {
        return root(A) == root(B);
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            N = Integer.parseInt(data);

            Percolation matrix = new Percolation(N);

            String[] randc = new String[2];
            int row = 0;
            int col = 0;
            String brs;

            while (Boolean.TRUE) {

                brs = br.readLine();
                if (connection(0, N * N + 1)) {
                    System.out.print(row + "","" + col);
                    break;
                }
                if (brs == null) {
                    System.out.print(-1);
                    break;
                }
                randc = brs.split("","");
                row = Integer.parseInt(randc[0]);
                col = Integer.parseInt(randc[1]);

                open(row, col);
            }

//            if (br.readLine() != null) {
//                System.out.print(row + "","" + col);
//            }
        }
    }

}

@579437aecc38e370740e5586e16684d8@"
"b03611003","10","0.096","122464","@d3f078c5ec39128959f1f131ab00e4a2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package percolation;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 */
public class Percolation {

    /**
     * @param args the command line arguments
     *
     *
     * by union!!!!!!!!!!!!!!
     *
     *
     *
     *
     */
    private static int[] id;
    private static int[] bw;
//    0 as black, 1 as white
    static int N;
    static int siteid;

    public Percolation(int N) {
//        initial the id&bw of the mitrix
        id = new int[N * N + 2];
        bw = new int[N * N + 2];
//       [0] is top, [N+1] is bottom
        for (int i = 0; i < N * N + 2; i++) {
            id[i] = i;
            bw[i] = 0;
        }
//       martix begin from 1 end at N
        bw[0] = 1;
        bw[N * N + 1] = 1;
    }

    public static void open(int row, int col) {
//        open a new site and check the connection
        siteid = (row - 1) * N + col;
        bw[siteid] = 1;

        if (siteid <= N) {
            union(siteid, 0);
//          connect the top     

            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
//            connect the one below

        } else if (siteid > N * N - N) {
            union(siteid, N * N + 1);
//          connect the bottom 

            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
//            connect the one above

        } else if (siteid % N == 1) {

                     if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
//            if (bw[siteid - 1] == 1) {
//                union(siteid, siteid - 1);
//            }
            if (bw[siteid + 1] == 1) {
                union(siteid, siteid + 1);
            }
            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
        } else if (siteid % N == 0) {

                     if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
            if (bw[siteid - 1] == 1) {
                union(siteid, siteid - 1);
            }
//            if (bw[siteid + 1] == 1) {
//                union(siteid, siteid + 1);
//            }
            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
        } else {
//          the sites between
            if (bw[siteid - N] == 1) {
                union(siteid, siteid - N);
            }
            if (bw[siteid - 1] == 1) {
                union(siteid, siteid - 1);
            }
            if (bw[siteid + 1] == 1) {
                union(siteid, siteid + 1);
            }
            if (bw[siteid + N] == 1) {
                union(siteid, siteid + N);
            }
        }

    }

    public static void union(int A, int B) {
//        把id 設成最小的位子
        int a = root(A);
        int b = root(B);

        if (a < b) {
            id[b] = a;
        } else {
            id[a] = b;
        }
    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static boolean connection(int A, int B) {
        return root(A) == root(B);
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String data = br.readLine();
            N = Integer.parseInt(data);

            Percolation matrix = new Percolation(N);

            String[] randc = new String[2];
            int row = 0;
            int col = 0;
            String brs;

            while (Boolean.TRUE) {

                brs = br.readLine();
                if (connection(0, N * N + 1)) {
                    System.out.print(row + "","" + col);
                    break;
                }
                if (brs == null) {
                    System.out.print(-1);
                    break;
                }
                randc = brs.split("","");
                row = Integer.parseInt(randc[0]);
                col = Integer.parseInt(randc[1]);

                open(row, col);
            }

//            if (br.readLine() != null) {
//                System.out.print(row + "","" + col);
//            }
        }
    }

}

@d3f078c5ec39128959f1f131ab00e4a2@"
"b01705003","0","0.84","102480","@0c655cd2a92ec8bd8e0fadbafdece1d2@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.Array;
public class Bingo {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            // store the first integer in variable stringCount (number of announced strings)
            int stringCount = Integer.parseInt(data[0]);
            // store the second integer in variable num (dimension of matrix: num * num)            
            int num = Integer.parseInt(data[1]);
            // initilization of a String array in Java
            String[] announce = new String[stringCount];
            String[][] matrix = new String[num][num];
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
             String[] data = br.readLine().split("","");
             for(int t=0;t<stringCount;t++){
             	announce[t]=data[t] ;
			 }
             for(int k=1;k<=num;k++){
             	String[] data = br.readLine().split("","");
             	for(int p=1;p<=num;p++){
             		matrix[k][p]=data[p];
				 }
			 }
			 
             for(int e=0;e<stringCount;e++){
             	for(int f=1;f<=num;f++){
             		for(int g=1;g<=num;g++){
             			while(announce[e]!=null){
             				if(matrix[f][g]==announce[e]){
             					matrix[f][g]=""NZ"";
							 }
						 }
					 }
				 }
			 }
			 int Count = 0 ;
			 int row = 0 ;
			 int Column = 0 ;
             for(int z=1;z<=num;z++){
             	for(int q=1;q<=num;q++){
             		if(matrix[z][q] == ""NZ"")
             		{
             			row++ ;
					 }
				 }
				 if(row==num){
				 	Count++ ;
				 	row = 0 ;
				 }
			 }
             
             for(int q=1;q<=num;q++){
             	for(int z=1;z<=num;z++){
             		if(matrix[z][q] == ""NZ"")
             		{
             			Column++ ;
					 }
				 }
				 if(Column==num){
				 	Count++ ;
				 	Column = 0 ;
				 }
			 }
             int oblique1 = 0 ;
             int oblique2 = 0 ;
             for(int t=1;t<=num;t++){
             	if(matrix[t][t]==""NZ""){
             		oblique1++;
				 }
			 }
			 if(oblique1==num){
			 	Count++;
			 }
			 for(int u=1;u<=num;u++){
			 	for(int o=num;o>=1;o--){
			 		if(matrix[u][o]==""NZ""){
             		oblique2++;
					 }
					 if(oblique2==num){
					 	Count++;
					 }
				}
			 }
			 System.out.printf(""%d"", Count);
         }    
    }
}

@0c655cd2a92ec8bd8e0fadbafdece1d2@"
