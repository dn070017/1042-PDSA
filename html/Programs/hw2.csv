"r04945025","10","0.116","146848","@12eebfb0cd3f1d5661009056c3238868@import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private final int num;
    private QuickUnionUF uf;
    private int[] flag;
    private int[] count;

    public LabelCC(int num){
        this.num = num;
        flag = new int[num * num];
    }

    public int getPos(int x, int y){
        x--;
        y--;
        if(x < 0 || y < 0) return -1;
        if(x > num || y > num) return -1;
        return flag[x * num + y];
    }

    public void setPos(int x, int y, int val){
        x--;
        y--;
        if(x < 0 || y < 0) return;
        if(x > num || y > num) return;
        flag[x * num + y] = val;
    }

    public void initUF(int group){
        uf = new QuickUnionUF(group);
        count = new int[group];
    }

    public void addCount(int group){
        if(group < 0) return;
        count[--group]++;
    }

    public int[] getCount(){
        return count;
    }

    public void union(int a, int b){
        a--;
        b--;
        if(a < b) uf.union(b, a);
        if(a >= b) uf.union(a, b);
    }

    public int find(int a){
        a--;
        return uf.find(a) + 1;
    }

    public static int lower(int a, int b){
        if(a < b) return a;
        return b;
    }

    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            int num = Integer.parseInt(br.readLine());

            LabelCC lcc = new LabelCC(num);

            for(String in = br.readLine(); in != null; in = br.readLine()){
                String[] data = in.split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                lcc.setPos(x, y, -1);
            }

            int group = 1;
            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    if(lcc.getPos(i, j) == -1) continue;

                    int left = lcc.getPos(i - 1, j);
                    int top = lcc.getPos(i, j - 1);

                    if(left == -1 && top == -1){
                        lcc.setPos(i, j, group);
                        group++;
                    }
                    else if(left != -1 && top == -1){
                        lcc.setPos(i, j, left);
                    }
                    else if(left == -1 && top != -1){
                        lcc.setPos(i, j, top);
                    }
                    else{
                        lcc.setPos(i, j, LabelCC.lower(top, left));
                    }
                }
            }

            /*
            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    System.out.printf(""%s\t"", lcc.getPos(i,j) == -1 ? ""-"": lcc.getPos(i, j));
                }
                System.out.printf(""\n"");
            }
            System.out.printf(""\n"");
            */

            lcc.initUF(--group);

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    int left = lcc.getPos(i - 1, j);
                    int top = lcc.getPos(i, j - 1);
                    int current = lcc.getPos(i, j);

                    if(current == -1) continue;
                    if(left != -1 && current != left) lcc.union(left, current);
                    if(top != -1 && current != top) lcc.union(top, current);
                }
            }

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    //System.out.printf(""%s\t"", lcc.getPos(i,j) == -1 ? ""-"": lcc.find(lcc.getPos(i, j)));
                    lcc.addCount(lcc.getPos(i,j) == -1 ? -1: lcc.find(lcc.getPos(i, j)));
                }
                //System.out.printf(""\n"");
            }
            //System.out.printf(""\n"");

            int[] count = lcc.getCount();
            Arrays.sort(count);

            for(int i = 0; i < count.length; i++){
                if(count[i] != 0) System.out.printf(""%d\n"", count[i]);
            }
        }

    }
}

@12eebfb0cd3f1d5661009056c3238868@"
"r04945025","10","0.104","135808","@80370be121ee4380c67f89e87ea2b6db@import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private final int num;
    private QuickUnionUF uf;
    private int[] flag;

    public LabelCC(int num){
        this.num = num;
        flag = new int[num * num];
    }

    public int getPos(int x, int y){
        x--;
        y--;
        if(x < 0 || y < 0) return -1;
        if(x > num || y > num) return -1;
        return flag[x * num + y];
    }

    public void setPos(int x, int y, int val){
        x--;
        y--;
        if(x < 0 || y < 0) return;
        if(x > num || y > num) return;
        flag[x * num + y] = val;
    }

    public void initUF(int group){
        uf = new QuickUnionUF(group);
    }

    public void union(int a, int b){
        a--;
        b--;
        if(a < b) uf.union(b, a);
        if(a >= b) uf.union(a, b);
    }

    public int find(int a){
        a--;
        return uf.find(a) + 1;
    }

    public static int lower(int a, int b){
        if(a < b) return a;
        return b;
    }

    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetX = Integer.parseInt(data[1]);
            int targetY = Integer.parseInt(data[2]);

            LabelCC lcc = new LabelCC(num);


            for(String in = br.readLine(); in != null; in = br.readLine()){
                data = in.split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                lcc.setPos(x, y, -1);
            }

            int group = 1;
            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    if(lcc.getPos(i, j) == -1) continue;

                    int left = lcc.getPos(i - 1, j);
                    int top = lcc.getPos(i, j - 1);

                    if(left == -1 && top == -1){
                        lcc.setPos(i, j, group);
                        group++;
                    }
                    else if(left != -1 && top == -1){
                        lcc.setPos(i, j, left);
                    }
                    else if(left == -1 && top != -1){
                        lcc.setPos(i, j, top);
                    }
                    else{
                        lcc.setPos(i, j, LabelCC.lower(top, left));
                    }
                }
            }

            lcc.initUF(--group);


            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    int left = lcc.getPos(i - 1, j);
                    int top = lcc.getPos(i, j - 1);
                    int current = lcc.getPos(i, j);

                    if(current == -1) continue;
                    if(left != -1 && current != left) lcc.union(left, current);
                    if(top != -1 && current != top) lcc.union(top, current);
                }
            }

            /*for(int i = 1; i <= num; i++){
                for(int j =1; j <= num; j++){
                    System.out.printf(""%s\t"", lcc.getPos(i, j) == -1? ""-"": lcc.find(lcc.getPos(i, j)));
                }
                System.out.printf(""\n"");
            }

            System.out.printf(""\n(%d, %d): \n"", targetX, targetY);*/

            System.out.printf(""%d\n"", lcc.find(lcc.getPos(targetX, targetY)));
        }

    }
}

@80370be121ee4380c67f89e87ea2b6db@"
"r04945025","10","0.104","127600","@80370be121ee4380c67f89e87ea2b6db@import java.util.Arrays;
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private final int num;
    private QuickUnionUF uf;
    private int[] flag;

    public LabelCC(int num){
        this.num = num;
        flag = new int[num * num];
    }

    public int getPos(int x, int y){
        x--;
        y--;
        if(x < 0 || y < 0) return -1;
        if(x > num || y > num) return -1;
        return flag[x * num + y];
    }

    public void setPos(int x, int y, int val){
        x--;
        y--;
        if(x < 0 || y < 0) return;
        if(x > num || y > num) return;
        flag[x * num + y] = val;
    }

    public void initUF(int group){
        uf = new QuickUnionUF(group);
    }

    public void union(int a, int b){
        a--;
        b--;
        if(a < b) uf.union(b, a);
        if(a >= b) uf.union(a, b);
    }

    public int find(int a){
        a--;
        return uf.find(a) + 1;
    }

    public static int lower(int a, int b){
        if(a < b) return a;
        return b;
    }

    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetX = Integer.parseInt(data[1]);
            int targetY = Integer.parseInt(data[2]);

            LabelCC lcc = new LabelCC(num);


            for(String in = br.readLine(); in != null; in = br.readLine()){
                data = in.split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                lcc.setPos(x, y, -1);
            }

            int group = 1;
            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    if(lcc.getPos(i, j) == -1) continue;

                    int left = lcc.getPos(i - 1, j);
                    int top = lcc.getPos(i, j - 1);

                    if(left == -1 && top == -1){
                        lcc.setPos(i, j, group);
                        group++;
                    }
                    else if(left != -1 && top == -1){
                        lcc.setPos(i, j, left);
                    }
                    else if(left == -1 && top != -1){
                        lcc.setPos(i, j, top);
                    }
                    else{
                        lcc.setPos(i, j, LabelCC.lower(top, left));
                    }
                }
            }

            lcc.initUF(--group);


            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    int left = lcc.getPos(i - 1, j);
                    int top = lcc.getPos(i, j - 1);
                    int current = lcc.getPos(i, j);

                    if(current == -1) continue;
                    if(left != -1 && current != left) lcc.union(left, current);
                    if(top != -1 && current != top) lcc.union(top, current);
                }
            }

            /*for(int i = 1; i <= num; i++){
                for(int j =1; j <= num; j++){
                    System.out.printf(""%s\t"", lcc.getPos(i, j) == -1? ""-"": lcc.find(lcc.getPos(i, j)));
                }
                System.out.printf(""\n"");
            }

            System.out.printf(""\n(%d, %d): \n"", targetX, targetY);*/

            System.out.printf(""%d\n"", lcc.find(lcc.getPos(targetX, targetY)));
        }

    }
}

@80370be121ee4380c67f89e87ea2b6db@"
"b02611019","0","1","131120","@4e193641689ac01a4dfab8238b22bb0a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author S410
 */


public class connectedcomponents {

    
    static WeightedQuickUnionUF uf;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String[] numstr = br.readLine().split("","");
        int num = Integer.parseInt(numstr[0]);
        int tarx=Integer.parseInt(numstr[1]);
        int tary=Integer.parseInt(numstr[2]);
        

        Integer[][] matrix = new Integer[num][];
        for (int i = 0; i < num; i++) {
            matrix[i] = new Integer[num];
            for (int j = 0; j < num; j++) {
                matrix[i][j] = -1;
            }
        }
        while (br.ready()) {
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0]) - 1;
            int y = Integer.parseInt(coor[1]) - 1;
            matrix[x][y] = 0;
        }
        int index = 1;
        if (matrix[0][0] == -1) {
            matrix[0][0] = index++;
        }
        uf = new WeightedQuickUnionUF (num*num);
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                if (i * j == 0 && matrix[i][j] == -1) {
                    if (i==0&&j==0){
                        matrix[i][j]=index++;
                    }
                    else if (i == 0 && matrix[i][j - 1] != 0) {
                        matrix[i][j] = matrix[i][j - 1];
                    } else if (j == 0 && matrix[i - 1][j] != 0) {
                        matrix[i][j] = matrix[i-1][j];
                    } else {
                        matrix[i][j] = index++;
                    }
                }

                else if (matrix[i][j] == -1) {
                    if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                        matrix[i][j] = index++;
                    }
                    if (matrix[i - 1][j] != 0&&matrix[i][j - 1] != 0){
                        
                        if (matrix[i][j-1]>matrix[i-1][j]){
                            matrix[i][j] = matrix[i-1][j ];
                            uf.union(matrix[i - 1][j], matrix[i][j-1]);
                        }
                        else{
                            matrix[i][j] = matrix[i][j-1 ];
                            uf.union(matrix[i ][j-1], matrix[i-1][j]);
                        }
                            
                        
                    }
                    else if (matrix[i - 1][j] != 0) {
                        matrix[i][j] = matrix[i - 1][j];
                    }
                    else if (matrix[i][j - 1] != 0) {
                        matrix[i][j] = matrix[i][j - 1];
                    }
                }
            }
        }
        
        
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                if(matrix[i][j]!=0&&matrix[i][j]!=uf.find(matrix[i][j])){
                    matrix[i][j]=uf.find(matrix[i][j]);
                }
            }
        }
        //測試輸出label
//        for (int i = 0; i < num; i++) {
//            for (int j = 0; j < num; j++) {
//                StdOut.print(matrix[i][j]+"" "");
//            }
//            StdOut.print(""\n"");
//        }
//        
        StdOut.print(matrix[tarx-1][tary-1]);
    }
}

@4e193641689ac01a4dfab8238b22bb0a@"
"b02611019","9","1.01","124880","@0e943f0c276a5bb93884fd1ba509ac85@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author S410
 */


public class LabelCC {

    
    static WeightedQuickUnionUF uf;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String[] numstr = br.readLine().split("","");
        int num = Integer.parseInt(numstr[0]);
        int tarx=Integer.parseInt(numstr[1]);
        int tary=Integer.parseInt(numstr[2]);
        

        Integer[][] matrix = new Integer[num][];
        for (int i = 0; i < num; i++) {
            matrix[i] = new Integer[num];
            for (int j = 0; j < num; j++) {
                matrix[i][j] = -1;
            }
        }
        while (br.ready()) {
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0]) - 1;
            int y = Integer.parseInt(coor[1]) - 1;
            matrix[x][y] = 0;
        }
        int index = 1;
        if (matrix[0][0] == -1) {
            matrix[0][0] = index++;
        }
        uf = new WeightedQuickUnionUF (num*num);
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                if (i * j == 0 && matrix[i][j] == -1) {
                    if (i==0&&j==0){
                        matrix[i][j]=index++;
                    }
                    else if (i == 0 && matrix[i][j - 1] != 0) {
                        matrix[i][j] = matrix[i][j - 1];
                    } else if (j == 0 && matrix[i - 1][j] != 0) {
                        matrix[i][j] = matrix[i-1][j];
                    } else {
                        matrix[i][j] = index++;
                    }
                }

                else if (matrix[i][j] == -1) {
                    if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                        matrix[i][j] = index++;
                    }
                    if (matrix[i - 1][j] != 0&&matrix[i][j - 1] != 0){
                        
                        if (matrix[i][j-1]>matrix[i-1][j]){
                            matrix[i][j] = matrix[i-1][j ];
                            uf.union(matrix[i - 1][j], matrix[i][j-1]);
                        }
                        else{
                            matrix[i][j] = matrix[i][j-1 ];
                            uf.union(matrix[i ][j-1], matrix[i-1][j]);
                        }
                            
                        
                    }
                    else if (matrix[i - 1][j] != 0) {
                        matrix[i][j] = matrix[i - 1][j];
                    }
                    else if (matrix[i][j - 1] != 0) {
                        matrix[i][j] = matrix[i][j - 1];
                    }
                }
            }
        }
        
        
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                if(matrix[i][j]!=0&&matrix[i][j]!=uf.find(matrix[i][j])){
                    matrix[i][j]=uf.find(matrix[i][j]);
                }
            }
        }
        //測試輸出label
//        for (int i = 0; i < num; i++) {
//            for (int j = 0; j < num; j++) {
//                StdOut.print(matrix[i][j]+"" "");
//            }
//            StdOut.print(""\n"");
//        }
//        
        StdOut.print(matrix[tarx-1][tary-1]);
    }
}

@0e943f0c276a5bb93884fd1ba509ac85@"
"r04942099","1","2.79","174000","@1c9ec0bf6482866f0d718006e8a96820@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=0;
                idt[i]=i;
            }
            QuickFindUF wei = new QuickFindUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg] = 1;
               
                if(reg%size!=0){
                    if(state[reg-1]==1){
                        wei.union(idt[reg],idt[reg-1]);                   
                    }
                }
                
                if(reg-size>0){
                    if(state[reg-size]==1){
                        if(reg%size==0 || reg%size!=0 && state[reg-1]==0) 
                        wei.union(idt[reg],idt[reg-size]);                   
                    }
                }
                
                if( reg%size==0 ||  reg%size!=0 && state[reg-1]==0  ){
                     if( reg-size<0 ||  reg-size>0 && state[reg-size]==0  ){
                         number[reg]=now;
                         ++now;
                     }               
                }
                int time=0;
                int check=0;
                 for(int j=0;j<size*size;++j){
                     
                     if(wei.connected( idt[reg],idt[j]) ){
                         if(time==0) {
                             check = number[j];
                             number[reg] = check;
                         }
                         else number[j]=check;
                             
                             
                     }
                 
                 }
                
                
                
                
            
            }
            
            
            
            
            
            
            
            System.out.println(number[ (target[0]-1)*size+target[0]-1 ]);
        }

    }
}
@1c9ec0bf6482866f0d718006e8a96820@"
"r04546032","9","0.99","124512","@8781baa7a2bdbf6b59280bec19da054d@
import java.io.FileReader;
import java.io.BufferedReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;

/**
 *
 * @author CHIN LUNG
 */
public class LabelCC {

    private WeightedQuickUnionUF wuf;
    private int[][] mark;
  

    public LabelCC(int N) {
        mark = new int[N+2][N+2];
        wuf = new WeightedQuickUnionUF(N * N);
        int count = 0;
        for (int i = 0; i < N+2; i++) {
            for (int j = 0; j < N+2; j++) {
                if((1<=i && i<=N)&&(1<=j && j<=N))
                {
                    mark[i][j] = 1;
                    count++;
                }
                else
                {
                    mark[i][j] = 0;
                }
            }
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] number = br.readLine().split("","");
            int N = Integer.parseInt(number[0]);
            int targetx = Integer.parseInt(number[1]);
            int targety = Integer.parseInt(number[2]);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));
            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);

            LabelCC lcc = new LabelCC(N);
            int label = 1;
            //先將讀到的bolck設為0
            for (int i = 0; i < temp2.length; i += 2) {
                lcc.mark[temp2[i]][temp2[i + 1]] = 0;
            }
            //開始找她的up left 有無鄰近社的點
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y < N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {
                    if(lcc.mark[x][y] <=lcc.mark[x][y-1])
                    {
                        if(lcc.mark[x-1][y] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.wuf.union(lcc.mark[x][y], Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]));
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x][y-1];
                        }
                    }
                    if(lcc.mark[x][y] <=lcc.mark[x-1][y])
                    {
                        if(lcc.mark[x][y-1] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.wuf.union(lcc.mark[x][y], Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]));
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x-1][y];
                        }
                    }
                    if(lcc.mark[x-1][y]==0 && lcc.mark[x][y-1]==0)
                    {
                        lcc.mark[x][y] = label;
                        label++;
                    }
                    }
                }
            }
           //將union起來的格子做替換
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y <N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {
                        lcc.mark[x][y] = lcc.wuf.find(lcc.mark[x][y]);
                    }
                }
            }
            //印出屬於哪一群若無則印出0
            System.out.println(lcc.mark[targetx][targety]);
        }
    }
}

@8781baa7a2bdbf6b59280bec19da054d@"
"r04942099","9","3.6","185792","@fd57b44c09a4057d1cef53263dce25c9@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            QuickFindUF wei = new QuickFindUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
            
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<size*size;++i){
                if(state[i]==1){
                int check=number[i];
                 for(int j=0;j<size*size;++j){
                     
                     if(wei.connected( idt[i],idt[j]) ){                         
                             if(check>number[j]){
                                 check = number[j];
                             }
                     }        
                 }
                 number[i]=check;
                 for(int j=0;j<size*size;++j){
                     if(wei.connected( idt[i],idt[j]) ) number[j]=check;                             
                 }
                }
            }
            
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[0]-1]);
            
            
            System.out.println(number[ (target[0]-1)*size+target[1]-1 ]);
        }

    }
}
@fd57b44c09a4057d1cef53263dce25c9@"
"r04546032","9","1.01","134720","@a45fe823becee9e8bf849ce3ade88e8f@
import java.io.FileReader;
import java.io.BufferedReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;

/**
 *
 * @author CHIN LUNG
 */
public class LabelCC {

    private WeightedQuickUnionUF wuf;
    private int[][] mark;
  

    public LabelCC(int N) {
        mark = new int[N+2][N+2];
        wuf = new WeightedQuickUnionUF(N * N);
        int count = 0;
        for (int i = 0; i < N+2; i++) {
            for (int j = 0; j < N+2; j++) {
                if((1<=i && i<=N)&&(1<=j && j<=N))
                {
                    mark[i][j] = 1;
                    count++;
                }
                else
                {
                    mark[i][j] = 0;
                }
            }
        }
        for(int i = 0; i < N*N; i++)
        {
            wuf.union(i, i);
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] number = br.readLine().split("","");
            int N = Integer.parseInt(number[0]);
            int targetx = Integer.parseInt(number[1]);
            int targety = Integer.parseInt(number[2]);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));
            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);

            LabelCC lcc = new LabelCC(N);
            int label = 1;
            //先將讀到的bolck設為0
            for (int i = 0; i < temp2.length; i += 2) {
                lcc.mark[temp2[i]][temp2[i + 1]] = 0;
            }
            //開始找她的up left 有無鄰近社的點
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y < N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {
                    if(lcc.mark[x][y] <=lcc.mark[x][y-1])
                    {
                        if(lcc.mark[x-1][y] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.wuf.union(lcc.mark[x][y], Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]));
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x][y-1];
                        }
                    }
                    if(lcc.mark[x][y] <=lcc.mark[x-1][y])
                    {
                        if(lcc.mark[x][y-1] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.wuf.union(lcc.mark[x][y], Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]));
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x-1][y];
                        }
                    }
                    if(lcc.mark[x-1][y]==0 && lcc.mark[x][y-1]==0)
                    {
                        lcc.mark[x][y] = label;
                        label++;
                    }
                    }
                }
            }
           //將union起來的格子做替換
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y <N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {
                        if(lcc.mark.length==3)
                        {
                            lcc.mark[1][1] = 1;
                        }
                        else
                        {lcc.mark[x][y] = lcc.wuf.find(lcc.mark[x][y]);}
                    }
                }
            }
            //印出屬於哪一群若無則印出0
            System.out.println(lcc.mark[targetx][targety]);
        }
    }
}

@a45fe823becee9e8bf849ce3ade88e8f@"
"r04942099","9","3.83","167264","@5f1e1d1fb215865a4eb0a258fffb7d72@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            QuickFindUF wei = new QuickFindUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
            
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<size*size;++i){
                if(state[i]==1){
                int check=number[i];
                 for(int j=0;j<size*size;++j){
                     
                     if(wei.connected( idt[i],idt[j]) ){                         
                             if(check>number[j]){
                                 check = number[j];
                             }
                     }        
                 }
                 number[i]=check;
                 for(int j=0;j<size*size;++j){
                     if(wei.connected( idt[i],idt[j]) ) number[j]=check;                             
                 }
                }
            }
            
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[0]-1]);
            
            if(state[(target[0]-1)*size+target[1]-1]==1)
            System.out.println(number[ (target[0]-1)*size+target[1]-1 ]);
            else System.out.println(""0"");
        }

    }
}
@5f1e1d1fb215865a4eb0a258fffb7d72@"
"r04942099","9","3.42","179248","@aa00c970cd4bbc1ba7700fa5644a063e@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            QuickFindUF wei = new QuickFindUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
            
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<size*size;++i){
                if(state[i]==1){
                int check=number[i];
                 for(int j=0;j<size*size;++j){
                     
                     if(wei.connected( idt[i],idt[j]) ){                         
                             if(check>number[j]){
                                 check = number[j];
                             }
                     }        
                 }
                 number[i]=check;
                 for(int j=0;j<size*size;++j){
                     if(wei.connected( idt[i],idt[j]) ) number[j]=check;                             
                 }
                }
            }
            
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[0]-1]);
            
            if(state[(target[0]-1)*size+target[1]-1]==1)
            System.out.println(number[ (target[0]-1)*size+target[1]-1 ]);
            else System.out.println(""-1"");
        }

    }
}
@aa00c970cd4bbc1ba7700fa5644a063e@"
"r04942099","9","3.02","170704","@1fdb01795761977316ce41c041110b0d@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            UF wei = new UF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
            
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<size*size;++i){
                if(state[i]==1){
                int check=number[i];
                 for(int j=0;j<size*size;++j){
                     
                     if(wei.connected( idt[i],idt[j]) ){                         
                             if(check>number[j]){
                                 check = number[j];
                             }
                     }        
                 }
                 number[i]=check;
                 for(int j=0;j<size*size;++j){
                     if(wei.connected( idt[i],idt[j]) ) number[j]=check;                             
                 }
                }
            }
            
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[0]-1]);
            
            if(state[(target[0]-1)*size+target[1]-1]==1)
            System.out.println(number[ (target[0]-1)*size+target[1]-1 ]);
            else System.out.println(""0"");
        }

    }
}
@1fdb01795761977316ce41c041110b0d@"
"r04942099","9","3.48","185024","@ee1325dde0cb6beee56d7c51eb67bd28@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            QuickFindUF wei = new QuickFindUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
            
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<size*size;++i){
                if(state[i]==1){
                int check=number[i];
                 for(int j=0;j<size*size;++j){
                     
                     if(wei.connected( idt[i],idt[j]) ){                         
                             if(check>number[j]){
                                 check = number[j];
                             }
                     }        
                 }
                 number[i]=check;
                 for(int j=0;j<size*size;++j){
                     if(wei.connected( idt[i],idt[j]) ) number[j]=check;                             
                 }
                }
            }
            
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[0]-1]);
            
            if(state[(target[0]-1)*size+target[1]-1]==1)
            System.out.println(number[ (target[0]-1)*size+target[1]-1 ]);
            else System.out.print(0);
        }

    }
}
@ee1325dde0cb6beee56d7c51eb67bd28@"
"r04942099","9","3.1","174032","@ae4f8150467825301fa24abca95f76a7@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
            
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<size*size;++i){
                if(state[i]==1){
                int check=number[i];
                 for(int j=0;j<size*size;++j){
                     
                     if(wei.connected( idt[i],idt[j]) ){                         
                             if(check>number[j]){
                                 check = number[j];
                             }
                     }        
                 }
                 number[i]=check;
                 for(int j=0;j<size*size;++j){
                     if(wei.connected( idt[i],idt[j]) ) number[j]=check;                             
                 }
                }
            }
            
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[0]-1]);
            
            if(state[(target[0]-1)*size+target[1]-1]==1)
            System.out.println(number[ (target[0]-1)*size+target[1]-1 ]);
            else System.out.print(0);
        }

    }
}
@ae4f8150467825301fa24abca95f76a7@"
"r04546032","9","1.01","134496","@2b3ca624e4246c3e32ec61a0a7a8c1f2@
import java.io.FileReader;
import java.io.BufferedReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;

/**
 *
 * @author CHIN LUNG
 */
public class LabelCC {

    private WeightedQuickUnionUF wuf;
    private int[][] mark;
  

    public LabelCC(int N) {
        mark = new int[N+2][N+2];
        wuf = new WeightedQuickUnionUF(N * N);
        int count = 0;
        for (int i = 0; i < N+2; i++) {
            for (int j = 0; j < N+2; j++) {
                if((1<=i && i<=N)&&(1<=j && j<=N))
                {
                    mark[i][j] = 1;
                    count++;
                }
                else
                {
                    mark[i][j] = 0;
                }
            }
        }
        for(int i = 0; i < N*N; i++)
        {
            wuf.union(i, i);
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] number = br.readLine().split("","");
            int N = Integer.parseInt(number[0]);
            int targetx = Integer.parseInt(number[1]);
            int targety = Integer.parseInt(number[2]);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));
            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);

            LabelCC lcc = new LabelCC(N);
            int label = 1;
            //先將讀到的bolck設為0
            for (int i = 0; i < temp2.length; i += 2) {
                lcc.mark[temp2[i]][temp2[i + 1]] = 0;
            }
            //開始找她的up left 有無鄰近社的點
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y < N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {
                    if(lcc.mark[x][y] <=lcc.mark[x][y-1])
                    {
                        if(lcc.mark[x-1][y] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.wuf.union(lcc.mark[x][y], Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]));
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x][y-1];
                        }
                    }
                    if(lcc.mark[x][y] <=lcc.mark[x-1][y])
                    {
                        if(lcc.mark[x][y-1] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.wuf.union(lcc.mark[x][y], Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]));
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x-1][y];
                        }
                    }
                    if(lcc.mark[x-1][y]==0 && lcc.mark[x][y-1]==0)
                    {
                        lcc.mark[x][y] = label;
                        label++;
                    }
                    }
                }
            }
           //將union起來的格子做替換
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y <N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {   
                        if(lcc.mark.length==3)
                        {
                             lcc.mark[x][y] = lcc.wuf.find(lcc.mark[x][y]-1);
                        }
                        else
                        lcc.mark[x][y] = lcc.wuf.find(lcc.mark[x][y]);
                    }
                }
            }
            //印出屬於哪一群若無則印出0
            System.out.println(lcc.mark[targetx][targety]);
        }
    }
}

@2b3ca624e4246c3e32ec61a0a7a8c1f2@"
"r04942099","9","3.12","183680","@64bbef071672577245f94cfc7693f8f8@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
            
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<(target[0]-1)*size+target[1]-1;++i){
                if(state[i]==1){
                int check=number[i];
                 for(int j=0;j<(target[0]-1)*size+target[1]-1;++j){
                     
                     if(wei.connected( idt[i],idt[j]) ){                         
                             if(check>number[j]){
                                 check = number[j];
                             }
                     }        
                 }
                 number[i]=check;
                 for(int j=0;j<size*size;++j){
                     if(wei.connected( idt[i],idt[j]) ) number[j]=check;                             
                 }
                }
            }
            
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[0]-1]);
            
            if(state[(target[0]-1)*size+target[1]-1]==1)
            System.out.println(number[ (target[0]-1)*size+target[1]-1 ]);
            else System.out.print(0);
        }

    }
}
@64bbef071672577245f94cfc7693f8f8@"
"r04631023","7","1.11","157168","@a8b97036af5530f7787cec7979efb648@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N];
            int count = 1;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.println(""1,1"");
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                id[N * (x - 1) + y] = 1;
            }

            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == 1 && y == N) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == N && y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == N && y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == 1) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] != 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        }
                    }
                }
            }
            
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        for (int k = 1; k <= count; k++) {
                            //System.out.printf(""%d\n"", x);
                            //System.out.printf(""%d\n"", y);
                            //System.out.printf(""%d\n"", k);
                            //System.out.printf(""%d\n"", uf.find(N * (x - 1) + y));
                            if (Label[k] == uf.find(N * (x - 1) + y)) {
                                break ;
                            }
                            if (k == count) {
                                Label[count] = uf.find(N * (x - 1) + y);
                                count++;
                                break ;
                            }
                        }
                    }
                }
            }
            Arrays.sort(Label);
            for (int i = N*N-1; i >= (N*N-count+1); i = i-1) {
                if (Label[i] == uf.find(N * (Locationx - 1) + Locationy)) {
                    System.out.printf(""%d\n"", i-(N*N)+count);
                }
            }
        }
    }
}

@a8b97036af5530f7787cec7979efb648@"
"r04631023","7","1.11","153488","@1b1be140c72ce996cf75b2e04d7807c5@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N];
            int count = 1;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.println(""1,1"");
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                id[N * (x - 1) + y] = 1;
            }

            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == 1 && y == N) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == N && y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == N && y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == 1) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] != 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        }
                    }
                }
            }
            if(id[(N * (Locationx - 1) + Locationy)] == 1){
                System.out.printf(""%d\n"", 0);
                return ;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        for (int k = 1; k <= count; k++) {
                            //System.out.printf(""%d\n"", x);
                            //System.out.printf(""%d\n"", y);
                            //System.out.printf(""%d\n"", k);
                            //System.out.printf(""%d\n"", uf.find(N * (x - 1) + y));
                            if (Label[k] == uf.find(N * (x - 1) + y)) {
                                break ;
                            }
                            if (k == count) {
                                Label[count] = uf.find(N * (x - 1) + y);
                                count++;
                                break ;
                            }
                        }
                    }
                }
            }
            Arrays.sort(Label);
            for (int i = N*N-1; i >= (N*N-count+1); i = i-1) {
                if (Label[i] == uf.find(N * (Locationx - 1) + Locationy)) {
                    System.out.printf(""%d\n"", i-(N*N)+count);
                }
            }
        }
    }
}

@1b1be140c72ce996cf75b2e04d7807c5@"
"r04921104","4","0.76","134224","@2010600c2ab2219b87e93a62c6da9034@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;
import java.util.Arrays;

public class LabelCC {
    
    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    public LabelCC(int N) {
        if (N < 0) {
            throw new IllegalArgumentException();
        }
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }

        parent[rootQ] = rootP;
        rank[rootP]++;
    }

    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
        }
    }

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[] target = {Integer.valueOf(info.get(0)[1]), Integer.valueOf(info.get(0)[2])};
        int[][] image = new int[size][size];

        //initiallize image
        for (int i = 0; i < image.length; i++) {
            Arrays.fill(image[i], 1);
        }
        for (int i = 1; i < info.size(); i++) {
            image[Integer.valueOf(info.get(i)[0]) - 1][Integer.valueOf(info.get(i)[1]) - 1] = 0;
        }

        //initiallize uf object
        LabelCC uf = new LabelCC(size * size);
//        for(int i = 0; i < image.length; i++){
//            for(int j = 0; j < image[0].length; j++){
//                System.out.print(image[i][j]+ "" "");
//            }
//            System.out.println(' ');
//        }
        int label = 1;
        for (int i = 0; i < image.length; i++) {
            for (int j = 0; j < image[0].length; j++) {
                if (image[i][j] > 0) {
                    try {
                        if (image[i][j - 1] > 0 && image[i - 1][j] > 0) {
                            if (image[i][j - 1] < image[i - 1][j]) {
                                image[i][j] = image[i][j - 1];
                                uf.union(size * i + j - 1, size * i + j);
                                uf.union(size * i + j - 1, size * (i - 1) + j);
                            } else {
                                image[i][j] = image[i - 1][j];
                                uf.union(size * (i - 1) + j, size * i + j);
                                uf.union(size * (i - 1) + j, size * i + j - 1);
                            }
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i][j - 1] > 0) {
                            image[i][j] = image[i][j - 1];
                            uf.union(size * i + j - 1, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i - 1][j] > 0) {
                            image[i][j] = image[i - 1][j];
                            uf.union(size * (i - 1) + j, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    image[i][j] = label;
                    label++;
                }
            }
        }

        int ii = uf.find(size * (target[0] - 1) + target[1] - 1) / 8;
        int jj = uf.find(size * (target[0] - 1) + target[1] - 1) % 8;
        System.out.println(image[ii][jj]);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                if (image[i][j] == 0) {
//                    System.out.print(""x"" + ""    "");
//                } else {
//                    if (uf.find(size * i + j) > 10) {
//                        System.out.print(uf.find(size * i + j) + ""   "");
//                    } else {
//                        System.out.print(uf.find(size * i + j) + ""    "");
//                    }
//                }
//            }
//            System.out.println(' ');
//        }
    }
}

@2010600c2ab2219b87e93a62c6da9034@"
"r04921104","4","0.89","132832","@d75fc580f471f6d41d9f10c33d3e5b61@import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;
import java.util.Arrays;

public class LabelCC {
    
    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    public LabelCC(int N) {
        if (N < 0) {
            throw new IllegalArgumentException();
        }
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }

        parent[rootQ] = rootP;
        rank[rootP]++;
    }

    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
        }
    }

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[] target = {Integer.valueOf(info.get(0)[1]), Integer.valueOf(info.get(0)[2])};
        int[][] image = new int[size][size];

        //initiallize image
        for (int i = 0; i < image.length; i++) {
            Arrays.fill(image[i], 1);
        }
        for (int i = 1; i < info.size(); i++) {
            image[Integer.valueOf(info.get(i)[0]) - 1][Integer.valueOf(info.get(i)[1]) - 1] = 0;
        }

        //initiallize uf object
        UF uf = new UF(size * size);
//        for(int i = 0; i < image.length; i++){
//            for(int j = 0; j < image[0].length; j++){
//                System.out.print(image[i][j]+ "" "");
//            }
//            System.out.println(' ');
//        }
        int label = 1;
        for (int i = 0; i < image.length; i++) {
            for (int j = 0; j < image[0].length; j++) {
                if (image[i][j] > 0) {
                    try {
                        if (image[i][j - 1] > 0 && image[i - 1][j] > 0) {
                            if (image[i][j - 1] < image[i - 1][j]) {
                                image[i][j] = image[i][j - 1];
                                uf.union(size * i + j - 1, size * i + j);
                                uf.union(size * i + j - 1, size * (i - 1) + j);
                            } else {
                                image[i][j] = image[i - 1][j];
                                uf.union(size * (i - 1) + j, size * i + j);
                                uf.union(size * (i - 1) + j, size * i + j - 1);
                            }
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i][j - 1] > 0) {
                            image[i][j] = image[i][j - 1];
                            uf.union(size * i + j - 1, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i - 1][j] > 0) {
                            image[i][j] = image[i - 1][j];
                            uf.union(size * (i - 1) + j, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    image[i][j] = label;
                    label++;
                }
            }
        }

        int ii = uf.find(size * (target[0] - 1) + target[1] - 1) / 8;
        int jj = uf.find(size * (target[0] - 1) + target[1] - 1) % 8;
        System.out.println(image[ii][jj]);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                if (image[i][j] == 0) {
//                    System.out.print(""x"" + ""    "");
//                } else {
//                    if (uf.find(size * i + j) > 10) {
//                        System.out.print(uf.find(size * i + j) + ""   "");
//                    } else {
//                        System.out.print(uf.find(size * i + j) + ""    "");
//                    }
//                }
//            }
//            System.out.println(' ');
//        }
    }
}

@d75fc580f471f6d41d9f10c33d3e5b61@"
"r04921104","0","1.43","180320","@099adfe68ddeca39644d78b77104cdd0@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;
import java.util.Arrays;

public class LabelCC {

    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    public LabelCC(int N) {
        if (N < 0) {
            throw new IllegalArgumentException();
        }
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }

        parent[rootQ] = rootP;
        rank[rootP]++;
    }

    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
        }
    }

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[] target = {Integer.valueOf(info.get(0)[1]), Integer.valueOf(info.get(0)[2])};
        int[][] image = new int[size][size];

        //initiallize image
        for (int i = 0; i < image.length; i++) {
            Arrays.fill(image[i], 1);
        }
        for (int i = 1; i < info.size(); i++) {
            image[Integer.valueOf(info.get(i)[0]) - 1][Integer.valueOf(info.get(i)[1]) - 1] = 0;
        }

        //initiallize uf object
        UF uf = new UF(size * size);
        for (int i = 0; i < image.length; i++) {
            for (int j = 0; j < image[0].length; j++) {
                System.out.print(image[i][j] + "" "");
            }
            System.out.println(' ');
        }
        int label = 1;
        for (int i = 0; i < image.length; i++) {
            for (int j = 0; j < image[0].length; j++) {
                if (image[i][j] > 0) {
                    try {
                        if (image[i][j - 1] > 0 && image[i - 1][j] > 0) {
                            if (image[i][j - 1] < image[i - 1][j]) {
                                image[i][j] = image[i][j - 1];
                                uf.union(size * i + j - 1, size * i + j);
                                uf.union(size * i + j - 1, size * (i - 1) + j);
                            } else {
                                image[i][j] = image[i - 1][j];
                                uf.union(size * (i - 1) + j, size * i + j);
                                uf.union(size * (i - 1) + j, size * i + j - 1);
                            }
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i][j - 1] > 0) {
                            image[i][j] = image[i][j - 1];
                            uf.union(size * i + j - 1, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i - 1][j] > 0) {
                            image[i][j] = image[i - 1][j];
                            uf.union(size * (i - 1) + j, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    image[i][j] = label;
                    label++;
                }
            }
        }

        int ii = uf.find(size * (target[0] - 1) + target[1] - 1) / size;
        int jj = uf.find(size * (target[0] - 1) + target[1] - 1) % size;
        System.out.println(image[ii][jj]);
        for (int i = 0; i < image.length; i++) {
            for (int j = 0; j < image[0].length; j++) {
                ii = uf.find(size * i + j) / size;
                jj = uf.find(size * i + j) % size;
                System.out.print(image[ii][jj] + ""   "");
            }
            System.out.println(' ');
        }
    }
}

@099adfe68ddeca39644d78b77104cdd0@"
"r04921104","0","1.11","125872","@a159bb1cc4a1e85c69e46b5f7552d9e1@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import edu.princeton.cs.algs4.UF;
import java.util.Arrays;

public class LabelCC {

    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    public LabelCC(int N) {
        if (N < 0) {
            throw new IllegalArgumentException();
        }
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }

        parent[rootQ] = rootP;
        rank[rootP]++;
    }

    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
        }
    }

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[] target = {Integer.valueOf(info.get(0)[1]), Integer.valueOf(info.get(0)[2])};
        int[][] image = new int[size][size];

        //initiallize image
        for (int i = 0; i < image.length; i++) {
            Arrays.fill(image[i], 1);
        }
        for (int i = 1; i < info.size(); i++) {
            image[Integer.valueOf(info.get(i)[0]) - 1][Integer.valueOf(info.get(i)[1]) - 1] = 0;
        }

        //initiallize uf object
        UF uf = new UF(size * size);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                System.out.print(image[i][j] + "" "");
//            }
//            System.out.println(' ');
//        }
        int label = 1;
        for (int i = 0; i < image.length; i++) {
            for (int j = 0; j < image[0].length; j++) {
                if (image[i][j] > 0) {
                    try {
                        if (image[i][j - 1] > 0 && image[i - 1][j] > 0) {
                            if (image[i][j - 1] < image[i - 1][j]) {
                                image[i][j] = image[i][j - 1];
                                uf.union(size * i + j - 1, size * i + j);
                                uf.union(size * i + j - 1, size * (i - 1) + j);
                            } else {
                                image[i][j] = image[i - 1][j];
                                uf.union(size * (i - 1) + j, size * i + j);
                                uf.union(size * (i - 1) + j, size * i + j - 1);
                            }
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i][j - 1] > 0) {
                            image[i][j] = image[i][j - 1];
                            uf.union(size * i + j - 1, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i - 1][j] > 0) {
                            image[i][j] = image[i - 1][j];
                            uf.union(size * (i - 1) + j, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    image[i][j] = label;
                    label++;
                }
            }
        }

        int ii = uf.find(size * (target[0] - 1) + target[1] - 1) / size;
        int jj = uf.find(size * (target[0] - 1) + target[1] - 1) % size;
        System.out.println(image[ii][jj]);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                ii = uf.find(size * i + j) / size;
//                jj = uf.find(size * i + j) % size;
//                System.out.print(image[ii][jj] + ""   "");
//            }
//            System.out.println(' ');
//        }
    }
}

@a159bb1cc4a1e85c69e46b5f7552d9e1@"
"r04921104","9","1","148176","@81f7244a6be40ffe1203d673e53f3605@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;
import java.util.Arrays;

public class LabelCC {

    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    public LabelCC(int N) {
        if (N < 0) {
            throw new IllegalArgumentException();
        }
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }

        parent[rootQ] = rootP;
        rank[rootP]++;
    }

    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
        }
    }

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[] target = {Integer.valueOf(info.get(0)[1]), Integer.valueOf(info.get(0)[2])};
        int[][] image = new int[size][size];

        //initiallize image
        for (int i = 0; i < image.length; i++) {
            Arrays.fill(image[i], 1);
        }
        for (int i = 1; i < info.size(); i++) {
            image[Integer.valueOf(info.get(i)[0]) - 1][Integer.valueOf(info.get(i)[1]) - 1] = 0;
        }

        //initiallize uf object
        UF uf = new UF(size * size);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                System.out.print(image[i][j] + "" "");
//            }
//            System.out.println(' ');
//        }
        int label = 1;
        for (int i = 0; i < image.length; i++) {
            for (int j = 0; j < image[0].length; j++) {
                if (image[i][j] > 0) {
                    try {
                        if (image[i][j - 1] > 0 && image[i - 1][j] > 0) {
                            if (image[i][j - 1] < image[i - 1][j]) {
                                image[i][j] = image[i][j - 1];
                                uf.union(size * i + j - 1, size * i + j);
                                uf.union(size * i + j - 1, size * (i - 1) + j);
                            } else {
                                image[i][j] = image[i - 1][j];
                                uf.union(size * (i - 1) + j, size * i + j);
                                uf.union(size * (i - 1) + j, size * i + j - 1);
                            }
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i][j - 1] > 0) {
                            image[i][j] = image[i][j - 1];
                            uf.union(size * i + j - 1, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i - 1][j] > 0) {
                            image[i][j] = image[i - 1][j];
                            uf.union(size * (i - 1) + j, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    image[i][j] = label;
                    label++;
                }
            }
        }

        int ii = uf.find(size * (target[0] - 1) + target[1] - 1) / size;
        int jj = uf.find(size * (target[0] - 1) + target[1] - 1) % size;
        System.out.println(image[ii][jj]);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                ii = uf.find(size * i + j) / size;
//                jj = uf.find(size * i + j) % size;
//                System.out.print(image[ii][jj] + ""   "");
//            }
//            System.out.println(' ');
//        }
    }
}

@81f7244a6be40ffe1203d673e53f3605@"
"r04921104","10","0.104","148624","@5bb7606221b22d04fdbb2be02a940587@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;
import java.util.Arrays;

public class LabelCC {

    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private int count;     // number of components

    public LabelCC(int N) {
        if (N < 0) {
            throw new IllegalArgumentException();
        }
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }

    public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }

    public int count() {
        return count;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }

        parent[rootQ] = rootP;
        rank[rootP]++;
    }

    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
        }
    }

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[] target = {Integer.valueOf(info.get(0)[1]), Integer.valueOf(info.get(0)[2])};
        int[][] image = new int[size][size];

        //initiallize image
        for (int i = 0; i < image.length; i++) {
            Arrays.fill(image[i], 1);
        }
        for (int i = 1; i < info.size(); i++) {
            image[Integer.valueOf(info.get(i)[0]) - 1][Integer.valueOf(info.get(i)[1]) - 1] = 0;
        }

        //initiallize uf object
        LabelCC uf = new LabelCC(size * size);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                System.out.print(image[i][j] + "" "");
//            }
//            System.out.println(' ');
//        }
        int label = 1;
        for (int i = 0; i < image.length; i++) {
            for (int j = 0; j < image[0].length; j++) {
                if (image[i][j] > 0) {
                    try {
                        if (image[i][j - 1] > 0 && image[i - 1][j] > 0) {
                            if (image[i][j - 1] < image[i - 1][j]) {
                                image[i][j] = image[i][j - 1];
                                uf.union(size * i + j - 1, size * i + j);
                                uf.union(size * i + j - 1, size * (i - 1) + j);
                            } else {
                                image[i][j] = image[i - 1][j];
                                uf.union(size * (i - 1) + j, size * i + j);
                                uf.union(size * (i - 1) + j, size * i + j - 1);
                            }
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i][j - 1] > 0) {
                            image[i][j] = image[i][j - 1];
                            uf.union(size * i + j - 1, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i - 1][j] > 0) {
                            image[i][j] = image[i - 1][j];
                            uf.union(size * (i - 1) + j, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    image[i][j] = label;
                    label++;
                }
            }
        }

        int ii = uf.find(size * (target[0] - 1) + target[1] - 1) / size;
        int jj = uf.find(size * (target[0] - 1) + target[1] - 1) % size;
        System.out.println(image[ii][jj]);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                ii = uf.find(size * i + j) / size;
//                jj = uf.find(size * i + j) % size;
//                System.out.print(image[ii][jj] + ""   "");
//            }
//            System.out.println(' ');
//        }
    }
}

@5bb7606221b22d04fdbb2be02a940587@"
"r04921104","10","0.103","148528","@3610ba909d6783848bfd1819969a3ef8@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.UF;
import java.util.Arrays;

public class LabelCC {

    private static class custom_UF {

        private int[] parent;  // parent[i] = parent of i
        private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
        private int count;     // number of components

        public custom_UF(int N) {
            if (N < 0) {
                throw new IllegalArgumentException();
            }
            count = N;
            parent = new int[N];
            rank = new byte[N];
            for (int i = 0; i < N; i++) {
                parent[i] = i;
                rank[i] = 0;
            }
        }

        public int find(int p) {
            validate(p);
            while (p != parent[p]) {
                parent[p] = parent[parent[p]];    // path compression by halving
                p = parent[p];
            }
            return p;
        }

        public int count() {
            return count;
        }

        public boolean connected(int p, int q) {
            return find(p) == find(q);
        }

        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ) {
                return;
            }

            parent[rootQ] = rootP;
            rank[rootP]++;
        }

        private void validate(int p) {
            int N = parent.length;
            if (p < 0 || p >= N) {
                throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
            }
        }
    }

    public static void main(String[] args) throws Exception {

        //Read input and pre-proccess all attribute
        BufferedReader br = null;
        String sCurrentLine;
        List<String[]> info = new ArrayList<String[]>();
        try {
            br = new BufferedReader(new FileReader(args[0]));
            while ((sCurrentLine = br.readLine()) != null) {
                String[] Line = sCurrentLine.split("","");
                info.add(sCurrentLine.split("",""));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        int size = Integer.valueOf(info.get(0)[0]);
        int[] target = {Integer.valueOf(info.get(0)[1]), Integer.valueOf(info.get(0)[2])};
        int[][] image = new int[size][size];

        //initiallize image
        for (int i = 0; i < image.length; i++) {
            Arrays.fill(image[i], 1);
        }
        for (int i = 1; i < info.size(); i++) {
            image[Integer.valueOf(info.get(i)[0]) - 1][Integer.valueOf(info.get(i)[1]) - 1] = 0;
        }

        //initiallize uf object
        custom_UF uf = new custom_UF(size * size);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                System.out.print(image[i][j] + "" "");
//            }
//            System.out.println(' ');
//        }
        int label = 1;
        for (int i = 0; i < image.length; i++) {
            for (int j = 0; j < image[0].length; j++) {
                if (image[i][j] > 0) {
                    try {
                        if (image[i][j - 1] > 0 && image[i - 1][j] > 0) {
                            if (image[i][j - 1] < image[i - 1][j]) {
                                image[i][j] = image[i][j - 1];
                                uf.union(size * i + j - 1, size * i + j);
                                uf.union(size * i + j - 1, size * (i - 1) + j);
                            } else {
                                image[i][j] = image[i - 1][j];
                                uf.union(size * (i - 1) + j, size * i + j);
                                uf.union(size * (i - 1) + j, size * i + j - 1);
                            }
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i][j - 1] > 0) {
                            image[i][j] = image[i][j - 1];
                            uf.union(size * i + j - 1, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    try {
                        if (image[i - 1][j] > 0) {
                            image[i][j] = image[i - 1][j];
                            uf.union(size * (i - 1) + j, size * i + j);
                            continue;
                        }
                    } catch (ArrayIndexOutOfBoundsException e) {
                    }
                    image[i][j] = label;
                    label++;
                }
            }
        }

        int ii = uf.find(size * (target[0] - 1) + target[1] - 1) / size;
        int jj = uf.find(size * (target[0] - 1) + target[1] - 1) % size;
        System.out.println(image[ii][jj]);
//        for (int i = 0; i < image.length; i++) {
//            for (int j = 0; j < image[0].length; j++) {
//                ii = uf.find(size * i + j) / size;
//                jj = uf.find(size * i + j) % size;
//                System.out.print(image[ii][jj] + ""   "");
//            }
//            System.out.println(' ');
//        }
    }
}

@3610ba909d6783848bfd1819969a3ef8@"
"r04921051","9","1.09","130048","@87c66de811e5e6bdb2883d8305457d73@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }

            
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            for(int temp = 0; temp <= len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }

        
            //print(dimension, matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@87c66de811e5e6bdb2883d8305457d73@"
"r04921051","0","2","271840","@e39baddea552795a9fb38f9de5b40146@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }

            
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            for(int temp = 0; temp <= len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
            int len2 = 0;
            int[][] tree2 = new int[dimension*dimension][2];
            
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree2[len2][1] = matrix[i][j];
                            tree2[len2][0] = matrix[i][j-1];}
                        else{
                            tree2[len2][0] = matrix[i][j];
                            tree2[len2][1] = matrix[i][j-1];}
                        len2++;
                    }
                }
            }
            
            for(int temp = 0; temp <= len2; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree2[temp][1]){
                    matrix[i][j] = tree2[temp][0];
                            
                }    
                }
            }
            }

        
            print(dimension, matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@e39baddea552795a9fb38f9de5b40146@"
"r04921051","0","1.96","264400","@e39baddea552795a9fb38f9de5b40146@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }

            
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            for(int temp = 0; temp <= len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
            int len2 = 0;
            int[][] tree2 = new int[dimension*dimension][2];
            
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree2[len2][1] = matrix[i][j];
                            tree2[len2][0] = matrix[i][j-1];}
                        else{
                            tree2[len2][0] = matrix[i][j];
                            tree2[len2][1] = matrix[i][j-1];}
                        len2++;
                    }
                }
            }
            
            for(int temp = 0; temp <= len2; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree2[temp][1]){
                    matrix[i][j] = tree2[temp][0];
                            
                }    
                }
            }
            }

        
            print(dimension, matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@e39baddea552795a9fb38f9de5b40146@"
"r04921051","9","1.12","134816","@37219194d2cea0e224e177eaefbc415b@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }

            
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            for(int temp = 0; temp <= len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
            int len2 = 0;
            int[][] tree2 = new int[dimension*dimension][2];
            
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree2[len2][1] = matrix[i][j];
                            tree2[len2][0] = matrix[i][j-1];}
                        else{
                            tree2[len2][0] = matrix[i][j];
                            tree2[len2][1] = matrix[i][j-1];}
                        len2++;
                    }
                }
            }
            
            for(int temp = 0; temp <= len2; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree2[temp][1]){
                    matrix[i][j] = tree2[temp][0];
                            
                }    
                }
            }
            }

        
            //print(dimension, matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@37219194d2cea0e224e177eaefbc415b@"
"r04942099","9","3.11","175344","@339cd3583c816501854442d42ff40f1d@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
            if(state[(target[0]-1)*size+target[1]-1]==1){
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<(target[0]-1)*size+target[1]-1;++i){
                if(state[i]==1){
                int check=number[i];
                 for(int j=0;j<(target[0]-1)*size+target[1]-1;++j){
                     
                     if(wei.connected( idt[i],idt[j]) ){                         
                             if(check>number[j]){
                                 check = number[j];
                             }
                     }        
                 }
                 number[i]=check;
                 for(int j=0;j<size*size;++j){
                     if(wei.connected( idt[i],idt[j]) ) number[j]=check;                             
                 }
                }
            }
            }
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[0]-1]);
            
            if(state[(target[0]-1)*size+target[1]-1]==1)
            System.out.println(number[ (target[0]-1)*size+target[1]-1 ]);
            else System.out.println(0);
        }

    }
}
@339cd3583c816501854442d42ff40f1d@"
"r04942099","8","1.47","172992","@72ae97759b06913e942da2ebdf29e6e8@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
            if(state[(target[0]-1)*size+target[1]-1]==1){
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<size*size;++i){
                if(state[i]==1){
                int check=number[i];
                 for(int j=0;j<size*size;++j){
                     
                     if(wei.connected( idt[i],idt[j]) ){                         
                             if(check>number[j]){
                                 check = number[j];
                             }
                     }        
                 }
                 number[i]=check;
                 for(int j=0;j<size*size;++j){
                     if(wei.connected( idt[i],idt[j]) ) number[j]=check;                             
                 }
                }
            }
            }
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[1]-1]);
            
           
            System.out.print(number[ (target[0]-1)*size+target[1]-1 ]);
            
        }

    }
}
@72ae97759b06913e942da2ebdf29e6e8@"
"r04447001","5","0.98","123808","@9fc90089aa5f1846f14ce0a49b645dad@import java.io.FileReader;
import java.io.BufferedReader;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class LabelCC {
    protected int[] parent;  // parent[i] = parent of i
    protected byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    protected int count;     // number of components

    
    public LabelCC(int N) {
        if (N < 0) throw new IllegalArgumentException();
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    public int returnCC(int i){
    return parent[i];
    }
    
     public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }
     
      public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    
      public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootQ] = rootP;
    }//changed version for simple union to support 
      
    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
      
      
     public static void main(String[] args)throws Exception {
        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        String[] data3 = data.split("","");
        int N = Integer.parseInt(data3[0]);
        int targetx = Integer.parseInt(data3[1]);
        int targety = Integer.parseInt(data3[2]);//target X and target y
        
        
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
            Statearray[i][j] = 1;
            }
        }//initialize array with all open

        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 0; // close this site       
        }
        br.close();
        LabelCC result = new LabelCC(12);//initialize artificial groupings
        int[][] Labelarray = new int[N][N];   
        int currentlabel = 1;
        for(int i = 0; i < N ; i ++){
            for (int j = 0; j < N; j++) {
                if (Statearray[i][j] == 0) {
                    continue;
                } else if (checkbound(i - 1, N) && checkbound(j - 1, N) && Statearray[(i - 1)][j] * Statearray[i][(j - 1)] == 1) {
                    int Label1 = Labelarray[(i - 1)][j];
                    int Label2 = Labelarray[i][(j - 1)];
                    if (Label1 > Label2) {
                        Labelarray[i][j] = Label2;
                        result.union(Label1, Label2);
                    } else {
                        Labelarray[i][j] = Label1;
                        result.union(Label2, Label1);
                    }
                } else if (checkbound(i - 1, N) && Statearray[(i - 1)][j] == 1) {
                    Labelarray[i][j] = Labelarray[(i - 1)][j];
                } else if (checkbound(j - 1, N) && Statearray[i][(j - 1)] == 1) {
                    Labelarray[i][j] = Labelarray[i][(j - 1)];
                } else {
                    Labelarray[i][j] = currentlabel;
                    currentlabel++;
                }
            }
        }// the first run

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (Labelarray[i][j] != 0) {
                        int nowlabel = Labelarray[i][j];
                        if (result.returnCC(nowlabel) != result.find(nowlabel)) {
                            int newlabel = result.find(nowlabel);
                            Labelarray[i][j] = newlabel;
                        }
                    }
                }
            }

        System.out.print(Labelarray[(targetx-1)][(targety-1)]);
        }
        
        catch(Exception e){
          System.out.println(-1);  
        }
    }
     
    public static boolean checkbound(int P, int Q) {
        boolean result = true;
        if (P < 0 || P > (Q - 1)) {
            result = false;
        }
        return result;
    }
}

@9fc90089aa5f1846f14ce0a49b645dad@"
"r04447001","6","0.99","123200","@3a0c03f75df7442333a2677813e444b9@import java.io.FileReader;
import java.io.BufferedReader;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class LabelCC {
    protected int[] parent;  // parent[i] = parent of i
    protected byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    protected int count;     // number of components

    
    public LabelCC(int N) {
        if (N < 0) throw new IllegalArgumentException();
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    public int returnCC(int i){
    return parent[i];
    }
    
     public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }
     
      public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    
      public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootQ] = rootP;
    }//changed version for simple union to support 
      
    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
      
      
     public static void main(String[] args)throws Exception {
        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        String[] data3 = data.split("","");
        int N = Integer.parseInt(data3[0]);
        int targetx = Integer.parseInt(data3[1]);
        int targety = Integer.parseInt(data3[2]);//target X and target y
        
        
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
            Statearray[i][j] = 1;
            }
        }//initialize array with all open

        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 0; // close this site       
        }
        br.close();
        LabelCC result = new LabelCC(64);//initialize artificial groupings
        int[][] Labelarray = new int[N][N];   
        int currentlabel = 1;
        for(int i = 0; i < N ; i ++){
            for (int j = 0; j < N; j++) {
                if (Statearray[i][j] == 0) {
                    continue;
                } else if (checkbound(i - 1, N) && checkbound(j - 1, N) && Statearray[(i - 1)][j] * Statearray[i][(j - 1)] == 1) {
                    int Label1 = Labelarray[(i - 1)][j];
                    int Label2 = Labelarray[i][(j - 1)];
                    if (Label1 > Label2) {
                        Labelarray[i][j] = Label2;
                        result.union(Label1, Label2);
                    } else {
                        Labelarray[i][j] = Label1;
                        result.union(Label2, Label1);
                    }
                } else if (checkbound(i - 1, N) && Statearray[(i - 1)][j] == 1) {
                    Labelarray[i][j] = Labelarray[(i - 1)][j];
                } else if (checkbound(j - 1, N) && Statearray[i][(j - 1)] == 1) {
                    Labelarray[i][j] = Labelarray[i][(j - 1)];
                } else {
                    Labelarray[i][j] = currentlabel;
                    currentlabel++;
                }
            }
        }// the first run

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (Labelarray[i][j] != 0) {
                        int nowlabel = Labelarray[i][j];
                        if (result.returnCC(nowlabel) != result.find(nowlabel)) {
                            int newlabel = result.find(nowlabel);
                            Labelarray[i][j] = newlabel;
                        }
                    }
                }
            }

        System.out.print(Labelarray[(targetx-1)][(targety-1)]);
        }
        
        catch(Exception e){
          System.out.println(-1);  
        }
    }
     
    public static boolean checkbound(int P, int Q) {
        boolean result = true;
        if (P < 0 || P > (Q - 1)) {
            result = false;
        }
        return result;
    }
}

@3a0c03f75df7442333a2677813e444b9@"
"r04921051","0","1.06","274400","@ff90167da89b317cb6efb36a11e649e4@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }

            
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
    for (int k = 0; k < 5;k++){
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            System.out.println(dimension);
            for (int i=0; i < len; i++)
            System.out.printf(""(%d,%d)\n"",tree[i][0],tree[i][1]);
            
            
            
            for(int temp = 0; temp < len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
                
    }    
            print(dimension, matrix);
            
            
            //System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@ff90167da89b317cb6efb36a11e649e4@"
"r04921051","9","1.79","138192","@e345180297a7d6c1bdcbd497fd119c76@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }

            
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
    for (int k = 0; k < 5;k++){
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            //System.out.println(dimension);
            //for (int i=0; i < len; i++)
            //System.out.printf(""(%d,%d)\n"",tree[i][0],tree[i][1]);
            
            
            
            for(int temp = 0; temp < len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
                
    }    
            //print(dimension, matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@e345180297a7d6c1bdcbd497fd119c76@"
"r04921051","8","1.12","146336","@149df29d406145d5bf9c65c7a60fba7f@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }

            
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
    for (int k = 0; k < 1000;k++){
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            //System.out.println(dimension);
            //for (int i=0; i < len; i++)
            //System.out.printf(""(%d,%d)\n"",tree[i][0],tree[i][1]);
            
            
            
            for(int temp = 0; temp < len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
                
    }    
            //print(dimension, matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@149df29d406145d5bf9c65c7a60fba7f@"
"r04921051","8","0.78","141200","@2d5e0c2e054126e9cf927060bc72bdb3@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }

            
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
    for (int k = 0; k < 100;k++){
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            //System.out.println(dimension);
            //for (int i=0; i < len; i++)
            //System.out.printf(""(%d,%d)\n"",tree[i][0],tree[i][1]);
            
            
            
            for(int temp = 0; temp < len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
                
    }    
            //print(dimension, matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@2d5e0c2e054126e9cf927060bc72bdb3@"
"r04921051","9","3.19","137440","@f07c0beea8e4e15677868480ce139235@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }

            
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
    for (int k = 0; k < 10;k++){
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            //System.out.println(dimension);
            //for (int i=0; i < len; i++)
            //System.out.printf(""(%d,%d)\n"",tree[i][0],tree[i][1]);
            
            
            
            for(int temp = 0; temp < len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
                
    }    
            //print(dimension, matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@f07c0beea8e4e15677868480ce139235@"
"r04447001","7","0.99","121376","@6e536c2111f33674393f1aaf663d8433@import java.io.FileReader;
import java.io.BufferedReader;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class LabelCC {
    protected int[] parent;  // parent[i] = parent of i
    protected byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    protected int count;     // number of components

    
    public LabelCC(int N) {
        if (N < 0) throw new IllegalArgumentException();
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    public int returnCC(int i){
    return parent[i];
    }
    
     public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }
     
      public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    
      public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootQ] = rootP;
    }//changed version for simple union to support 
      
    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
      
      
     public static void main(String[] args)throws Exception {
        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        String[] data3 = data.split("","");
        int N = Integer.parseInt(data3[0]);
        int targetx = Integer.parseInt(data3[1]);
        int targety = Integer.parseInt(data3[2]);//target X and target y
        
        
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
            Statearray[i][j] = 1;
            }
        }//initialize array with all open

        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 0; // close this site       
        }
        br.close();
        LabelCC result = new LabelCC(20);//initialize artificial groupings
        int[][] Labelarray = new int[N][N];   
        int currentlabel = 1;
        for(int i = 0; i < N ; i ++){
            for (int j = 0; j < N; j++) {
                if (Statearray[i][j] == 0) {
                    continue;
                } else if (checkbound(i - 1, N) && checkbound(j - 1, N) && Statearray[(i - 1)][j] * Statearray[i][(j - 1)] == 1) {
                    int Label1 = Labelarray[(i - 1)][j];
                    int Label2 = Labelarray[i][(j - 1)];
                    if (Label1 > Label2) {
                        Labelarray[i][j] = Label2;
                        result.union(Label2, Label1);
                    } else {
                        Labelarray[i][j] = Label1;
                        result.union(Label1, Label2);
                    }
                } else if (checkbound(i - 1, N) && Statearray[(i - 1)][j] == 1) {
                    Labelarray[i][j] = Labelarray[(i - 1)][j];
                } else if (checkbound(j - 1, N) && Statearray[i][(j - 1)] == 1) {
                    Labelarray[i][j] = Labelarray[i][(j - 1)];
                } else {
                    Labelarray[i][j] = currentlabel;
                    currentlabel++;
                }
            }
        }// the first run

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (Labelarray[i][j] != 0) {
                        int nowlabel = Labelarray[i][j];
                        if (result.parent[i] != nowlabel) {
                            Labelarray[i][j] = result.find(nowlabel);
                        }
                    }
                }
            }//second run
            
            /*for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
            System.out.print(Labelarray[i][j]+"" "");
            }
            System.out.println();
            }*/

        System.out.print(Labelarray[(targetx-1)][(targety-1)]);
        }
        
        catch(Exception e){
          System.out.println(-1);  
        }
    }
     
    public static boolean checkbound(int P, int Q) {
        boolean result = true;
        if (P < 0 || P > (Q - 1)) {
            result = false;
        }
        return result;
    }
}

@6e536c2111f33674393f1aaf663d8433@"
"r04447001","7","0.96","124944","@268dadc6cf385583510b8b3e2b5f6dae@import java.io.FileReader;
import java.io.BufferedReader;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class LabelCC {
    protected int[] parent;  // parent[i] = parent of i
    protected byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    protected int count;     // number of components

    
    public LabelCC(int N) {
        if (N < 0) throw new IllegalArgumentException();
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    public int returnCC(int i){
    return parent[i];
    }
    
     public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }
     
      public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    
      public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootQ] = rootP;
    }//changed version for simple union to support 
      
    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
      
      
     public static void main(String[] args)throws Exception {
        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        String[] data3 = data.split("","");
        int N = Integer.parseInt(data3[0]);
        int targetx = Integer.parseInt(data3[1]);
        int targety = Integer.parseInt(data3[2]);//target X and target y
        
        
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
            Statearray[i][j] = 1;
            }
        }//initialize array with all open

        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 0; // close this site       
        }
        br.close();
        LabelCC result = new LabelCC(64);//initialize artificial groupings
        int[][] Labelarray = new int[N][N];   
        int currentlabel = 1;
        for(int i = 0; i < N ; i ++){
            for (int j = 0; j < N; j++) {
                if (Statearray[i][j] == 0) {
                    continue;
                } else if (checkbound(i - 1, N) && checkbound(j - 1, N) && Statearray[(i - 1)][j] * Statearray[i][(j - 1)] == 1) {
                    int Label1 = Labelarray[(i - 1)][j];
                    int Label2 = Labelarray[i][(j - 1)];
                    if (Label1 > Label2) {
                        Labelarray[i][j] = Label2;
                        result.union(Label2, Label1);
                    } else {
                        Labelarray[i][j] = Label1;
                        result.union(Label1, Label2);
                    }
                } else if (checkbound(i - 1, N) && Statearray[(i - 1)][j] == 1) {
                    Labelarray[i][j] = Labelarray[(i - 1)][j];
                } else if (checkbound(j - 1, N) && Statearray[i][(j - 1)] == 1) {
                    Labelarray[i][j] = Labelarray[i][(j - 1)];
                } else {
                    Labelarray[i][j] = currentlabel;
                    currentlabel++;
                }
            }
        }// the first run

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (Labelarray[i][j] != 0) {
                        int nowlabel = Labelarray[i][j];
                        if (result.parent[i] != nowlabel) {
                            Labelarray[i][j] = result.find(nowlabel);
                        }
                    }
                }
            }//second run
            
            /*for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
            System.out.print(Labelarray[i][j]+"" "");
            }
            System.out.println();
            }*/

        System.out.print(Labelarray[(targetx-1)][(targety-1)]);
        }
        
        catch(Exception e){
          System.out.println(-1);  
        }
    }
     
    public static boolean checkbound(int P, int Q) {
        boolean result = true;
        if (P < 0 || P > (Q - 1)) {
            result = false;
        }
        return result;
    }
}

@268dadc6cf385583510b8b3e2b5f6dae@"
"r04447001","10","0.099","126800","@b6b67d32d11715c61b5580c57525b66c@import java.io.FileReader;
import java.io.BufferedReader;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author jerry
 */
public class LabelCC {
    protected int[] parent;  // parent[i] = parent of i
    protected byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    protected int count;     // number of components

    
    public LabelCC(int N) {
        if (N < 0) throw new IllegalArgumentException();
        count = N;
        parent = new int[N];
        rank = new byte[N];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            rank[i] = 0;
        }
    }
    
    public int returnCC(int i){
    return parent[i];
    }
    
     public int find(int p) {
        validate(p);
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];    // path compression by halving
            p = parent[p];
        }
        return p;
    }
     
      public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    
      public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootQ] = rootP;
    }//changed version for simple union to support 
      
    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
      
      
     public static void main(String[] args)throws Exception {
        try{
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String data = br.readLine();//read in first integer
        String[] data3 = data.split("","");
        int N = Integer.parseInt(data3[0]);
        int targetx = Integer.parseInt(data3[1]);
        int targety = Integer.parseInt(data3[2]);//target X and target y
        
        
        int[][] Statearray = new int[N][N]; // using 0 and 1 to indicate location, 0 = close, 1 = open
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
            Statearray[i][j] = 1;
            }
        }//initialize array with all open

        //imagine both connected state in top and bottom row
        int x,x2,y,y2;
        for(String line = br.readLine(); line != null;line = br.readLine()){
        String[] data2 = line.split("","");
        x = Integer.parseInt(data2[0]);
        y = Integer.parseInt(data2[1]);
        x2 = x-1;
        y2 = y-1;//easy for array use
        Statearray[x2][y2] = 0; // close this site       
        }
        br.close();
        LabelCC result = new LabelCC(N*N);//initialize artificial groupings
        int[][] Labelarray = new int[N][N];   
        int currentlabel = 1;
        for(int i = 0; i < N ; i ++){
            for (int j = 0; j < N; j++) {
                if (Statearray[i][j] == 0) {
                    continue;
                } else if (checkbound(i - 1, N) && checkbound(j - 1, N) && Statearray[(i - 1)][j] * Statearray[i][(j - 1)] == 1) {
                    int Label1 = Labelarray[(i - 1)][j];
                    int Label2 = Labelarray[i][(j - 1)];
                    if (Label1 > Label2) {
                        Labelarray[i][j] = Label2;
                        result.union(Label2, Label1);
                    } else {
                        Labelarray[i][j] = Label1;
                        result.union(Label1, Label2);
                    }
                } else if (checkbound(i - 1, N) && Statearray[(i - 1)][j] == 1) {
                    Labelarray[i][j] = Labelarray[(i - 1)][j];
                } else if (checkbound(j - 1, N) && Statearray[i][(j - 1)] == 1) {
                    Labelarray[i][j] = Labelarray[i][(j - 1)];
                } else {
                    Labelarray[i][j] = currentlabel;
                    currentlabel++;
                }
            }
        }// the first run

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (Labelarray[i][j] != 0) {
                        int nowlabel = Labelarray[i][j];
                        if (result.parent[i] != nowlabel) {
                            Labelarray[i][j] = result.find(nowlabel);
                        }
                    }
                }
            }//second run
            
            /*for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
            System.out.print(Labelarray[i][j]+"" "");
            }
            System.out.println();
            }*/

        System.out.print(Labelarray[(targetx-1)][(targety-1)]);
        }
        
        catch(Exception e){
          System.out.println(-1);  
        }
    }
     
    public static boolean checkbound(int P, int Q) {
        boolean result = true;
        if (P < 0 || P > (Q - 1)) {
            result = false;
        }
        return result;
    }
}

@b6b67d32d11715c61b5580c57525b66c@"
"r04942099","8","1.89","164912","@a8a086dcfd29c6c56a177aa4165ea0ee@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int size = Integer.parseInt(data[0]);
            int [] target= new int [2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            // store the second integer in variable num (dimension of matrix: num * num)            
            // initilization of a String array in Java
            // printf in Java (you should comment out or delete this in your final submission)
            //System.out.printf(""number of announced strings: %d\ndimension of matrix: %d x %d\n"", stringCount, num, num);
            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) { //readLine()依序讀取檔案內的一行文字
                openstring = openstring + open + "" "";
                ++num;  //每讀一行，num就加1
            }
            String [] temp = new String[num];
            String [] temp2 = new String[num];
            int [][] match = new int[num][2];
            temp = openstring.split("" "");
            for(int i =0;i<num;++i){
                temp2 = temp[i].split("","");
                for(int j=0;j<2;++j){
                    match[i][j] = Integer.parseInt(temp2[j]);
                    //System.out.println(match[i][j]);
                }
            }
            int [] state = new int [size*size];//open or not
            int [] number = new int [size*size];
            int [] idt = new int [size*size];
            
            for(int i=0;i<size*size;++i){
                number[i]=0;
                state[i]=1;
                idt[i]=i;
            }
            QuickFindUF wei = new QuickFindUF(size*size);
            int now = 1; //assign number;
            int reg = 0;
            
            
            for(int i=0;i<num;++i){
                reg =  (match[i][0]-1)*size + match[i][1]-1 ;
                state[reg]=0;
            }
           
            for(int i=0;i<size*size;++i){
               if(state[i]==1){
                int neigh=0;
                
                if(i%size!=0){
                    if(state[i-1]==1){
                        wei.union(idt[i], idt[i-1]);
                        number[i]=number[i-1];
                        ++neigh;
                    }
                }
                if(i-size>-1){
                    if(state[i-size]==1){
                        wei.union(idt[i], idt[i-size]);
                        number[i]=number[i-size];
                        ++neigh;
                    }
                }
                if(neigh==0){
                    number[i]=now;
                    ++now;
                }
                
                
                
                
               }
            }
            
            for(int i=0;i<size*size;++i){
              if(state[i]==1){
                  if(i-size>-1&&state[i-size]==1){
                      if(number[i-size]<number[i]) wei.union(number[i], number[i-size]);
                      if(number[i-size]>number[i]) wei.union(number[i-size], number[i]);
                  }
                  if(i%size!=0&&state[i-1]==1){
                      if(number[i-1]<number[i]) wei.union(number[i], number[i-1]);
                      if(number[i-1]>number[i]) wei.union(number[i-1], number[i]);
              }
                
                
                
            }
            }
            
            //for(int i=0; i<size*size;++i) System.out.println(number[i]);
            //System.out.println(state[(target[0]-1)*size+target[1]-1]);
            
            
            System.out.print(number[ (target[0]-1)*size+target[1]-1 ]);
            
        }

    }
}

@a8a086dcfd29c6c56a177aa4165ea0ee@"
"r04942099","8","1.8","157408","@44ee3210d55d60419af2d87d2654a364@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;
                state[i] = 1;
                idt[i] = i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size * size);
            int now = 1;
            int reg = 0;

            for (int i = 0; i < num; ++i) {
                reg = (match[i][0] - 1) * size + match[i][1] - 1;
                state[reg] = 0;
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;

                    if (i % size != 0 && state[i - 1] == 1 && i - size > -1 && state[i - size] == 1) {
                        if (number[i - size] > number[i - 1]) {
                            wei.union(idt[i], idt[i - 1]);
                            number[i] = number[i - 1];
                            ++neigh;
                        } else {
                            wei.union(idt[i], idt[i - size]);
                            number[i] = number[i - size];
                            ++neigh;
                        }
                    } else if (i % size != 0 && state[i - 1] == 1) {
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    } else if (i - size > -1 && state[i - size] == 1) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;
                    }
                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    if (i - size > -1 && state[i - size] == 1) {
                        if (number[i - size] < number[i]) {
                            wei.union(number[i], number[i - size]);
                        }
                        if (number[i - size] > number[i]) {
                            wei.union(number[i - size], number[i]);
                        }
                    }
                    if (i % size != 0 && state[i - 1] == 1) {
                        if (number[i - 1] < number[i]) {
                            wei.union(number[i], number[i - 1]);
                        }
                        if (number[i - 1] > number[i]) {
                            wei.union(number[i - 1], number[i]);
                        }
                    }

                }
            }

            System.out.println(number[(target[0] - 1) * size + target[1] - 1]);

        }

    }
}

@44ee3210d55d60419af2d87d2654a364@"
"r04942099","8","1.81","155008","@3da01d8c901e7660b4710916936c48de@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;
                state[i] = 1;
                idt[i] = i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size * size);
            int now = 1;
            int reg = 0;

            for (int i = 0; i < num; ++i) {
                reg = (match[i][0] - 1) * size + match[i][1] - 1;
                state[reg] = 0;
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;                    
                    if (i % size != 0 && state[i - 1] == 1) {
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    }
                    if (i - size > -1 && state[i - size] == 1) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;
                    }
                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    if (i - size > -1 && state[i - size] == 1) {
                        if (number[i - size] < number[i]) {
                            wei.union(number[i], number[i - size]);
                        }
                        if (number[i - size] > number[i]) {
                            wei.union(number[i - size], number[i]);
                        }
                    }
                    if (i % size != 0 && state[i - 1] == 1) {
                        if (number[i - 1] < number[i]) {
                            wei.union(number[i], number[i - 1]);
                        }
                        if (number[i - 1] > number[i]) {
                            wei.union(number[i - 1], number[i]);
                        }
                    }

                }
            }

            System.out.println(number[(target[0] - 1) * size + target[1] - 1]);

        }

    }
}

@3da01d8c901e7660b4710916936c48de@"
"r04942099","9","2.01","159808","@e6d3b74bb7548b6ba7afa2d067f2df04@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;
                state[i] = 1;
                idt[i] = i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size * size);
            int now = 1;
            int reg = 0;

            for (int i = 0; i < num; ++i) {
                reg = (match[i][0] - 1) * size + match[i][1] - 1;
                state[reg] = 0;
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;
                    if (i % size != 0 && state[i - 1] == 1) {
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    }
                    if (i - size > -1 && state[i - size] == 1) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;
                    }
                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    if (i - size > -1 && state[i - size] == 1) {
                        if (number[i - size] < number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i - size];
                                }
                            }
                        }
                        if (number[i - size] > number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i - size]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }
                    if (i % size != 0 && state[i - 1] == 1) {
                        if (number[i - 1] < number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i-1];
                                }
                            }
                        }
                        if (number[i - 1] > number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i-1]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }

                }
            }
            
                System.out.println(number[(target[0]-1)*size+target[1]-1]);
            

        }

    }
}

@e6d3b74bb7548b6ba7afa2d067f2df04@"
"r04942099","7","13.2","155696","@fee9fe544caa0a2dbce7ed320bbe238b@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;
                state[i] = 1;
                idt[i] = i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size * size);
            int now = 1;
            int reg = 0;

            for (int i = 0; i < num; ++i) {
                reg = (match[i][0] - 1) * size + match[i][1] - 1;
                state[reg] = 0;
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;
                    if (i % size != 0 && state[i - 1] == 1) {
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    }
                    if (i - size > -1 && state[i - size] == 1) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;
                    }
                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    if (i - size > -1 && state[i - size] == 1) {
                        if (number[i - size] < number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i - size];
                                }
                            }
                        }
                        if (number[i - size] > number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i - size]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }
                    if (i % size != 0 && state[i - 1] == 1) {
                        if (number[i - 1] < number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i-1];
                                }
                            }
                        }
                        if (number[i - 1] > number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i-1]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }

                }
            }
            int x =1;
            for(int i=30;i>3;--i){ 
                x = x*i; 
                
                }
            int x4=1;
            for(int i=30;i>3;--i){ 
                x4 = x4*i; 
                
                }
            int x2 =1;
            for(int i=30;i>3;--i){ 
                x2 = x2*i; 
                
                }
            int x3 =1;
            for(int i=0;i<300000;--i){ 
                x3 = x3+i; 
                
                }
            
            System.out.println(number[(target[0]-1)*size+target[1]-1]);
            
            

        }

    }
}

@fee9fe544caa0a2dbce7ed320bbe238b@"
"r04942099","9","1.94","160000","@0c28c2bb598d7f62a8cd4b83c6d1f196@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;
                state[i] = 1;
                idt[i] = i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size * size);
            int now = 1;
            int reg = 0;

            for (int i = 0; i < num; ++i) {
                reg = (match[i][0] - 1) * size + match[i][1] - 1;
                state[reg] = 0;
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;
                    if (i % size != 0 && state[i - 1] == 1) {
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    }
                    if (i - size > -1 && state[i - size] == 1) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;
                    }
                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    if (i - size > -1 && state[i - size] == 1) {
                        if (number[i - size] < number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i - size];
                                }
                            }
                        }
                        if (number[i - size] > number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i - size]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }
                    if (i % size != 0 && state[i - 1] == 1) {
                        if (number[i - 1] < number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i-1];
                                }
                            }
                        }
                        if (number[i - 1] > number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i-1]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }

                }
            }
        
            if(state[(target[0]-1)*size+target[1]-1]==1){
            System.out.println(number[(target[0]-1)*size+target[1]-1]);
            }else{
            System.out.println(""0"");
            }
            

        }

    }
}

@0c28c2bb598d7f62a8cd4b83c6d1f196@"
"r04942099","9","2.04","162384","@a017bf4378c36d08f8a1f33cc716f3c8@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;
                state[i] = 1;
                idt[i] = i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size * size);
            int now = 1;
            int reg = 0;

            for (int i = 0; i < num; ++i) {
                reg = (match[i][0] - 1) * size + match[i][1] - 1;
                state[reg] = 0;
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;
                    if (i % size != 0 && state[i - 1] == 1) {
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    }
                    if (i - size > -1 && state[i - size] == 1) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;
                    }
                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    if (i - size > -1 && state[i - size] == 1) {
                        if (number[i - size] < number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i - size];
                                }
                            }
                        }
                        if (number[i - size] > number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i - size]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }
                    if (i % size != 0 && state[i - 1] == 1) {
                        if (number[i - 1] < number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i-1];
                                }
                            }
                        }
                        if (number[i - 1] > number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i-1]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }

                }
            }
        
            if(state[(target[0]-1)*size+target[1]-1]==1){
            System.out.println(number[(target[0]-1)*size+target[1]-1]);
            }else{
            System.out.println(""-1"");
            }
            

        }

    }
}

@a017bf4378c36d08f8a1f33cc716f3c8@"
"r04942099","9","1.99","167440","@93700fdfd8759d796c84ed643995648d@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;
                state[i] = 1;
                idt[i] = i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size * size);
            int now = 1;
            int reg = 0;

            for (int i = 0; i < num; ++i) {
                reg = (match[i][0] - 1) * size + match[i][1] - 1;
                state[reg] = 0;
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;
                    if (i % size != 0 && state[i - 1] == 1) {
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    }
                    if (i - size > -1 && state[i - size] == 1) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;
                    }
                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    if (i - size > -1 && state[i - size] == 1) {
                        if (number[i - size] < number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i - size];
                                }
                            }
                        }
                        if (number[i - size] > number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i - size]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }
                    if (i % size != 0 && state[i - 1] == 1) {
                        if (number[i - 1] < number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i-1];
                                }
                            }
                        }
                        if (number[i - 1] > number[i]) {
                             for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i-1]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }

                }
            }
        
            if(state[(target[0]-1)*size+target[1]-1]==1){
            System.out.println(number[(target[0]-1)*size+target[1]-1]);
            }else{
            System.out.println(0);
            }
            

        }

    }
}

@93700fdfd8759d796c84ed643995648d@"
"b02611019","10","0.104","134896","@45b70418b2bb5e4ecfed65b383563741@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author S410
 */


public class LabelCC {

    
    static QuickFindUF uf;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String[] numstr = br.readLine().split("","");
        int num = Integer.parseInt(numstr[0]);
        int tarx=Integer.parseInt(numstr[1]);
        int tary=Integer.parseInt(numstr[2]);
        

        Integer[][] matrix = new Integer[num][];
        for (int i = 0; i < num; i++) {
            matrix[i] = new Integer[num];
            for (int j = 0; j < num; j++) {
                matrix[i][j] = -1;
            }
        }
        while (br.ready()) {
            String[] coor = br.readLine().split("","");
            int x = Integer.parseInt(coor[0]) - 1;
            int y = Integer.parseInt(coor[1]) - 1;
            matrix[x][y] = 0;
        }
        int index = 1;
        if (matrix[0][0] == -1) {
            matrix[0][0] = index++;
        }
        uf = new QuickFindUF (num*num);
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                if (i * j == 0 && matrix[i][j] == -1) {
                    if (i==0&&j==0){
                        matrix[i][j]=index++;
                    }
                    else if (i == 0 && matrix[i][j - 1] != 0) {
                        matrix[i][j] = matrix[i][j - 1];
                    } else if (j == 0 && matrix[i - 1][j] != 0) {
                        matrix[i][j] = matrix[i-1][j];
                    } else {
                        matrix[i][j] = index++;
                    }
                }

                else if (matrix[i][j] == -1) {
                    if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                        matrix[i][j] = index++;
                    }
                    if (matrix[i - 1][j] != 0&&matrix[i][j - 1] != 0){
                        
                        if (matrix[i][j-1]>matrix[i-1][j]){
                            matrix[i][j] = matrix[i-1][j ];
                            uf.union( matrix[i][j-1],matrix[i - 1][j]);
                        }
                        else{
                            matrix[i][j] = matrix[i][j-1 ];
                            uf.union( matrix[i-1][j],matrix[i ][j-1]);
                        }
                            
                        
                    }
                    else if (matrix[i - 1][j] != 0) {
                        matrix[i][j] = matrix[i - 1][j];
                    }
                    else if (matrix[i][j - 1] != 0) {
                        matrix[i][j] = matrix[i][j - 1];
                    }
                }
            }
        }
        
        
        for (int i = 0; i < num; i++) {
            for (int j = 0; j < num; j++) {
                if(matrix[i][j]!=0&&matrix[i][j]!=uf.find(matrix[i][j])){
                    matrix[i][j]=uf.find(matrix[i][j]);
                }
            }
        }
//        測試輸出label
//        for (int i = 0; i < num; i++) {
//            for (int j = 0; j < num; j++) {
//                StdOut.print(matrix[i][j]+"" "");
//            }
//            StdOut.print(""\n"");
//        }
        
        StdOut.print(matrix[tarx-1][tary-1]);
    }
}

@45b70418b2bb5e4ecfed65b383563741@"
"r04942099","9","1.93","162864","@11aa9e54e70977ec71e29087da0c0b7c@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;
                state[i] = 1;
                idt[i] = i;
            }
            WeightedQuickUnionUF wei = new WeightedQuickUnionUF(size * size);
            int now = 1;
            int reg = 0;

            for (int i = 0; i < num; ++i) {
                reg = (match[i][0] - 1) * size + match[i][1] - 1;
                state[reg] = 0;
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;
                    if (i % size != 0 && state[i - 1] == 1) {
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    }
                    if (i - size > -1 && state[i - size] == 1 && i % size != 0 && state[i - 1] == 1) {
                        if (number[i - 1] > number[i - size]) {
                            wei.union(idt[i], idt[i - size]);
                            number[i] = number[i - size];
                            ++neigh;
                        }
                    }
                    if (i - size > -1 && state[i - size] == 1 && i % size != 0 && state[i - 1] == 0) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;

                    }
                    if (i - size > -1 && state[i - size] == 1 && i % size == 0) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;
                    }
                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    if (i - size > -1 && state[i - size] == 1) {
                        if (number[i - size] < number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i - size];
                                }
                            }
                        }
                        if (number[i - size] > number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i - size]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }
                    if (i % size != 0 && state[i - 1] == 1) {
                        if (number[i - 1] < number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i]) {
                                    number[j] = number[i - 1];
                                }
                            }
                        }
                        if (number[i - 1] > number[i]) {
                            for (int j = 0; j < size * size; j++) {
                                if (number[j] == number[i - 1]) {
                                    number[j] = number[i];
                                }
                            }
                        }
                    }

                }
            }

           
                System.out.println(number[ (target[0]-1)*size+target[1]-1  ]);
           

        }

    }
}

@11aa9e54e70977ec71e29087da0c0b7c@"
"r04631023","7","1.24","164320","@793a02d10ae5ef1b965671985b4f058a@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N];
            int count = 1;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.println(""1,1"");
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                id[N * (x - 1) + y] = 1;
            }

            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == 1 && y == N) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == N && y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == N && y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == 1) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] != 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        }
                    }
                }
            }
            
            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0);
                return;
            }
            
            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            
            System.out.printf(""%d\n"", Arrays.binarySearch(Label, uf.find(N * (Locationx - 1) + Locationy)) - N * N + count);
        }
    }
}
@793a02d10ae5ef1b965671985b4f058a@"
"r04942099","10","0.188","162912","@8815c25f6e63bc8065109ff8be32131c@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;
                state[i] = 1;
                idt[i] = i;
            }
            QuickFindUF wei = new QuickFindUF(size * size);
            int now = 1;
            int reg = 0;

            for (int i = 0; i < num; ++i) {
                reg = (match[i][0] - 1) * size + match[i][1] - 1;
                state[reg] = 0;
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;
                    if (i % size != 0 && state[i - 1] == 1 && i - size > -1 && state[i - size] == 0 || i % size != 0 && state[i - 1] == 1 && i - size < 0) {//111111111111
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    }
                    if (i - size > -1 && state[i - size] == 1 && i % size != 0 && state[i - 1] == 1) {//22222222
                        if (number[i - 1] > number[i - size]) {
                            wei.union(idt[i], idt[i - size]);
                            wei.union(idt[i-1], idt[i]);
                            number[i] = number[i - size];
                            ++neigh;
                        } else {
                            wei.union(idt[i], idt[i - 1]);
                            wei.union(idt[i-size], idt[i]);
                            number[i] = number[i - 1];
                            ++neigh;
                        }

                    }
                    if (i - size > -1 && state[i - size] == 1 && i % size != 0 && state[i - 1] == 0 || i - size > -1 && state[i - size] == 1 && i % size == 0) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;

                    }

                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                number[i] = number[wei.find(i)];
            }
            
            System.out.println(number[ (target[0]-1)*size+target[1]-1  ]);

        }

    }
}

@8815c25f6e63bc8065109ff8be32131c@"
"b03611023","9","1.38","152544","@702f432c278b66ee1721f79572ee722e@
import java.io.FileReader;
import java.io.BufferedReader;
        

public class LabelCC {
    
  /*  public void union(int q, int p){
        
        
    }*/
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])) ){
            
            String[] N = br.readLine().split("","");
            
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            int a = Integer.parseInt(N[1]);
            int b = Integer.parseInt(N[2]);
            //System.out.print(a);
            //System.out.print(b);
            int[][] label = new int[n+1][n+1];
            int[][] open = new int[n+1][n+1];
            
            int x;
            int y;
            
            for(x = 1;x<n+1;x++){
                for(y = 1;y<n+1;y++){
                    open[x][y] = 1;
                }
            }
            
            UF uf = new UF(n*n);
            
            String buffer;
            String gg = """";
            int i = 0;
            
            buffer = br.readLine();
            while(buffer != null){
                gg = gg.concat(buffer);
                gg = gg.concat("","");
                i++;
                buffer = br.readLine();
            }
            String[] lgg = gg.split("","");
            int[] data = new int[2];
            for(int j = 0;j<2*i;j+=2){
                data[0] = Integer.parseInt(lgg[j]);
                data[1] = Integer.parseInt(lgg[j+1]);
                //System.out.print(lgg[j]);
                //System.out.print(lgg[j+1]);
                open[data[0]][data[1]] = 0;                
            }
            int[] root = new int[n*n+1];
            for(x = 0; x<n*n+1; x++){
                root[x] = x;
            }
            int count = 1;
            for(x = 1;x<n+1 ;x++){
                for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                    if(open[x-1][y] == 1 && open[x][y-1] == 1 && label[x][y-1] != label[x-1][y] ){
                        if(label[x-1][y] < label[x][y-1]){
                        label[x][y] = label[x-1][y];
                        //System.out.print(label[x][y]);
                        root[label[x][y-1]] = label[x-1][y];
                        
                        }
                        else{
                             label[x][y] = label[x][y-1];
                             //System.out.print(label[x][y]);
                             root[label[x-1][y]] = label[x][y-1];
                            
                        }
                    }
                    else if(open[x-1][y] == 1){
                        label[x][y] = label[x-1][y];
                        //System.out.print(label[x][y]);
                       
                    }
                    else if(open[x][y-1] == 1){
                        label[x][y] = label[x][y-1];
                       // System.out.print(label[x][y]);                       
                    }
                    else {
                        label[x][y] = count;
                        count++;
                       // System.out.print(label[x][y]);                        
                    }
                }    
                }
            }            
        for(x=1;x<n+1;x++){
            for(y = 1;y<n+1;y++){
                while(root[label[x][y]] != label[x][y]){
                    label[x][y] = root[label[x][y]];
                }
                //System.out.print(label[x][y]);
            }
        }
        System.out.print(label[a][b]);
            
        }
    }
    
    
    
    
    
    
    
}

@702f432c278b66ee1721f79572ee722e@"
"r04631023","7","1.22","164000","@92594c687ec6df0cc6eb907fb1a32c56@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;




/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N];
            int count = 1;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", -1);
                    return;
                }
                id[N * (x - 1) + y] = 1;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == 1 && y == N) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == N && y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == N && y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == 1) {
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] != 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (x == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y + 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + 1);
                                }
                            }
                        } else if (y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y + N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y + N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y + N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        }
                    }
                }
            }
            
            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0);
                return;
            }
            
            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            System.out.printf(""%d\n"", Arrays.binarySearch(Label, uf.find(N * (Locationx - 1) + Locationy)) - N * N + count);
        }
    }
}

@92594c687ec6df0cc6eb907fb1a32c56@"
"b02611028","7","0.91","128112","@caf181ebcb9ccf23e76add210ae075c1@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    matrix[i][j] = 1;
                }
            }
            //finish maps
            while (true) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0] - 1][ordinarynum[1] - 1] = 0;

                if (!br.ready()) {
                    break;
                }

            }
            QuickUnionUF uf = new QuickUnionUF(N * N + 1);
            int count = 1;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        if (i == 0 && j == 0) {
                            continue;
                        }
                        if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                count++;
                            }
                            matrix[i][j] = count;
                        }
                        if (i != 0) {
                            if (j == 0) {
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                } else {
                                    count++;
                                    matrix[i][j] = count;
                                }
                            }
                            if (j != 0) {
                                if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                    count++;
                                    matrix[i][j] = count;
                                }
                                if (matrix[i][j - 1] != 0) {
                                    matrix[i][j] = matrix[i][j - 1];
                                }
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                }
                                if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                                    matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                                    uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]),Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                                }
                            }
                        }
                    }
                }
            }

            /*for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(matrix[i][j] + "" "");
                }
                System.out.printf(""%n"");
            }*/
            System.out.print(matrix[target[0]-1][target[1]-1]);

        }
    }
}

@caf181ebcb9ccf23e76add210ae075c1@"
"b02611028","7","0.9","122672","@caf181ebcb9ccf23e76add210ae075c1@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    matrix[i][j] = 1;
                }
            }
            //finish maps
            while (true) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0] - 1][ordinarynum[1] - 1] = 0;

                if (!br.ready()) {
                    break;
                }

            }
            QuickUnionUF uf = new QuickUnionUF(N * N + 1);
            int count = 1;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        if (i == 0 && j == 0) {
                            continue;
                        }
                        if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                count++;
                            }
                            matrix[i][j] = count;
                        }
                        if (i != 0) {
                            if (j == 0) {
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                } else {
                                    count++;
                                    matrix[i][j] = count;
                                }
                            }
                            if (j != 0) {
                                if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                    count++;
                                    matrix[i][j] = count;
                                }
                                if (matrix[i][j - 1] != 0) {
                                    matrix[i][j] = matrix[i][j - 1];
                                }
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                }
                                if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                                    matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                                    uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]),Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                                }
                            }
                        }
                    }
                }
            }

            /*for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(matrix[i][j] + "" "");
                }
                System.out.printf(""%n"");
            }*/
            System.out.print(matrix[target[0]-1][target[1]-1]);

        }
    }
}

@caf181ebcb9ccf23e76add210ae075c1@"
"b02611028","7","0.91","126560","@caf181ebcb9ccf23e76add210ae075c1@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    matrix[i][j] = 1;
                }
            }
            //finish maps
            while (true) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0] - 1][ordinarynum[1] - 1] = 0;

                if (!br.ready()) {
                    break;
                }

            }
            QuickUnionUF uf = new QuickUnionUF(N * N + 1);
            int count = 1;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        if (i == 0 && j == 0) {
                            continue;
                        }
                        if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                count++;
                            }
                            matrix[i][j] = count;
                        }
                        if (i != 0) {
                            if (j == 0) {
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                } else {
                                    count++;
                                    matrix[i][j] = count;
                                }
                            }
                            if (j != 0) {
                                if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                    count++;
                                    matrix[i][j] = count;
                                }
                                if (matrix[i][j - 1] != 0) {
                                    matrix[i][j] = matrix[i][j - 1];
                                }
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                }
                                if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                                    matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                                    uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]),Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                                }
                            }
                        }
                    }
                }
            }

            /*for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(matrix[i][j] + "" "");
                }
                System.out.printf(""%n"");
            }*/
            System.out.print(matrix[target[0]-1][target[1]-1]);

        }
    }
}

@caf181ebcb9ccf23e76add210ae075c1@"
"b02611028","7","0.92","122720","@31f92164c6f619e096ceb9725aa8a6c7@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    matrix[i][j] = 1;
                }
            }
            //finish maps
            while (true) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0] - 1][ordinarynum[1] - 1] = 0;

                if (!br.ready()) {
                    break;
                }

            }
            QuickUnionUF uf = new QuickUnionUF(N * N + 1);
            int count = 1;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        if (i == 0 && j == 0) {
                            continue;
                        }
                        if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                count++;
                            }
                            matrix[i][j] = count;
                            continue;
                        }
                        if (i != 0) {
                            if (j == 0) {
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    continue;
                                } else {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                            }
                            if (j != 0) {
                                if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                                if (matrix[i][j - 1] != 0) {
                                    matrix[i][j] = matrix[i][j - 1];
                                    
                                }
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    
                                }
                                if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                                    matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                                    uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]),Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                                }
                            }
                        }
                    }
                }
            }

            /*for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(matrix[i][j] + "" "");
                }
                System.out.printf(""%n"");
            }*/
            System.out.print(matrix[target[0]-1][target[1]-1]);

        }
    }
}

@31f92164c6f619e096ceb9725aa8a6c7@"
"b02611023","4","0.99","127472","@0cf5d34d75821fbb2fad709ddcb506c7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 1][num + 1];
            String line;
            String[] lines = new String[2];
            
            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }
            
            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;               
                line = br.readLine();
            }
            
            int count = 1;
            int root = 0;
            int[] pass = new int[num*num];
            
            for(int i = 1; i <= num; i++){
                
                if(matrix[t_row][t_col] == 0){
                    break;
                }
                
                for(int j = 1; j <= num; j++){
                    
                    int label = num*(i-1)+(j-1);
                    
                    if(matrix[i][j] == 0){
                        continue;
                    }
                    
                    else if((matrix[i][j]-matrix[i-1][j]==0) & (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                        }
                        if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }
                    
                    else if((matrix[i][j]-matrix[i-1][j]==1) & (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }
                    else if(matrix[i][j]-matrix[i-1][j]==0){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }
                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }
            
            int[] sec_pass = new int[num*num];
            
            for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                sec_pass[pass[2*i]] = pass[2*i];
                sec_pass[pass[2*i+1]] = pass[2*i];
            }
            
            for(int i = 0; i < num*num; i++){
                if(cc[i] == sec_pass[cc[i]]){
                    continue;
                }
                else{
                    cc[i] = sec_pass[cc[i]];
                }
                
            }
            
            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            /*for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                System.out.println(pass[i]);  
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();
                
            }*/
            
            
            
        }     
    }
}

@0cf5d34d75821fbb2fad709ddcb506c7@"
"b02611023","5","0.87","125056","@f7dd02cfc858408d4487c2e9142228c4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];
            
            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }
            
            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;               
                line = br.readLine();
            }
            
            int count = 1;
            int root = 0;
            int[] pass = new int[num*num];
            
            for(int i = 1; i <= num; i++){
                
                if(matrix[t_row][t_col] == 0){
                    break;
                }
                
                for(int j = 1; j <= num; j++){
                    
                    int label = num*(i-1)+(j-1);
                    
                    if(matrix[i][j] == 0){
                        continue;
                    }
                    
                    else if((matrix[i][j]-matrix[i-1][j]==0) & (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                        }
                        if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }
                    
                    else if((matrix[i][j]-matrix[i-1][j]==1) & (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                        if(matrix[i][j]-matrix[i][j+1]==1){
                            pass[root] = cc[label];
                            root++;
                            pass[root] = cc[label];
                            root++;
                        }
                    }
                    else if(matrix[i][j]-matrix[i-1][j]==0){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }
                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }
            
            int[] sec_pass = new int[num*num];
            
            for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                sec_pass[pass[2*i]] = pass[2*i];
                sec_pass[pass[2*i+1]] = pass[2*i];
            }
            
            for(int i = 0; i < num*num; i++){
                if(cc[i] == sec_pass[cc[i]]){
                    continue;
                }
                else{
                    cc[i] = sec_pass[cc[i]];
                }
                
            }
            
            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            /*for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                System.out.println(pass[i]);  
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();
                
            }*/
            
            
            
        }     
    }
}

@f7dd02cfc858408d4487c2e9142228c4@"
"b02611023","0","0","0","@1d5002b979b201ddcce72db39475b5e0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(""input.txt""))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int root = 0;
            int[] pass = new int[num*num];

            for(int i = 1; i <= num; i++){

                if(matrix[t_row][t_col] == 0){
                    break;
                }

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) & (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) & (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                        /*if(matrix[i][j]-matrix[i][j+1]==1){
                            pass[root] = cc[label];
                            root++;
                            pass[root] = cc[label];
                            root++;
                        }*/
                    }
                    else if(matrix[i][j]-matrix[i-1][j]==0){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }
                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            int[] sec_pass = new int[num*num];

            for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                sec_pass[pass[2*i]] = pass[2*i];
                sec_pass[pass[2*i+1]] = pass[2*i];
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]]){
                	cc[i] = sec_pass[cc[i]];
                }
                else{
                    continue;
                }

            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);

            /*for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                System.out.println(pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@1d5002b979b201ddcce72db39475b5e0@"
"b02611023","4","0.97","126304","@ae1229664b7846b24e6793ad057904a5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int root = 0;
            int[] pass = new int[num*num];

            for(int i = 1; i <= num; i++){

                if(matrix[t_row][t_col] == 0){
                    break;
                }

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) & (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) & (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                        /*if(matrix[i][j]-matrix[i][j+1]==1){
                            pass[root] = cc[label];
                            root++;
                            pass[root] = cc[label];
                            root++;
                        }*/
                    }
                    else if(matrix[i][j]-matrix[i-1][j]==0){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }
                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            int[] sec_pass = new int[num*num];

            for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                sec_pass[pass[2*i]] = pass[2*i];
                sec_pass[pass[2*i+1]] = pass[2*i];
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]]){
                	cc[i] = sec_pass[cc[i]];
                }
                else{
                    continue;
                }

            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);

            /*for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                System.out.println(pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@ae1229664b7846b24e6793ad057904a5@"
"b02611023","9","1","121248","@d1c29a762be4da454cdfab5df71c979a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int root = 0;
            int[] pass = new int[num*num];

            for(int i = 1; i <= num; i++){

                if(matrix[t_row][t_col] == 0){
                    break;
                }

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) & (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) & (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                        /*if(matrix[i][j]-matrix[i][j+1]==1){
                            pass[root] = cc[label];
                            root++;
                            pass[root] = cc[label];
                            root++;
                        }*/
                    }
                    else if(matrix[i][j]-matrix[i-1][j]==0){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }
                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            int[] sec_pass = new int[num*num];

            for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                sec_pass[pass[2*i]] = pass[2*i];
                sec_pass[pass[2*i+1]] = pass[2*i];
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]] & sec_pass[cc[i]] != 0){
                	cc[i] = sec_pass[cc[i]];
                }
                else{
                    continue;
                }

            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);

            /*for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@d1c29a762be4da454cdfab5df71c979a@"
"r04546032","5","1.03","130656","@fa4165cb6fbc19e284eec3b06fa606dd@
import java.io.FileReader;
import java.io.BufferedReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;

/**
 *
 * @author CHIN LUNG
 */
public class LabelCC {

    private WeightedQuickUnionUF wuf;
    private int[][] mark;
    private QuickUnionUF quf;

    public LabelCC(int N) {
        mark = new int[N+2][N+2];
        wuf = new WeightedQuickUnionUF(N * N);
        quf = new   QuickUnionUF(N*N);
        int count = 0;
        for (int i = 0; i < N+2; i++) {
            for (int j = 0; j < N+2; j++) {
                if((1<=i && i<=N)&&(1<=j && j<=N))
                {
                    mark[i][j] = 1;
                    count++;
                }
                else
                {
                    mark[i][j] = 0;
                }
            }
        }
        for(int i = 0; i < N*N;i++)
        {
            wuf.union(i, i);
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] number = br.readLine().split("","");
            int N = Integer.parseInt(number[0]);
            int targetx = Integer.parseInt(number[1]);
            int targety = Integer.parseInt(number[2]);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));
            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);

            LabelCC lcc = new LabelCC(N);
            int label = 1;
            //先將讀到的bolck設為0
            for (int i = 0; i < temp2.length; i += 2) {
                lcc.mark[temp2[i]][temp2[i + 1]] = 0;
            }
            //開始找她的up left 有無鄰近社的點
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y < N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {
                    if(lcc.mark[x][y] <=lcc.mark[x][y-1])
                    {
                        if(lcc.mark[x-1][y] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.quf.union(lcc.mark[x][y], Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]));
                    
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x][y-1];
                        }
                    }
                    if(lcc.mark[x][y] <=lcc.mark[x-1][y])
                    {
                        if(lcc.mark[x][y-1] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.quf.union(lcc.mark[x][y], Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]));
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x-1][y];
                        }
                    }
                    if(lcc.mark[x-1][y]==0 && lcc.mark[x][y-1]==0)
                    {
                        lcc.mark[x][y] = label;
                        label++;
                    }
                    }
                }
            }
           //將union起來的格子做替換
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y <N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {   
                        lcc.mark[x][y] = lcc.quf.find(lcc.mark[x][y]);
                    }
                }
            }
            //印出屬於哪一群若無則印出0
            System.out.println(lcc.mark[targetx][targety]);
        }
    }
}

@fa4165cb6fbc19e284eec3b06fa606dd@"
"r04631023","4","1.27","160304","@da50d7387eb6b82a39feca9c53503877@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N];
            int count = 1;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                id[N * (x - 1) + y] = 1;
            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == 1 && y == 1) {
                        } else if (x == 1 && y == N) {
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == N && y == 1) {
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == N && y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == 1) {
                            if (id[N * (x - 1) + y - 1] != 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (x == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        } else if (y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                        } else if (y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - N)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - N);
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y, N * (x - 1) + y - 1)) {
                                    uf.union(N * (x - 1) + y, N * (x - 1) + y - 1);
                                }
                            }
                        }
                    }
                }
            }

            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0);
                return;
            }

            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            System.out.printf(""%d\n"", Arrays.binarySearch(Label, uf.find(N * (Locationx - 1) + Locationy)) - N * N + count);
        }
    }
}

@da50d7387eb6b82a39feca9c53503877@"
"r04921028","8","0.99","127744","@889463f7066bdb6a53a5d77b948a1c7c@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {
            String buf1[] = br.readLine().split("","");
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            count++;
                          M[i][j]=count;  
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        System.out.println(M[targetx-1][targety-1]); 
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        }
       
    }
    
}

@889463f7066bdb6a53a5d77b948a1c7c@"
"r04631023","6","1.23","162752","@f68c7ca86d34fe4574c7d176256bbeaa@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N];
            int count = 1;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                id[N * (x - 1) + y] = 1;
            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == 1 && y == 1) {
                        } else if (x == 1 && y == N) {
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == N && y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                        } else if (x == N && y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == 1) {
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                        } else if (y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        }
                    }
                }
            }

            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0);
                return;
            }

            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            System.out.printf(""%d\n"", Arrays.binarySearch(Label, uf.find(N * (Locationx - 1) + Locationy)) - N * N + count);
        }
    }
}
@f68c7ca86d34fe4574c7d176256bbeaa@"
"r04631023","3","0.28","101760","@6195e7b245a980a74df70da065c7039d@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);
            Locationy = 9 - Locationy ;

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N];
            int count = 1;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                id[N * (x - 1) +(9-y)] = 1;
            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == 1 && y == 1) {
                        } else if (x == 1 && y == N) {
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == N && y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                        } else if (x == N && y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == 1) {
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                        } else if (y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        }
                    }
                }
            }

            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0);
                return;
            }

            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            System.out.printf(""%d\n"", Arrays.binarySearch(Label, uf.find(N * (Locationx - 1) + Locationy)) - N * N + count);
        }
    }
}

@6195e7b245a980a74df70da065c7039d@"
"r04631023","6","1.23","159008","@bfa560314858e8d75bb6f9218bdc846f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);
            Locationy = (N+1) - Locationy ;

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N];
            int count = 1;
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF(N * N + 2);
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                id[N * (x - 1) +((N+1)-y)] = 1;
            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == 1 && y == 1) {
                        } else if (x == 1 && y == N) {
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == N && y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                        } else if (x == N && y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == 1) {
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (x == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        } else if (y == 1) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                        } else if (y == N) {
                            if (id[N * (x - 1) + y - N] == 0) {
                                if (!uf.connected(N * (x - 1) + y- N, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- N, N * (x - 1) + y );
                                }
                            }
                            if (id[N * (x - 1) + y - 1] == 0) {
                                if (!uf.connected(N * (x - 1) + y- 1, N * (x - 1) + y )) {
                                    uf.union(N * (x - 1) + y- 1, N * (x - 1) + y );
                                }
                            }
                        }
                    }
                }
            }

            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0);
                return;
            }

            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            System.out.printf(""%d\n"", Arrays.binarySearch(Label, uf.find(N * (Locationx - 1) + Locationy)) - N * N + count);
        }
    }
}

@bfa560314858e8d75bb6f9218bdc846f@"
"r04921028","4","1.01","127456","@a74230b9d72f24068d4980cda8011896@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {
            String buf1[] = br.readLine().split("","");
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            count++;
                          M[i][j]=count;  
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i-1][j], M[i][j-1]);
                            }
                            else{
                                uf.union(M[i][j-1], M[i-1][j]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        int label=0;
        for(int i=1;i<n*n;i++){
            label++;
            if(uf.connected(M[targetx-1][targety-1],i)&&M[targetx-1][targety-1]!=i){
                if(M[targetx-1][targety-1]<i){
                System.out.println(M[targetx-1][targety-1]);
                }
                else{
                    System.out.println(i);
                }
                label = 0; 
                break;
            }
        }
//        System.out.println(label);
        if(label==n*n-2){
        System.out.println(M[targetx-1][targety-1]); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        }
       
    }
    
}
@a74230b9d72f24068d4980cda8011896@"
"b02611019","8","0.9","123488","@8bbe0aaae1f72382714fcb19ddb75301@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    matrix[i][j] = 1;
                }
            }
            //finish maps
            while (true) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0] - 1][ordinarynum[1] - 1] = 0;

                if (!br.ready()) {
                    break;
                }

            }
            QuickUnionUF uf = new QuickUnionUF(N * N + 1);
            int count = 1;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        if (i == 0 && j == 0) {
                            continue;
                        }
                        if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                count++;
                            }
                            matrix[i][j] = count;
                            continue;
                        }
                        if (i != 0) {
                            if (j == 0) {
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    continue;
                                } else {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                            }
                            if (j != 0) {
                                if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                                if (matrix[i][j - 1] != 0) {
                                    matrix[i][j] = matrix[i][j - 1];
                                    
                                }
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    
                                }
                                if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                                    matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                                    uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]),Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                                }
                            }
                        }
                    }
                }
            }

            /*for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(matrix[i][j] + "" "");
                }
                System.out.printf(""%n"");
            }*/
            System.out.print(uf.find(matrix[target[0]-1][target[1]-1]));

        }
    }
}


@8bbe0aaae1f72382714fcb19ddb75301@"
"r04921028","8","0.99","125936","@2dbfd9fb4b882f8a01796b0ed8613a38@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {
            String buf1[] = br.readLine().split("","");
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            count++;
                          M[i][j]=count;  
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i-1][j], M[i][j-1]);
                            }
                            else{
                                uf.union(M[i][j-1], M[i-1][j]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        System.out.println(M[targetx-1][targety-1]); 
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        }
       
    }
    
}
@2dbfd9fb4b882f8a01796b0ed8613a38@"
"r04921028","9","1","127280","@c800650c50bf547f72c3d7604fd47b2b@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {
            String buf1[] = br.readLine().split("","");
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            count++;
                          M[i][j]=count;  
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        }
       
    }
    
}
@c800650c50bf547f72c3d7604fd47b2b@"
"r04921028","9","1.01","126016","@c63f61dd8b9cef2c066914adf3b934ac@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {
            String buf1[] = br.readLine().split("","");
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            count++;
                          M[i][j]=count;  
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@c63f61dd8b9cef2c066914adf3b934ac@"
"r04921094","9","1.01","125264","@9734127518a9252244d669448db2756e@//import edu.princeton.cs.algs4.*;

import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
	QuickUnionUF quickUnionUF;
	boolean[][] booleanMap;
	int[][] labelMap;
	int size;
	
	public LabelCC(int size){
		this.size = size;
		quickUnionUF = new QuickUnionUF (size * size);
		booleanMap = new boolean [size][size];
		labelMap = new int[size][size];
		for(int i = 0; i < size; i++){
			for (int j = 0; j < size; j++){
				booleanMap[i][j] = true;
			}
		}
	}

	public void inputSite(int row, int col){
		booleanMap[row][col] = false;
	}

	public void labelling(){
		int tempLeft;
		int tempTop;
		int labelCount = 1;

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		//System.out.print(booleanMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }

		for(int i = 0; i < size; i++){
			for(int j = 0; j < size; j++){
				if(booleanMap[i][j]){
					tempLeft = 0;
					tempTop = 0;
					int[] left = {i, j-1};
					int[] top = {i-1, j};
					if(left[1] >= 0 && booleanMap[left[0]][left[1]]){
						tempLeft = labelMap[left[0]][left[1]];
					}
				
					if(top[0] >= 0 && booleanMap[top[0]][top[1]]){
						tempTop = labelMap[top[0]][top[1]];
					}

					if(tempLeft > 0 && tempTop > 0){
						int rootLeft = quickUnionUF.find(toInt(left[0], left[1]));
						int rootTop = quickUnionUF.find(toInt(top[0], top[1]));
						if(tempLeft > tempTop){
							labelMap[i][j] = tempTop;
							if(rootLeft != rootTop){
								quickUnionUF.union(toInt(left[0], left[1]),toInt(top[0], top[1]));
							}
							else{
								quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
							}
						}
						else{
							labelMap[i][j] = tempLeft;
							if(rootLeft != rootTop){
								quickUnionUF.union(toInt(top[0], top[1]), toInt(left[0],left[1]));
							}
							else{
								quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
							}
						}
					}
					else if(tempLeft > 0){
						labelMap[i][j] = tempLeft;
						quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
					}
					else if(tempTop > 0){
						labelMap[i][j] = tempTop;
						quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
					}
					else{
						labelMap[i][j] = labelCount;
						++labelCount;
					}
				}
			}
		}

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		System.out.print(labelMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }
		// System.out.println(""----------------------------"");

		merge();
	}

	private void merge(){
		for(int i = 0; i < size; i++){
			for(int j = 0; j < size ; j++){
				int [] coordinate;
				coordinate = toCoordinate(quickUnionUF.find(toInt(i,j)));
				if(labelMap[coordinate[0]][ coordinate[1]] != labelMap[i][j]){
					labelMap[i][j] = labelMap[coordinate[0]][coordinate[1]];
				}
			}
		}

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		System.out.print(labelMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }
	}

	public int check(int row, int col){
		return labelMap[row][col];
	}

	private int toInt(int row, int col){
			return row * size + col;
	}

	private int[] toCoordinate(int length){
		int[] coordinate = new int [2];

		coordinate[0] = length/size;
		coordinate[1] = length%size;

		return coordinate;
	}

	public static void main(String[] args) throws Exception {
		String[] firstLine;
		int size;
		int checkRow, checkClo;
		String buffer;
		BufferedReader br = new BufferedReader(new FileReader(args[0]));
		int test;

		firstLine = br.readLine().split("","");
		size = Integer.valueOf(firstLine[0]);
		checkRow = Integer.valueOf(firstLine[1]);
		checkClo = Integer.valueOf(firstLine[2]);
		LabelCC labelCC = new LabelCC(size);

		while((buffer = br.readLine()) != null && buffer.length() != 0){
			String[] coordinate = buffer.split("","");
			labelCC.inputSite(Integer.valueOf(coordinate[0]) - 1, Integer.valueOf(coordinate[1]) - 1);
			//System.out.println(coordinate[0] + coordinate[1]);
		}

		labelCC.labelling();
		System.out.println(labelCC.check(checkRow - 1, checkClo - 1));
	}
}
@9734127518a9252244d669448db2756e@"
"r04921094","9","1.02","123808","@9734127518a9252244d669448db2756e@//import edu.princeton.cs.algs4.*;

import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
	QuickUnionUF quickUnionUF;
	boolean[][] booleanMap;
	int[][] labelMap;
	int size;
	
	public LabelCC(int size){
		this.size = size;
		quickUnionUF = new QuickUnionUF (size * size);
		booleanMap = new boolean [size][size];
		labelMap = new int[size][size];
		for(int i = 0; i < size; i++){
			for (int j = 0; j < size; j++){
				booleanMap[i][j] = true;
			}
		}
	}

	public void inputSite(int row, int col){
		booleanMap[row][col] = false;
	}

	public void labelling(){
		int tempLeft;
		int tempTop;
		int labelCount = 1;

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		//System.out.print(booleanMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }

		for(int i = 0; i < size; i++){
			for(int j = 0; j < size; j++){
				if(booleanMap[i][j]){
					tempLeft = 0;
					tempTop = 0;
					int[] left = {i, j-1};
					int[] top = {i-1, j};
					if(left[1] >= 0 && booleanMap[left[0]][left[1]]){
						tempLeft = labelMap[left[0]][left[1]];
					}
				
					if(top[0] >= 0 && booleanMap[top[0]][top[1]]){
						tempTop = labelMap[top[0]][top[1]];
					}

					if(tempLeft > 0 && tempTop > 0){
						int rootLeft = quickUnionUF.find(toInt(left[0], left[1]));
						int rootTop = quickUnionUF.find(toInt(top[0], top[1]));
						if(tempLeft > tempTop){
							labelMap[i][j] = tempTop;
							if(rootLeft != rootTop){
								quickUnionUF.union(toInt(left[0], left[1]),toInt(top[0], top[1]));
							}
							else{
								quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
							}
						}
						else{
							labelMap[i][j] = tempLeft;
							if(rootLeft != rootTop){
								quickUnionUF.union(toInt(top[0], top[1]), toInt(left[0],left[1]));
							}
							else{
								quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
							}
						}
					}
					else if(tempLeft > 0){
						labelMap[i][j] = tempLeft;
						quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
					}
					else if(tempTop > 0){
						labelMap[i][j] = tempTop;
						quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
					}
					else{
						labelMap[i][j] = labelCount;
						++labelCount;
					}
				}
			}
		}

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		System.out.print(labelMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }
		// System.out.println(""----------------------------"");

		merge();
	}

	private void merge(){
		for(int i = 0; i < size; i++){
			for(int j = 0; j < size ; j++){
				int [] coordinate;
				coordinate = toCoordinate(quickUnionUF.find(toInt(i,j)));
				if(labelMap[coordinate[0]][ coordinate[1]] != labelMap[i][j]){
					labelMap[i][j] = labelMap[coordinate[0]][coordinate[1]];
				}
			}
		}

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		System.out.print(labelMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }
	}

	public int check(int row, int col){
		return labelMap[row][col];
	}

	private int toInt(int row, int col){
			return row * size + col;
	}

	private int[] toCoordinate(int length){
		int[] coordinate = new int [2];

		coordinate[0] = length/size;
		coordinate[1] = length%size;

		return coordinate;
	}

	public static void main(String[] args) throws Exception {
		String[] firstLine;
		int size;
		int checkRow, checkClo;
		String buffer;
		BufferedReader br = new BufferedReader(new FileReader(args[0]));
		int test;

		firstLine = br.readLine().split("","");
		size = Integer.valueOf(firstLine[0]);
		checkRow = Integer.valueOf(firstLine[1]);
		checkClo = Integer.valueOf(firstLine[2]);
		LabelCC labelCC = new LabelCC(size);

		while((buffer = br.readLine()) != null && buffer.length() != 0){
			String[] coordinate = buffer.split("","");
			labelCC.inputSite(Integer.valueOf(coordinate[0]) - 1, Integer.valueOf(coordinate[1]) - 1);
			//System.out.println(coordinate[0] + coordinate[1]);
		}

		labelCC.labelling();
		System.out.println(labelCC.check(checkRow - 1, checkClo - 1));
	}
}
@9734127518a9252244d669448db2756e@"
"b02611028","8","0.9","127680","@c498aca17bc79fe2c965b486b431bc59@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    matrix[i][j] = 1;
                }
            }
            //finish maps
            while (true) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0] - 1][ordinarynum[1] - 1] = 0;

                if (!br.ready()) {
                    break;
                }

            }
            QuickUnionUF uf = new QuickUnionUF(N * N + 1);
            int count = 1;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        if (i == 0 && j == 0) {
                            continue;
                        }
                        if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                count++;
                            }
                            matrix[i][j] = count;
                            continue;
                        }
                        if (i != 0) {
                            if (j == 0) {
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    continue;
                                } else {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                            }
                            if (j != 0) {
                                if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                                if (matrix[i][j - 1] != 0) {
                                    matrix[i][j] = matrix[i][j - 1];
                                    
                                }
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    
                                }
                                if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                                    matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                                    uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]),Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                                }
                            }
                        }
                    }
                }
            }

            /*for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(uf.find(matrix[i][j]) + "" "");
                }
                System.out.printf(""%n"");
            }*/
            System.out.print(uf.find(matrix[target[0]-1][target[1]-1]));

        }
    }
}

@c498aca17bc79fe2c965b486b431bc59@"
"r04921094","0","0.51","127408","@54efe43852201d06d9d908da37c2005d@import edu.princeton.cs.algs4.*;

import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
	QuickUnionUF quickUnionUF;
	boolean[][] booleanMap;
	int[][] labelMap;
	int size;
	
	public LabelCC(int size){
		this.size = size;
		quickUnionUF = new QuickUnionUF (size * size);
		booleanMap = new boolean [size][size];
		labelMap = new int[size][size];
		for(int i = 0; i < size; i++){
			for (int j = 0; j < size; j++){
				booleanMap[i][j] = true;
			}
		}
	}

	public void inputSite(int row, int col){
		booleanMap[row][col] = false;
	}

	public void labelling(){
		int tempLeft;
		int tempTop;
		int labelCount = 1;

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		//System.out.print(booleanMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }

		for(int i = 0; i < size; i++){
			for(int j = 0; j < size; j++){
				if(booleanMap[i][j]){
					tempLeft = 0;
					tempTop = 0;
					int[] left = {i, j-1};
					int[] top = {i-1, j};
					if(left[1] >= 0 && booleanMap[left[0]][left[1]]){
						tempLeft = labelMap[left[0]][left[1]];
					}
				
					if(top[0] >= 0 && booleanMap[top[0]][top[1]]){
						tempTop = labelMap[top[0]][top[1]];
					}

					if(tempLeft > 0 && tempTop > 0){
						int rootLeft = quickUnionUF.find(toInt(left[0], left[1]));
						int rootTop = quickUnionUF.find(toInt(top[0], top[1]));
						if(tempLeft > tempTop){
							labelMap[i][j] = tempTop;
							if(rootLeft != rootTop){
								quickUnionUF.union(toInt(left[0], left[1]),toInt(top[0], top[1]));
								quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
							}
							else{
								quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
							}
						}
						else{
							labelMap[i][j] = tempLeft;
							if(rootLeft != rootTop){
								quickUnionUF.union(toInt(top[0], top[1]), toInt(left[0],left[1]));
								quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
							}
							else{
								quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
							}
						}
					}
					else if(tempLeft > 0){
						labelMap[i][j] = tempLeft;
						quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
					}
					else if(tempTop > 0){
						labelMap[i][j] = tempTop;
						quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
					}
					else{
						labelMap[i][j] = labelCount;
						++labelCount;
					}
				}
			}
		}

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		System.out.print(labelMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }
		// System.out.println(""----------------------------"");

		merge();
	}

	private void merge(){
		for(int i = 0; i < size; i++){
			for(int j = 0; j < size ; j++){
				int [] coordinate;
				coordinate = toCoordinate(quickUnionUF.find(toInt(i,j)));
				if(labelMap[coordinate[0]][ coordinate[1]] != labelMap[i][j]){
					labelMap[i][j] = labelMap[coordinate[0]][coordinate[1]];
				}
			}
		}

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		System.out.print(labelMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }
	}

	public int check(int row, int col){
		return labelMap[row][col];
	}

	private int toInt(int row, int col){
			return row * size + col;
	}

	private int[] toCoordinate(int length){
		int[] coordinate = new int [2];

		coordinate[0] = length/size;
		coordinate[1] = length%size;

		return coordinate;
	}

	public static void main(String[] args) throws Exception {
		String[] firstLine;
		int size;
		int checkRow, checkClo;
		String buffer;
		BufferedReader br = new BufferedReader(new FileReader(args[0]));
		int test;

		firstLine = br.readLine().split("","");
		size = Integer.valueOf(firstLine[0]);
		checkRow = Integer.valueOf(firstLine[1]);
		checkClo = Integer.valueOf(firstLine[2]);
		LabelCC labelCC = new LabelCC(size);

		while((buffer = br.readLine()) != null && buffer.length() != 0){
			String[] coordinate = buffer.split("","");
			labelCC.inputSite(Integer.valueOf(coordinate[0]) - 1, Integer.valueOf(coordinate[1]) - 1);
		}

		labelCC.labelling();
		System.out.println(labelCC.check(checkRow - 1, checkClo - 1));
	}
}
@54efe43852201d06d9d908da37c2005d@"
"r04921094","10","0.098","129488","@86abd8064aa7bdfda2a3e165a5954512@//import edu.princeton.cs.algs4.*;

import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
	QuickUnionUF quickUnionUF;
	boolean[][] booleanMap;
	int[][] labelMap;
	int size;
	
	public LabelCC(int size){
		this.size = size;
		quickUnionUF = new QuickUnionUF (size * size);
		booleanMap = new boolean [size][size];
		labelMap = new int[size][size];
		for(int i = 0; i < size; i++){
			for (int j = 0; j < size; j++){
				booleanMap[i][j] = true;
			}
		}
	}

	public void inputSite(int row, int col){
		booleanMap[row][col] = false;
	}

	public void labelling(){
		int tempLeft;
		int tempTop;
		int labelCount = 1;

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		//System.out.print(booleanMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }

		for(int i = 0; i < size; i++){
			for(int j = 0; j < size; j++){
				if(booleanMap[i][j]){
					tempLeft = 0;
					tempTop = 0;
					int[] left = {i, j-1};
					int[] top = {i-1, j};
					if(left[1] >= 0 && booleanMap[left[0]][left[1]]){
						tempLeft = labelMap[left[0]][left[1]];
					}
				
					if(top[0] >= 0 && booleanMap[top[0]][top[1]]){
						tempTop = labelMap[top[0]][top[1]];
					}

					if(tempLeft > 0 && tempTop > 0){
						int rootLeft = quickUnionUF.find(toInt(left[0], left[1]));
						int rootTop = quickUnionUF.find(toInt(top[0], top[1]));
						if(tempLeft > tempTop){
							labelMap[i][j] = tempTop;
							if(rootLeft != rootTop){
								quickUnionUF.union(toInt(left[0], left[1]),toInt(top[0], top[1]));
								quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
							}
							else{
								quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
							}
						}
						else{
							labelMap[i][j] = tempLeft;
							if(rootLeft != rootTop){
								quickUnionUF.union(toInt(top[0], top[1]), toInt(left[0],left[1]));
								quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
							}
							else{
								quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
							}
						}
					}
					else if(tempLeft > 0){
						labelMap[i][j] = tempLeft;
						quickUnionUF.union(toInt(i,j), toInt(left[0],left[1]));
					}
					else if(tempTop > 0){
						labelMap[i][j] = tempTop;
						quickUnionUF.union(toInt(i,j), toInt(top[0],top[1]));
					}
					else{
						labelMap[i][j] = labelCount;
						++labelCount;
					}
				}
			}
		}

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		System.out.print(labelMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }
		// System.out.println(""----------------------------"");

		merge();
	}

	private void merge(){
		for(int i = 0; i < size; i++){
			for(int j = 0; j < size ; j++){
				int [] coordinate;
				coordinate = toCoordinate(quickUnionUF.find(toInt(i,j)));
				if(labelMap[coordinate[0]][ coordinate[1]] != labelMap[i][j]){
					labelMap[i][j] = labelMap[coordinate[0]][coordinate[1]];
				}
			}
		}

		// for(int i = 0; i < size; i++){
		// 	for (int j = 0; j < size; j++){
		// 		System.out.print(labelMap[i][j] + "" "");
		// 	}
		// 	System.out.println();
		// }
	}

	public int check(int row, int col){
		return labelMap[row][col];
	}

	private int toInt(int row, int col){
			return row * size + col;
	}

	private int[] toCoordinate(int length){
		int[] coordinate = new int [2];

		coordinate[0] = length/size;
		coordinate[1] = length%size;

		return coordinate;
	}

	public static void main(String[] args) throws Exception {
		String[] firstLine;
		int size;
		int checkRow, checkClo;
		String buffer;
		BufferedReader br = new BufferedReader(new FileReader(args[0]));
		int test;

		firstLine = br.readLine().split("","");
		size = Integer.valueOf(firstLine[0]);
		checkRow = Integer.valueOf(firstLine[1]);
		checkClo = Integer.valueOf(firstLine[2]);
		LabelCC labelCC = new LabelCC(size);

		while((buffer = br.readLine()) != null && buffer.length() != 0){
			String[] coordinate = buffer.split("","");
			labelCC.inputSite(Integer.valueOf(coordinate[0]) - 1, Integer.valueOf(coordinate[1]) - 1);
		}

		labelCC.labelling();
		System.out.println(labelCC.check(checkRow - 1, checkClo - 1));
	}
}
@86abd8064aa7bdfda2a3e165a5954512@"
"b02611028","9","1.01","127776","@ea6172804cacc09e35a6183a64ab32bd@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    matrix[i][j] = 1;
                }
            }
            //finish maps
            int ready=1;
            if(!br.ready())ready++;
            while (ready==1) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0] - 1][ordinarynum[1] - 1] = 0;

                if (!br.ready()) {
                    break;
                }

            }
            QuickUnionUF uf = new QuickUnionUF(N * N + 1);
            int count = 1;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        if (i == 0 && j == 0) {
                            continue;
                        }
                        if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                count++;
                            }
                            matrix[i][j] = count;
                            continue;
                        }
                        if (i != 0) {
                            if (j == 0) {
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    continue;
                                } else {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                            }
                            if (j != 0) {
                                if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                                if (matrix[i][j - 1] != 0) {
                                    matrix[i][j] = matrix[i][j - 1];
                                    
                                }
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    
                                }
                                if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                                    matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                                    uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]),Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                                }
                            }
                        }
                    }
                }
            }

            /*for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(uf.find(matrix[i][j]) + "" "");
                }
                System.out.printf(""%n"");
            }*/
            System.out.print(uf.find(matrix[target[0]-1][target[1]-1]));

        }
    }
}

@ea6172804cacc09e35a6183a64ab32bd@"
"r04921044","9","0.99","124816","@54c9713df76a2a0052755f7667601f05@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.lang.Math;

public class LabelCC {
    int mapSize;
    int[][] map;
    int bound;
    ArrayList<Integer> roots;

    public LabelCC(int _mapSize) {
        mapSize = _mapSize;
        map = new int[mapSize][mapSize];
        bound = mapSize * mapSize;
        roots = new ArrayList<>();
    }

    public void block(int row, int col) {
        map[row][col] = bound;
    }

    public void construct() {
        int indexCounter = 0;
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                if (map[i][j] == bound) {
                    continue;
                }

                int up = (i==0) ? bound : map[i-1][j];
                int left = (j==0) ? bound : map[i][j-1];

                map[i][j] = Math.min(Math.min(up, left), indexCounter);
                if (map[i][j] == indexCounter) {
                    roots.add(indexCounter);
                    indexCounter++;
                }

                if (Math.max(up, left) != bound && up != left) {
                    roots.set(Math.max(up, left), Math.min(up, left));
                }
            }
        }
    }

    public int findRoot(int row, int col) {
        if (map[row][col] == bound) {
            return 0;
        }

        int root = roots.get(map[row][col]);
        while (root != roots.get(root)) {
            root = roots.get(root);
        }

        return root + 1;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String[] paramsStrings = buffer.readLine().split("","");

        LabelCC labelCC = new LabelCC(Integer.parseInt(paramsStrings[0]));

        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            labelCC.block(Integer.parseInt(coord[0]) - 1, Integer.parseInt(coord[1]) - 1);
        }

        labelCC.construct();

        System.out.println(labelCC.findRoot(Integer.parseInt(paramsStrings[1]) - 1,
                                            Integer.parseInt(paramsStrings[2]) - 1));
    }
}
@54c9713df76a2a0052755f7667601f05@"
"r04921028","9","1.02","123744","@5e28f7674ed0d715d7cbc3e97e853d0e@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            count++;
                          M[i][j]=count;  
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@5e28f7674ed0d715d7cbc3e97e853d0e@"
"r04921044","8","0.71","120912","@7107719f94a0a7e38fb878204992900a@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.lang.Math;

public class LabelCC {
    int mapSize;
    int[][] map;
    int bound;
    ArrayList<Integer> roots;

    public LabelCC(int _mapSize) {
        mapSize = _mapSize;
        map = new int[mapSize][mapSize];
        bound = mapSize * mapSize;
        roots = new ArrayList<> ();
    }

    public void block(int row, int col) {
        map[row][col] = bound;
    }

    public void construct() {
        int indexCounter = 0;
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                if (map[i][j] == bound) {
                    continue;
                }

                int up = (i==0) ? bound : map[i-1][j];
                int left = (j==0) ? bound : map[i][j-1];

                map[i][j] = Math.min(Math.min(up, left), indexCounter);
                if (map[i][j] == indexCounter) {
                    roots.add(indexCounter);
                    indexCounter++;
                }

                if (Math.max(up, left) != bound && up != left) {
                    int set = Math.min(up, left);
                    int last = roots.get(Math.max(up, left));
                    roots.set(Math.max(up, left), set);

                    ArrayList<Integer> needsSet = new ArrayList<> ();
                    while (roots.get(last) != set) {
                        needsSet.add(last);
                        last = roots.get(last);
                    }
                    for (int k=0; k<needsSet.size(); ++k) {
                        roots.set(needsSet.get(k), set);
                    }
                }
            }
        }
    }

    public int findRoot(int row, int col) {
        if (map[row][col] == bound) {
            return 0;
        }

        int root = roots.get(map[row][col]);
        while (root != roots.get(root)) {
            root = roots.get(root);
        }

        return root + 1;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String[] paramsStrings = buffer.readLine().split("","");

        LabelCC labelCC = new LabelCC(Integer.parseInt(paramsStrings[0]));

        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            labelCC.block(Integer.parseInt(coord[0]) - 1, Integer.parseInt(coord[1]) - 1);
        }

        labelCC.construct();

        System.out.println(labelCC.findRoot(Integer.parseInt(paramsStrings[1]) - 1,
                                            Integer.parseInt(paramsStrings[2]) - 1));
    }
}
@7107719f94a0a7e38fb878204992900a@"
"r04921028","9","1","127504","@cab805c0b81bf251ed9dfd9206fb2eb9@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            count++;
                          M[i][j]=count;  
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@cab805c0b81bf251ed9dfd9206fb2eb9@"
"r04921028","9","1.02","125520","@cab805c0b81bf251ed9dfd9206fb2eb9@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            count++;
                          M[i][j]=count;  
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@cab805c0b81bf251ed9dfd9206fb2eb9@"
"r04921028","9","0.99","122528","@086ed7a29bed073fd79e4e5c5e958c92@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(i==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@086ed7a29bed073fd79e4e5c5e958c92@"
"r04631023","8","1.01","125952","@2a8d9c61f98c52c5ecf08cf594d7fd83@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                id[N * (x - 1) + y] = 1;
            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count ;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N] ;
                                }else{
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1] ;
                                }
                            }
                        }
                    }
                }
            }
            
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        while(LabelConnect[Label[N * (x - 1) + y]]!=Label[N * (x - 1) + y]){
                            Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }
                    }
                }
            }
            /*
            for(int i = 1; i<=7;i++){
                System.out.printf(""%d\n"", LabelConnect[i]);
            }

            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0);
                return;
            }
            
            for(int i = 1, Cal = 0;i<=N*N;i++){
                if(Cal == N-1){
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0 ;
                }else{
                    System.out.printf(""%d "", Label[i]);
                    Cal++ ;
                }
                
            }
            /*
            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            */
            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);
                    
        }
    }
}

@2a8d9c61f98c52c5ecf08cf594d7fd83@"
"r04921044","8","0.75","123376","@dccc947733a4b62264a76707068a5e24@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
import java.lang.Math;

public class LabelCC {
    int mapSize;
    int[][] map;
    int bound;
    ArrayList<Integer> roots;

    public LabelCC(int _mapSize) {
        mapSize = _mapSize;
        map = new int[mapSize][mapSize];
        bound = mapSize * mapSize;
        roots = new ArrayList<> ();
    }

    public void block(int row, int col) {
        map[row][col] = bound;
    }

    public void construct() {
        int indexCounter = 0;
        for (int i=0; i<mapSize; ++i) {
            for (int j=0; j<mapSize; ++j) {
                if (map[i][j] == bound) {
                    continue;
                }

                int up = (i==0) ? bound : map[i-1][j];
                int left = (j==0) ? bound : map[i][j-1];

                map[i][j] = Math.min(Math.min(up, left), indexCounter);
                if (map[i][j] == indexCounter) {
                    roots.add(indexCounter);
                    indexCounter++;
                }

                if (Math.max(up, left) != bound && up != left) {
                    int set = Math.min(up, left);
                    int last = roots.get(Math.max(up, left));
                    roots.set(Math.max(up, left), set);

                    ArrayList<Integer> needsSet = new ArrayList<> ();
                    while (roots.get(last) > set) {
                        needsSet.add(last);
                        last = roots.get(last);
                    }
                    for (int k=0; k<needsSet.size(); ++k) {
                        roots.set(needsSet.get(k), set);
                    }
                }
            }
        }
    }

    public int findRoot(int row, int col) {
        if (map[row][col] == bound) {
            return 0;
        }

        int root = roots.get(map[row][col]);
        while (root != roots.get(root)) {
            root = roots.get(root);
        }

        return root + 1;
    }

    public static void main(String[] args) throws Exception {
        BufferedReader buffer = new BufferedReader(new FileReader(args[0]));
        String[] paramsStrings = buffer.readLine().split("","");

        LabelCC labelCC = new LabelCC(Integer.parseInt(paramsStrings[0]));

        String coordLine;
        while ((coordLine = buffer.readLine()) != null) {
            String[] coord = coordLine.split("","");
            labelCC.block(Integer.parseInt(coord[0]) - 1, Integer.parseInt(coord[1]) - 1);
        }

        labelCC.construct();

        System.out.println(labelCC.findRoot(Integer.parseInt(paramsStrings[1]) - 1,
                                            Integer.parseInt(paramsStrings[2]) - 1));
    }
}
@dccc947733a4b62264a76707068a5e24@"
"r04631023","8","1.03","131856","@c1e78492fab4c98265aa7a62e931a84f@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                id[N * (x - 1) + y] = 1;
            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count ;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N] ;
                                }else{
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1] ;
                                }
                            }
                        }
                    }
                }
            }           
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        while(LabelConnect[Label[N * (x - 1) + y]]!=Label[N * (x - 1) + y]){
                            Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }
                    }
                }
            }
            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0) ;
                return ;
            }
            
            /*
            for(int i = 1; i<=7;i++){
                System.out.printf(""%d\n"", LabelConnect[i]);
            }

            
            
            for(int i = 1, Cal = 0;i<=N*N;i++){
                if(Cal == N-1){
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0 ;
                }else{
                    System.out.printf(""%d "", Label[i]);
                    Cal++ ;
                }
                
            }
            /*
            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            */
            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);
                    
        }
    }
}

@c1e78492fab4c98265aa7a62e931a84f@"
"r04921028","6","1.08","127392","@8814f709a0dce8f4c0de8ec55b5080cd@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(i==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(j==1||i==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@8814f709a0dce8f4c0de8ec55b5080cd@"
"r04921028","9","0.99","120736","@ee1c14a1d31108b4a8c20e71696533c0@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(i==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@ee1c14a1d31108b4a8c20e71696533c0@"
"r04921028","8","0.99","125872","@90fee8af051db9d764832ce20aca84d8@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(i==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(j==1&&i==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@90fee8af051db9d764832ce20aca84d8@"
"r04921028","9","0.98","126096","@086ed7a29bed073fd79e4e5c5e958c92@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(i==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@086ed7a29bed073fd79e4e5c5e958c92@"
"r04631023","9","1.03","131136","@efab71a215994a94889fba0a4cebce01@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                Open = Data.split("","");
                if (Open[0].isEmpty()) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                id[N * (x - 1) + y] = 1;
            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count ;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count ;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N] ;
                                }else{
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1] ;
                                }
                            }
                        }
                    }
                }
            }           
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        while(LabelConnect[Label[N * (x - 1) + y]]!=Label[N * (x - 1) + y]){
                            Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }
                    }
                }
            }
            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0) ;
                return ;
            }
            
            /*
            for(int i = 1; i<=7;i++){
                System.out.printf(""%d\n"", LabelConnect[i]);
            }

            
            
            for(int i = 1, Cal = 0;i<=N*N;i++){
                if(Cal == N-1){
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0 ;
                }else{
                    System.out.printf(""%d "", Label[i]);
                    Cal++ ;
                }
                
            }
            /*
            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            */
            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);
                    
        }
    }
}

@efab71a215994a94889fba0a4cebce01@"
"r04631023","9","1.01","131696","@a3bb7faec25d7a24424fcd615183666a@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (Open[0].isEmpty() || Open[1].isEmpty()) {
                }else{
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                if (x > N || y > N || x < 1 || y < 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                id[N * (x - 1) + y] = 1;
                }
            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count ;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count ;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N] ;
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1] ;
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count ;
                                LabelConnect[count] = count ;
                                count++ ;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N] ;
                                }else{
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1] ;
                                }
                            }
                        }
                    }
                }
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        while(LabelConnect[Label[N * (x - 1) + y]]!=Label[N * (x - 1) + y]){
                            Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }
                    }
                }
            }
            if (id[(N * (Locationx - 1) + Locationy)] == 1) {
                System.out.printf(""%d\n"", 0) ;
                return ;
            }
            
            /*
            for(int i = 1; i<=7;i++){
                System.out.printf(""%d\n"", LabelConnect[i]);
            }

            
            
            for(int i = 1, Cal = 0;i<=N*N;i++){
                if(Cal == N-1){
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0 ;
                }else{
                    System.out.printf(""%d "", Label[i]);
                    Cal++ ;
                }
                
            }
            /*
            for (int i = 1; i <= N * N; i++) {
                if (id[i] == 0) {
                    if (Arrays.binarySearch(Label, uf.find(i)) < 0) {
                        Label[count] = uf.find(i);
                        count++;
                        Arrays.sort(Label);
                    }
                }
            }
            */
            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);
                    
        }
    }
}

@a3bb7faec25d7a24424fcd615183666a@"
"b03611023","6","1","156288","@7c737a36ce41d23039ce7b8c773c95c6@
import java.io.FileReader;
import java.io.BufferedReader;
        

public class LabelCC {
    
  
                    
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])) ){
            
            String[] N = br.readLine().split("","");
            
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            int a = Integer.parseInt(N[1]);
            int b = Integer.parseInt(N[2]);
            //System.out.print(a);
            //System.out.print(b);
            int[][] label = new int[n+1][n+1];
            int[][] open = new int[n+1][n+1];
            
            int x;
            int y;
            
            for(x = 1;x<n+1;x++){
                for(y = 1;y<n+1;y++){
                    open[x][y] = 1;
                }
            }
            
           
            
            String buffer;
            String gg = """";
            int i = 0;
            
            buffer = br.readLine();
            while(buffer != null){
                gg = gg.concat(buffer);
                gg = gg.concat("","");
                i++;
                buffer = br.readLine();
            }
            String[] lgg = gg.split("","");
            int[] data = new int[2];
            for(int j = 0;j<2*i;j+=2){
                data[0] = Integer.parseInt(lgg[j]);
                data[1] = Integer.parseInt(lgg[j+1]);
                //System.out.print(lgg[j]);
                //System.out.print(lgg[j+1]);
                open[data[0]][data[1]] = 0;                
            }
            int[] root = new int[n*n+1];
            for(x = 0; x<n*n+1; x++){
                root[x] = x;
            }
            
            int count = 1;
            for(x = 1;x<n+1 ;x++){
                for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                    if(open[x-1][y] == 1 && open[x][y-1] == 1 && label[x][y-1] != label[x-1][y] ){
                        label[x][y] = label[x-1][y];
                        root[label[x][y-1]] = label[x-1][y];
                       /* if(label[x-1][y] < label[x][y-1]){
                        label[x][y] = label[x-1][y];
                        //System.out.print(label[x][y]);
                        root[label[x][y-1]] = label[x-1][y];
                        
                        }
                        else{
                             label[x][y] = label[x][y-1];
                             //System.out.print(label[x][y]);
                             root[label[x-1][y]] = label[x][y-1];
                            
                        }*/
                    }
                    else if(open[x-1][y] == 1){
                        label[x][y] = label[x-1][y];
                        //System.out.print(label[x][y]);
                       
                    }
                    else if(open[x][y-1] == 1){
                        label[x][y] = label[x][y-1];
                        //System.out.print(label[x][y]);                       
                    }
                    else {
                        label[x][y] = count;
                        count++;
                        //System.out.print(label[x][y]);                        
                    }
                }    
                }
            }            
        for(x=1;x<n+1;x++){
            for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                while(root[label[x][y]] != label[x][y]){
                    label[x][y] = root[label[x][y]];
                }
                }
               // System.out.print(label[x][y]);
            }
        }
      /*  for(x = 1;x<count;x++){
            System.out.print(root[x]);
            
        }*/
        System.out.print(label[a][b]);
            
        }
    }
    
    
    
    
    
    
    
}

@7c737a36ce41d23039ce7b8c773c95c6@"
"b03611023","9","1.3","154272","@20fa4f2d5c7d1180b8ddd3131a6574fc@
import java.io.FileReader;
import java.io.BufferedReader;
        

public class LabelCC {
    
  
                    
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])) ){
            
            String[] N = br.readLine().split("","");
            
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            int a = Integer.parseInt(N[1]);
            int b = Integer.parseInt(N[2]);
            //System.out.print(a);
            //System.out.print(b);
            int[][] label = new int[n+1][n+1];
            int[][] open = new int[n+1][n+1];
            
            int x;
            int y;
            
            for(x = 1;x<n+1;x++){
                for(y = 1;y<n+1;y++){
                    open[x][y] = 1;
                }
            }
            
           
            
            String buffer;
            String gg = """";
            int i = 0;
            
            buffer = br.readLine();
            while(buffer != null){
                gg = gg.concat(buffer);
                gg = gg.concat("","");
                i++;
                buffer = br.readLine();
            }
            String[] lgg = gg.split("","");
            int[] data = new int[2];
            for(int j = 0;j<2*i;j+=2){
                data[0] = Integer.parseInt(lgg[j]);
                data[1] = Integer.parseInt(lgg[j+1]);
                //System.out.print(lgg[j]);
                //System.out.print(lgg[j+1]);
                open[data[0]][data[1]] = 0;                
            }
            int[] root = new int[n*n+1];
            for(x = 0; x<n*n+1; x++){
                root[x] = x;
            }
            
            int count = 1;
            for(x = 1;x<n+1 ;x++){
                for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                    if(open[x-1][y] == 1 && open[x][y-1] == 1 ){  
                       
                        if(label[x-1][y] <= label[x][y-1]){
                        label[x][y] = label[x-1][y];
                        //System.out.print(label[x][y]);
                        root[label[x][y-1]] = label[x-1][y];
                        
                        }
                        else{
                             label[x][y] = label[x][y-1];
                             //System.out.print(label[x][y]);
                             root[label[x-1][y]] = label[x][y-1];
                            
                        }
                    }
                    else if(open[x-1][y] == 1){
                        label[x][y] = label[x-1][y];
                        //System.out.print(label[x][y]);
                       
                    }
                    else if(open[x][y-1] == 1){
                        label[x][y] = label[x][y-1];
                        //System.out.print(label[x][y]);                       
                    }
                    else {
                        label[x][y] = count;
                        count++;
                        //System.out.print(label[x][y]);                        
                    }
                }    
                }
            }            
        for(x=1;x<n+1;x++){
            for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                while(root[label[x][y]] != label[x][y]){
                    label[x][y] = root[label[x][y]];
                }
                }
               // System.out.print(label[x][y]);
            }
        }
      /*  for(x = 1;x<count;x++){
            System.out.print(root[x]);
            
        }*/
        System.out.print(label[a][b]);
            
        }
    }
    
    
    
    
    
    
    
}

@20fa4f2d5c7d1180b8ddd3131a6574fc@"
"r04546032","10","0.102","126288","@b4de5bef771a7ca5bf027d6035e01b12@
import java.io.FileReader;
import java.io.BufferedReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;

/**
 *
 * @author CHIN LUNG
 */
public class LabelCC {

    private WeightedQuickUnionUF wuf;
    private QuickUnionUF qu;
    private int[][] mark;


    public LabelCC(int N) {
        mark = new int[N+2][N+2];
        wuf = new WeightedQuickUnionUF(N * N);
        qu = new   QuickUnionUF(N*N);
        int count = 0;
        for (int i = 0; i < N+2; i++) {
            for (int j = 0; j < N+2; j++) {
                if((1<=i && i<=N)&&(1<=j && j<=N))
                {
                    mark[i][j] = 1;
                    count++;
                }
                else
                {
                    mark[i][j] = 0;
                }
            }
        }
        for(int i = 0; i < N*N;i++)
        {
            wuf.union(i, i);
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] number = br.readLine().split("","");
            int N = Integer.parseInt(number[0]);
            int targetx = Integer.parseInt(number[1]);
            int targety = Integer.parseInt(number[2]);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));
            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);

            LabelCC lcc = new LabelCC(N);
            int label = 1;
            //先將讀到的bolck設為0
            for (int i = 0; i < temp2.length; i += 2) {
                lcc.mark[temp2[i]][temp2[i + 1]] = 0;
            }
            //開始找她的up left 有無鄰近社的點
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y < N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {
                    if(lcc.mark[x][y] <=lcc.mark[x][y-1])
                    {
                        if(lcc.mark[x-1][y] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.qu.union( Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]),lcc.mark[x][y]);
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x][y-1];
                        }
                    }
                    if(lcc.mark[x][y] <=lcc.mark[x-1][y])
                    {
                        if(lcc.mark[x][y-1] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.qu.union( Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]),lcc.mark[x][y]);
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x-1][y];
                        }
                    }
                    if(lcc.mark[x-1][y]==0 && lcc.mark[x][y-1]==0)
                    {
                        lcc.mark[x][y] = label;
                        label++;
                    }
                    }
                }
            }
           //將union起來的格子做替換
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y <N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {   
                        lcc.mark[x][y] = lcc.qu.find(lcc.mark[x][y]);
                    }
                }
            }
            //印出屬於哪一群若無則印出0
            System.out.println(lcc.mark[targetx][targety]);
        }
    }
}

@b4de5bef771a7ca5bf027d6035e01b12@"
"r04631023","9","0.99","130576","@ace263c2a23033a62aa5ed9341fd8313@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = 1;

            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        }
                    }
                }
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    while (LabelConnect[Label[N * (x - 1) + y]] != Label[N * (x - 1) + y]) {
                        Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]];
                    }
                }
            }
            /*
            for (int i = 1, Cal = 0; i <= N * N; i++) {
                if (Cal == N - 1) {
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0;
                } else {
                    System.out.printf(""%d "", Label[i]);
                    Cal++;
                }
            }
            */
            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);

        }
    }
}

@ace263c2a23033a62aa5ed9341fd8313@"
"b03611023","9","1.37","152240","@8a9171854f5a67d9d30b11ab4a39ac51@
import java.io.FileReader;
import java.io.BufferedReader;
        

public class LabelCC {
    
  
                    
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])) ){
            
            String[] N = br.readLine().split("","");
            
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            int a = Integer.parseInt(N[1]);
            int b = Integer.parseInt(N[2]);
            //System.out.print(a);
            //System.out.print(b);
            int[][] label = new int[n+1][n+1];
            int[][] open = new int[n+1][n+1];
            
            int x;
            int y;
            
            for(x = 1;x<n+1;x++){
                for(y = 1;y<n+1;y++){
                    open[x][y] = 1;
                }
            }
            
           
            
            String buffer;
            String gg = """";
            int i = 0;
            
            buffer = br.readLine();
            while(buffer != null){
                gg = gg.concat(buffer);
                gg = gg.concat("","");
                i++;
                buffer = br.readLine();
            }
            String[] lgg = gg.split("","");
            int[] data = new int[2];
            for(int j = 0;j<2*i;j+=2){
                data[0] = Integer.parseInt(lgg[j]);
                data[1] = Integer.parseInt(lgg[j+1]);
                //System.out.print(lgg[j]);
                //System.out.print(lgg[j+1]);
                open[data[0]][data[1]] = 0;                
            }
            int[] root = new int[n*n+1];
            for(x = 0; x<n*n+1; x++){
                root[x] = x;
            }
            
            int count = 1;
            for(x = 1;x<n+1 ;x++){
                for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                    if(open[x-1][y] == 1 && open[x][y-1] == 1 && label[x][y-1] != label[x-1][y] ){  
                        while(root[label[x-1][y]] != label[x-1][y]){
                    label[x-1][y] = root[label[x-1][y]];
                }
                         while(root[label[x][y-1]] != label[x][y-1]){
                    label[x][y-1] = root[label[x][y-1]];
                }
                        if(label[x-1][y] < label[x][y-1]){
                        label[x][y] = label[x-1][y];
                        //System.out.print(label[x][y]);
                        root[label[x][y-1]] = label[x-1][y];
                        
                        }
                        else{
                             label[x][y] = label[x][y-1];
                             //System.out.print(label[x][y]);
                             root[label[x-1][y]] = label[x][y-1];
                            
                        }
                    }
                    else if(open[x-1][y] == 1){
                        label[x][y] = label[x-1][y];
                        //System.out.print(label[x][y]);
                       
                    }
                    else if(open[x][y-1] == 1){
                        label[x][y] = label[x][y-1];
                        //System.out.print(label[x][y]);                       
                    }
                    else {
                        label[x][y] = count;
                        count++;
                        //System.out.print(label[x][y]);                        
                    }
                }    
                }
            }            
        for(x=1;x<n+1;x++){
            for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                while(root[label[x][y]] != label[x][y]){
                    label[x][y] = root[label[x][y]];
                }
                }
               // System.out.print(label[x][y]);
            }
        }
      /*  for(x = 1;x<count;x++){
            System.out.print(root[x]);
            
        }*/
        System.out.print(label[a][b]);
            
        }
    }
    
    
    
    
    
    
    
}

@8a9171854f5a67d9d30b11ab4a39ac51@"
"b02611028","9","0.99","126112","@0fa74382cbc8f6b71358b4499d6f907e@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N][N];
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    matrix[i][j] = 1;
                }
            }
            //finish maps
            int ready=1;
            if(!br.ready())ready++;
            while (ready==1) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0] - 1][ordinarynum[1] - 1] = 0;

                if (!br.ready()) {
                    break;
                }

            }
            QuickUnionUF uf = new QuickUnionUF(N * N + 1);
            int count = 1;
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (matrix[i][j] == 1) {
                        if (i == 0 && j == 0) {
                            continue;
                        }
                        if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                count++;
                            }
                            matrix[i][j] = count;
                            continue;
                        }
                        if (i != 0) {
                            if (j == 0) {
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    continue;
                                } else {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                            }
                            if (j != 0) {
                                if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                    count++;
                                    matrix[i][j] = count;
                                    continue;
                                }
                                if (matrix[i][j - 1] != 0) {
                                    matrix[i][j] = matrix[i][j - 1];
                                    
                                }
                                if (matrix[i - 1][j] != 0) {
                                    matrix[i][j] = matrix[i - 1][j];
                                    
                                }
                                if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                                    matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                                    uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]),Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                                }
                            }
                        }
                    }
                }
            }

            /*for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    System.out.print(uf.find(matrix[i][j]) + "" "");
                }
                System.out.printf(""%n"");
            }*/
            if(matrix[target[0]-1][target[1]-1]==0)System.out.print(0);
            System.out.print(uf.find(matrix[target[0]-1][target[1]-1]));

        }
    }
}

@0fa74382cbc8f6b71358b4499d6f907e@"
"b02611023","9","0.99","126128","@e844e99abf02354e23bec9ad9f59997a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int root = 0;
            int[] pass = new int[num*num];

            for(int i = 1; i <= num; i++){

                if(matrix[t_row][t_col] == 0){
                    break;
                }

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) & (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) & (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    else if(matrix[i][j]-matrix[i-1][j]==0){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            int[] sec_pass = new int[num*num];

            for(int i = 0; i < num*num; i++){
                if(pass[2*i] == 0){
                    break;
                }
                sec_pass[pass[2*i]] = pass[2*i];
                sec_pass[pass[2*i+1]] = pass[2*i];
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]] & sec_pass[cc[i]] != 0){
                	cc[i] = sec_pass[cc[i]];
                }
                else{
                    continue;
                }

            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);

            /*for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@e844e99abf02354e23bec9ad9f59997a@"
"r04631023","9","1.02","127376","@e9b118c02fb5bf9dc623e7579fb1f16c@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = 1;

            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        }
                    }
                }
            }
            int next = 1 ;
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    while (LabelConnect[Label[N * (x - 1) + y]] != Label[N * (x - 1) + y]) {
                        next = Label[N * (x - 1) + y] ;
                        Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]];
                        if(LabelConnect[next] != LabelConnect[Label[N * (x - 1) + y]]){
                            LabelConnect[next] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }                        
                    }
                }
            }
            /*
            for (int i = 1, Cal = 0; i <= N * N; i++) {
                if (Cal == N - 1) {
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0;
                } else {
                    System.out.printf(""%d "", Label[i]);
                    Cal++;
                }
            }
            */
            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);

        }
    }
}

@e9b118c02fb5bf9dc623e7579fb1f16c@"
"r04631041","9","1.1","132368","@904248a89c99cd2554a1eb5d66a4594f@import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
//---------------------------API from QuickFindUF data structure--------------//    
private static int[] id;    // id[i] = component identifier of i
private static int count;   // number of components
private static int counter;
public static void QuickFindUF(int N) {
        counter=0;
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }
 public static int count() {
        return count;
    }
 public static int find(int p) {
        validate(p);
        return id[p];
    }

    // validate that p is a valid index
private static void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
        }
    }
public static boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
public static void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;
        count--;
    }
//----------------------------------------------------------------------------//
public static void setzero (int row, int column ,int size){
    id[(row-1)*size+column-1]=0;
}
public static void first_pass (int[][] m,int row, int column,int size){
if (m[row][column]==1){
if (m[row-1][column]==0 && m[row][column-1]==0){
    counter++;
    id[(row-1)*size+column-1]=counter;
}
else if(m[row-1][column]==1 &&m[row][column-1]==0)
    union((row-1)*size+column-1,(row-2)*size+column-1);    
else if(m[row][column-1]==1 &&m[row-1][column]==0)
    union((row-1)*size+column-1,(row-1)*size+column-2);
else if(m[row-1][column]==1 && m[row][column-1]==1 ){
        if ((row-2)*size+column-1<(row-1)*size+column-2)
          union((row-1)*size+column-1,(row-2)*size+column-1);
        else
          union((row-1)*size+column-1,(row-1)*size+column-2); 
        }
}
}
public static void second_pass(int[][] m,int row,int column,int size){
  if (m[row][column]==1 && m[row-1][column]==1 && m[row][column-1]==1){  
      if (id[(row-2)*size+column-1]<id[(row-1)*size+column-2])
          union((row-1)*size+column-2,(row-2)*size+column-1);
      else
          union((row-2)*size+column-1,(row-1)*size+column-2);
  }
  }
public static void printt(int row, int column, int size){

    System.out.println(id[(row-1)*size+column-1]);
}


    
    public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
       //   System.out.println(size+"",""+assignrow+"",""+assigncolumn);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          QuickFindUF(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
          setzero(x_coordinate,y_coordinate,size);
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
//          for (int i=0 ; i<size+2 ; i++){
//              for (int j=0 ; j<size+2 ; j++)
//           System.out.print(matrix[i][j]+""\t"");
//           System.out.println("""");
//           }
        for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            first_pass(matrix,i,j,size);
         for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            second_pass(matrix,i,j,size);                  
             
              printt(assignrow,assigncolumn,size);
            
          
       }
    }
}
@904248a89c99cd2554a1eb5d66a4594f@"
"r04631041","7","1.11","136352","@5b4f038dc6daf640e858d09fa351b955@import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
//---------------------------API from QuickFindUF data structure--------------//    
private static int[] id;    // id[i] = component identifier of i
private static int count;   // number of components
private static int counter;
public static void QuickFindUF(int N) {
        counter=0;
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }
 public static int count() {
        return count;
    }
 public static int find(int p) {
        validate(p);
        return id[p];
    }

    // validate that p is a valid index
private static void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
        }
    }
public static boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
public static void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;
        count--;
    }
//----------------------------------------------------------------------------//
public static void setzero (int row, int column ,int size){
    id[(row-1)*size+column-1]=0;
}
public static void first_pass (int[][] m,int row, int column,int size){
if (m[row][column]==1){
if (m[row-1][column]==0 && m[row][column-1]==0){
    counter++;
    id[(row-1)*size+column-1]=counter;
}
else if(m[row-1][column]==1 &&m[row][column-1]==0)
    union((row-1)*size+column-1,(row-2)*size+column-1);    
else if(m[row][column-1]==1 &&m[row-1][column]==0)
    union((row-1)*size+column-1,(row-1)*size+column-2);
else if(m[row-1][column]==1 && m[row][column-1]==1 ){
        if ((row-2)*size+column-1<(row-1)*size+column-2){
          union((row-1)*size+column-1,(row-2)*size+column-1);
          union((row-1)*size+column-2,(row-2)*size+column-1);
        }
        else{
          union((row-1)*size+column-1,(row-1)*size+column-2);
          union((row-2)*size+column-1,(row-1)*size+column-2);      
        }
        }
}
}
public static void second_pass(int[][] m,int row,int column,int size){
  if (m[row][column]==1 && m[row-1][column]==1 && m[row][column-1]==1){  
      if (id[(row-2)*size+column-1]<id[(row-1)*size+column-2])
          union((row-1)*size+column-2,(row-2)*size+column-1);
      else
          union((row-2)*size+column-1,(row-1)*size+column-2);
  }
  }
public static void printt(int row, int column, int size){

    System.out.println(id[(row-1)*size+column-1]);
}


    
    public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
       //   System.out.println(size+"",""+assignrow+"",""+assigncolumn);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          QuickFindUF(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
          setzero(x_coordinate,y_coordinate,size);
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
//          for (int i=0 ; i<size+2 ; i++){
//              for (int j=0 ; j<size+2 ; j++)
//           System.out.print(matrix[i][j]+""\t"");
//           System.out.println("""");
//           }
        for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            first_pass(matrix,i,j,size);
         for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            second_pass(matrix,i,j,size);                  
             
              printt(assignrow,assigncolumn,size);
            
          
       }
    }
}
@5b4f038dc6daf640e858d09fa351b955@"
"r04631041","9","1.09","138192","@eae26a065d0dea4c8418bcbd86fa14b9@import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
//---------------------------API from QuickFindUF data structure--------------//    
private static int[] id;    // id[i] = component identifier of i
private static int count;   // number of components
private static int counter;
public static void QuickFindUF(int N) {
        counter=0;
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }
 public static int count() {
        return count;
    }
 public static int find(int p) {
        validate(p);
        return id[p];
    }

    // validate that p is a valid index
private static void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
        }
    }
public static boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
public static void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;
        count--;
    }
//----------------------------------------------------------------------------//
public static void setzero (int row, int column ,int size){
    id[(row-1)*size+column-1]=0;
}
public static void first_pass (int[][] m,int row, int column,int size){
if (m[row][column]==1){
if (m[row-1][column]==0 && m[row][column-1]==0){
    counter++;
    id[(row-1)*size+column-1]=counter;
}
else if(m[row-1][column]==1 &&m[row][column-1]==0)
    union((row-1)*size+column-1,(row-2)*size+column-1);    
else if(m[row][column-1]==1 &&m[row-1][column]==0)
    union((row-1)*size+column-1,(row-1)*size+column-2);
else if(m[row-1][column]==1 && m[row][column-1]==1 ){
        if ((row-2)*size+column-1<(row-1)*size+column-2)
          union((row-1)*size+column-1,(row-2)*size+column-1);
        else
          union((row-1)*size+column-1,(row-1)*size+column-2);
        }
}
}
public static void second_pass(int[][] m,int row,int column,int size){
  if (m[row][column]==1 && m[row-1][column]==1 && m[row][column-1]==1){  
      if (id[(row-2)*size+column-1]<id[(row-1)*size+column-2]){
          union((row-1)*size+column-2,(row-2)*size+column-1);
          union((row-1)*size+column-1,(row-2)*size+column-1);     
      }
      else{
          union((row-2)*size+column-1,(row-1)*size+column-2);
          union((row-1)*size+column-1,(row-1)*size+column-2);
      }
  }
  }
public static void printt(int row, int column, int size){

    System.out.println(id[(row-1)*size+column-1]);
}


    
    public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
       //   System.out.println(size+"",""+assignrow+"",""+assigncolumn);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          QuickFindUF(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
          setzero(x_coordinate,y_coordinate,size);
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
//          for (int i=0 ; i<size+2 ; i++){
//              for (int j=0 ; j<size+2 ; j++)
//           System.out.print(matrix[i][j]+""\t"");
//           System.out.println("""");
//           }
        for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            first_pass(matrix,i,j,size);
         for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            second_pass(matrix,i,j,size);                  
             
              printt(assignrow,assigncolumn,size);
            
          
       }
    }
}
@eae26a065d0dea4c8418bcbd86fa14b9@"
"b03611041","0","0.98","129376","@f240f45cb8cca96b4ac49261da2ffa4b@import edu.princeton.cs.algs4.WeightedQuickUnionUF;

import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
//            int label[][]=new int[num+2][num+2],
            int ufNum=num*num+(num*num+1)/2+1;
            System.out.printf(""%d\n"",ufNum);
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(ufNum+1);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
//                    int current=i*num+j+1;
//                    if(current < ufNum)
//                        label[i][j]= current;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(labelNum,currentID);
                            labelNum++;
                        }
                        else{
                            if((currentID-1)%num==0)
                                uf.union(currentID-num,currentID);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID-1,currentID);
                                else uf.union(currentID-num,currentID);
                            }
                        }
//                        System.out.printf(""%d\n"",currentID);
                    }
                }
            }

            int temp=(num*num+1)/2+1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                        if(currentID%num==0){
                            if(uf.find(currentID-num)!=uf.find(currentID) && uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
                        }else{
                            if(uf.find(currentID+1)!=uf.find(currentID)&&uf.find(currentID+1)<temp)uf.union(currentID+1,currentID);
                            if(uf.find(currentID-num)!=uf.find(currentID)&&uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
                        }
                    }
                }
            }

            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    System.out.printf(""%d "",matrix[i][j]?1:0);
                }
                System.out.printf(""\n"");
            }
            System.out.printf(""\n"");
            for(int i=0;i<num;i++){
                for (int j=0;j<num;j++){
                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
                }
                System.out.printf(""\n"");
            }
            System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));
        }
    }
}

@f240f45cb8cca96b4ac49261da2ffa4b@"
"b03611023","9","1.36","152384","@b491009c12e0eabf04eab16d0cdb7622@
import java.io.FileReader;
import java.io.BufferedReader;
        

public class LabelCC {
    
  
                    
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])) ){
            
            String[] N = br.readLine().split("","");
            
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            int a = Integer.parseInt(N[1]);
            int b = Integer.parseInt(N[2]);
            //System.out.print(a);
            //System.out.print(b);
            int[][] label = new int[n+1][n+1];
            int[][] open = new int[n+1][n+1];
            
            int x;
            int y;
            
            for(x = 1;x<n+1;x++){
                for(y = 1;y<n+1;y++){
                    open[x][y] = 1;
                }
            }
            
           
            
            String buffer;
            String gg = """";
            int i = 0;
            
            buffer = br.readLine();
            while(buffer != null){
                gg = gg.concat(buffer);
                gg = gg.concat("","");
                i++;
                buffer = br.readLine();
            }
            String[] lgg = gg.split("","");
            int[] data = new int[2];
            for(int j = 0;j<2*i;j+=2){
                data[0] = Integer.parseInt(lgg[j]);
                data[1] = Integer.parseInt(lgg[j+1]);              
                open[data[0]][data[1]] = 0;                
            }
            int[] root = new int[n*n+1];
            for(x = 0; x<n*n+1; x++){
                root[x] = x;
            }
            
            int count = 1;
            for(x = 1;x<n+1 ;x++){
                for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                    if(open[x-1][y] == 1 && open[x][y-1] == 1 && label[x][y-1] != label[x-1][y] ){  
                       int d = label[x][y-1];
                       int f = label[x-1][y];
                        while(root[label[x-1][y]] != label[x-1][y]){
                    label[x-1][y] = root[label[x-1][y]];
                }
                        while(root[label[x][y-1]] != label[x][y-1]){
                    label[x][y-1] = root[label[x][y-1]];
                }
                        if(label[x][y-1] <= label[x-1][y]){
                        label[x][y] = d;
                       // System.out.print(label[x][y]);
                        root[label[x-1][y]] = label[x][y-1];
                        
                        }
                        else{
                             label[x][y] = f;
                           //  System.out.print(label[x][y]);
                             root[label[x][y-1]] = label[x-1][y];
                            
                        }
                    }
                    else if(open[x-1][y] == 1){
                        label[x][y] = label[x-1][y];
                       // System.out.print(label[x][y]);
                       
                    }
                    else if(open[x][y-1] == 1){
                        label[x][y] = label[x][y-1];
                      //  System.out.print(label[x][y]);                       
                    }
                    else {
                        label[x][y] = count;
                        count++;
                      //  System.out.print(label[x][y]);                        
                    }
                }    
                }
            }            
        for(x=1;x<n+1;x++){
            for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                while(root[label[x][y]] != label[x][y]){
                    label[x][y] = root[label[x][y]];
                }
                }
               // System.out.print(label[x][y]);
            }
        }
      /*  for(x = 1;x<count;x++){
            System.out.print(root[x]);
            
        }*/
        System.out.print(label[a][b]);
            
        }
    }
    
    
    
    
    
    
    
}

@b491009c12e0eabf04eab16d0cdb7622@"
"b03611041","0","2.19","292368","@5d5d13df21d9d23d48a4dec09caad392@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
//            int label[][]=new int[num+2][num+2],
            int ufNum=num*num+(num*num+1)/2+1;
            System.out.printf(""%d\n"",ufNum);
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(ufNum+1);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
//                    int current=i*num+j+1;
//                    if(current < ufNum)
//                        label[i][j]= current;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(labelNum,currentID);
                            labelNum++;
                        }
                        else{
                            if((currentID-1)%num==0)
                                uf.union(currentID-num,currentID);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID-1,currentID);
                                else uf.union(currentID-num,currentID);
                            }
                        }
//                        System.out.printf(""%d\n"",currentID);
                    }
                }
            }

            int temp=(num*num+1)/2+1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                        if(currentID%num==0){
                            if(uf.find(currentID-num)!=uf.find(currentID) && uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
                        }else{
                            if(uf.find(currentID+1)!=uf.find(currentID)&&uf.find(currentID+1)<temp)uf.union(currentID+1,currentID);
                            if(uf.find(currentID-num)!=uf.find(currentID)&&uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
                        }
                    }
                }
            }

            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    System.out.printf(""%d "",matrix[i][j]?1:0);
                }
                System.out.printf(""\n"");
            }
            System.out.printf(""\n"");
            for(int i=0;i<num;i++){
                for (int j=0;j<num;j++){
                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
                }
                System.out.printf(""\n"");
            }
            System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));
        }
    }
}

@5d5d13df21d9d23d48a4dec09caad392@"
"b03611041","6","1.05","130624","@7f5b24ce97e8e5a12377f11fa9d06d06@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
//            int label[][]=new int[num+2][num+2],
            int ufNum=num*num+(num*num+1)/2+1;
//            System.out.printf(""%d\n"",ufNum);
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(ufNum+1);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
//                    int current=i*num+j+1;
//                    if(current < ufNum)
//                        label[i][j]= current;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(labelNum,currentID);
                            labelNum++;
                        }
                        else{
                            if((currentID-1)%num==0)
                                uf.union(currentID-num,currentID);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID-1,currentID);
                                else uf.union(currentID-num,currentID);
                            }
                        }
//                        System.out.printf(""%d\n"",currentID);
                    }
                }
            }

            int temp=(num*num+1)/2+1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                        if(currentID%num==0){
                            if(uf.find(currentID-num)!=uf.find(currentID) && uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
                        }else{
                            if(uf.find(currentID+1)!=uf.find(currentID)&&uf.find(currentID+1)<temp)uf.union(currentID+1,currentID);
                            if(uf.find(currentID-num)!=uf.find(currentID)&&uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
                        }
                    }
                }
            }

//            for(int i=0;i<num+2;i++){
//                for (int j=0;j<num+2;j++){
//                    System.out.printf(""%d "",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }
            System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));
        }
    }
}

@7f5b24ce97e8e5a12377f11fa9d06d06@"
"b03611041","6","1.04","129392","@fbe544e790bb724d6a44e36a996a732c@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
//            int label[][]=new int[num+2][num+2],
            int ufNum=num*num+(num*num+1)/2+1;
//            System.out.printf(""%d\n"",ufNum);
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(ufNum+1);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
//                    int current=i*num+j+1;
//                    if(current < ufNum)
//                        label[i][j]= current;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(labelNum,currentID);
                            labelNum++;
                        }
                        else{
                            if((currentID-1)%num==0)
                                uf.union(currentID-num,currentID);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID-1,currentID);
                                else uf.union(currentID-num,currentID);
                            }
                        }
//                        System.out.printf(""%d\n"",currentID);
                    }
                }
            }

            int temp=(num*num+1)/2+1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                        if(currentID%num==0){
                            if(uf.find(currentID-num)!=uf.find(currentID) && uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
                        }else{
                            if(uf.find(currentID+1)!=uf.find(currentID)&&uf.find(currentID+1)<temp)uf.union(currentID+1,currentID);
                            if(uf.find(currentID-num)!=uf.find(currentID)&&uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
                        }
                    }
                }
            }

//            for(int i=0;i<num+2;i++){
//                for (int j=0;j<num+2;j++){
//                    System.out.printf(""%d "",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }
            if(uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1)>=temp) {
                System.out.printf(""%d"", 0);
            }else
                System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));
        }
    }
}

@fbe544e790bb724d6a44e36a996a732c@"
"b03611023","0","1.56","178416","@aa90b813a1a5bcc0218651d2280a2d94@
import java.io.FileReader;
import java.io.BufferedReader;
        

public class LabelCC {
    
  
                    
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])) ){
            
            String[] N = br.readLine().split("","");
            
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            int a = Integer.parseInt(N[1]);
            int b = Integer.parseInt(N[2]);
            //System.out.print(a);
            //System.out.print(b);
            int[][] label = new int[n+1][n+1];
            int[][] open = new int[n+1][n+1];
            
            int x;
            int y;
            
            for(x = 1;x<n+1;x++){
                for(y = 1;y<n+1;y++){
                    open[x][y] = 1;
                }
            }
            
           
            
            String buffer;
            String gg = """";
            int i = 0;
            
            buffer = br.readLine();
            while(buffer != null){
                gg = gg.concat(buffer);
                gg = gg.concat("","");
                i++;
                buffer = br.readLine();
            }
            String[] lgg = gg.split("","");
            int[] data = new int[2];
            for(int j = 0;j<2*i;j+=2){
                data[0] = Integer.parseInt(lgg[j]);
                data[1] = Integer.parseInt(lgg[j+1]);              
                open[data[0]][data[1]] = 0;                
            }
            int[] root = new int[n*n+1];
            for(x = 0; x<n*n+1; x++){
                root[x] = x;
            }
            
            int count = 1;
            for(x = 1;x<n+1 ;x++){
                for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                    if(open[x-1][y] == 1 && open[x][y-1] == 1 && label[x][y-1] != label[x-1][y] ){  
                       int d = label[x][y-1];
                       int f = label[x-1][y];
                      /*  while(root[label[x-1][y]] != label[x-1][y]){
                    label[x-1][y] = root[label[x-1][y]];
                }
                        while(root[label[x][y-1]] != label[x][y-1]){
                    label[x][y-1] = root[label[x][y-1]];
                }*/
                        if(label[x][y-1] <= label[x-1][y]){
                        label[x][y] = d;
                       // System.out.print(label[x][y]);
                        root[label[x-1][y]] = label[x][y-1];
                        
                        }
                        else{
                             label[x][y] = f;
                           //  System.out.print(label[x][y]);
                             root[label[x][y-1]] = label[x-1][y];
                            
                        }
                    }
                    else if(open[x-1][y] == 1){
                        label[x][y] = label[x-1][y];
                       // System.out.print(label[x][y]);
                       
                    }
                    else if(open[x][y-1] == 1){
                        label[x][y] = label[x][y-1];
                      //  System.out.print(label[x][y]);                       
                    }
                    else {
                        label[x][y] = count;
                        count++;
                      //  System.out.print(label[x][y]);                        
                    }
                }    
                }
            }            
        for(x=1;x<n+1;x++){
            for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                while(root[label[x][y]] != label[x][y]){
                    label[x][y] = root[label[x][y]];
                }
                }
                System.out.print(label[x][y]);
            }
        }
      /*  for(x = 1;x<count;x++){
            System.out.print(root[x]);
            
        }*/
        System.out.print(label[a][b]);
            
        }
    }
    
    
    
    
    
    
    
}

@aa90b813a1a5bcc0218651d2280a2d94@"
"b03611023","9","1.37","156048","@55f11920f013d3f7e5e346913209b3bb@
import java.io.FileReader;
import java.io.BufferedReader;
        

public class LabelCC {
    
  
                    
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])) ){
            
            String[] N = br.readLine().split("","");
            
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            int a = Integer.parseInt(N[1]);
            int b = Integer.parseInt(N[2]);
            //System.out.print(a);
            //System.out.print(b);
            int[][] label = new int[n+1][n+1];
            int[][] open = new int[n+1][n+1];
            
            int x;
            int y;
            
            for(x = 1;x<n+1;x++){
                for(y = 1;y<n+1;y++){
                    open[x][y] = 1;
                }
            }
            
           
            
            String buffer;
            String gg = """";
            int i = 0;
            
            buffer = br.readLine();
            while(buffer != null){
                gg = gg.concat(buffer);
                gg = gg.concat("","");
                i++;
                buffer = br.readLine();
            }
            String[] lgg = gg.split("","");
            int[] data = new int[2];
            for(int j = 0;j<2*i;j+=2){
                data[0] = Integer.parseInt(lgg[j]);
                data[1] = Integer.parseInt(lgg[j+1]);              
                open[data[0]][data[1]] = 0;                
            }
            int[] root = new int[n*n+1];
            for(x = 0; x<n*n+1; x++){
                root[x] = x;
            }
            
            int count = 1;
            for(x = 1;x<n+1 ;x++){
                for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                    if(open[x-1][y] == 1 && open[x][y-1] == 1 && label[x][y-1] != label[x-1][y] ){  
                       int d = label[x][y-1];
                       int f = label[x-1][y];
                      /*  while(root[label[x-1][y]] != label[x-1][y]){
                    label[x-1][y] = root[label[x-1][y]];
                }
                        while(root[label[x][y-1]] != label[x][y-1]){
                    label[x][y-1] = root[label[x][y-1]];
                }*/
                        if(label[x][y-1] <= label[x-1][y]){
                        label[x][y] = d;
                       // System.out.print(label[x][y]);
                        root[label[x-1][y]] = label[x][y-1];
                        
                        }
                        else{
                             label[x][y] = f;
                           //  System.out.print(label[x][y]);
                             root[label[x][y-1]] = label[x-1][y];
                            
                        }
                    }
                    else if(open[x-1][y] == 1){
                        label[x][y] = label[x-1][y];
                       // System.out.print(label[x][y]);
                       
                    }
                    else if(open[x][y-1] == 1){
                        label[x][y] = label[x][y-1];
                      //  System.out.print(label[x][y]);                       
                    }
                    else {
                        label[x][y] = count;
                        count++;
                      //  System.out.print(label[x][y]);                        
                    }
                }    
                }
            }            
        for(x=1;x<n+1;x++){
            for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                while(root[label[x][y]] != label[x][y]){
                    label[x][y] = root[label[x][y]];
                }
                }
               // System.out.print(label[x][y]);
            }
        }
      /*  for(x = 1;x<count;x++){
            System.out.print(root[x]);
            
        }*/
        System.out.print(label[a][b]);
            
        }
    }
    
    
    
    
    
    
    
}

@55f11920f013d3f7e5e346913209b3bb@"
"b02611023","9","0.99","125136","@a719e1cb76ca0ef747f8de2e2a47ef8a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int root = 0;
            int[] pass = new int[num*num];

            for(int i = 1; i <= num; i++){

                if(matrix[t_row][t_col] == 0){
                    break;
                }

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) && (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    else if(matrix[i][j]-matrix[i-1][j]==0 && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            int[] sec_pass = new int[num*num];

            for(int i = 0; i < num*num; i++){
                if(pass[2*i] == 0){
                    break;
                }
                sec_pass[pass[2*i]] = pass[2*i];
                sec_pass[pass[2*i+1]] = pass[2*i];
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]] & sec_pass[cc[i]] != 0){
                	cc[i] = sec_pass[cc[i]];
                }
                else{
                    continue;
                }

            }

            if(t_row == 1 && t_col == 1){
                System.out.println(""1"");
            }
            else{
                System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            }
            

            /*for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@a719e1cb76ca0ef747f8de2e2a47ef8a@"
"r04631041","9","1.1","133328","@b8e8081f0003a9ce7eb5aa43aa8a34f5@import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
//---------------------------API from QuickFindUF data structure--------------//    
private static int[] id;    // id[i] = component identifier of i
private static int count;   // number of components
private static int counter;
public static void QuickFindUF(int N) {
        counter=0;
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }
 public static int count() {
        return count;
    }
 public static int find(int p) {
        validate(p);
        return id[p];
    }

    // validate that p is a valid index
private static void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
        }
    }
public static boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
public static void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;
        count--;
    }
//----------------------------------------------------------------------------//
public static void setzero (int row, int column ,int size){
    id[(row-1)*size+column-1]=0;
}
public static void first_pass (int[][] m,int row, int column,int size){
if (m[row][column]==1){
if (m[row-1][column]==0 && m[row][column-1]==0){
    counter++;
    id[(row-1)*size+column-1]=counter;
}
else if(m[row-1][column]==1 &&m[row][column-1]==0)
    union((row-1)*size+column-1,(row-2)*size+column-1);    
else if(m[row][column-1]==1 &&m[row-1][column]==0)
    union((row-1)*size+column-1,(row-1)*size+column-2);
else if(m[row-1][column]==1 && m[row][column-1]==1 ){
        if (id[(row-2)*size+column-1]<id[(row-1)*size+column-2])
          union((row-1)*size+column-1,(row-2)*size+column-1);
        else 
          union((row-1)*size+column-1,(row-1)*size+column-2);
        }
}
}
public static void second_pass(int[][] m,int row,int column,int size){
  if (m[row][column]==1 && m[row-1][column]==1 && m[row][column-1]==1){  
      if (id[(row-2)*size+column-1]<id[(row-1)*size+column-2]){
          union((row-1)*size+column-2,(row-2)*size+column-1);
          union((row-1)*size+column-1,(row-2)*size+column-1);     
      }
      else{
          union((row-2)*size+column-1,(row-1)*size+column-2);
          union((row-1)*size+column-1,(row-1)*size+column-2);
      }
  }
  }
public static void printt(int row, int column, int size){

//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i]+""\t"");
//        System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+8]+""\t"");
//       System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+16]+""\t"");
//       System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+24]+""\t"");
//     System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+32]+""\t"");
//     System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+40]+""\t"");
//     System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+48]+""\t"");
//     System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+56]+""\t"");
    System.out.println(id[(row-1)*size+column-1]);
}


    
    public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          QuickFindUF(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
          setzero(x_coordinate,y_coordinate,size);
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
        for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            first_pass(matrix,i,j,size);
         for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            second_pass(matrix,i,j,size);                  
             
              printt(assignrow,assigncolumn,size);
            
          
       }
    }
}

@b8e8081f0003a9ce7eb5aa43aa8a34f5@"
"b02611023","9","0.98","123248","@a9a9a3f74b001fce16f56663e60d9173@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int root = 0;
            int[] pass = new int[num*num];

            for(int i = 1; i <= num; i++){

                if(matrix[t_row][t_col] == 0){
                    break;
                }

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) && (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            pass[root] = cc[num*(i-1)+(j-2)];
                            root++;
                            pass[root] = cc[num*(i-2)+(j-1)];
                            root++;
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    else if(matrix[i][j]-matrix[i-1][j]==0 && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            int[] sec_pass = new int[num*num+1];

            for(int i = 0; i < num*num; i++){
                if(pass[2*i] == 0){
                    break;
                }
                sec_pass[pass[2*i]] = pass[2*i];
                sec_pass[pass[2*i+1]] = pass[2*i];
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]] && sec_pass[cc[i]] != 0){
                	cc[i] = sec_pass[cc[i]];
                }
                else{
                    continue;
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            

            /*for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@a9a9a3f74b001fce16f56663e60d9173@"
"r04921115","10","0.1","130256","@ec5cdeccd0547801f8344a356c61c396@import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
    private int[] id;     // id[i] = parent of i

    public LabelCC(int N) {
        if (N < 0) throw new IllegalArgumentException();
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }
    public int find(int p) {
        if (p < 0 || p >= id.length) throw new IndexOutOfBoundsException();
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int i = find(p);
        int j = find(q);
        id[i]=j;
    }
    
	public static void main(String[] args) throws Exception{
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        	String[] data = br.readLine().split("","");
        	int N = Integer.parseInt(data[0]);
        	int target_x = Integer.parseInt(data[1]);
        	int target_y = Integer.parseInt(data[2]);
        	//System.out.printf(""N: %d x: %d y: %d"", N, target_x, target_y);
        	int i, j, k;
        	int [][] matrix = new int[N+2][N+2];
        	boolean [][] status = new boolean[N+2][N+2];
        	int [][] label = new int[N+2][N+2]; 
        	k=1;
        	for(i = 0 ; i<N+2 ;i++){
            	for(j = 0 ; j<N+2 ;j++){
            		if(i>=1 && i<=N && j>=1 && j<=N){
            			matrix[i][j] = k++ ;
            			status[i][j] = true;
            			label[i][j] = 0;
            		}else{
            			label[i][j] = 0;
            			matrix[i][j] = -1;
            			status[i][j] = false;
            		}
            		// 2 as default virtual block in the beginning
            		// in order to let the matrix calculation more convenient
            	}
        	}
            
        	LabelCC labelcc = new LabelCC(N*N+1);

            String temp;
        	while((temp = br.readLine())!=null){
	    		String[] coordinates = temp.split("","");
	    		int block_row = Integer.parseInt(coordinates[0]);
	            int block_col = Integer.parseInt(coordinates[1]);
	            matrix[block_row][block_col]=0;// 0 as real block
	            status[block_row][block_col]=false;
	            label[block_row][block_col]=0;
	        }
        	
//        	for(i = 0 ; i<N+2 ;i++){
//            	for(j = 0 ; j<N+2 ;j++){
//            		System.out.printf(""%d "", matrix[i][j]);
//            		if(j==N+1){
//            			System.out.printf(""\n"");
//            		}
//            	}
//        	}
//			System.out.printf(""-------\n"");

        	int currentlabelcount=0;
        	
        	for(i = 1 ; i<N+1 ;i++){
            	for(j = 1 ; j<N+1 ;j++){
            		if(status[i][j]!=false){
            			if(label[i][j-1]==0 && label[i-1][j]==0){
            				currentlabelcount++;
            				label[i][j] = currentlabelcount;
            			}
            			if(label[i][j-1]!=0 && label[i-1][j]==0){
            				label[i][j] = label[i][j-1];
            			}
            			if(label[i][j-1]==0 && label[i-1][j]!=0){
            				label[i][j] = label[i-1][j];
            			}
            			if(label[i][j-1]!=0 && label[i-1][j]!=0){
            				if(label[i][j-1] > label[i-1][j]){
            					label[i][j] = label[i-1][j];
            					labelcc.union(label[i][j-1], label[i-1][j]);
            				}else{
            					label[i][j] = label[i][j-1];
            					labelcc.union(label[i-1][j], label[i][j-1]);
            				}
            			}
            		}
            	}
        	}
        	
    		System.out.printf(""%d"", labelcc.find(label[target_x][target_y]));
//        	for(i = 0 ; i<N+2 ;i++){
//            	for(j = 0 ; j<N+2 ;j++){
//            		System.out.printf(""%d "", label[i][j]);
//            		if(j==N+1){
//            			System.out.printf(""\n"");
//            		}
//            	}
//        	}
//			System.out.printf(""...........\n"");
//
//        	for(i = 0 ; i<N+2 ;i++){
//            	for(j = 0 ; j<N+2 ;j++){
//            		System.out.printf(""%d "", labelcc.find(label[i][j]));
//            		if(j==N+1){
//            			System.out.printf(""\n"");
//            		}
//            	}
//        	}
        }
    }
}

@ec5cdeccd0547801f8344a356c61c396@"
"r04921115","10","0.102","131024","@ba1277fe41527ee92602e41ca0f1ecb8@import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
    private int[] id;     // id[i] = parent of i

    public LabelCC(int N) {
        if (N < 0) throw new IllegalArgumentException();
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }
    public int find(int p) {
        if (p < 0 || p >= id.length) throw new IndexOutOfBoundsException();
        while (p != id[p]) {
            p = id[p];
        }
        return p;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    public void union(int p, int q) {
        int i = find(p);
        int j = find(q);
        id[i]=j;
    }
    
	public static void main(String[] args) throws Exception{
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        	String[] data = br.readLine().split("","");
        	int N = Integer.parseInt(data[0]);
        	int target_x = Integer.parseInt(data[1]);
        	int target_y = Integer.parseInt(data[2]);
        	//System.out.printf(""N: %d x: %d y: %d"", N, target_x, target_y);
        	int i, j, k;
        	boolean [][] status = new boolean[N+2][N+2];
        	int [][] label = new int[N+2][N+2]; 
        	k=1;
        	for(i = 0 ; i<N+2 ;i++){
            	for(j = 0 ; j<N+2 ;j++){
            		if(i>=1 && i<=N && j>=1 && j<=N){
            			status[i][j] = true;
            			label[i][j] = 0;
            		}else{
            			label[i][j] = 0;
            			status[i][j] = false;
            		}
            		// 2 as default virtual block in the beginning
            		// in order to let the matrix calculation more convenient
            	}
        	}
            
        	LabelCC labelcc = new LabelCC(N*N+1);

            String temp;
        	while((temp = br.readLine())!=null){
	    		String[] coordinates = temp.split("","");
	    		int block_row = Integer.parseInt(coordinates[0]);
	            int block_col = Integer.parseInt(coordinates[1]);
	            status[block_row][block_col]=false;
	            label[block_row][block_col]=0;
	        }
        	
//        	for(i = 0 ; i<N+2 ;i++){
//            	for(j = 0 ; j<N+2 ;j++){
//            		System.out.printf(""%d "", matrix[i][j]);
//            		if(j==N+1){
//            			System.out.printf(""\n"");
//            		}
//            	}
//        	}
//			System.out.printf(""-------\n"");

        	int currentlabelcount=0;
        	
        	for(i = 1 ; i<N+1 ;i++){
            	for(j = 1 ; j<N+1 ;j++){
            		if(status[i][j]!=false){
            			if(label[i][j-1]==0 && label[i-1][j]==0){
            				currentlabelcount++;
            				label[i][j] = currentlabelcount;
            			}
            			if(label[i][j-1]!=0 && label[i-1][j]==0){
            				label[i][j] = label[i][j-1];
            			}
            			if(label[i][j-1]==0 && label[i-1][j]!=0){
            				label[i][j] = label[i-1][j];
            			}
            			if(label[i][j-1]!=0 && label[i-1][j]!=0){
            				if(label[i][j-1] > label[i-1][j]){
            					label[i][j] = label[i-1][j];
            					labelcc.union(label[i][j-1], label[i-1][j]);
            				}else{
            					label[i][j] = label[i][j-1];
            					labelcc.union(label[i-1][j], label[i][j-1]);
            				}
            			}
            		}
            	}
        	}
        	
    		System.out.printf(""%d"", labelcc.find(label[target_x][target_y]));
//        	for(i = 0 ; i<N+2 ;i++){
//            	for(j = 0 ; j<N+2 ;j++){
//            		System.out.printf(""%d "", label[i][j]);
//            		if(j==N+1){
//            			System.out.printf(""\n"");
//            		}
//            	}
//        	}
//			System.out.printf(""...........\n"");
//
//        	for(i = 0 ; i<N+2 ;i++){
//            	for(j = 0 ; j<N+2 ;j++){
//            		System.out.printf(""%d "", labelcc.find(label[i][j]));
//            		if(j==N+1){
//            			System.out.printf(""\n"");
//            		}
//            	}
//        	}
        }
    }
}

@ba1277fe41527ee92602e41ca0f1ecb8@"
"b02611023","9","0.98","125248","@5266e2437a61cb9a3e7abca4eaf3f413@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int[] sec_pass = new int[num*num+1];

            for(int i = 1; i <= num; i++){

                if(matrix[t_row][t_col] == 0){
                    break;
                }

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) && (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-2)+(j-1)];
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-1)+(j-2)];
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    else if(matrix[i][j]-matrix[i-1][j]==0 && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]] && sec_pass[cc[i]] != 0){
                	cc[i] = sec_pass[cc[i]];
                }
                else{
                    continue;
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            

            /*for(int i = 0; i < num*num; i++){
                if(pass[i] == 0){
                    break;
                }
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@5266e2437a61cb9a3e7abca4eaf3f413@"
"r04921028","8","1.02","126912","@e9df4814b45a05386d0c12c6338c5442@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        int ready = 0;
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
            
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
            ready = 1;
        }
        
        
        if(ready==1){
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                    } 
                    if(i!=0&&j==0){
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(i==1){M[i][j] = count; }
                            else{
//                                System.out.println(i);
//                                System.out.println(j);
//                                System.out.println(M[i][j]);
                                
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count;}
                            else{
                                count++;

                                M[i][j] = count; 
                            }
                        }
                    }
                    
                    if(i!=0&&j!=0){
                        
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(i==1&j==1){M[i][j] = count;}
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }           
                }
                
            }
            
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
        if(ready==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@e9df4814b45a05386d0c12c6338c5442@"
"b02611023","9","0.98","119872","@d360a727dfcf89822add755fc7292db3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int[] sec_pass = new int[num*num+1];

            for(int i = 1; i <= num; i++){

                if(matrix[t_row][t_col] == 0){
                    break;
                }

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) && (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-2)+(j-1)];
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-1)+(j-2)];
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    else if(matrix[i][j]-matrix[i-1][j]==0 && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]] && sec_pass[cc[i]] != 0){
                	cc[i] = sec_pass[cc[i]];
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            

            /*for(int i = 0; i < num*num; i++){
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@d360a727dfcf89822add755fc7292db3@"
"b02611023","9","0.97","125776","@367971c22774097e47bc25bc3dabd91c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int[] sec_pass = new int[num*num+1];

            for(int i = 1; i <= num; i++){

                if(matrix[t_row][t_col] == 0){
                    break;
                }

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    if((matrix[i][j]-matrix[i-1][j]==0) && (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-2)+(j-1)];
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-1)+(j-2)];
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    if((matrix[i][j]-matrix[i-1][j]==1) && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    if(matrix[i][j]-matrix[i-1][j]==0 && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    if(matrix[i][j]-matrix[i-1][j]==1 && (matrix[i][j]-matrix[i][j-1]==0)) {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]] && sec_pass[cc[i]] != 0){
                	cc[i] = sec_pass[cc[i]];
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            

            /*for(int i = 0; i < num*num; i++){
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@367971c22774097e47bc25bc3dabd91c@"
"r04921028","8","1.01","121840","@263ec733a105a53bc242560e03201f0b@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        int ready = 0;
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
            
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
            ready = 1;
        }
        
        
        if(ready==1){
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                    } 
                    if(i!=0&&j==0){
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            
//                                System.out.println(i);
//                                System.out.println(j);
//                                System.out.println(M[i][j]);
                            count++;
                            M[i][j]=count;  
                            
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count;}
                            else{
                                count++;

                                M[i][j] = count; 
                            }
                        }
                    }
                    
                    if(i!=0&&j!=0){
                        
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(i==1&j==1){M[i][j] = count;}
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }           
                }
                
            }
            
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
        if(ready==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@263ec733a105a53bc242560e03201f0b@"
"r04945021","10","0.1","121216","@d799d698f64b1820d06560e75db3392e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int Num = Integer.parseInt(data[0]);
            int FinalNum1 = Integer.parseInt(data[1]);
            int FinalNum2 = Integer.parseInt(data[2]);

            int[][] matrix = new int[Num][Num];
            for (int i = 0; i < Num; i++) {
                Arrays.fill(matrix[i], 1);
            }

            QuickUnionUF uf = new QuickUnionUF(Num * Num);
            String line;

            //標好block的位置
            while ((line = br.readLine()) != null) {
                if ("""".equals(line)) {
                    continue;
                }
                String[] DataBlock = line.split("","");
                int row = Integer.parseInt(DataBlock[0]);
                int col = Integer.parseInt(DataBlock[1]);
                //block
                matrix[row - 1][col - 1] = 0;
            }

         
            
            int PoNum = 0;
            for (int i = 0; i < Num; i++) {
                for (int j = 0; j < Num; j++) {
                    if(matrix[i][j]==0){
                        continue;
                    }
//(0,0)
                   else if (i == 0 && j == 0) {
                        if (matrix[i][j] == 1) {
                            PoNum++;
                            matrix[i][j] = PoNum;
                            
                        }
                    } else if (i == 0 && j > 0) {
                        if (matrix[i][j-1] == 0) {
                            PoNum++;
                            matrix[i][j] = PoNum;
                            
                        } else {
                            matrix[i][j] = matrix[i][j-1];
                        }
                    } else if (i > 0 && j == 0) {
                        if (matrix[i-1][j] == 0) {
                            PoNum++;
                            matrix[i][j] = PoNum;
                            
                        } else {
                            matrix[i][j] = matrix[i-1][j];
                        }
                    } else if(i>0&&j>0){
                        if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                            PoNum++;
                            matrix[i][j] = PoNum;
                            
                        } else if (matrix[i - 1][j] != 0 && matrix[i][j - 1] != 0) {
                            if (matrix[i - 1][j] >= matrix[i][j - 1]) {
                                matrix[i][j] = matrix[i][j - 1];
                                uf.union(matrix[i-1][j], matrix[i][j]);
                                
                            } else {
                                matrix[i][j] = matrix[i - 1][j];
                                uf.union(matrix[i][j - 1], matrix[i][j]);
                                
                            }
                        } else {
                            if (matrix[i - 1][j] == 0 && matrix[i][j - 1] != 0) {
                                matrix[i][j] = matrix[i][j - 1];
                            } else if (matrix[i - 1][j] != 0 && matrix[i][j - 1] == 0) {
                                matrix[i][j] = matrix[i - 1][j];
                            }
                        }
                    }

                }

            }

                       
            System.out.println(uf.find(matrix[FinalNum1-1][FinalNum2-1]));
        }

    }

}

@d799d698f64b1820d06560e75db3392e@"
"r04921028","9","1","125984","@d667d784217e92b4b1d096ae68940471@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
       
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            
                            count++;
                            M[i][j]=count;  
                            
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                
                }
                
            }
        }
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        if(M[targetx-1][targety-1]>0){
        System.out.println(uf.find(M[targetx-1][targety-1])); 
        }
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }
       
    }
    
}
@d667d784217e92b4b1d096ae68940471@"
"r04631041","9","1.09","134272","@b8e8081f0003a9ce7eb5aa43aa8a34f5@import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
//---------------------------API from QuickFindUF data structure--------------//    
private static int[] id;    // id[i] = component identifier of i
private static int count;   // number of components
private static int counter;
public static void QuickFindUF(int N) {
        counter=0;
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }
 public static int count() {
        return count;
    }
 public static int find(int p) {
        validate(p);
        return id[p];
    }

    // validate that p is a valid index
private static void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
        }
    }
public static boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
public static void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;
        count--;
    }
//----------------------------------------------------------------------------//
public static void setzero (int row, int column ,int size){
    id[(row-1)*size+column-1]=0;
}
public static void first_pass (int[][] m,int row, int column,int size){
if (m[row][column]==1){
if (m[row-1][column]==0 && m[row][column-1]==0){
    counter++;
    id[(row-1)*size+column-1]=counter;
}
else if(m[row-1][column]==1 &&m[row][column-1]==0)
    union((row-1)*size+column-1,(row-2)*size+column-1);    
else if(m[row][column-1]==1 &&m[row-1][column]==0)
    union((row-1)*size+column-1,(row-1)*size+column-2);
else if(m[row-1][column]==1 && m[row][column-1]==1 ){
        if (id[(row-2)*size+column-1]<id[(row-1)*size+column-2])
          union((row-1)*size+column-1,(row-2)*size+column-1);
        else 
          union((row-1)*size+column-1,(row-1)*size+column-2);
        }
}
}
public static void second_pass(int[][] m,int row,int column,int size){
  if (m[row][column]==1 && m[row-1][column]==1 && m[row][column-1]==1){  
      if (id[(row-2)*size+column-1]<id[(row-1)*size+column-2]){
          union((row-1)*size+column-2,(row-2)*size+column-1);
          union((row-1)*size+column-1,(row-2)*size+column-1);     
      }
      else{
          union((row-2)*size+column-1,(row-1)*size+column-2);
          union((row-1)*size+column-1,(row-1)*size+column-2);
      }
  }
  }
public static void printt(int row, int column, int size){

//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i]+""\t"");
//        System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+8]+""\t"");
//       System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+16]+""\t"");
//       System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+24]+""\t"");
//     System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+32]+""\t"");
//     System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+40]+""\t"");
//     System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+48]+""\t"");
//     System.out.println("""");
//    for (int i=0 ; i<8 ; i++)
//        System.out.print(id[i+56]+""\t"");
    System.out.println(id[(row-1)*size+column-1]);
}


    
    public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          QuickFindUF(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
          setzero(x_coordinate,y_coordinate,size);
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
        for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            first_pass(matrix,i,j,size);
         for (int i=1 ; i<size+1 ; i++)
            for (int j=1 ; j<size+1 ; j++)
            second_pass(matrix,i,j,size);                  
             
              printt(assignrow,assigncolumn,size);
            
          
       }
    }
}

@b8e8081f0003a9ce7eb5aa43aa8a34f5@"
"r04921012","1","0.9","130016","@d358c577187c4b8f4b5ddc29d9053454@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=1;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    //private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        table.add(0);
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){

        if(x>0 && y>0){
            if (isLabel(y-1,x) || isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
    /**
     * Is site (row i, column j) full?
     */
    public int[] confirm(int[] table){
        boolean b=false;
        for (int i=0;i<table.length;i++){
            if (table[i]==i+1){
                }else{
                    table[i]=table[table[i]-1];
                    b=true;
                }
            }
        if (b){
            table=confirm(table);
        }
        return table;
    }

    /**
     * Does the system percolate?
     */


    private int getQFIndex(int i, int j) {
        return size * (i) + j+1;
    }
    /**
     * @param args the command line arguments
     */
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[1]);
            target[1]=Integer.parseInt(data[2]);
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                
            }
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    matrix.Label(y, x);
                }
            }
            
            //matrix.confirm(matrix.table);
            if (matrix.isOpen(target[1],target[0])){
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1)+1;
                }
            }else{
                out=0;
            }
            

        }
        System.out.println(out);
    }
    
}

@d358c577187c4b8f4b5ddc29d9053454@"
"r04921012","0","0","0","@e5a3b03ec236b3b3e9fde07ea86ba25f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=1;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    //private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        table.add(0);
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){

        if(x>0 && y>0){
            if (isLabel(y-1,x) || isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
    /**
     * Is site (row i, column j) full?
     */
    public int[] confirm(int[] table){
        boolean b=false;
        for (int i=0;i<table.length;i++){
            if (table[i]==i+1){
                }else{
                    table[i]=table[table[i]-1];
                    b=true;
                }
            }
        if (b){
            table=confirm(table);
        }
        return table;
    }


    private int getQFIndex(int i, int j) {
        return size * (i) + j+1;
    }
    /**
     * @param args the command line arguments
     */
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[1]);
            target[1]=Integer.parseInt(data[2]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                
            }
            System.out.println(matrix.opened[0][0]);
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    matrix.Label(y, x);
                }
            }
            
            //matrix.confirm(matrix.table);
            if (matrix.isOpen(target[1],target[0])){
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1)+1;
                }
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
    
}

@e5a3b03ec236b3b3e9fde07ea86ba25f@"
"r04921012","0","0.98","126272","@d2794c07ba8eb692c2fa081e8b78905e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.List;

/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=1;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    //private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        table.add(0);
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){

        if(x>0 && y>0){
            if (isLabel(y-1,x) || isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
    /**
     * Is site (row i, column j) full?
     */
    public int[] confirm(int[] table){
        boolean b=false;
        for (int i=0;i<table.length;i++){
            if (table[i]==i+1){
                }else{
                    table[i]=table[table[i]-1];
                    b=true;
                }
            }
        if (b){
            table=confirm(table);
        }
        return table;
    }


    private int getQFIndex(int i, int j) {
        return size * (i) + j+1;
    }
    /**
     * @param args the command line arguments
     */
    /**
     * @param args the command line arguments
     */
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[1]);
            target[1]=Integer.parseInt(data[2]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                
            }
            System.out.println(matrix.opened[0][0]);
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    matrix.Label(y, x);
                }
            }
            
            //matrix.confirm(matrix.table);
            if (matrix.isOpen(target[1],target[0])){
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1)+1;
                }
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
    
}

@d2794c07ba8eb692c2fa081e8b78905e@"
"r04921012","8","0.85","125840","@cb4405e22a4220f9c7beec9f51c356f7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;


/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    //private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
    /**
     * Is site (row i, column j) full?
     */
    public int[] confirm(int[] table){
        boolean b=false;
        for (int i=0;i<table.length;i++){
            if (table[i]==i+1){
                }else{
                    table[i]=table[table[i]-1];
                    b=true;
                }
            }
        if (b){
            table=confirm(table);
        }
        return table;
    }


    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                
            }

            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }

/*            for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){

                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1)+1;
                }
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
    
}

@cb4405e22a4220f9c7beec9f51c356f7@"
"r04921012","8","0.85","128960","@6331de3fef78265175e781e941310f92@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;


/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    //private WeightedQuickUnionUF qf;

    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
    /**
     * Is site (row i, column j) full?
     */
    public int[] confirm(int[] table){
        boolean b=false;
        for (int i=0;i<table.length;i++){
            if (table[i]==i+1){
                }else{
                    table[i]=table[table[i]-1];
                    b=true;
                }
            }
        if (b){
            table=confirm(table);
        }
        return table;
    }


    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            if (N==0){
                System.out.println(0);
            }
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                
            }

            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }

/*            for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){

                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1)+1;
                }
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
    
}

@6331de3fef78265175e781e941310f92@"
"r04921012","8","0.85","130064","@f422b407ae89280cf70b9dd8048e6fb6@
//package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;


/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }

    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }

    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }

            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*            for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){

                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1)+1;
                }
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
    
}

@f422b407ae89280cf70b9dd8048e6fb6@"
"r04631034","0","0.85","125840","@fb934a3403c719c2c6cb78a95ee47d03@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import edu.princeton.cs.algs4.*;
import java.util.*;
/**
 *
 * @author user
 */
public class LabelCC {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here
          In in = new In(args[0]);
          String[] TopRow =in.readLine().split("","");
          
          String[][] matrix = new String[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];
//          System.out.println(matrix.length);
//          System.out.println(TopRow[0]+"" ""+TopRow[1]+"" ""+TopRow[2]);
          String line;       
//         ArrayList<Integer> Row = new ArrayList<Integer>();
//          ArrayList<Integer> Column = new ArrayList<Integer>();
            while ((line = in.readLine()) != null) {
//                Row.add(Integer.parseInt(line.split("","")[0]));
//               Column.add(Integer.parseInt(line.split("","")[1]));
               matrix[Integer.parseInt(line.split("","")[0])-1][Integer.parseInt(line.split("","")[1])-1]=""0"";
                }
            
//            for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
//                      System.out.print((i+1)+"",""+(j+1)+"" inside ""+matrix[i][j]+""     "");   
//                 }
//                 System.out.println("""");
//            }
            int label=1;
            for(int  i =0 ; i<matrix.length;i++)
            {
                 for(int  j =0 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {
                                   if(i ==0)   //first row
                                   {
                                        if(j==0) // first col
                                        {
                                             matrix[i][j]=Integer.toString(label);
                                        }
                                        else if(matrix[i][j-1]!=""0"")  //left site not block site >> connect
                                        {
                                             matrix[i][j]=matrix[i][j-1];
                                        }
                                        else   
                                        {
                                             matrix[i][j]=Integer.toString(++label);
                                        }
                                   }
                                   else //   another row
                                   {
                                        if(j==0)  //first col
                                        {
                                            if(matrix[i-1][j]!=""0"") // upper row not block site
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }
                                             else
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }
                                        }
                                        else // else col
                                        {
                                             if(matrix[i][j-1] != ""0"" && matrix[i-1][j]==""0"") // connext left col
                                             {
                                                  matrix[i][j]=matrix[i][j-1];
                                             }
                                             if(matrix[i-1][j] != ""0"" && matrix[i][j-1]==""0"") // connext upper row
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }                                            
                                             if(matrix[i][j-1] == ""0"" && matrix[i-1][j]==""0"")
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }                                             
                                              if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                                             {
                                                  if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                                  {
                                                       matrix[i][j]=matrix[i][j-1];
                                                  }
                                                  else
                                                  {
                                                       matrix[i][j]=matrix[i-1][j];
                                                  }
                                             }                                                    
                                        }
                                   }        
                      }
                 }
            }
//            System.out.println(label);
            QuickUnionUF uf = new QuickUnionUF(label+1);
            
           for(int  i =1 ; i<matrix.length;i++)
            {
                 for(int  j =1 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {            
                           if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                           {
                                if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                 {
                                       uf.union(Integer.parseInt(matrix[i-1][j]),Integer.parseInt(matrix[i][j-1]));
                                  }
                                  else
                                   {
                                        uf.union(Integer.parseInt(matrix[i][j-1]),Integer.parseInt(matrix[i-1][j]));
                                    }               
                           }
                      }
                 }
            }
            
            
            
            
            
            
            
            
//            System.out.println(""check"");
//            
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      System.out.print(matrix[i][j]+""     "");
//                 }
//                                      System.out.println("""");
//            }
            
            
                        System.out.println(uf.find(Integer.parseInt(matrix[Integer.parseInt(TopRow[1])-1][Integer.parseInt(TopRow[2])-1])));
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
     }
}

@fb934a3403c719c2c6cb78a95ee47d03@"
"r04631034","9","1.49","171168","@6157bb10a46a3f67f817f2f31b8cdf54@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.*;
import java.util.*;
/**
 *
 * @author user
 */
public class LabelCC {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here
          In in = new In(args[0]);
          String[] TopRow =in.readLine().split("","");
          
          String[][] matrix = new String[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];
//          System.out.println(matrix.length);
//          System.out.println(TopRow[0]+"" ""+TopRow[1]+"" ""+TopRow[2]);
          String line;       
//         ArrayList<Integer> Row = new ArrayList<Integer>();
//          ArrayList<Integer> Column = new ArrayList<Integer>();
            while ((line = in.readLine()) != null) {
//                Row.add(Integer.parseInt(line.split("","")[0]));
//               Column.add(Integer.parseInt(line.split("","")[1]));
               matrix[Integer.parseInt(line.split("","")[0])-1][Integer.parseInt(line.split("","")[1])-1]=""0"";
                }
            
//            for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
//                      System.out.print((i+1)+"",""+(j+1)+"" inside ""+matrix[i][j]+""     "");   
//                 }
//                 System.out.println("""");
//            }
            int label=1;
            for(int  i =0 ; i<matrix.length;i++)
            {
                 for(int  j =0 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {
                                   if(i ==0)   //first row
                                   {
                                        if(j==0) // first col
                                        {
                                             matrix[i][j]=Integer.toString(label);
                                        }
                                        else if(matrix[i][j-1]!=""0"")  //left site not block site >> connect
                                        {
                                             matrix[i][j]=matrix[i][j-1];
                                        }
                                        else   
                                        {
                                             matrix[i][j]=Integer.toString(++label);
                                        }
                                   }
                                   else //   another row
                                   {
                                        if(j==0)  //first col
                                        {
                                            if(matrix[i-1][j]!=""0"") // upper row not block site
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }
                                             else
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }
                                        }
                                        else // else col
                                        {
                                             if(matrix[i][j-1] != ""0"" && matrix[i-1][j]==""0"") // connext left col
                                             {
                                                  matrix[i][j]=matrix[i][j-1];
                                             }
                                             if(matrix[i-1][j] != ""0"" && matrix[i][j-1]==""0"") // connext upper row
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }                                            
                                             if(matrix[i][j-1] == ""0"" && matrix[i-1][j]==""0"")
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }                                             
                                              if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                                             {
                                                  if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                                  {
                                                       matrix[i][j]=matrix[i][j-1];
                                                  }
                                                  else
                                                  {
                                                       matrix[i][j]=matrix[i-1][j];
                                                  }
                                             }                                                    
                                        }
                                   }        
                      }
                 }
            }
//            System.out.println(label);
            QuickUnionUF uf = new QuickUnionUF(label+1);
            
           for(int  i =1 ; i<matrix.length;i++)
            {
                 for(int  j =1 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {            
                           if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                           {
                                if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                 {
                                       uf.union(Integer.parseInt(matrix[i-1][j]),Integer.parseInt(matrix[i][j-1]));
                                  }
                                  else
                                   {
                                        uf.union(Integer.parseInt(matrix[i][j-1]),Integer.parseInt(matrix[i-1][j]));
                                    }               
                           }
                      }
                 }
            }
            
            
            
            
            
            
            
            
//            System.out.println(""check"");
//            
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      System.out.print(matrix[i][j]+""     "");
//                 }
//                                      System.out.println("""");
//            }
            
            
                        System.out.println(uf.find(Integer.parseInt(matrix[Integer.parseInt(TopRow[1])-1][Integer.parseInt(TopRow[2])-1])));
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
     }
}

@6157bb10a46a3f67f817f2f31b8cdf54@"
"r04921028","9","0.99","127520","@6707263fca1ffc562d8d8158736c95db@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
//                        System.out.println(""1"");
                    } 
                    
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            
                            count++;
                            M[i][j]=count;  
                            
                        }
                    }
                   
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                    }
                     
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            count++;
                            M[i][j] = count; 
                        }
                        
                        
                    }
                    
                
                }
                
                
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        
              
        
        
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        
        }
       
    }
    
}
@6707263fca1ffc562d8d8158736c95db@"
"r04631034","9","1.48","174224","@e2db4b5ca1d3ecda7edc296512e04bd3@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.*;
import java.util.*;
/**
 *
 * @author user
 */
public class LabelCC {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here
          In in = new In(args[0]);
          String[] TopRow =in.readLine().split("","");
          
          String[][] matrix = new String[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];
//          System.out.println(matrix.length);
//          System.out.println(TopRow[0]+"" ""+TopRow[1]+"" ""+TopRow[2]);
          String line;       
//         ArrayList<Integer> Row = new ArrayList<Integer>();
//          ArrayList<Integer> Column = new ArrayList<Integer>();
            while ((line = in.readLine()) != null) {
//                Row.add(Integer.parseInt(line.split("","")[0]));
//               Column.add(Integer.parseInt(line.split("","")[1]));
               matrix[Integer.parseInt(line.split("","")[0])-1][Integer.parseInt(line.split("","")[1])-1]=""0"";
                }
            
//            for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
//                      System.out.print((i+1)+"",""+(j+1)+"" inside ""+matrix[i][j]+""     "");   
//                 }
//                 System.out.println("""");
//            }
            int label=1;
            for(int  i =0 ; i<matrix.length;i++)
            {
                 for(int  j =0 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {
                                   if(i ==0)   //first row
                                   {
                                        if(j==0) // first col
                                        {
                                             matrix[i][j]=Integer.toString(label);
                                        }
                                        else if(matrix[i][j-1]!=""0"")  //left site not block site >> connect
                                        {
                                             matrix[i][j]=matrix[i][j-1];
                                        }
                                        else   
                                        {
                                             matrix[i][j]=Integer.toString(++label);
                                        }
                                   }
                                   else //   another row
                                   {
                                        if(j==0)  //first col
                                        {
                                            if(matrix[i-1][j]!=""0"") // upper row not block site
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }
                                             else
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }
                                        }
                                        else // else col
                                        {
                                             if(matrix[i][j-1] != ""0"" && matrix[i-1][j]==""0"") // connext left col
                                             {
                                                  matrix[i][j]=matrix[i][j-1];
                                             }
                                             if(matrix[i-1][j] != ""0"" && matrix[i][j-1]==""0"") // connext upper row
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }                                            
                                             if(matrix[i][j-1] == ""0"" && matrix[i-1][j]==""0"")
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }                                             
                                              if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                                             {
                                                  if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                                  {
                                                       matrix[i][j]=matrix[i][j-1];
                                                  }
                                                  else
                                                  {
                                                       matrix[i][j]=matrix[i-1][j];
                                                  }
                                             }                                                    
                                        }
                                   }        
                      }
                 }
            }
//            System.out.println(label);
            QuickUnionUF uf = new QuickUnionUF(label+1);
            
           for(int  i =1 ; i<matrix.length;i++)
            {
                 for(int  j =1 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {            
                           if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                           {
                                if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                 {
                                       uf.union(uf.find(Integer.parseInt(matrix[i-1][j])),uf.find(Integer.parseInt(matrix[i][j-1])));
                                  }
                                  else
                                   {
                                        uf.union(uf.find(Integer.parseInt(matrix[i][j-1])),uf.find(Integer.parseInt(matrix[i-1][j])));
                                    }               
                           }
                      }
                 }
            }
            
                   
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      System.out.print(matrix[i][j]+""     "");
//                 }
//                                      System.out.println("""");
//            }
            
            
                        System.out.println(uf.find(Integer.parseInt(matrix[Integer.parseInt(TopRow[1])-1][Integer.parseInt(TopRow[2])-1])));
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
     }
}

@e2db4b5ca1d3ecda7edc296512e04bd3@"
"r04546032","10","0.102","124672","@0e1082c5cef993a643da731f3ad3c3da@
import java.io.FileReader;
import java.io.BufferedReader;
import java.net.URLDecoder;
import java.util.Arrays;
import java.util.ArrayList;

/**
 *
 * @author CHIN LUNG
 */
public class LabelCC {


    private QuickUnionUF qu;
    private int[][] mark;


    public LabelCC(int N) {
        mark = new int[N+2][N+2];
        qu = new   QuickUnionUF(N*N);
        int count = 0;
        for (int i = 0; i < N+2; i++) {
            for (int j = 0; j < N+2; j++) {
                if((1<=i && i<=N)&&(1<=j && j<=N))
                {
                    mark[i][j] = 1;
                    count++;
                }
                else
                {
                    mark[i][j] = 0;
                }
            }
        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] number = br.readLine().split("","");
            int N = Integer.parseInt(number[0]);
            int targetx = Integer.parseInt(number[1]);
            int targety = Integer.parseInt(number[2]);
            ArrayList<Integer> temp = new ArrayList<>();
            String[] data;
            String line;

            while ((line = br.readLine()) != null) {
                data = line.split("","");
                temp.add(Integer.parseInt(data[0]));
                temp.add(Integer.parseInt(data[1]));
            }

            Integer[] temp2 = temp.toArray(new Integer[temp.size()]);

            LabelCC lcc = new LabelCC(N);
            int label = 1;
            //先將讀到的bolck設為0
            for (int i = 0; i < temp2.length; i += 2) {
                lcc.mark[temp2[i]][temp2[i + 1]] = 0;
            }
            //開始找她的up left 有無鄰近社的點
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y < N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {
                    if(lcc.mark[x][y] <=lcc.mark[x][y-1])
                    {
                        if(lcc.mark[x-1][y] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.qu.union( Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]),lcc.mark[x][y]);
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x][y-1];
                        }
                    }
                    if(lcc.mark[x][y] <=lcc.mark[x-1][y])
                    {
                        if(lcc.mark[x][y-1] !=0)
                        {
                            lcc.mark[x][y] = Math.min(lcc.mark[x-1][y], lcc.mark[x][y-1]);
                            lcc.qu.union( Math.max(lcc.mark[x-1][y], lcc.mark[x][y-1]),lcc.mark[x][y]);
                        }
                        else
                        {
                            lcc.mark[x][y] = lcc.mark[x-1][y];
                        }
                    }
                    if(lcc.mark[x-1][y]==0 && lcc.mark[x][y-1]==0)
                    {
                        lcc.mark[x][y] = label;
                        label++;
                    }
                    }
                }
            }
           //將union起來的格子做替換
            for(int x = 1; x < N+1;x++)
            {
                for(int y = 1; y <N+1;y++)
                {
                    if(lcc.mark[x][y] !=0)
                    {   
                        lcc.mark[x][y] = lcc.qu.find(lcc.mark[x][y]);
                    }
                }
            }
            //印出屬於哪一群若無則印出0
            System.out.println(lcc.mark[targetx][targety]);
        }
    }
}

@0e1082c5cef993a643da731f3ad3c3da@"
"b03611041","8","1.04","133856","@c78bf4df039b1afa3e2d1d26cd99dd85@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int ufNum=num*num+(num*num+1)/2+1;
            int temp=(num*num+1)/2+1;
//            System.out.printf(""%d %d\n"",ufNum,temp);
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(ufNum+1);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
//                    int current=i*num+j+1;
//                    if(current < ufNum)
//                        label[i][j]= current;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

//            for(int i=0;i<num+2;i++){
//                for (int j=0;j<num+2;j++){
//                    System.out.printf(""%d "",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(labelNum,currentID);
                            labelNum++;
                        }
                        else{
                            if((currentID-temp)%num==0)
                                uf.union(currentID-num,currentID);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID-1,currentID);
                                else uf.union(currentID-num,currentID);
                            }
                        }
//                        System.out.printf(""%d\n"",currentID);
                    }
                }
            }

//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                        if(!((currentID+1-temp)%num==0)) {
                            if (uf.find(currentID + 1) != uf.find(currentID) && uf.find(currentID + 1) < temp)
                                uf.union(currentID + 1, currentID);
                            if (uf.find(currentID - num) != uf.find(currentID) && uf.find(currentID - num) < temp)
                                uf.union(currentID - num, currentID);
                        }else{
                            if (uf.find(currentID - num) != uf.find(currentID) && uf.find(currentID - num) < temp)
                                uf.union(currentID - num, currentID);
                        }
//                        if(currentID%num==0){
//                            if(uf.find(currentID-num)!=uf.find(currentID) && uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
//                        }else{
//                            if(uf.find(currentID+1)!=uf.find(currentID)&&uf.find(currentID+1)<temp)uf.union(currentID+1,currentID);
//                            if(uf.find(currentID-num)!=uf.find(currentID)&&uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
//                        }
                    }
                }
            }


//            System.out.printf(""\n"");
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            if(uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1)>=temp) {
                System.out.printf(""%d"", 0);
            }else
                System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));
        }
    }
}

@c78bf4df039b1afa3e2d1d26cd99dd85@"
"r04921028","9","1.01","126928","@e5828f67149781f8425334efa2aa7d28@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                    
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                   
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                                if(inread==0){
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                        
                        
                    }
                    
                
                }
                
                
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        
              
        
        
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        
        }
       
    }
    
}
@e5828f67149781f8425334efa2aa7d28@"
"r03945012","10","0.132","161440","@9d3e371eba224f10b518cb9c54791c8b@import java.io.BufferedReader;
import java.util.Scanner;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;

/**
 * 1042 PDSA
 * hw02_LabelCC
 * @author Robert
 */


public class LabelCC {

    public static void main(String[] args) throws Exception{
        // read file (.txt)
        InputStream is = null; 
        InputStreamReader isr = null;
        BufferedReader br = null;
        try{
            is = new FileInputStream(args[0]);
            isr = new InputStreamReader(is, StandardCharsets.UTF_8);
            br = new BufferedReader(isr);
            Scanner inputdata = new Scanner(br);
            
            // num = data[0] = matrix size
            // data[1,2] = label(x,y)
            // initialize matrix == 1
            String[] data;
            data = inputdata.nextLine().split("","");
            int num = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]) -1;
            int y = Integer.parseInt(data[2]) -1;
            int[][] matrix = new int[num][num];
            for (int[] row : matrix) {
                java.util.Arrays.fill(row, 1);
            }
            // setup uf for(0-63) as label number
            QuickUnionUF uf = new QuickUnionUF(num*num);
            
            
            // read main data
            // set blocks area = 0
            while (inputdata.hasNextLine()) {
                String[] tmp = inputdata.nextLine().split("","");
                int row = Integer.parseInt(tmp[0])-1;
                int col = Integer.parseInt(tmp[1])-1;
                matrix[row][col] = 0;
            }
            
            // Labelling connected components            
            // the first pass
            int count = 1;
            for (int i=0; i< matrix.length; i++){
                for (int j=0; j< matrix[0].length; j++){
                    if (matrix[i][j]==1){
                        if (i == 0 && j==0){
                            matrix[i][j] =count;
                            count++;
                        }
                        else if (i == 0){
                            if (matrix[i][j-1]>0)
                                matrix[i][j] = matrix[i][j-1];
                            else{
                                matrix[i][j] = count;
                                count++;
                            }
                        }
                        else if (j == 0){
                            if (matrix[i-1][j]>0)
                                matrix[i][j] = matrix[i-1][j];
                            else{
                                matrix[i][j] = count;
                                count++;
                            }
                        }
                        else {
                            if (matrix[i-1][j] == 0 && matrix[i][j-1] == 0){
                                matrix[i][j] = count;
                                count++;
                            }
                            else if (matrix[i-1][j] == 0)
                                matrix[i][j] = matrix[i][j-1]; 
                            else if (matrix[i][j-1] == 0)
                                matrix[i][j] = matrix[i-1][j];
                            else{
                                if (matrix[i-1][j] > matrix[i][j-1]){
                                    uf.union(matrix[i-1][j], matrix[i][j-1]);
                                    matrix[i][j] = matrix[i][j-1];
                                }
                                else if (matrix[i-1][j] < matrix[i][j-1]) {
                                    uf.union(matrix[i][j-1], matrix[i-1][j]);
                                    matrix[i][j] = matrix[i-1][j];
                                }
                                else  
                                    matrix[i][j] = matrix[i-1][j];
                            }             
                        }
                    }
                }
            }
            
            // the second pass
            for (int i=0; i< matrix.length; i++){
                for (int j=0; j< matrix[0].length; j++){
                    matrix[i][j] = uf.find(matrix[i][j]);
                }
            }
            
            System.out.print(matrix[x][y]);
            
            
        }
        catch(FileNotFoundException | NumberFormatException e){
        }
        finally{
        // releases resources associated with the streams
            if(is!=null)
                is.close();
            if(isr!=null)
                isr.close();
            if(br!=null)
                br.close();
        } 
    }
    
}

@9d3e371eba224f10b518cb9c54791c8b@"
"r04631034","9","1.48","174432","@6d0adb14eed6b16a97883555192d4370@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.*;
import java.util.*;
/**
 *
 * @author user
 */
public class LabelCC {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here
          In in = new In(args[0]);
          String[] TopRow =in.readLine().split("","");
          
          String[][] matrix = new String[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];
//          System.out.println(matrix.length);
//          System.out.println(TopRow[0]+"" ""+TopRow[1]+"" ""+TopRow[2]);
          String line;       
//         ArrayList<Integer> Row = new ArrayList<Integer>();
//          ArrayList<Integer> Column = new ArrayList<Integer>();
            while ((line = in.readLine()) != null) {
//                Row.add(Integer.parseInt(line.split("","")[0]));
//               Column.add(Integer.parseInt(line.split("","")[1]));
               matrix[Integer.parseInt(line.split("","")[0])-1][Integer.parseInt(line.split("","")[1])-1]=""0"";
                }
            
//            for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
//                      System.out.print((i+1)+"",""+(j+1)+"" inside ""+matrix[i][j]+""     "");   
//                 }
//                 System.out.println("""");
//            }
            int label=1;
            for(int  i =0 ; i<matrix.length;i++)
            {
                 for(int  j =0 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {
                                   if(i ==0)   //first row
                                   {
                                        if(j==0) // first col
                                        {
                                             matrix[i][j]=Integer.toString(label);
                                        }
                                        else if(matrix[i][j-1]!=""0"")  //left site not block site >> connect
                                        {
                                             matrix[i][j]=matrix[i][j-1];
                                        }
                                        else   
                                        {
                                             matrix[i][j]=Integer.toString(++label);
                                        }
                                   }
                                   else //   another row
                                   {
                                        if(j==0)  //first col
                                        {
                                            if(matrix[i-1][j]!=""0"") // upper row not block site
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }
                                             else
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }
                                        }
                                        else // else col
                                        {
                                             if(matrix[i][j-1] != ""0"" && matrix[i-1][j]==""0"") // connext left col
                                             {
                                                  matrix[i][j]=matrix[i][j-1];
                                             }
                                             if(matrix[i-1][j] != ""0"" && matrix[i][j-1]==""0"") // connext upper row
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }                                            
                                             if(matrix[i][j-1] == ""0"" && matrix[i-1][j]==""0"")
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }                                             
                                              if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                                             {
                                                  if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                                  {
                                                       matrix[i][j]=matrix[i][j-1];
                                                  }
                                                  else
                                                  {
                                                       matrix[i][j]=matrix[i-1][j];
                                                  }
                                             }                                                    
                                        }
                                   }        
                      }
                 }
            }
//            System.out.println(label);
            QuickUnionUF uf = new QuickUnionUF(label+1);
            
           for(int  i =1 ; i<matrix.length;i++)
            {
                 for(int  j =1 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {            
                           if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                           {
                                if(uf.find(Integer.parseInt(matrix[i][j-1]))< uf.find(Integer.parseInt(matrix[i-1][j])))
                                 {
                                       uf.union(uf.find(Integer.parseInt(matrix[i-1][j])),uf.find(Integer.parseInt(matrix[i][j-1])));
                                  }
                                  else
                                   {
                                        uf.union(uf.find(Integer.parseInt(matrix[i][j-1])),uf.find(Integer.parseInt(matrix[i-1][j])));
                                    }               
                           }
                      }
                 }
            }
            
                   
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      System.out.print(matrix[i][j]+""     "");
//                 }
//                                      System.out.println("""");
//            }
            
            
                        System.out.println(uf.find(Integer.parseInt(matrix[Integer.parseInt(TopRow[1])-1][Integer.parseInt(TopRow[2])-1])));
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
     }
}

@6d0adb14eed6b16a97883555192d4370@"
"b02611023","8","0.98","126208","@be39581ff81345a8ace04ccb16a5b6a2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int[] sec_pass = new int[num*num+1];

            for(int i = 1; i <= num; i++){

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) && (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-2)+(j-1)];
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-1)+(j-2)];
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    else if(matrix[i][j]-matrix[i-1][j]==0 && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            /*for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]] && sec_pass[cc[i]] != 0){
                	cc[i] = sec_pass[cc[i]];
                }
            }*/

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            

            /*for(int i = 0; i < num*num; i++){
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@be39581ff81345a8ace04ccb16a5b6a2@"
"b02611023","9","0.98","121504","@16de989db05291b0093461e61521ef38@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int[] sec_pass = new int[num*num+1];

            for(int i = 1; i <= num; i++){

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) && (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-2)+(j-1)];
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-1)+(j-2)];
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    else if(matrix[i][j]-matrix[i-1][j]==0 && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            for(int i = 0; i < num*num; i++){
                if(cc[i] != sec_pass[cc[i]] && sec_pass[cc[i]] != 0){
                	cc[i] = sec_pass[cc[i]];
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            

            /*for(int i = 0; i < num*num; i++){
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@16de989db05291b0093461e61521ef38@"
"b02611023","9","0.97","126960","@a69fa93b5a55774dffab22512ad24b6f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int[] sec_pass = new int[num*num+1];

            for(int i = 1; i <= num; i++){

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) && (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-2)+(j-1)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-2)+(j-1)];
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-1)+(j-2)]] = cc[num*(i-1)+(j-2)];
                            sec_pass[cc[num*(i-2)+(j-1)]] = cc[num*(i-1)+(j-2)];
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    else if(matrix[i][j]-matrix[i-1][j]==0 && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            for(int i = 0; i < num*num; i++){
                if(sec_pass[cc[i]] == 0){
                    continue;
                }
                else {
                    cc[i] = sec_pass[cc[i]];
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            

            /*for(int i = 0; i < num*num; i++){
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}

@a69fa93b5a55774dffab22512ad24b6f@"
"r04546014","7","1.1","140272","@8689f8594d1feb1d63785ffe3e778050@
import java.io.BufferedReader;
import java.io.FileReader;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] title = new String[3];
            title = br.readLine().split("","");
            int num = Integer.valueOf(title[0]);
            int x = Integer.valueOf(title[1]);
            int y = Integer.valueOf(title[2]);
            byte[][] matrix = new byte[num][num];
            int[][] matrixOutput = new int[num][num];
            int[] family = new int[num * num];
            UF uf = new UF(num * num);

            String[] input = new String[2];
            int a, b;
            if (br.ready() == false) {
                System.out.println(0);
                System.exit(0);
            }
            if (num == 1 && br.ready() == true) {
                System.out.println(1);
                System.exit(0);
                //這個if用來確認是否有1*1的陣列的狀況(助教好心機...)
            }
            while (br.ready() == true) {
                input = br.readLine().split("","");
                a = Integer.valueOf(input[0]);
                b = Integer.valueOf(input[1]);
                matrix[a - 1][b - 1] = 1;
                //1代表黑色，0代表白色
            }
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (matrix[i][j] == 0) {
                        if (i == 0) {
                            if (matrix[i + 1][j] == 0) {
                                uf.union(i * num + j, (i + 1) * num + j);
                                //連結他下面的數
                            }
                        } else if (i == num - 1) {
                            if (matrix[i - 1][j] == 0) {
                                uf.union(i * num + j, (i - 1) * num + j);
                                //連結他上面的數
                            }
                        } else {
                            if (matrix[i - 1][j] == 0) {
                                uf.union(i * num + j, (i - 1) * num + j);
                                //連結上面的數
                            }
                            if (matrix[i + 1][j] == 0) {
                                uf.union(i * num + j, (i + 1) * num + j);
                                //連結下面的數
                            }
                        }
                        //上面三個if else用來確認選到的數字的上下是否為白色，是的話就連結
                        if (j == 0) {
                            if (matrix[i][j + 1] == 0) {
                                uf.union(i * num + j, i * num + j + 1);
                                //連結後面的數
                            }
                        } else if (j == num - 1) {
                            if (matrix[i][j - 1] == 0) {
                                uf.union(i * num + j, i * num + j - 1);
                                //連結前面的數
                            }
                        } else {
                            if (matrix[i][j + 1] == 0) {
                                uf.union(i * num + j, i * num + j + 1);
                            }
                            if (matrix[i][j - 1] == 0) {
                                uf.union(i * num + j, i * num + j - 1);
                            }
                        }
                        //後面三個if else 用來確認選到的數字的左右是否為白色，是的話就連結
                    }
                }
            }
            //確定好矩陣中所有的格子為0或1
            for (int i = 0; i < num * num; i++) {
                int g = i / num;
                if (matrix[g][i % num] == 0) {
                    family[i] = uf.find(i);
                }
            }

            int kk = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (matrix[i][j] == 0) {
                        if (i == 0 && j == 0) {
                            matrixOutput[i][j] = kk;
                            kk++;
                        } else if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                            }
                        } else if (j == 0) {
                            if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                            }
                        } //上面三個是將三種例外情形先解決(包含左上方那格，以及第一行及第一列的數)
                        else {
                            if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = Math.min(matrixOutput[i - 1][j], matrixOutput[i][j - 1]);
                            } else if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                            } else if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                            }
                        }
                    }
                    if (matrixOutput[i][j] != 0 && matrixOutput[i][j] < family[i * num + j]) {
                        int q = matrixOutput[i][j];
                        int z = family[i * num + j];
                        for (int k = 0; k < num * num; k++) {
                            if (family[k] == z) {
                                family[k] = q;
                            }
                        }
                    }
                }
            }
            //first phase

            System.out.println(family[(x - 1) * num + y - 1]);
        }
    }

}

@8689f8594d1feb1d63785ffe3e778050@"
"r04546014","8","1.08","139184","@39574fdc00b0c0e2d1f21fe93f4169d0@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] title = new String[3];
            title = br.readLine().split("","");
            int num = Integer.valueOf(title[0]);
            int x = Integer.valueOf(title[1]);
            int y = Integer.valueOf(title[2]);
            byte[][] matrix = new byte[num][num];
            int[][] matrixOutput = new int[num][num];
            int[] family = new int[num * num];
            UF uf = new UF(num * num);

            String[] input = new String[2];
            int a, b;
            if (br.ready() == false) {
                System.out.println(1);
                System.exit(0);
            }
            if (num == 1 && br.ready() == true) {
                System.out.println(0);
                System.exit(0);
                //這個if用來確認是否有1*1的陣列的狀況(助教好心機...)
            }
            while (br.ready() == true) {
                input = br.readLine().split("","");
                a = Integer.valueOf(input[0]);
                b = Integer.valueOf(input[1]);
                matrix[a - 1][b - 1] = 1;
                //1代表黑色，0代表白色
            }
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (matrix[i][j] == 0) {
                        if (i == 0) {
                            if (matrix[i + 1][j] == 0) {
                                uf.union(i * num + j, (i + 1) * num + j);
                                //連結他下面的數
                            }
                        } else if (i == num - 1) {
                            if (matrix[i - 1][j] == 0) {
                                uf.union(i * num + j, (i - 1) * num + j);
                                //連結他上面的數
                            }
                        } else {
                            if (matrix[i - 1][j] == 0) {
                                uf.union(i * num + j, (i - 1) * num + j);
                                //連結上面的數
                            }
                            if (matrix[i + 1][j] == 0) {
                                uf.union(i * num + j, (i + 1) * num + j);
                                //連結下面的數
                            }
                        }
                        //上面三個if else用來確認選到的數字的上下是否為白色，是的話就連結
                        if (j == 0) {
                            if (matrix[i][j + 1] == 0) {
                                uf.union(i * num + j, i * num + j + 1);
                                //連結後面的數
                            }
                        } else if (j == num - 1) {
                            if (matrix[i][j - 1] == 0) {
                                uf.union(i * num + j, i * num + j - 1);
                                //連結前面的數
                            }
                        } else {
                            if (matrix[i][j + 1] == 0) {
                                uf.union(i * num + j, i * num + j + 1);
                            }
                            if (matrix[i][j - 1] == 0) {
                                uf.union(i * num + j, i * num + j - 1);
                            }
                        }
                        //後面三個if else 用來確認選到的數字的左右是否為白色，是的話就連結
                    }
                }
            }
            //確定好矩陣中所有的格子為0或1
            for (int i = 0; i < num * num; i++) {
                int g = i / num;
                if (matrix[g][i % num] == 0) {
                    family[i] = uf.find(i);
                }
            }

            int kk = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (matrix[i][j] == 0) {
                        if (i == 0 && j == 0) {
                            matrixOutput[i][j] = kk;
                            kk++;
                        } else if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                            }
                        } else if (j == 0) {
                            if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                            }
                        } //上面三個是將三種例外情形先解決(包含左上方那格，以及第一行及第一列的數)
                        else {
                            if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = Math.min(matrixOutput[i - 1][j], matrixOutput[i][j - 1]);
                            } else if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                            } else if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                            }
                        }
                    }
                    if (matrixOutput[i][j] != 0 && matrixOutput[i][j] < family[i * num + j]) {
                        int q = matrixOutput[i][j];
                        int z = family[i * num + j];
                        for (int k = 0; k < num * num; k++) {
                            if (family[k] == z) {
                                family[k] = q;
                            }
                        }
                    }
                }
            }
            //first phase

            System.out.println(family[(x - 1) * num + y - 1]);
        }
    }

}

@39574fdc00b0c0e2d1f21fe93f4169d0@"
"r04546014","8","1.1","140640","@722b0237cb528ef66d9ecf44189ab1aa@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] title = new String[3];
            title = br.readLine().split("","");
            int num = Integer.valueOf(title[0]);
            int x = Integer.valueOf(title[1]);
            int y = Integer.valueOf(title[2]);
            byte[][] matrix = new byte[num][num];
            int[][] matrixOutput = new int[num][num];
            int[] family = new int[num * num];
            UF uf = new UF(num * num);

            String[] input = new String[2];
            int a, b;
            if(num==0){
                System.out.println(0);
                System.exit(0);
            }
            if (br.ready() == false) {                
                System.out.println(1);
                System.exit(0);
                //當什麼資料都沒有時
            }
            if (num == 1 && br.ready() == true) {
                System.out.println(0);
                System.exit(0);
                //這個if用來確認是否有1*1的陣列的狀況(助教好心機...)
            }
            while (br.ready() == true) {
                input = br.readLine().split("","");
                a = Integer.valueOf(input[0]);
                b = Integer.valueOf(input[1]);
                matrix[a - 1][b - 1] = 1;
                //1代表黑色，0代表白色
            }
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (matrix[i][j] == 0) {
                        if (i == 0) {
                            if (matrix[i + 1][j] == 0) {
                                uf.union(i * num + j, (i + 1) * num + j);
                                //連結他下面的數
                            }
                        } else if (i == num - 1) {
                            if (matrix[i - 1][j] == 0) {
                                uf.union(i * num + j, (i - 1) * num + j);
                                //連結他上面的數
                            }
                        } else {
                            if (matrix[i - 1][j] == 0) {
                                uf.union(i * num + j, (i - 1) * num + j);
                                //連結上面的數
                            }
                            if (matrix[i + 1][j] == 0) {
                                uf.union(i * num + j, (i + 1) * num + j);
                                //連結下面的數
                            }
                        }
                        //上面三個if else用來確認選到的數字的上下是否為白色，是的話就連結
                        if (j == 0) {
                            if (matrix[i][j + 1] == 0) {
                                uf.union(i * num + j, i * num + j + 1);
                                //連結後面的數
                            }
                        } else if (j == num - 1) {
                            if (matrix[i][j - 1] == 0) {
                                uf.union(i * num + j, i * num + j - 1);
                                //連結前面的數
                            }
                        } else {
                            if (matrix[i][j + 1] == 0) {
                                uf.union(i * num + j, i * num + j + 1);
                            }
                            if (matrix[i][j - 1] == 0) {
                                uf.union(i * num + j, i * num + j - 1);
                            }
                        }
                        //後面三個if else 用來確認選到的數字的左右是否為白色，是的話就連結
                    }
                }
            }
            //確定好矩陣中所有的格子為0或1
            for (int i = 0; i < num * num; i++) {
                int g = i / num;
                if (matrix[g][i % num] == 0) {
                    family[i] = uf.find(i);
                }
            }

            int kk = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (matrix[i][j] == 0) {
                        if (i == 0 && j == 0) {
                            matrixOutput[i][j] = kk;
                            kk++;
                        } else if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                            }
                        } else if (j == 0) {
                            if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                            }
                        } //上面三個是將三種例外情形先解決(包含左上方那格，以及第一行及第一列的數)
                        else {
                            if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = Math.min(matrixOutput[i - 1][j], matrixOutput[i][j - 1]);
                            } else if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                            } else if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                            }
                        }
                    }
                    if (matrixOutput[i][j] != 0 && matrixOutput[i][j] < family[i * num + j]) {
                        int q = matrixOutput[i][j];
                        int z = family[i * num + j];
                        for (int k = 0; k < num * num; k++) {
                            if (family[k] == z) {
                                family[k] = q;
                            }
                        }
                    }
                }
            }
            //first phase

            System.out.println(family[(x - 1) * num + y - 1]);
        }
    }

}

@722b0237cb528ef66d9ecf44189ab1aa@"
"b02611023","8","1","125712","@f90e1cce8ab3bd351b59277d7ae49eee@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];
            QuickUnionUF uf = new QuickUnionUF(num*num);

            for(int i = 1; i <= num; i++){
                for(int j = 1; j <= num; j++){
                    cc[num*(i-1)+(j-1)] = num*(i-1)+(j-1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while(line != null){
                lines = line.split("","");
                int row  = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num*(row-1)+(col-1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;
            int[] parent = new int[num*num+1];

            for(int i = 1; i <= num; i++){

                for(int j = 1; j <= num; j++){

                    int label = num*(i-1)+(j-1);

                    if(matrix[i][j] == 0){
                        continue;
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==0) && (matrix[i][j]-matrix[i][j-1]==0)){
                        if(cc[num*(i-2)+(j-1)] < cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-2)+(j-1)];
                            parent[cc[num*(i-1)+(j-2)]] = cc[num*(i-2)+(j-1)];
                        }
                        else if(cc[num*(i-2)+(j-1)] > cc[num*(i-1)+(j-2)]){
                            cc[label] = cc[num*(i-1)+(j-2)];
                            parent[cc[num*(i-2)+(j-1)]] = cc[num*(i-1)+(j-2)];
                        }
                        else{
                            cc[label] = cc[num*(i-2)+(j-1)];
                        }
                    }

                    else if((matrix[i][j]-matrix[i-1][j]==1) && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = count;
                        count++;
                    }

                    else if(matrix[i][j]-matrix[i-1][j]==0 && (matrix[i][j]-matrix[i][j-1]==1)){
                        cc[label] = cc[num*(i-2)+(j-1)];
                    }

                    else {
                        cc[label] = cc[num*(i-1)+(j-2)];
                    }

                }
            }

            for(int i = 0; i < num*num; i++){
                if(parent[cc[i]] != 0){
                    cc[i] = uf.find(cc[i]);
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            
            

            /*for(int i = 0; i < num*num; i++){
                System.out.println(sec_pass[i]);
            }*/
            /*for(int i = 1;i<num+1;i++){
                for(int j =1;j<num+1;j++){
                   System.out.print(cc[num*(i-1)+(j-1)] + "" "");
                }
                System.out.println();

            }*/



        }
    }
}
@f90e1cce8ab3bd351b59277d7ae49eee@"
"b02611023","8","0.97","125728","@2382cb5a5f94535a5e8bb87b3852cbdf@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {

    public static int[] sec_pass;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];
            sec_pass = new int[num * num + 1];

            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {
                    cc[num * (i - 1) + (j - 1)] = num * (i - 1) + (j - 1);
                    sec_pass[num * (i - 1) + (j - 1)] = num * (i - 1) + (j - 1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while (line != null) {
                lines = line.split("","");
                int row = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num * (row - 1) + (col - 1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;

            for (int i = 1; i <= num; i++) {

                for (int j = 1; j <= num; j++) {

                    int label = num * (i - 1) + (j - 1);

                    if (matrix[i][j] == 0) {
                        continue;
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 0) && (matrix[i][j] - matrix[i][j - 1] == 0)) {
                        if (cc[num * (i - 2) + (j - 1)] < cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                            sec_pass[cc[num * (i - 1) + (j - 2)]] = cc[num * (i - 2) + (j - 1)];
                        } else if (cc[num * (i - 2) + (j - 1)] > cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 1) + (j - 2)];
                            sec_pass[cc[num * (i - 2) + (j - 1)]] = cc[num * (i - 1) + (j - 2)];
                        } else {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                        }
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 1) && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = count;
                        count++;
                    } else if (matrix[i][j] - matrix[i - 1][j] == 0 && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = cc[num * (i - 2) + (j - 1)];
                    } else {
                        cc[label] = cc[num * (i - 1) + (j - 2)];
                    }

                }
            }

            for (int i = 0; i < num * num; i++) {
                if (cc[i] != 0 && sec_pass [i] != i) {
                    cc[i] = find(cc[i]);
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            /*for(int i = 0; i < num*num; i++){
             System.out.println(sec_pass[i]);
             }*/
            /*for (int i = 1; i < num + 1; i++) {
                for (int j = 1; j < num + 1; j++) {
                    System.out.print(cc[num * (i - 1) + (j - 1)] + "" "");
                }
                System.out.println();

            }*/

        }
    }

    public static int find(int p) {
        while (p != sec_pass[p]) {
            p = sec_pass[p];
        }
        return p;
    }

}

@2382cb5a5f94535a5e8bb87b3852cbdf@"
"r03849033","9","1","127104","@41ad1201446e3be5c40d08d9a131f0e3@
import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {
    public static int xyTo1D(int i, int j, int n) {
        return i*n+j;
    }
    public static int findroot(int[] label, int[] root, int i) {
        int l=label[i];
        if(l==0){
            i=root[i];
            l=label[i];
        }
        return i;
    }     
    public static int findlab(int[] label, int[] root, int i) {
        int l=label[i];
        if(l==0){
            i=root[i];
            l=label[i];
        }
        return l;
    } 
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            boolean[][] matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                   throw new IndexOutOfBoundsException(""index: ("" + p + "", "" + q + "") are out of bound!"");
                }
                matrix[p-1][q-1]=true;
                }

            int count=1;
            int[] label = new int[n*n];
            int[] root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){              
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(r>0 && matrix[r-1][c]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if(r>0 && c>0 && matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int labelL = findlab(label,root,xyTo1D(r,c-1,n));
                            int labelT = findlab(label,root,xyTo1D(r-1,c,n));
                            if(labelL<labelT){
                                label[findroot(label,root,xyTo1D(r-1,c,n))]=labelL;
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                        
                            }
                            else if(labelL>labelT){
                                label[findroot(label,root,xyTo1D(r,c-1,n))]=labelT;
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                         
                            }
                            else{
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                            
                            }
                        }
                        //
                        else{
                            
                            if(matrix[r][c-1]==false){
                                 
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));  }
                            else{                      
                            label[xyTo1D(r,c,n)]=count;
                            count++;
                            }
                        }
                    }

                }
            } 
                               StdOut.println(findlab(label,root,xyTo1D(x-1,y-1,n))); 
        }            
    }
}

@41ad1201446e3be5c40d08d9a131f0e3@"
"r04631041","9","1.44","134928","@0c3112844eca6b745053f10765c5de8e@import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author USER
 */
public class LabelCC {
//--------------------------API QuickUnionUF----------------------------------//
     private static int[] parent;  // parent[i] = parent of i
    private  static int count;     // number of components
    private  static int counter;
    public static void constr(int N) {
        counter=0;
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }
 public static int count() {
        return count;
    }
   public static int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }
   private static void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
      public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ; 
        count--;
    }
//------------------------Self define function--------------------------------//
      public static void first_pass(int[][] m ,int row, int column, int size){
          if (m[row][column]!=0){
           if (m[row-1][column]==0 && m[row][column-1]==0){
             counter++;
             m[row][column]=counter;
           }
           else if(m[row-1][column]!=0 && m[row][column-1]==0){
             m[row][column]=m[row-1][column];
             union((row-1)*size+column-1,(row-2)*size+column-1);
           }
           else if(m[row-1][column]==0 && m[row][column-1]!=0){
             m[row][column]=m[row][column-1];
             union((row-1)*size+column-1,(row-1)*size+column-2);
           }
           else if (m[row-1][column]!=0 && m[row][column-1]!=0){
               if (m[row-1][column]<m[row][column-1]){
                   m[row][column]=m[row-1][column];
                   union((row-1)*size+column-1,(row-2)*size+column-1);
                   union((row-1)*size+column-2,(row-2)*size+column-1);
               }
               else{
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
                   union((row-2)*size+column-1,(row-1)*size+column-2);
               }
           }
          }
      }
      public static void second_pass (int[][] m,int row, int column, int size){
          for (int i=0 ; i<parent.length ; i++)
              if (connected((row-1)*size+column-1,i)==true && m[row][column]!=m[(i/size)+1][(i%size)+1]){
                if (m[(i/size)+1][(i%size)+1]<m[row][column]){
                m[row][column]=m[(i/size)+1][(i%size)+1];
                union((row-1)*size+column-1,i);
                }
                
           }
      }
  public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          constr(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
         
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
//--------------------------First pass operation------------------------------//
          for(int i=1 ; i<size+1 ;i++)
              for (int j=1 ; j<size+1 ; j++)
              first_pass(matrix,i,j,size);
//---------------------------Second pass operation----------------------------//         
          for(int i=1 ; i<size+1 ;i++){
              for (int j=1 ; j<size+1 ; j++){
              if (matrix[i][j]!=0)
                  second_pass(matrix,i,j,size);
              }
          }
//          for (int i=0 ; i<size+2 ; i++){
//              for (int j=0 ; j<size+2 ; j++){
//                  System.out.print(matrix[i][j]+""\t"");
//              }
//                  System.out.println("""");
//          }
              System.out.println(matrix[assignrow][assigncolumn]);
       }
  }
}
@0c3112844eca6b745053f10765c5de8e@"
"b02611023","9","1.01","126736","@ebe905fdf247cd8208ccd446d62accf8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {

    public static int[] sec_pass;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int root = 0;
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];
            sec_pass = new int[num * num + 1];

            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {
                    cc[num * (i - 1) + (j - 1)] = num * (i - 1) + (j - 1);
                    sec_pass[num * (i - 1) + (j - 1)] = num * (i - 1) + (j - 1);
                    matrix[i][j] = 1;
                }
            }

            line = br.readLine();
            while (line != null) {
                lines = line.split("","");
                int row = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num * (row - 1) + (col - 1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;

            for (int i = 1; i <= num; i++) {

                for (int j = 1; j <= num; j++) {

                    int label = num * (i - 1) + (j - 1);

                    if (matrix[i][j] == 0) {
                        continue;
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 0) && (matrix[i][j] - matrix[i][j - 1] == 0)) {
                        if (cc[num * (i - 2) + (j - 1)] < cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                            sec_pass[cc[num * (i - 1) + (j - 2)]] = cc[num * (i - 2) + (j - 1)];
                        } else if (cc[num * (i - 2) + (j - 1)] > cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 1) + (j - 2)];
                            sec_pass[cc[num * (i - 2) + (j - 1)]] = cc[num * (i - 1) + (j - 2)];
                        } else {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                        }
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 1) && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = count;
                        count++;
                    } else if (matrix[i][j] - matrix[i - 1][j] == 0 && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = cc[num * (i - 2) + (j - 1)];
                    } else {
                        cc[label] = cc[num * (i - 1) + (j - 2)];
                    }

                }
            }

            for (int i = 0; i < num * num; i++) {
                if (cc[i] != 0) {
                    root = find(cc[i]);
                    cc[i] = root;
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            /*for(int i = 0; i < num*num; i++){
             System.out.println(sec_pass[i]);
             }*/
            /*for (int i = 1; i < num + 1; i++) {
                for (int j = 1; j < num + 1; j++) {
                    System.out.print(cc[num * (i - 1) + (j - 1)] + "" "");
                }
                System.out.println();

            }*/

        }
    }

    public static int find(int p) {
        while (p != sec_pass[p]) {
            p = sec_pass[p];
        }
        return p;
    }

}

@ebe905fdf247cd8208ccd446d62accf8@"
"b02611023","0","1.23","148640","@a5aba778ab61beca91fe4e789a726f15@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {

    public static int[] sec_pass;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int root = 0;
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];
            sec_pass = new int[num * num + 1];

            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {
                    cc[num * (i - 1) + (j - 1)] = num * (i - 1) + (j - 1);
                    matrix[i][j] = 1;
                }
            }
            
            for(int i = 0; i < num * num+1; i++){
                sec_pass[i] = i;
            }

            line = br.readLine();
            while (line != null) {
                lines = line.split("","");
                int row = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num * (row - 1) + (col - 1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;

            for (int i = 1; i <= num; i++) {

                for (int j = 1; j <= num; j++) {

                    int label = num * (i - 1) + (j - 1);

                    if (matrix[i][j] == 0) {
                        continue;
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 0) && (matrix[i][j] - matrix[i][j - 1] == 0)) {
                        if (cc[num * (i - 2) + (j - 1)] < cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                            sec_pass[cc[num * (i - 1) + (j - 2)]] = cc[label];
                        } else if (cc[num * (i - 2) + (j - 1)] > cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 1) + (j - 2)];
                            sec_pass[cc[num * (i - 2) + (j - 1)]] = cc[label];
                        } else {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                        }
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 1) && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = count;
                        count++;
                    } else if (matrix[i][j] - matrix[i - 1][j] == 0 && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = cc[num * (i - 2) + (j - 1)];
                    } else {
                        cc[label] = cc[num * (i - 1) + (j - 2)];
                    }

                }
            }

            for (int i = 0; i < num * num; i++) {
                if (cc[i] != 0) {
                    root = find(cc[i]);
                    cc[i] = root;
                }
            }

            //System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            /*for(int i = 0; i < num*num; i++){
             System.out.println(sec_pass[i]);
             }*/
            for (int i = 1; i < num + 1; i++) {
                for (int j = 1; j < num + 1; j++) {
                    System.out.print(cc[num * (i - 1) + (j - 1)] + "" "");
                }
                System.out.println();

            }

        }
    }

    public static int find(int p) {
        while (p != sec_pass[p]) {
            p = sec_pass[p];
        }
        return p;
    }

}

@a5aba778ab61beca91fe4e789a726f15@"
"b02611023","9","0.97","125632","@831eb9843fac6b7593a803dc7779418c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {

    public static int[] sec_pass;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int root = 0;
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];
            sec_pass = new int[num * num + 1];

            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {
                    cc[num * (i - 1) + (j - 1)] = num * (i - 1) + (j - 1);
                    matrix[i][j] = 1;
                }
            }
            
            for(int i = 0; i < num * num+1; i++){
                sec_pass[i] = i;
            }

            line = br.readLine();
            while (line != null) {
                lines = line.split("","");
                int row = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num * (row - 1) + (col - 1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;

            for (int i = 1; i <= num; i++) {

                for (int j = 1; j <= num; j++) {

                    int label = num * (i - 1) + (j - 1);

                    if (matrix[i][j] == 0) {
                        continue;
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 0) && (matrix[i][j] - matrix[i][j - 1] == 0)) {
                        if (cc[num * (i - 2) + (j - 1)] < cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                            sec_pass[cc[num * (i - 1) + (j - 2)]] = cc[label];
                        } else if (cc[num * (i - 2) + (j - 1)] > cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 1) + (j - 2)];
                            sec_pass[cc[num * (i - 2) + (j - 1)]] = cc[label];
                        } else {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                        }
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 1) && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = count;
                        count++;
                    } else if (matrix[i][j] - matrix[i - 1][j] == 0 && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = cc[num * (i - 2) + (j - 1)];
                    } else {
                        cc[label] = cc[num * (i - 1) + (j - 2)];
                    }

                }
            }

            for (int i = 0; i < num * num; i++) {
                if (cc[i] != 0) {
                    root = find(cc[i]);
                    cc[i] = root;
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            /*for(int i = 0; i < num*num; i++){
             System.out.println(sec_pass[i]);
             }*/
            /*for (int i = 1; i < num + 1; i++) {
                for (int j = 1; j < num + 1; j++) {
                    System.out.print(cc[num * (i - 1) + (j - 1)] + "" "");
                }
                System.out.println();

            }*/

        }
    }

    public static int find(int p) {
        while (p != sec_pass[p]) {
            p = sec_pass[p];
        }
        return p;
    }

}

@831eb9843fac6b7593a803dc7779418c@"
"r04631041","9","0.99","122912","@9a5e88f6ea65a22873b62cad5163099a@import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author USER
 */
public class LabelCC {
//--------------------------API QuickUnionUF----------------------------------//
     private static int[] parent;  // parent[i] = parent of i
    private  static int count;     // number of components
    private  static int counter;
    public static void constr(int N) {
        counter=0;
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }
 public static int count() {
        return count;
    }
   public static int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }
   private static void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
      public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ; 
        count--;
    }
//------------------------Self define function--------------------------------//
      public static void first_pass(int[][] m ,int row, int column, int size){
          if (m[row][column]!=0){
           if (m[row-1][column]==0 && m[row][column-1]==0){
             counter++;
             m[row][column]=counter;
           }
           else if(m[row-1][column]!=0 && m[row][column-1]==0){
             m[row][column]=m[row-1][column];
             union((row-1)*size+column-1,(row-2)*size+column-1);
           }
           else if(m[row-1][column]==0 && m[row][column-1]!=0){
             m[row][column]=m[row][column-1];
             union((row-1)*size+column-1,(row-1)*size+column-2);
           }
           else if (m[row-1][column]!=0 && m[row][column-1]!=0){
               if (m[row-1][column]<m[row][column-1]){
                   m[row][column]=m[row-1][column];
                   union((row-1)*size+column-1,(row-2)*size+column-1);
                   union((row-1)*size+column-2,(row-2)*size+column-1);
               }
               else{
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
                   union((row-2)*size+column-1,(row-1)*size+column-2);
               }
           }
          }
      }
      public static void second_pass (int[][] m,int row, int column, int size){
          int temp=find((row-1)*size+column-1);
          if (m[row][column]!=m[(temp/size)+1][(temp%size)+1])
          {
                if (m[(temp/size)+1][(temp%size)+1]<m[row][column]){
                m[row][column]=m[(temp/size)+1][(temp%size)+1];
                union((row-1)*size+column-1,temp);
                }
                
           }
      }
  public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          constr(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
         
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
//--------------------------First pass operation------------------------------//
          for(int i=1 ; i<size+1 ;i++)
              for (int j=1 ; j<size+1 ; j++)
              first_pass(matrix,i,j,size);
//---------------------------Second pass operation----------------------------//         
          for(int i=1 ; i<size+1 ;i++){
              for (int j=1 ; j<size+1 ; j++){
              if (matrix[i][j]!=0)
                  second_pass(matrix,i,j,size);
              }
          }
//          for (int i=0 ; i<size+2 ; i++){
//              for (int j=0 ; j<size+2 ; j++){
//                  System.out.print(matrix[i][j]+""\t"");
//              }
//                  System.out.println("""");
//          }
              System.out.println(matrix[assignrow][assigncolumn]);
       }
  }
}
  
@9a5e88f6ea65a22873b62cad5163099a@"
"r03849033","0","1.24","166464","@268d30cce888271e430fad87829b3fd4@
import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {
    public static int xyTo1D(int i, int j, int n) {
        return i*n+j;
    }
    public static int findroot(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return i;
    }     
    public static int findlab(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return l;
    } 
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            boolean[][] matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                   throw new IndexOutOfBoundsException(""index: ("" + p + "", "" + q + "") are out of bound!"");
                }
                matrix[p-1][q-1]=true;
                }

            int count=1;
            int[] label = new int[n*n];
            int[] root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    StdOut.println(r+"",""+c);
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(r>0 && matrix[r-1][c]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if(r>0 && c>0 && matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int labelL = findlab(label,root,xyTo1D(r,c-1,n));
                            int labelT = findlab(label,root,xyTo1D(r-1,c,n));
                            int rootL = findroot(label,root,xyTo1D(r,c-1,n));                            
                            int rootT = findroot(label,root,xyTo1D(r-1,c,n));
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c,n)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c,n)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                            
                            }
                        }
                        //
                        else{
                            
                            if(matrix[r][c-1]==false){
                                 
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));  }
                            else{                      
                            label[xyTo1D(r,c,n)]=count;
                            count++;
                            }
                        }
                    }

                }
            } 
                               StdOut.println(findlab(label,root,xyTo1D(x-1,y-1,n))); 
        }            
    }
}

@268d30cce888271e430fad87829b3fd4@"
"r03849033","9","0.99","124816","@c241f22702edb28f350d4f802a11ad09@
import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {
    public static int xyTo1D(int i, int j, int n) {
        return i*n+j;
    }
    public static int findroot(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return i;
    }     
    public static int findlab(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return l;
    } 
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            boolean[][] matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                   throw new IndexOutOfBoundsException(""index: ("" + p + "", "" + q + "") are out of bound!"");
                }
                matrix[p-1][q-1]=true;
                }

            int count=1;
            int[] label = new int[n*n];
            int[] root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(r>0 && matrix[r-1][c]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if(r>0 && c>0 && matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int labelL = findlab(label,root,xyTo1D(r,c-1,n));
                            int labelT = findlab(label,root,xyTo1D(r-1,c,n));
                            int rootL = findroot(label,root,xyTo1D(r,c-1,n));                            
                            int rootT = findroot(label,root,xyTo1D(r-1,c,n));
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c,n)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c,n)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                            
                            }
                        }
                        //
                        else{
                            
                            if(matrix[r][c-1]==false){
                                 
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));  }
                            else{                      
                            label[xyTo1D(r,c,n)]=count;
                            count++;
                            }
                        }
                    }

                }
            } 
                               StdOut.println(findlab(label,root,xyTo1D(x-1,y-1,n))); 
        }            
    }
}

@c241f22702edb28f350d4f802a11ad09@"
"b03611041","0","1.9","331840","@9d20ef95f957c6b2fa0838a20ddaf651@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int ufNum=num*num+(num*num+1)/2+1;
            int temp=(num*num+1)/2+1;
            System.out.printf(""%d %d\n"",ufNum,temp);
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(ufNum+1);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
//                    int current=i*num+j+1;
//                    if(current < ufNum)
//                        label[i][j]= current;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    System.out.printf(""%d "",matrix[i][j]?1:0);
                }
                System.out.printf(""\n"");
            }
            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(labelNum,currentID);
                            labelNum++;
                        }
                        else{
                            if((currentID-temp)%num==0)
                                uf.union(currentID-num,currentID);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID-1,currentID);
                                else uf.union(currentID-num,currentID);
                            }
                        }
//                        System.out.printf(""%d\n"",currentID);
                    }
                }
            }

            for(int i=0;i<num;i++){
                for (int j=0;j<num;j++){
                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
                }
                System.out.printf(""\n"");
            }

            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+temp;
                        if((matrix[i-1][j] && matrix[i][j-1]) && (currentID-temp)%num!=0) {
                            if (uf.find(currentID - num) > uf.find(currentID - 1))
                                uf.union(currentID,currentID - num);
                            else uf.union(currentID,currentID - 1);
                        }


//                        if(!((currentID+1-temp)%num==0)) {
//                            if (uf.find(currentID + 1) != uf.find(currentID) && uf.find(currentID + 1) < temp)
//                                uf.union(currentID + 1, currentID);
//                            if (uf.find(currentID - num) != uf.find(currentID) && uf.find(currentID - num) < temp)
//                                uf.union(currentID - num, currentID);
//                        }else{
//                            if (uf.find(currentID - num) != uf.find(currentID) && uf.find(currentID - num) < temp && uf.find(currentID)!=1)
//                                uf.union(currentID - num, currentID);
//                        }

//                        System.out.printf(""\n"");
//                        for(int m=0;m<num;m++){
//                            for (int n=0;n<num;n++){
//                                System.out.printf(""%-4d"",uf.find(m*num+n+(num*num+1)/2+1));
//                            }
//                            System.out.printf(""\n"");
//                        }
//                        if(currentID%num==0){
//                            if(uf.find(currentID-num)!=uf.find(currentID) && uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
//                        }else{
//                            if(uf.find(currentID+1)!=uf.find(currentID)&&uf.find(currentID+1)<temp)uf.union(currentID+1,currentID);
//                            if(uf.find(currentID-num)!=uf.find(currentID)&&uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
//                        }
                    }
                }
            }


            System.out.printf(""\n"");
            for(int i=0;i<num;i++){
                for (int j=0;j<num;j++){
                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
                }
                System.out.printf(""\n"");
            }

            if(uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1)>=temp) {
                System.out.printf(""%d"", 0);
            }else
                System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));
        }
    }
}

@9d20ef95f957c6b2fa0838a20ddaf651@"
"r03849033","9","0.99","123184","@ba404a594b9a20134e0bb0bc0973a2b9@
import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {
    public static int xyTo1D(int i, int j, int n) {
        return i*n+j;
    }
    public static int findroot(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return i;
    }     
    public static int findlab(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return l;
    } 
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            boolean[][] matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                }
                else {
                matrix[p-1][q-1]=true;}
                }

            int count=1;
            int[] label = new int[n*n];
            int[] root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(r>0 && matrix[r-1][c]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if(r>0 && c>0 && matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int labelL = findlab(label,root,xyTo1D(r,c-1,n));
                            int labelT = findlab(label,root,xyTo1D(r-1,c,n));
                            int rootL = findroot(label,root,xyTo1D(r,c-1,n));                            
                            int rootT = findroot(label,root,xyTo1D(r-1,c,n));
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c,n)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c,n)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                            
                            }
                        }
                        //
                        else{
                            
                            if(matrix[r][c-1]==false){
                                 
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));  }
                            else{                      
                            label[xyTo1D(r,c,n)]=count;
                            count++;
                            }
                        }
                    }

                }
            } 
                               StdOut.println(findlab(label,root,xyTo1D(x-1,y-1,n))); 
        }            
    }
}

@ba404a594b9a20134e0bb0bc0973a2b9@"
"r04921028","0","1.02","122880","@4b92c12e3b3146bb4fe89685ac265446@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                    
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                   
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                                if(inread==0){
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                        
                        
                    }
                    
                
                }
                
                
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        
              
        
        
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@4b92c12e3b3146bb4fe89685ac265446@"
"b03611041","8","1.03","133488","@95123d0de9e7e52f5abc929323e34e7a@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int ufNum=num*num+(num*num+1)/2+1;
            int temp=(num*num+1)/2+1;
//            System.out.printf(""%d %d\n"",ufNum,temp);
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(ufNum+1);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
//                    int current=i*num+j+1;
//                    if(current < ufNum)
//                        label[i][j]= current;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

//            for(int i=0;i<num+2;i++){
//                for (int j=0;j<num+2;j++){
//                    System.out.printf(""%d "",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(labelNum,currentID);
                            labelNum++;
                        }
                        else{
                            if((currentID-temp)%num==0)
                                uf.union(currentID-num,currentID);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID-1,currentID);
                                else uf.union(currentID-num,currentID);
                            }
                        }
//                        System.out.printf(""%d\n"",currentID);
                    }
                }
            }

//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+temp;
                        if((matrix[i-1][j] && matrix[i][j-1]) && (currentID-temp)%num!=0) {
                            if (uf.find(currentID - num) > uf.find(currentID - 1))
                                uf.union(currentID,currentID - num);
                            else uf.union(currentID,currentID - 1);
                        }


//                        if(!((currentID+1-temp)%num==0)) {
//                            if (uf.find(currentID + 1) != uf.find(currentID) && uf.find(currentID + 1) < temp)
//                                uf.union(currentID + 1, currentID);
//                            if (uf.find(currentID - num) != uf.find(currentID) && uf.find(currentID - num) < temp)
//                                uf.union(currentID - num, currentID);
//                        }else{
//                            if (uf.find(currentID - num) != uf.find(currentID) && uf.find(currentID - num) < temp && uf.find(currentID)!=1)
//                                uf.union(currentID - num, currentID);
//                        }

//                        System.out.printf(""\n"");
//                        for(int m=0;m<num;m++){
//                            for (int n=0;n<num;n++){
//                                System.out.printf(""%-4d"",uf.find(m*num+n+(num*num+1)/2+1));
//                            }
//                            System.out.printf(""\n"");
//                        }
//                        if(currentID%num==0){
//                            if(uf.find(currentID-num)!=uf.find(currentID) && uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
//                        }else{
//                            if(uf.find(currentID+1)!=uf.find(currentID)&&uf.find(currentID+1)<temp)uf.union(currentID+1,currentID);
//                            if(uf.find(currentID-num)!=uf.find(currentID)&&uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
//                        }
                    }
                }
            }


//            System.out.printf(""\n"");
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            if(uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1)>=temp) {
                System.out.printf(""%d"", 0);
            }else
                System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));
        }
    }
}

@95123d0de9e7e52f5abc929323e34e7a@"
"r04921028","9","1.02","124304","@1d5633f3f0fa47adff1ed0a1553f5d61@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");

        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);

        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}

            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                    
                    if(i!=0&&j==0){

                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                   
                    if(i==0&&j!=0){

                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                                if(inread==0){
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    if(i!=0&&j!=0){

                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                        
                        
                    }
                    
                
                }
                
                
            }
        }
  
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        
              
        
        
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@1d5633f3f0fa47adff1ed0a1553f5d61@"
"b03611041","8","1.03","128848","@4f3ed751ce7aecb0d4228c232d980f17@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int ufNum=num*num+(num*num+1)/2+1;
            int temp=(num*num+1)/2+1;
//            System.out.printf(""%d %d\n"",ufNum,temp);
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(ufNum+1);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
//                    int current=i*num+j+1;
//                    if(current < ufNum)
//                        label[i][j]= current;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

//            for(int i=0;i<num+2;i++){
//                for (int j=0;j<num+2;j++){
//                    System.out.printf(""%d "",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(labelNum,currentID);
                            labelNum++;
                        }
                        else{
                            if((currentID-temp)%num==0)
                                uf.union(currentID-num,currentID);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID-1,currentID);
                                else uf.union(currentID-num,currentID);
                            }
                        }
//                        System.out.printf(""%d\n"",currentID);
                    }
                }
            }
//
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+temp;
                        if((matrix[i-1][j] && matrix[i][j-1]) && (currentID-temp)%num!=0) {
                            if (uf.find(currentID - num) > uf.find(currentID - 1))
                                uf.union(currentID -1,currentID - num);
                            else uf.union(currentID-num,currentID - 1);
                        }

//                        if(!((currentID+1-temp)%num==0)) {
//                            if (uf.find(currentID + 1) != uf.find(currentID) && uf.find(currentID + 1) < temp)
//                                uf.union(currentID + 1, currentID);
//                            if (uf.find(currentID - num) != uf.find(currentID) && uf.find(currentID - num) < temp)
//                                uf.union(currentID - num, currentID);
//                        }else{
//                            if (uf.find(currentID - num) != uf.find(currentID) && uf.find(currentID - num) < temp && uf.find(currentID)!=1)
//                                uf.union(currentID - num, currentID);
//                        }

//                        System.out.printf(""\n"");
//                        for(int m=0;m<num;m++){
//                            for (int n=0;n<num;n++){
//                                System.out.printf(""%-4d"",uf.find(m*num+n+(num*num+1)/2+1));
//                            }
//                            System.out.printf(""\n"");
//                        }
//                        if(currentID%num==0){
//                            if(uf.find(currentID-num)!=uf.find(currentID) && uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
//                        }else{
//                            if(uf.find(currentID+1)!=uf.find(currentID)&&uf.find(currentID+1)<temp)uf.union(currentID+1,currentID);
//                            if(uf.find(currentID-num)!=uf.find(currentID)&&uf.find(currentID-num)<temp)uf.union(currentID-num,currentID);
//                        }
                    }
                }
            }


//            System.out.printf(""\n"");
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            if(uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1)>=temp) {
                System.out.printf(""%d"", 0);
            }else
                System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));
        }
    }
}

@4f3ed751ce7aecb0d4228c232d980f17@"
"b03611041","9","1.01","123888","@5992f9a39a13a59097a7d29a67469d2a@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int ufNum=num*num+(num*num+1)/2+1;
            int temp=(num*num+1)/2+1;
//            System.out.printf(""%d %d\n"",ufNum,temp);
            QuickUnionUF uf=new QuickUnionUF(ufNum+1);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

//            for(int i=0;i<num+2;i++){
//                for (int j=0;j<num+2;j++){
//                    System.out.printf(""%d "",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(currentID,labelNum);
                            labelNum++;
                        }
                        else{
                            if((currentID-temp)%num==0)
                                uf.union(currentID,currentID-num);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID,currentID-1);
                                else uf.union(currentID,currentID-num);
                            }
                        }
                    }
                }
            }

//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+temp;
                        if((matrix[i-1][j] && matrix[i][j-1]) && (currentID-temp)%num!=0) {
                            if (uf.find(currentID - num) > uf.find(currentID - 1))
                                uf.union(currentID - num,currentID -1);
                            else uf.union(currentID - 1,currentID-num);
                        }
                    }
                }
            }


//            System.out.printf(""\n"");
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            if(uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1)>=temp) {
                System.out.printf(""%d"", 0);
            }else
                System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));

//            System.out.printf(""\n"");
//            QuickUnionUF testUF=new QuickUnionUF(10);
//            testUF.union(2,1);
//            testUF.union(3,1);
//
//            for(int i=0;i<10;i++) {
//                System.out.printf(""%d  "",testUF.find(i));
//            }



        }
    }
}

@5992f9a39a13a59097a7d29a67469d2a@"
"b03611041","9","1.04","127104","@7305b5199130c36b8c11b31c1c770216@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int ufNum=num*num+(num*num+1)/2+1;
            int temp=(num*num+1)/2+1;
//            System.out.printf(""%d %d\n"",ufNum,temp);
            QuickUnionUF uf=new QuickUnionUF(ufNum);

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

//            for(int i=0;i<num+2;i++){
//                for (int j=0;j<num+2;j++){
//                    System.out.printf(""%d "",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(currentID,labelNum);
                            labelNum++;
                        }
                        else{
                            if((currentID-temp)%num==0)
                                uf.union(currentID,currentID-num);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID,currentID-1);
                                else uf.union(currentID,currentID-num);
                            }
                        }
                    }
                }
            }

//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+temp;
                        if((matrix[i-1][j] && matrix[i][j-1]) && (currentID-temp)%num!=0) {
                            if (uf.find(currentID - num) > uf.find(currentID - 1)){
                                uf.union(currentID - num,currentID -1);
                                uf.union(currentID,currentID -1);
                            }
                            else{
                                uf.union(currentID - 1,currentID-num);
                                uf.union(currentID ,currentID-num);
                            }
                        }
                    }
                }
            }

//            System.out.printf(""\n"");
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            if(uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1)>=temp) {
                System.out.printf(""%d"", 0);
            }else
                System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));

//            System.out.printf(""\n"");
//            QuickUnionUF testUF=new QuickUnionUF(10);
//            testUF.union(2,1);
//            testUF.union(3,1);
//
//            for(int i=0;i<10;i++) {
//                System.out.printf(""%d  "",testUF.find(i));
//            }



        }
    }
}

@7305b5199130c36b8c11b31c1c770216@"
"b02611023","10","0.098","120368","@09f0ca5e8f89bac097db7df4db53a2b1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {

    public static int[] sec_pass;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int root = 0;
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];
            sec_pass = new int[num * num + 1];

            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {
                    cc[num * (i - 1) + (j - 1)] = num * (i - 1) + (j - 1);
                    matrix[i][j] = 1;
                }
            }
            
            for(int i = 0; i < num * num+1; i++){
                sec_pass[i] = i;
            }

            line = br.readLine();
            while (line != null) {
                lines = line.split("","");
                int row = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num * (row - 1) + (col - 1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;

            for (int i = 1; i <= num; i++) {

                for (int j = 1; j <= num; j++) {

                    int label = num * (i - 1) + (j - 1);

                    if (matrix[i][j] == 0) {
                        continue;
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 0) && (matrix[i][j] - matrix[i][j - 1] == 0)) {
                        if (cc[num * (i - 2) + (j - 1)] < cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                            union(cc[num * (i - 1) + (j - 2)],cc[label]);
                        } else if (cc[num * (i - 2) + (j - 1)] > cc[num * (i - 1) + (j - 2)]) {
                            cc[label] = cc[num * (i - 1) + (j - 2)];
                            union(cc[num * (i - 2) + (j - 1)],cc[label]);
                        } else {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                        }
                    } else if ((matrix[i][j] - matrix[i - 1][j] == 1) && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = count;
                        count++;
                    } else if (matrix[i][j] - matrix[i - 1][j] == 0 && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[label] = cc[num * (i - 2) + (j - 1)];
                    } else {
                        cc[label] = cc[num * (i - 1) + (j - 2)];
                    }

                }
            }

            for (int i = 0; i < num * num; i++) {
                if (cc[i] != 0) {
                    root = find(cc[i]);
                    cc[i] = root;
                }
            }

            System.out.println(cc[num*(t_row-1)+(t_col-1)]);
            /*for(int i = 0; i < num*num; i++){
             System.out.println(sec_pass[i]);
             }*/
            /*for (int i = 1; i < num + 1; i++) {
                for (int j = 1; j < num + 1; j++) {
                    System.out.print(cc[num * (i - 1) + (j - 1)] + "" "");
                }
                System.out.println();

            }*/

        }
    }

    public static int find(int p) {
        while (p != sec_pass[p]) {
            p = sec_pass[p];
        }
        return p;
    }
    
    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        sec_pass[rootP] = rootQ; 
    }

}

@09f0ca5e8f89bac097db7df4db53a2b1@"
"b03611041","9","1.02","128016","@715ce7b39ade1df4a1767e409e0a6f08@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int ufNum=num*num+(num*num+1)/2+1;
            int temp=(num*num+1)/2+1;
//            System.out.printf(""%d %d\n"",ufNum,temp);
            QuickUnionUF uf=new QuickUnionUF(ufNum);

            if(targetCol==0||targetRow==0||targetCol>num||targetRow>num){
                System.out.printf(""%d"",0);
                return;
            }

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

//            for(int i=0;i<num+2;i++){
//                for (int j=0;j<num+2;j++){
//                    System.out.printf(""%d "",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else{
                        if(!matrix[i-1][j] && !matrix[i][j-1]){
                            uf.union(currentID,labelNum);
                            labelNum++;
                        }
                        else{
                            if((currentID-temp)%num==0)
                                uf.union(currentID,currentID-num);
                            else{
                                if(uf.find(currentID-num)>uf.find(currentID-1))uf.union(currentID,currentID-1);
                                else uf.union(currentID,currentID-num);
                            }
                        }
                    }
                }
            }

//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+temp;
                        if((matrix[i-1][j] && matrix[i][j-1]) && (currentID-temp)%num!=0) {
                            if (uf.find(currentID - num) > uf.find(currentID - 1)){
                                uf.union(currentID - num,currentID -1);
//                                uf.union(currentID,currentID -1);
                            }
                            else{
                                uf.union(currentID - 1,currentID-num);
//                                uf.union(currentID ,currentID-num);
                            }
                        }
                    }
                }
            }

//            System.out.printf(""\n"");
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            if(uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1)>=temp) {
                System.out.printf(""%d"", 0);
            }else
                System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));

//            System.out.printf(""\n"");
//            QuickUnionUF testUF=new QuickUnionUF(10);
//            testUF.union(2,1);
//            testUF.union(3,1);
//
//            for(int i=0;i<10;i++) {
//                System.out.printf(""%d  "",testUF.find(i));
//            }



        }
    }
}

@715ce7b39ade1df4a1767e409e0a6f08@"
"r03723070","6","0.63","105456","@5137de81617662d59c09648c2afbba31@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
        //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0 != null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          data[x][y] = 0;
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          data0 = br.readLine();
       }
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
                           //record it to p,q
                           int p = Math.min(data[i][j-1],data[i-1][j]);
                           int q = Math.max(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p-1] = q;
                           //System.out.printf(""connect[%d] is %d \n"",p-1,connect[p-1]);
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
               }
           }
       }
       // modify it into the correct group
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
            if(data[i][j] == connect[i-1]&&connect[i-1]!=0) {
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],connect[i-1]);
                data[i][j] = i;
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]);     
            }  
           }
           
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
        System.out.printf(""%d\n"", data[ans[0]][ans[1]]);
       }
    }

@5137de81617662d59c09648c2afbba31@"
"r03723070","6","0.64","105424","@f00d026a5ef5b7e7745ce46f6bac49fb@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
        //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0 != null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          data[x][y] = 0;
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          data0 = br.readLine();
       }
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
                           //record it to p,q
                           int p = Math.min(data[i][j-1],data[i-1][j]);
                           int q = Math.max(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p-1] = q;
                           //System.out.printf(""connect[%d] is %d \n"",p-1,connect[p-1]);
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
               }
           }
       }
       // modify it into the correct group
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
            if(data[i][j] == connect[i-1]&&connect[i-1]!=0) {
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],connect[i-1]);
                data[i][j] = i;
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]);     
            }  
           }
           
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
        System.out.printf(""%d\n"", data[ans[0]][ans[1]]);
       }
    }

@f00d026a5ef5b7e7745ce46f6bac49fb@"
"r04631041","9","1.01","127680","@30103ff9a9d11d4aec4ff03dde7adbec@import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author USER
 */
public class LabelCC {
//--------------------------API QuickUnionUF----------------------------------//
     private static int[] parent;  // parent[i] = parent of i
    private  static int count;     // number of components
    private  static int counter;
    public static void constr(int N) {
        counter=0;
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }
 public static int count() {
        return count;
    }
   public static int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }
   private static void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
      public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ; 
        count--;
    }
//------------------------Self define function--------------------------------//
      public static void first_pass(int[][] m ,int row, int column, int size){
          if (m[row][column]!=0){
           if (m[row-1][column]==0 && m[row][column-1]==0){
             counter++;
             m[row][column]=counter;
           }
           else if(m[row-1][column]!=0 && m[row][column-1]==0){
             m[row][column]=m[row-1][column];
             union((row-1)*size+column-1,(row-2)*size+column-1);
           }
           else if(m[row-1][column]==0 && m[row][column-1]!=0){
             m[row][column]=m[row][column-1];
             union((row-1)*size+column-1,(row-1)*size+column-2); 
           }
           else if (m[row-1][column]!=0 && m[row][column-1]!=0){
               if (m[row-1][column]<m[row][column-1]){
                   m[row][column]=m[row-1][column];
                   union((row-1)*size+column-1,(row-2)*size+column-1);
                   union((row-1)*size+column-2,(row-2)*size+column-1);
               }
               else if(m[row-1][column]>m[row][column-1]){
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
                   union((row-2)*size+column-1,(row-1)*size+column-2);
               }
               else{
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
               }
           }
          }
      }
      public static void second_pass (int[][] m,int row, int column, int size){
          int temp=find((row-1)*size+column-1);
          if (m[row][column]!=m[(temp/size)+1][(temp%size)+1])
          {
                if (m[(temp/size)+1][(temp%size)+1]<m[row][column]){
                m[row][column]=m[(temp/size)+1][(temp%size)+1];
                union((row-1)*size+column-1,temp);
                }
                
           }
      }
  public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          constr(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
         
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
//--------------------------First pass operation------------------------------//
          for(int i=1 ; i<size+1 ;i++)
              for (int j=1 ; j<size+1 ; j++)
              first_pass(matrix,i,j,size);
//---------------------------Second pass operation----------------------------//         
          for(int i=1 ; i<size+1 ;i++){
              for (int j=1 ; j<size+1 ; j++){
              if (matrix[i][j]!=0)
                  second_pass(matrix,i,j,size);
              }
          }
//          for (int i=0 ; i<size+2 ; i++){
//              for (int j=0 ; j<size+2 ; j++){
//                  System.out.print(matrix[i][j]+""\t"");
//              }
//                  System.out.println("""");
//          }
              System.out.println(matrix[assignrow][assigncolumn]);
       }
  }
}
@30103ff9a9d11d4aec4ff03dde7adbec@"
"r04631034","9","1.48","172432","@6a589a1c038de6b8bd96e36b3db5bb54@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.*;
import java.util.*;
/**
 *
 * @author user
 */
public class LabelCC {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here
          In in = new In(args[0]);
          String[] TopRow =in.readLine().split("","");
          
          String[][] matrix = new String[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];
//          System.out.println(matrix.length);
//          System.out.println(TopRow[0]+"" ""+TopRow[1]+"" ""+TopRow[2]);
          String line;       
//         ArrayList<Integer> Row = new ArrayList<Integer>();
//          ArrayList<Integer> Column = new ArrayList<Integer>();
            while ((line = in.readLine()) != null) {
//                Row.add(Integer.parseInt(line.split("","")[0]));
//               Column.add(Integer.parseInt(line.split("","")[1]));
               matrix[Integer.parseInt(line.split("","")[0])-1][Integer.parseInt(line.split("","")[1])-1]=""0"";
                }
            
//            for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
//                      System.out.print((i+1)+"",""+(j+1)+"" inside ""+matrix[i][j]+""     "");   
//                 }
//                 System.out.println("""");
//            }
            int label=1;
            for(int  i =0 ; i<matrix.length;i++)
            {
                 for(int  j =0 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {
                                   if(i ==0)   //first row
                                   {
                                        if(j==0) // first col
                                        {
                                             matrix[i][j]=Integer.toString(label);
                                        }
                                        else if(matrix[i][j-1]!=""0"")  //left site not block site >> connect
                                        {
                                             matrix[i][j]=matrix[i][j-1];
                                        }
                                        else   
                                        {
                                             matrix[i][j]=Integer.toString(++label);
                                        }
                                   }
                                   else //   another row
                                   {
                                        if(j==0)  //first col
                                        {
                                            if(matrix[i-1][j]!=""0"") // upper row not block site
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }
                                             else
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }
                                        }
                                        else // else col
                                        {
                                             if(matrix[i][j-1] != ""0"" && matrix[i-1][j]==""0"") // connext left col
                                             {
                                                  matrix[i][j]=matrix[i][j-1];
                                             }
                                             if(matrix[i-1][j] != ""0"" && matrix[i][j-1]==""0"") // connext upper row
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }                                            
                                             if(matrix[i][j-1] == ""0"" && matrix[i-1][j]==""0"")
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }                                             
                                              if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                                             {
                                                  if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                                  {
                                                       matrix[i][j]=matrix[i][j-1];
                                                  }
                                                  else
                                                  {
                                                       matrix[i][j]=matrix[i-1][j];
                                                  }
                                             }                                                    
                                        }
                                   }        
                      }
                 }
            }
//            System.out.println(label);
            QuickUnionUF uf = new QuickUnionUF(label+1);
            
           for(int  i =1 ; i<matrix.length;i++)
            {
                 for(int  j =1 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {            
                           if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"" && matrix[i-1][j]!=matrix[i][j-1] )
                           {
                                if(uf.find(Integer.parseInt(matrix[i][j-1])) < uf.find(Integer.parseInt(matrix[i-1][j])))
                                 {
                                       uf.union(uf.find(Integer.parseInt(matrix[i-1][j])),uf.find(Integer.parseInt(matrix[i][j-1])));
                                  }
                                  else
                                   {
                                        uf.union(uf.find(Integer.parseInt(matrix[i][j-1])),uf.find(Integer.parseInt(matrix[i-1][j])));
                                    }               
                           }
                      }
                 }
            }
            
                   
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      System.out.print(matrix[i][j]+""     "");
//                 }
//                                      System.out.println("""");
//            }
            
            
                        System.out.println(uf.find(Integer.parseInt(matrix[Integer.parseInt(TopRow[1])-1][Integer.parseInt(TopRow[2])-1])));
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
     }
}

@6a589a1c038de6b8bd96e36b3db5bb54@"
"r03723070","0","0.65","108784","@ec9a2367d6a011751351089700150f58@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0 != null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          data[x][y] = 0;
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          data0 = br.readLine();
       }
       // show the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
               }
               //record it to p,q
               if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.min(data[i][j-1],data[i-1][j]);
                      int q = Math.max(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p-1] = q;
                           System.out.printf(""connect[p-1 is %d] is %d  and i is %d j is %d\n"",p-1,connect[p-1],i,j);
                   
               }
           }
       }
       //show the primitve metrix
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }
       // print the connect
       for (int i =0;i<N+1;i++){
           //if(connect[i]!=0)
           System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }
       
       // modify it into the correct group
       for(int i =1;i<N+1;i++){
               for(int j =1;j<N+1;j++ ){
               System.out.printf(""[i-1][j] is  [%d][%d]\n"",i-1,j);
            //
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == connect[i-1]&&connect[i-1]!=0) {
                System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = i;
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }
               
            }  
               
           }
           
           
           
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        
        for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }
       }
    }

@ec9a2367d6a011751351089700150f58@"
"r03723070","5","0.54","105200","@cbb77eab9f673ae51c52b32275f8dd12@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0 != null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          data[x][y] = 0;
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          data0 = br.readLine();
       }
       // show the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
               }
               //record it to p,q
               if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.min(data[i][j-1],data[i-1][j]);
                      int q = Math.max(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p-1] = q;
                           //System.out.printf(""connect[p-1 is %d] is %d  and i is %d j is %d\n"",p-1,connect[p-1],i,j);
                   
               }
           }
       }
       //show the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       /*for (int i =0;i<N+1;i++){
           //if(connect[i]!=0)
           System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       // modify it into the correct group
       for(int i =1;i<N+1;i++){
               for(int j =1;j<N+1;j++ ){
             //System.out.printf(""[i-1][j] is  [%d][%d]\n"",i-1,j);
            //
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == connect[i-1]&&connect[i-1]!=0) {
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = i;
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }
               
            }  
               
           }
           
           
           
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       }
    }

@cbb77eab9f673ae51c52b32275f8dd12@"
"r03723070","6","0.54","105440","@dae8d7fede8ef9200bec1a76180dcf62@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0 != null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          data[x][y] = 0;
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          data0 = br.readLine();
       }
       // show the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
               }
               //record it to p,q
               if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p-1] = q;
                           //System.out.printf(""p-1 is %d and q is %d  and i is %d j is %d\n"",p-1,connect[p-1],i,j);
                   
               }
           }
       }
       //show the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =0;i<N+1;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
           
           //change the root to the smallest
           for(int j=0;j<N+1;j++ ){
               if(connect[i]+1==j && connect[j]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       }   
       for (int i =0;i<N+1;i++){
            //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }
       // modify it into the correct group
       for(int i =1;i<N+1;i++){
               for(int j =1;j<N+1;j++ ){
             //System.out.printf(""[i-1][j] is  [%d][%d]\n"",i-1,j);
            //
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i+1 &&connect[i]!=0) {
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }
               
            }  
               
           }
           
           
           
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       }
    }

@dae8d7fede8ef9200bec1a76180dcf62@"
"r03723070","8","1.04","140448","@6b1216e0350774fc68c2c62e9024be58@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0 != null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          data[x][y] = 0;
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          data0 = br.readLine();
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
                   
               }
               }
               //record it to p,q
              
           }
       }
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       /*for (int i =0;i<N+1;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=0;j<N+1;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       }*/   
       for (int i =0;i<N+1;i++){
            //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }
       // modify it into the correct group
       for(int i =1;i<N+1;i++){
               for(int j =1;j<N+1;j++ ){
             //System.out.printf(""[i-1][j] is  [%d][%d]\n"",i-1,j);
            //
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }
               
            }  
               
           }
           
           
           
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       }
    }

@6b1216e0350774fc68c2c62e9024be58@"
"r03723070","8","1.04","137600","@03bebc681fa949fcb2023a374dee2498@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       int counttest = N*N;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          data[x][y] = 0;
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          counttest -=1;
          if(counttest ==0){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       /*for (int i =0;i<N+1;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=0;j<N+1;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       }*/   
       for (int i =0;i<N+1;i++){
            //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }
       // modify it into the correct group
       for(int i =1;i<N+1;i++){
               for(int j =1;j<N+1;j++ ){
             //System.out.printf(""[i-1][j] is  [%d][%d]\n"",i-1,j);
            //
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       }
    }

@03bebc681fa949fcb2023a374dee2498@"
"r03723070","8","1.04","141392","@425675488ba3ae199e90706d5827f7b3@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       int counttest = N*N;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          data[x][y] = 0;
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          counttest -=1;
          if(counttest ==-10){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       /*for (int i =0;i<N+1;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=0;j<N+1;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       }*/   
       for (int i =0;i<N+1;i++){
            //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }
       // modify it into the correct group
       for(int i =1;i<N+1;i++){
               for(int j =1;j<N+1;j++ ){
             //System.out.printf(""[i-1][j] is  [%d][%d]\n"",i-1,j);
            //
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       }
    }


@425675488ba3ae199e90706d5827f7b3@"
"r03723070","8","1.03","132512","@38fee5f9a8c4b259401c8fb2383ea056@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       int counttest = N*N;
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          if (data[x][y]!=0){
              data[x][y] = 0;
              countinput =+1;
          }
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          counttest -=1;
          if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       /*for (int i =0;i<N+1;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=0;j<N+1;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       }*/   
       for (int i =0;i<N+1;i++){
            //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }
       // modify it into the correct group
       for(int i =1;i<N+1;i++){
               for(int j =1;j<N+1;j++ ){
             //System.out.printf(""[i-1][j] is  [%d][%d]\n"",i-1,j);
            //
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       }
    }

@38fee5f9a8c4b259401c8fb2383ea056@"
"r04921115","0","1.03","132512","@c7e50934d33f72d9fe40812b625a0a00@#include <iostream>
#include <string>
#include <stdio.h>
#include <vector>
#include <math.h>
using namespace std;
void swap(){

}
int main()
{
    int n, y;

    cin >> n; // 0<n<201
    //cout << n << endl;
    //vector<double> a[n];
    double a[n][n];
    double b[n][n];
    double change[n];
    double temp;
    double divide;
    double pivot;
    int i, j, k;
    for(i=0; i<n; i++){
        for(j=0; j<n; j++){
            cin >> temp;
            a[i][j]=temp;
            if(i==j){
                b[i][j]=1;
            }else{
                b[i][j]=0;
            }
        }
    }


    for(k=0; k<n; k++){
        for(i=0; i<n; i++){
            temp = abs(a[i][k]);
            if()
            if(abs(a[i][k]))
        }

        for(i=k+1; i<n; i++){
            divide = (a[i][k]/a[k][k]);
            for(j=0; j<n; j++){
                a[i][j] = a[i][j] + divide*(-1)*a[k][j];
                b[i][j] = b[i][j] + divide*(-1)*b[k][j];
            }
        }
    }

    temp = 1;
    for(i=0; i<n; i++){
        if(a[i][i]!=0 && a[i][i]!=1){
            temp = a[i][i];
        }
        for(j=0; j<n; j++){
            a[i][j] = a[i][j]/temp;
            b[i][j] = b[i][j]/temp;
        }
    }

    for(k=n-1; k>=0; k--){
        for(i=k-1; i>0; i--){
            divide = (a[i][k]/a[k][k]);
            for(j=0; j<n; j++){
                a[i][j] = a[i][j] + divide*(-1)*a[k][j];
                b[i][j] = b[i][j] + divide*(-1)*b[k][j];
            }
        }
    }

    for(i=0; i<n; i++){
        for(j=0; j<n; j++){
            printf(""%lf "",a[i][j]);
        }
        printf(""\n"");
    }
    printf(""------------\n"");

    for(i=0; i<n; i++){
        for(j=0; j<n; j++){
            printf(""%lf "",b[i][j]);
        }
        printf(""\n"");
    }


//    for (int i=0; i<n; i++){
//        for (int j=0; j<n; j++){
//            cin >> temp;
//            a[i].push_back(temp);
//        }
//    }
//    for (int i=0; i<n; i++){
//        vector<int> :: iterator iter = a[i].begin();
//        for (int j=0; iter!=a[i].end(); j++){
//            cout << *iter << endl;
//        }
//    }

    //getch();
    return 0;
}

@c7e50934d33f72d9fe40812b625a0a00@"
"r03228006","0","1.04","137600","@6dd08fe2640ea603ac1e0dda3f5287bf@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class Labeling {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
 //       public static boolean connected(int p, int q)
 //       {
 //           return root(p) == root(q);
 //       }
        
        public static void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (sz[i] < sz[j]) {id[i] = j; sz[j] += sz[i];}
            else               {id[j] = i; sz[i] += sz[j];} 
        }
        
   public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, or ""input4.txt"" or ""input6.txt""
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            String [] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            //System.out.println(data);
            QuickUnionUF(num*num);

            int [] label = new int[num*num];
            Arrays.fill(label, num*num-1);
            int [] announce = {Integer.parseInt(data[1]),Integer.parseInt(data[2])} ;
            String temp = null;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split("","");
                    int t0 = Integer.parseInt(temp2[0]);
                    int t1 = Integer.parseInt(temp2[1]);
                    //System.out.println(t0+"",""+t1);
                    label[(t0-1)*num+t1-1]= 0;
                    }
            //for (int i = 0; i < num; i++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[i*num+j]);  
            //   }
            //System.out.println();
            //}
            int index=0;
            for(int i = 0; i<num*num; i++){
              //自己沒有堵塞才值得看
              if(label[i]>0){
               //if邊界
               if(i<num|(i%num)==0){
                  //兩邊界 
                  if(i<num&(i%num)==0){
                    label[i]=index+1;
                    index=index+1;}
                  //僅上邊界看左
                  else if(i<num){
                      if(label[i-1]>0){label[i]=label[i-1];}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }
                  //僅左邊界看上
                  else {
                      if(label[i-num]>0){label[i]=label[i-num];}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }}
               //if 非邊界
               else{
                   //都不塞
                   if(label[i-num]>0&label[i-1]>0){
                       if(label[i-num]==label[i-1]){
                           label[i]=label[i-1];}
                       else{
                           union(label[i-num],label[i-1]);
                           label[i]=label[i-1];}
                   }
                   //單塞
                   else if(label[i-num]>0|label[i-1]>0){
                       if(label[i-num]>0){
                           label[i]=label[i-num];}
                       else{
                           label[i]=label[i-1];}
                   }
                   //都塞
                   else{
                       label[i]=index+1;
                       index=index+1;}
               }}
            //System.out.println();
            //System.out.println(index);
            //System.out.println();
            //for(int i = 0; i<num*num;i++){
            //    label[i]=root(label[i]);
            //}    
            //for (int k = 0; k < num; k++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[k*num+j]);  
            //   }
            //System.out.println();
            //}
            }
            System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));
            //System.out.println(80%7!=0);
        }
}}


@6dd08fe2640ea603ac1e0dda3f5287bf@"
"r03228006","7","0.98","125664","@7bd6a98c228b18dc6714caa011d3f06d@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
 //       public static boolean connected(int p, int q)
 //       {
 //           return root(p) == root(q);
 //       }
        
        public static void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (sz[i] < sz[j]) {id[i] = j; sz[j] += sz[i];}
            else               {id[j] = i; sz[i] += sz[j];} 
        }
        
   public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, ""input6.txt""
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            String [] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            //System.out.println(data);
            QuickUnionUF(num*num);

            int [] label = new int[num*num];
            Arrays.fill(label, num*num-1);
            int [] announce = {Integer.parseInt(data[1]),Integer.parseInt(data[2])} ;
            String temp = null;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split("","");
                    int t0 = Integer.parseInt(temp2[0]);
                    int t1 = Integer.parseInt(temp2[1]);
                    //System.out.println(t0+"",""+t1);
                    label[(t0-1)*num+t1-1]= 0;
                    }
            //for (int i = 0; i < num; i++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[i*num+j]);  
            //   }
            //System.out.println();
            //}
            int index=0;
            for(int i = 0; i<num*num; i++){
              //自己沒有堵塞才值得看
              if(label[i]>0){
               //if邊界
               if(i<num|(i%num)==0){
                  //兩邊界 
                  if(i<num&(i%num)==0){
                    label[i]=index+1;
                    index=index+1;}
                  //僅上邊界看左
                  else if(i<num){
                      if(label[i-1]>0){label[i]=label[i-1];}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }
                  //僅左邊界看上
                  else {
                      if(label[i-num]>0){label[i]=label[i-num];}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }}
               //if 非邊界
               else{
                   //都不塞
                   if(label[i-num]>0&label[i-1]>0){
                       if(label[i-num]==label[i-1]){
                           label[i]=label[i-1];}
                       else{
                           union(label[i-num],label[i-1]);
                           label[i]=label[i-1];}
                   }
                   //單塞
                   else if(label[i-num]>0|label[i-1]>0){
                       if(label[i-num]>0){
                           label[i]=label[i-num];}
                       else{
                           label[i]=label[i-1];}
                   }
                   //都塞
                   else{
                       label[i]=index+1;
                       index=index+1;}
               }}
            //System.out.println();
            //System.out.println(index);
            //System.out.println();
            //for(int i = 0; i<num*num;i++){
            //    label[i]=root(label[i]);
            //}    
            //for (int k = 0; k < num; k++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[k*num+j]);  
            //   }
            //System.out.println();
            //}
            }
            System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));
            //System.out.println(80%7!=0);
        }
}}


@7bd6a98c228b18dc6714caa011d3f06d@"
"r03228006","7","0.95","120224","@ac36f02a1574523175c744d664841851@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
 //       public static boolean connected(int p, int q)
 //       {
 //           return root(p) == root(q);
 //       }
        
        public static void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (sz[i] < sz[j]) {id[i] = j; sz[j] += sz[i];}
            else               {id[j] = i; sz[i] += sz[j];} 
        }
        
   public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, ""input6.txt""~8
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            String [] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            //System.out.println(data);
            QuickUnionUF(num*num);

            int [] label = new int[num*num];
            Arrays.fill(label, num*num-1);
            int [] announce = {Integer.parseInt(data[1]),Integer.parseInt(data[2])} ;
            String temp = null;
            int flag=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split("","");
                    int t0 = Integer.parseInt(temp2[0]);
                    int t1 = Integer.parseInt(temp2[1]);
                    //System.out.println(t0+"",""+t1);
                    label[(t0-1)*num+t1-1]= 0;
                    flag=flag+1;
                    }
            //for (int i = 0; i < num; i++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[i*num+j]);  
            //   }
            //System.out.println();
            //}
            int index=0;
            for(int i = 0; i<num*num; i++){
              //自己沒有堵塞才值得看
              if(label[i]>0){
               //if邊界
               if(i<num|(i%num)==0){
                  //兩邊界 
                  if(i<num&(i%num)==0){
                    label[i]=index+1;
                    index=index+1;}
                  //僅上邊界看左
                  else if(i<num){
                      if(label[i-1]>0){label[i]=label[i-1];}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }
                  //僅左邊界看上
                  else {
                      if(label[i-num]>0){label[i]=label[i-num];}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }}
               //if 非邊界
               else{
                   //都不塞
                   if(label[i-num]>0&label[i-1]>0){
                       if(label[i-num]==label[i-1]){
                           label[i]=label[i-1];}
                       else{
                           union(label[i-num],label[i-1]);
                           label[i]=label[i-1];}
                   }
                   //單塞
                   else if(label[i-num]>0|label[i-1]>0){
                       if(label[i-num]>0){
                           label[i]=label[i-num];}
                       else{
                           label[i]=label[i-1];}
                   }
                   //都塞
                   else{
                       label[i]=index+1;
                       index=index+1;}
               }}
            //System.out.println();
            //System.out.println(index);
            //System.out.println();
            //for(int i = 0; i<num*num;i++){
            //    label[i]=root(label[i]);
            //}    
            //for (int k = 0; k < num; k++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[k*num+j]);  
            //   }
            //System.out.println();
            //}
            }
            if(flag==0){
                Arrays.fill(id,1);
            }
            System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));
            //System.out.println(80%7!=0);
        }
}}


@ac36f02a1574523175c744d664841851@"
"r03228006","8","1","127024","@6602966c2b5df9ae0492e7ccd1eb20ae@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
 //       public static boolean connected(int p, int q)
 //       {
 //           return root(p) == root(q);
 //       }
        
        public static void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (sz[i] < sz[j]) {id[i] = j; sz[j] += sz[i];}
            else               {id[j] = i; sz[i] += sz[j];} 
        }
        
   public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, ""input6.txt""~8
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            String [] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            //System.out.println(data);
            QuickUnionUF(num*num);

            int [] label = new int[num*num];
            Arrays.fill(label, num*num-1);
            int [] announce = {Integer.parseInt(data[1]),Integer.parseInt(data[2])} ;
            String temp = null;
            int flag=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split("","");
                    int t0 = Integer.parseInt(temp2[0]);
                    int t1 = Integer.parseInt(temp2[1]);
                    //System.out.println(t0+"",""+t1);
                    label[(t0-1)*num+t1-1]= 0;
                    flag=flag+1;
                    }
            //for (int i = 0; i < num; i++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[i*num+j]);  
            //   }
            //System.out.println();
            //}
            int index=0;
            for(int i = 0; i<num*num; i++){
              //自己沒有堵塞才值得看
              if(label[i]>0){
               //if邊界
               if(i<num|(i%num)==0){
                  //兩邊界 
                  if(i<num&(i%num)==0){
                    label[i]=index+1;
                    index=index+1;}
                  //僅上邊界看左
                  else if(i<num){
                      if(label[i-1]>0){label[i]=label[i-1];
                      sz[label[i-1]]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }
                  //僅左邊界看上
                  else {
                      if(label[i-num]>0){label[i]=label[i-num];
                      sz[label[i-num]]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }}
               //if 非邊界
               else{
                   //都不塞
                   if(label[i-num]>0&label[i-1]>0){
                       if(label[i-num]==label[i-1]){
                           label[i]=label[i-1];
                           sz[label[i-num]]++;}
                       else{
                           union(label[i-num],label[i-1]);
                           label[i]=root(label[i-1]);}
                   }
                   //單塞
                   else if(label[i-num]>0|label[i-1]>0){
                       if(label[i-num]>0){
                           label[i]=label[i-num];
                           sz[label[i-num]]++;}
                       else{
                           label[i]=label[i-1];
                           sz[label[i-1]]++;}
                   }
                   //都塞
                   else{
                       label[i]=index+1;
                       index=index+1;}
               }}
            //System.out.println();
            //System.out.println(index);
            //System.out.println();
            }
            for(int ii = 0; ii<num*num;ii++){
                label[ii]=root(label[ii]);
            }    
            //for (int k = 0; k < num; k++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[k*num+j]);  
            //   }
            //System.out.println();
            //}
            if(flag==0){
                Arrays.fill(id,1);
            }
            System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));
            //System.out.println(80%7!=0);
        }
}}


@6602966c2b5df9ae0492e7ccd1eb20ae@"
"r03723070","8","1.04","139696","@d0c2e3d1194a7a50f2610dfc0daeef2a@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          if (data[x][y]!=0){
              data[x][y] = 0;
              countinput =+1;
          }
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =0;i<N+1;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=0;j<N+1;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       int [] fff = new int [2];
       for(int i =1;i<N+1;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       }
    }

@d0c2e3d1194a7a50f2610dfc0daeef2a@"
"r03228006","8","0.99","125680","@bc9be5510a42ef92847637e200fb515e@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
 //       public static boolean connected(int p, int q)
 //       {
 //           return root(p) == root(q);
 //       }
        
        public static void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (sz[i] < sz[j]) {id[i] = j; sz[j] += sz[i];}
            else               {id[j] = i; sz[i] += sz[j];} 
        }
        
   public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, ""input6.txt""~8
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            String [] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            //System.out.println(data);
            QuickUnionUF(num*num);

            int [] label = new int[num*num];
            Arrays.fill(label, num*num-1);
            int [] announce = {Integer.parseInt(data[1]),Integer.parseInt(data[2])} ;
            String temp = null;
            int flag=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split("","");
                    int t0 = Integer.parseInt(temp2[0]);
                    int t1 = Integer.parseInt(temp2[1]);
                    //System.out.println(t0+"",""+t1);
                    label[(t0-1)*num+t1-1]= 0;
                    flag=flag+1;
                    }
            //for (int i = 0; i < num; i++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[i*num+j]);  
            //   }
            //System.out.println();
            //}
            int index=0;
            for(int i = 0; i<num*num; i++){
              //自己沒有堵塞才值得看
              if(label[i]>0){
               //if邊界
               if(i<num|(i%num)==0){
                  //兩邊界 
                  if(i<num&(i%num)==0){
                    label[i]=index+1;
                    index=index+1;}
                  //僅上邊界看左
                  else if(i<num){
                      if(label[i-1]>0){label[i]=label[i-1];
                      sz[label[i-1]]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }
                  //僅左邊界看上
                  else {
                      if(label[i-num]>0){label[i]=label[i-num];
                      sz[label[i-num]]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }}
               //if 非邊界
               else{
                   //都不塞
                   if(label[i-num]>0&label[i-1]>0){
                       if(label[i-num]==label[i-1]){
                           label[i]=label[i-1];
                           sz[label[i-num]]++;}
                       else{
                           if(label[i-num]>label[i-1]){
                           union(label[i-1],label[i-num]);
                           label[i]=root(label[i-1]);}
                           else{
                            union(label[i-num],label[i-1]);
                           label[i]=root(label[i-1]);}
                       }
                   }
                   //單塞
                   else if(label[i-num]>0|label[i-1]>0){
                       if(label[i-num]>0){
                           label[i]=label[i-num];
                           sz[label[i-num]]++;}
                       else{
                           label[i]=label[i-1];
                           sz[label[i-1]]++;}
                   }
                   //都塞
                   else{
                       label[i]=index+1;
                       index=index+1;}
               }}
            //System.out.println();
            //System.out.println(index);
            //System.out.println();
            }
            for(int ii = 0; ii<num*num;ii++){
                label[ii]=root(label[ii]);
            }    
            //for (int k = 0; k < num; k++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.printf(String.valueOf(label[k*num+j])+""\t"");  
            //   }
            //System.out.println();
            //}
            if(flag==0){
                Arrays.fill(id,1);
            }
            System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));
            //System.out.println(80%7!=0);
        }
}}


@bc9be5510a42ef92847637e200fb515e@"
"r03228006","8","0.95","126624","@fb73ab566f40b0f0c88d243489b91e80@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
 //       public static boolean connected(int p, int q)
 //       {
 //           return root(p) == root(q);
 //       }
        
        public static void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (sz[i] < sz[j]) {id[i] = j; sz[j] += sz[i];}
            else               {id[j] = i; sz[i] += sz[j];} 
        }
        
   public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, ""input6.txt""~8
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            String [] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            //System.out.println(data);
            QuickUnionUF(num*num);

            int [] label = new int[num*num];
            Arrays.fill(label, num*num-1);
            int [] announce = {Integer.parseInt(data[1]),Integer.parseInt(data[2])} ;
            String temp = null;
            int flag=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split("","");
                    int t0 = Integer.parseInt(temp2[0]);
                    int t1 = Integer.parseInt(temp2[1]);
                    //System.out.println(t0+"",""+t1);
                    label[(t0-1)*num+t1-1]= 0;
                    flag=flag+1;
                    }
            //for (int i = 0; i < num; i++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[i*num+j]);  
            //   }
            //System.out.println();
            //}
            int index=0;
            for(int i = 0; i<num*num; i++){
              //自己沒有堵塞才值得看
              if(label[i]>0){
               //if邊界
               if(i<num|(i%num)==0){
                  //兩邊界 
                  if(i<num&(i%num)==0){
                    label[i]=index+1;
                    index=index+1;}
                  //僅上邊界看左
                  else if(i<num){
                      if(label[i-1]>0){label[i]=label[i-1];
                      sz[root(label[i-1])]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }
                  //僅左邊界看上
                  else {
                      if(label[i-num]>0){label[i]=label[i-num];
                      sz[root(label[i-num])]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }}
               //if 非邊界
               else{
                   //都不塞
                   if(label[i-num]>0&label[i-1]>0){
                       if(label[i-num]==label[i-1]){
                           label[i]=label[i-1];
                           sz[root(label[i-num])]++;}
                       else{
                           if(label[i-num]>label[i-1]){
                           union(label[i-1],label[i-num]);
                           label[i]=root(label[i-1]);}
                           else{
                           union(label[i-num],label[i-1]);
                           label[i]=root(label[i-1]);}
                       }
                   }
                   //單塞
                   else if(label[i-num]>0|label[i-1]>0){
                       if(label[i-num]>0){
                           label[i]=label[i-num];
                           sz[root(label[i-num])]++;}
                       else{
                           label[i]=label[i-1];
                           sz[root(label[i-1])]++;}
                   }
                   //都塞
                   else{
                       label[i]=index+1;
                       index=index+1;}
               }}
            //System.out.println();
            //System.out.println(index);
            //System.out.println();
            }
            //for(int ii = 0; ii<num*num;ii++){
            //    label[ii]=root(label[ii]);
            //}    
            //for (int k = 0; k < num; k++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.printf(String.valueOf(label[k*num+j])+""\t"");  
            //   }
            //System.out.println();
            //}
            if(flag==0){
                Arrays.fill(id,1);
            }
            System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));
            //System.out.println(80%7!=0);
        }
}}


@fb73ab566f40b0f0c88d243489b91e80@"
"r03228006","8","0.99","126048","@abf7962be80c02d83be1b32dfbac6b1f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
 //       public static boolean connected(int p, int q)
 //       {
 //           return root(p) == root(q);
 //       }
        
        public static void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            if (sz[i] < sz[j]) {id[i] = j; sz[j] += sz[i];}
            else               {id[j] = i; sz[i] += sz[j];} 
        }
        
   public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, ""input6.txt""~8
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            String [] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            //System.out.println(data);
            QuickUnionUF(num*num);

            int [] label = new int[num*num];
            Arrays.fill(label, num*num-1);
            int [] announce = {Integer.parseInt(data[1]),Integer.parseInt(data[2])} ;
            String temp = null;
            int flag=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split("","");
                    int t0 = Integer.parseInt(temp2[0]);
                    int t1 = Integer.parseInt(temp2[1]);
                    //System.out.println(t0+"",""+t1);
                    label[(t0-1)*num+t1-1]= 0;
                    flag=flag+1;
                    }
            //for (int i = 0; i < num; i++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[i*num+j]);  
            //   }
            //System.out.println();
            //}
            int index=0;
            for(int i = 0; i<num*num; i++){
              //自己沒有堵塞才值得看
              if(label[i]>0){
               //if邊界
               if(i<num|(i%num)==0){
                  //兩邊界 
                  if(i<num&(i%num)==0){
                    label[i]=index+1;
                    index=index+1;}
                  //僅上邊界看左
                  else if(i<num){
                      if(label[i-1]>0){label[i]=label[i-1];
                      sz[root(label[i-1])]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }
                  //僅左邊界看上
                  else {
                      if(label[i-num]>0){label[i]=label[i-num];
                      sz[root(label[i-num])]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }}
               //if 非邊界
               else{
                   //都不塞
                   if(label[i-num]>0&label[i-1]>0){
                       if(label[i-num]==label[i-1]){
                           label[i]=label[i-1];
                           sz[root(label[i-num])]++;}
                       else{
                           if(label[i-num]>label[i-1]){
                           union(label[i-1],label[i-num]);
                           label[i]=root(label[i-1]);
                           sz[root(label[i-1])]++;}
                           else{
                           union(label[i-num],label[i-1]);
                           label[i]=root(label[i-num]);
                           sz[root(label[i-num])]++;}
                       }
                   }
                   //單塞
                   else if(label[i-num]>0|label[i-1]>0){
                       if(label[i-num]>0){
                           label[i]=label[i-num];
                           sz[root(label[i-num])]++;}
                       else{
                           label[i]=label[i-1];
                           sz[root(label[i-1])]++;}
                   }
                   //都塞
                   else{
                       label[i]=index+1;
                       index=index+1;}
               }}
            //System.out.println();
            //System.out.println(index);
            //System.out.println();
            }
            //for(int ii = 0; ii<num*num;ii++){
            //    label[ii]=root(label[ii]);
            //}    
            //for (int k = 0; k < num; k++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.printf(String.valueOf(label[k*num+j])+""\t"");  
            //   }
            //System.out.println();
            //}
            if(flag==0){
                Arrays.fill(id,1);
            }
            System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));
            //System.out.println(0%7);
        }
}}


@abf7962be80c02d83be1b32dfbac6b1f@"
"r03228006","10","0.1","125008","@2f30a2d4cc717dbc1f0586d16268e87c@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
    private static int[] id;
    private static int[] sz;
    //void indicate no return.
    public static void QuickUnionUF(int N)
    {
        id = new int[N];
        sz = new int[N];
        for(int i =0; i<N ; i++){
            id[i]=i; 
            sz[i]=1;
        }
    }
    
        private static int root(int i)
    {
        while (i != id[i]) 
            i = id[id[i]];
            return i;
        }
 //       public static boolean connected(int p, int q)
 //       {
 //           return root(p) == root(q);
 //       }
        
        public static void union(int p, int q) {
            //i(p)優先保存
            int i = root(p);
            int j = root(q);
            if(i == j) return;
            id[j] = i; sz[i] += sz[j]; 
        }
        
   public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style args[0]
        //args[0] is  just for juged system, ""input6.txt""~8
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            // read first line number as vector
            String [] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            //System.out.println(data);
            QuickUnionUF(num*num);

            int [] label = new int[num*num];
            Arrays.fill(label, num*num-1);
            int [] announce = {Integer.parseInt(data[1]),Integer.parseInt(data[2])} ;
            String temp = null;
            int flag=0;
            while ((temp = br.readLine())!=null) {
                    String[] temp2 = temp.split("","");
                    int t0 = Integer.parseInt(temp2[0]);
                    int t1 = Integer.parseInt(temp2[1]);
                    //System.out.println(t0+"",""+t1);
                    label[(t0-1)*num+t1-1]= 0;
                    flag=flag+1;
                    }
            //for (int i = 0; i < num; i++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.println(label[i*num+j]);  
            //   }
            //System.out.println();
            //}
            int index=0;
            for(int i = 0; i<num*num; i++){
              //自己沒有堵塞才值得看
              if(label[i]>0){
               //if邊界
               if(i<num|(i%num)==0){
                  //兩邊界 
                  if(i<num&(i%num)==0){
                    label[i]=index+1;
                    index=index+1;}
                  //僅上邊界看左
                  else if(i<num){
                      if(label[i-1]>0){label[i]=label[i-1];
                      sz[root(label[i-1])]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }
                  //僅左邊界看上
                  else {
                      if(label[i-num]>0){label[i]=label[i-num];
                      sz[root(label[i-num])]++;}
                      else {                    
                          label[i]=index+1;
                          index=index+1;}
                  }}
               //if 非邊界
               else{
                   //都不塞
                   if(label[i-num]>0&label[i-1]>0){
                       if(label[i-num]==label[i-1]){
                           label[i]=label[i-1];
                           sz[root(label[i-num])]++;}
                       else{
                           if(label[i-num]>label[i-1]){
                           union(label[i-1],label[i-num]);
                           label[i]=root(label[i-1]);
                           sz[root(label[i-1])]++;}
                           else{
                           union(label[i-num],label[i-1]);
                           label[i]=root(label[i-num]);
                           sz[root(label[i-num])]++;}
                       }
                   }
                   //單塞
                   else if(label[i-num]>0|label[i-1]>0){
                       if(label[i-num]>0){
                           label[i]=label[i-num];
                           sz[root(label[i-num])]++;}
                       else{
                           label[i]=label[i-1];
                           sz[root(label[i-1])]++;}
                   }
                   //都塞
                   else{
                       label[i]=index+1;
                       index=index+1;}
               }}
            //System.out.println();
            //System.out.println(index);
            //System.out.println();
            }
            for(int ii = 0; ii<num*num;ii++){
                label[ii]=root(label[ii]);
            }    
            //for (int k = 0; k < num; k++) {
            //    for (int j = 0; j < num; j++){
            //    System.out.printf(String.valueOf(label[k*num+j])+""\t"");  
            //   }
            //System.out.println();
            //}
            if(flag==0){
                Arrays.fill(id,1);
            }
            System.out.println(root(label[num*(announce[0]-1)+announce[1]-1]));
            //System.out.println(announce[0]+"" ""+announce[1]);
        }
}}


@2f30a2d4cc717dbc1f0586d16268e87c@"
"b02611023","10","0.1","127056","@ac63d36fd38b9d7225b8af31b6bc8482@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {

    public static int[] sec_pass;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);
            int t_col = Integer.parseInt(data[2]);
            int root = 0;
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];
            String line;
            String[] lines = new String[2];
            sec_pass = new int[num * num + 1];

            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {
                    cc[num * (i - 1) + (j - 1)] = num * (i - 1) + (j - 1);
                    matrix[i][j] = 1;
                }
            }

            for (int i = 0; i < num * num + 1; i++) {
                sec_pass[i] = i;
            }

            line = br.readLine();
            while (line != null) {
                lines = line.split("","");
                int row = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num * (row - 1) + (col - 1)] = 0;
                matrix[row][col] = 0;
                line = br.readLine();
            }

            int count = 1;

            if (matrix[t_row][t_col] != 0) {

                for (int i = 1; i <= num; i++) {

                    for (int j = 1; j <= num; j++) {

                        int label = num * (i - 1) + (j - 1);

                        if (matrix[i][j] == 0) {
                            continue;
                        } else if ((matrix[i][j] - matrix[i - 1][j] == 0) && (matrix[i][j] - matrix[i][j - 1] == 0)) {
                            if (cc[num * (i - 2) + (j - 1)] < cc[num * (i - 1) + (j - 2)]) {
                                cc[label] = cc[num * (i - 2) + (j - 1)];
                                union(cc[num * (i - 1) + (j - 2)], cc[label]);
                            } else if (cc[num * (i - 2) + (j - 1)] > cc[num * (i - 1) + (j - 2)]) {
                                cc[label] = cc[num * (i - 1) + (j - 2)];
                                union(cc[num * (i - 2) + (j - 1)], cc[label]);
                            } else {
                                cc[label] = cc[num * (i - 2) + (j - 1)];
                            }
                        } else if ((matrix[i][j] - matrix[i - 1][j] == 1) && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                            cc[label] = count;
                            count++;
                        } else if (matrix[i][j] - matrix[i - 1][j] == 0 && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                            cc[label] = cc[num * (i - 2) + (j - 1)];
                        } else {
                            cc[label] = cc[num * (i - 1) + (j - 2)];
                        }

                    }
                }

                for (int i = 0; i < num * num; i++) {
                    if (cc[i] != 0) {
                        root = find(cc[i]);
                        cc[i] = root;
                    }
                }

            }

            System.out.println(cc[num * (t_row - 1) + (t_col - 1)]);
            /*for(int i = 0; i < num*num; i++){
             System.out.println(sec_pass[i]);
             }*/
            /*for (int i = 1; i < num + 1; i++) {
             for (int j = 1; j < num + 1; j++) {
             System.out.print(cc[num * (i - 1) + (j - 1)] + "" "");
             }
             System.out.println();

             }*/

        }
    }

    public static int find(int p) {
        while (p != sec_pass[p]) {
            p = sec_pass[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        sec_pass[rootP] = rootQ;
    }

}

@ac63d36fd38b9d7225b8af31b6bc8482@"
"r04631004","9","1.1","143840","@fdff5d968ace0ea9d2a0f8d698ab641d@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);

                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }
//                for (i = 0; i < num; i++) {  //input grid
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(grid[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(grid[i][j]);
//                            }
//                        } else {
//                            System.out.print(grid[i][j] + "" "");
//                        }
//                    }
//                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (label[m][l] == storeunionpoint.biglabel[i][j]) {
                                        label[m][l] = storeunionpoint.smalllabel[i][j];
                                    }
                                }
                            }
                        }
                    }
                }
//                for (i = 0; i < num; i++) {  //output final result
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            System.out.println(label[i][j]);
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(label[targetcoord[0]-1][targetcoord[1]-1]);
            }
        }
    }

}
@fdff5d968ace0ea9d2a0f8d698ab641d@"
"r04631004","9","1.21","149408","@0dfaeeb59da8431469d55ec6593ba5ab@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);

                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }
//                for (i = 0; i < num; i++) {  //input grid
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(grid[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(grid[i][j]);
//                            }
//                        } else {
//                            System.out.print(grid[i][j] + "" "");
//                        }
//                    }
//                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                UP templabel=new UP(num,num);
                templabel.checknum=label.clone();
                
                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (templabel.checknum[m][l] == storeunionpoint.biglabel[i][j]) {
                                            label[m][l] = storeunionpoint.smalllabel[i][j];
                                            templabel.biglabel[m][l]=storeunionpoint.biglabel[i][j];
                                            templabel.smalllabel[m][l]=storeunionpoint.smalllabel[i][j];
                                    }
                                }
                            }
                        }
                    }
                }
                
                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number again
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (templabel.biglabel[m][l] == storeunionpoint.biglabel[i][j] && templabel.smalllabel[m][l]>storeunionpoint.smalllabel[i][j]) {
                                            label[m][l] = storeunionpoint.smalllabel[i][j];
                                    }
                                    else if (templabel.smalllabel[m][l] == storeunionpoint.biglabel[i][j]) {
                                            label[m][l] = storeunionpoint.smalllabel[i][j];
                                    }
                                }
                            }
                        }
                    }
                }
//                for (i = 0; i < num; i++) {  //output final result
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            System.out.println(label[i][j]);
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(label[targetcoord[0]-1][targetcoord[1]-1]);
            }
        }
    }

}
@0dfaeeb59da8431469d55ec6593ba5ab@"
"r03723070","8","1.3","134352","@371ac4baeee060de92a2219a6d93c313@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          //if (data[x][y]!=0){
              data[x][y] = 0;
              //countinput =+1;
          //}
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          //if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              //break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =0;i<N+1;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=0;j<N+1;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       for(int i =1;i<N*N/2+1;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    

@371ac4baeee060de92a2219a6d93c313@"
"r03723070","9","1.25","136800","@925f7c1e683f91f43786d7602af276ff@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          //if (data[x][y]!=0){
              data[x][y] = 0;
              //countinput =+1;
          //}
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          //if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              //break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =0;i<N*N/2+1;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=0;j<N*N/2+1;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       for(int i =1;i<N*N/2+1;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    

@925f7c1e683f91f43786d7602af276ff@"
"r03723070","9","1.1","136096","@3bba905e2d44f813db559ff2e86030ba@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          //if (data[x][y]!=0){
              data[x][y] = 0;
              //countinput =+1;
          //}
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          //if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              //break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =0;i<count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=0;j<count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       for(int i =1;i<count;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    

@3bba905e2d44f813db559ff2e86030ba@"
"r04631004","9","1.15","153856","@cd57275551a9175d58931070106e903c@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }
                
                UP templabel = new UP(num, num);
                templabel.checknum = label.clone();

                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (templabel.checknum[m][l] == storeunionpoint.biglabel[i][j]) {
                                        label[m][l] = storeunionpoint.smalllabel[i][j];
                                        templabel.biglabel[m][l] = storeunionpoint.biglabel[i][j];
                                        templabel.smalllabel[m][l] = storeunionpoint.smalllabel[i][j];
                                    }
                                }
                            }
                            //storeunionpoint.checknum[i][j] = 0;
                        }
                    }
                }

                int temppoint = 0;
                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number again
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (templabel.biglabel[m][l] == storeunionpoint.smalllabel[i][j]) {
                                        temppoint = templabel.smalllabel[m][l];
                                        break;
                                    }
                                }
                            }
                            if (temppoint != 0) {
                                for (int m = 0; m < num; m++) {
                                    for (int l = 0; l < num; l++) {
                                        if (label[m][l] == storeunionpoint.smalllabel[i][j]) {
                                            label[m][l] = temppoint;
                                        }
                                    }
                                }
                            }
                            temppoint = 0;
                        }
                    }
                }
                System.out.println(label[targetcoord[0] - 1][targetcoord[1] - 1]);
            }
        }
    }

}
@cd57275551a9175d58931070106e903c@"
"r03723070","0","1.05","142544","@90cea43a573ae4fc5a5ec1b3c536a40e@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          //if (data[x][y]!=0){
              data[x][y] = 0;
              //countinput =+1;
          //}
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          //if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              //break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }
       // modify it into the correct group
       //int [] fff = new int [2];
       for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    

@90cea43a573ae4fc5a5ec1b3c536a40e@"
"r03723070","0","0.92","127904","@292c36766eca1dfafcf3974a4d48ed8b@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          //if (data[x][y]!=0){
              data[x][y] = 0;
              //countinput =+1;
          //}
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          //if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              //break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }/*
       // modify it into the correct group
       //int [] fff = new int [2];
       for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    

@292c36766eca1dfafcf3974a4d48ed8b@"
"r03723070","8","1","142768","@e0caaadc055e5e503c5f28a3dddb4325@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          //if (data[x][y]!=0){
              data[x][y] = 0;
              //countinput =+1;
          //}
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          //if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              //break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    

@e0caaadc055e5e503c5f28a3dddb4325@"
"r03723070","9","1.12","146608","@f57a58713ec9b846ab2b11c42bdb804f@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          //if (data[x][y]!=0){
              data[x][y] = 0;
              //countinput =+1;
          //}
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          //if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              //break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    

@f57a58713ec9b846ab2b11c42bdb804f@"
"r03723070","3","1.01","137840","@bc7350f446ded7a1841d27aca63490e0@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          //if (data[x][y]!=0){
              data[x][y] = 0;
              //countinput =+1;
          //}
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          //if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              //break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       /*for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch; 
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }*/
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
       //find the final result
       for(int i =1;i<=count;i++){
           if(data[ans[0]][ans[1]] == i)
           data[ans[0]][ans[1]] = connect[i];
       }
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
        }*/
       }
       }
    

@bc7350f446ded7a1841d27aca63490e0@"
"r03723070","6","1.02","133776","@fb8c716582130da9b3a63baa3e964ead@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
               //if(j==N)
               //System.out.printf(""%d\n"", data[i][j]);
               //if(j==N&&i==N)
                   //System.out.printf(""\n"");
               //else
               //System.out.printf(""%d"", data[i][j]);
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
  
       int countinput = 0;
       //System.out.printf(""x is %d\n"",counttest);
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
          //System.out.printf(""x is %d, y is %d \n"",x,y);
          //if (data[x][y]!=0){
              data[x][y] = 0;
              //countinput =+1;
          //}
          data0 = br.readLine();
          //System.out.printf(""data[%d][%d] is %d\n"",x,y,data[x][y]);
          //if(countinput == N*N){
              //System.out.printf(""x is %d y is %d\n"",x,y);
              //break;}
          
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i-1,j,data[i-1][j]);
                       //System.out.printf(""neighbor open data[%d][%d] is %d\n"",i,j-1,data[i][j-1]);
                       //System.out.printf(""new open data[%d][%d] is %d\n"",i,j,data[i][j]);
                       //System.out.printf(""new open data[1][1] is %d\n\n"",data[1][1]);
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                           //data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""connect data[%d,%d] is %d\n"",i,j,data[i][j]);
                       // record the connect point
 
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                       
                   }
                   
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       /*for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch; 
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }   
       }*/
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
       //find the final result
       /*for(int i =1;i<=count;i++){
           if(data[ans[0]][ans[1]] == i && connect[i] !=0)
           data[ans[0]][ans[1]] = connect[i];
       }*/
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
        }*/
       }
       }
    

@fb8c716582130da9b3a63baa3e964ead@"
"r04631004","6","1.22","155296","@2529863f6c43fa1979dc2d6dbaf1126e@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }
//                for (i = 0; i < num; i++) {  //input grid
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(grid[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(grid[i][j]);
//                            }
//                        } else {
//                            System.out.print(grid[i][j] + "" "");
//                        }
//                    }
//                }
//
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                UP templabel = new UP(num, num);
                templabel.checknum = label.clone();

                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (templabel.checknum[m][l] == storeunionpoint.biglabel[i][j]) {
                                        label[m][l] = storeunionpoint.smalllabel[i][j];
                                        templabel.biglabel[m][l] = storeunionpoint.biglabel[i][j];
                                        templabel.smalllabel[m][l] = storeunionpoint.smalllabel[i][j];
                                    }
                                }
                            }
                            //storeunionpoint.checknum[i][j] = 0;
                        }
                    }
                }

                int temppoint = 0;
                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number again
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (templabel.biglabel[m][l] == storeunionpoint.smalllabel[i][j]) {
                                        temppoint = templabel.smalllabel[m][l];
                                        break;
                                    }
                                }
                            }
                            if (temppoint != 0) {
                                for (int m = 0; m < num; m++) {
                                    for (int l = 0; l < num; l++) {
                                        if (label[m][l] == storeunionpoint.smalllabel[i][j]) {
                                            label[m][l] = temppoint;
                                        }
                                    }
                                }
                            }
                            temppoint = 0;
                        }
                    }
                }

                int[][] finallabel = new int[num][num];
                finallabel = label.clone();
                int tempcount = 1;
                int x = 0;
                int changenum = 0;
                for (i = 0; i < num; i++) {  //rearrange the num of label
                    for (j = 0; j < num; j++) {
                        if (finallabel[i][j] >= tempcount) {
                            if (finallabel[i][j] == tempcount) {
                                tempcount++;
                            } else {
                                changenum=finallabel[i][j];
                                for (int m = 0; m < num; m++) {
                                    for (int l = 0; l < num; l++) {
                                        if (finallabel[m][l] == changenum) {
                                            finallabel[m][l] = tempcount;
                                        }
                                    }
                                }
                                tempcount++;
                            }
                        }
                    }
                }

//                for (i = 0; i < num; i++) {  //output final result
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            System.out.println(label[i][j]);
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(label[targetcoord[0] - 1][targetcoord[1] - 1]);
            }
        }
    }

}

@2529863f6c43fa1979dc2d6dbaf1126e@"
"r03723070","9","1.04","136048","@f2fe4523f9605681a9787e11ac3ebc53@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = 0;
          data0 = br.readLine();
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           data[i][j] = data[i][j-1];
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   }
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      int p = Math.max(data[i][j-1],data[i-1][j]);
                      int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       /*for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }  
       }*/ 
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
       for(int i =1;i<=count;i++){
           if(data[ans[0]][ans[1]] == i && connect[i] !=0)
           data[ans[0]][ans[1]] = connect[i];
           if(data[ans[0]][ans[1]] == i && connect[i] ==0)
           data[ans[0]][ans[1]] = data[ans[0]][ans[1]] ;
       }
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    
@f2fe4523f9605681a9787e11ac3ebc53@"
"r04631004","9","1.13","149120","@6ee0b6f50f6980033981b9ea1c12413d@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }
//                for (i = 0; i < num; i++) {  //input grid
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(grid[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(grid[i][j]);
//                            }
//                        } else {
//                            System.out.print(grid[i][j] + "" "");
//                        }
//                    }
//                }
//
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                UP templabel = new UP(num, num);
                templabel.checknum = label.clone();

                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (templabel.checknum[m][l] == storeunionpoint.biglabel[i][j]) {
                                        label[m][l] = storeunionpoint.smalllabel[i][j];
                                        templabel.biglabel[m][l] = storeunionpoint.biglabel[i][j];
                                        templabel.smalllabel[m][l] = storeunionpoint.smalllabel[i][j];
                                    }
                                }
                            }
                            storeunionpoint.checknum[i][j] = 0;
                        }
                    }
                }

                int temppoint = 0;
                int loopend=0;
                int x=0;
                while (loopend!=1) {
                    for (i = 0; i < num; i++) {  //change bigger label number to smaller label number again
                        for (j = 0; j < num; j++) {
                            if (storeunionpoint.checknum[i][j] == 1) {
                                for (int m = 0; m < num; m++) {
                                    for (int l = 0; l < num; l++) {
                                        if (templabel.biglabel[m][l] == storeunionpoint.smalllabel[i][j]) {
                                            temppoint = templabel.smalllabel[m][l];
                                            break;
                                        }
                                    }
                                }
                                if (temppoint != 0) {
                                    for (int m = 0; m < num; m++) {
                                        for (int l = 0; l < num; l++) {
                                            if (label[m][l] == storeunionpoint.smalllabel[i][j]) {
                                                label[m][l] = temppoint;
                                            }
                                        }
                                    }
                                }
                                temppoint = 0;
                                storeunionpoint.checknum[i][j] = 0;
                            }
                        }
                    }
                    for (i = 0; i < num; i++) {  //change bigger label number to smaller label number again
                        for (j = 0; j < num; j++) 
                        {
                            if(storeunionpoint.checknum[i][j]==1)
                            {
                                x=1;
                                break;
                            }
                        }
                        if(x==0)
                            loopend=1;
                        x=0;
                    }
                }

//                for (i = 0; i < num; i++) {  //output final result
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            System.out.println(label[i][j]);
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(label[targetcoord[0] - 1][targetcoord[1] - 1]);
            }
        }
    }

}

@6ee0b6f50f6980033981b9ea1c12413d@"
"r04631004","9","1.16","148832","@d4a80bacf54fa45ebaeb67523f3e8b83@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }
//                for (i = 0; i < num; i++) {  //input grid
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(grid[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(grid[i][j]);
//                            }
//                        } else {
//                            System.out.print(grid[i][j] + "" "");
//                        }
//                    }
//                }
//
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                UP templabel = new UP(num, num);
                templabel.checknum = label.clone();

                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (templabel.checknum[m][l] == storeunionpoint.biglabel[i][j]) {
                                        label[m][l] = storeunionpoint.smalllabel[i][j];
                                        templabel.checknum[m][l]=storeunionpoint.smalllabel[i][j];
                                        templabel.biglabel[m][l] = storeunionpoint.biglabel[i][j];
                                        templabel.smalllabel[m][l] = storeunionpoint.smalllabel[i][j];
                                    }
                                }
                            }
                            storeunionpoint.checknum[i][j] = 0;
                        }
                    }
                }

//                                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                                
                int temppoint = 0;
                int loopend=0;
                int x=0;
                while (loopend!=1) {
                    for (i = 0; i < num; i++) {  //change bigger label number to smaller label number again
                        for (j = 0; j < num; j++) {
                            if (storeunionpoint.checknum[i][j] == 1) {
                                for (int m = 0; m < num; m++) {
                                    for (int l = 0; l < num; l++) {
                                        if (templabel.biglabel[m][l] == storeunionpoint.smalllabel[i][j]) {
                                            temppoint = templabel.smalllabel[m][l];
                                            break;
                                        }
                                    }
                                }
                                if (temppoint != 0) {
                                    for (int m = 0; m < num; m++) {
                                        for (int l = 0; l < num; l++) {
                                            if (label[m][l] == storeunionpoint.smalllabel[i][j]) {
                                                label[m][l] = temppoint;
                                            }
                                        }
                                    }
                                }
                                temppoint = 0;
                                storeunionpoint.checknum[i][j] = 0;
                            }
                        }
                    }
                    for (i = 0; i < num; i++) {  //change bigger label number to smaller label number again
                        for (j = 0; j < num; j++) 
                        {
                            if(storeunionpoint.checknum[i][j]==1)
                            {
                                x=1;
                                break;
                            }
                        }
                        if(x==0)
                            loopend=1;
                        x=0;
                    }
                }

//                for (i = 0; i < num; i++) {  //output final result
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            System.out.println(label[i][j]);
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(label[targetcoord[0] - 1][targetcoord[1] - 1]);
            }
        }
    }

}

@d4a80bacf54fa45ebaeb67523f3e8b83@"
"r04631004","9","1.14","145520","@ba59bc6ccdde3a9cfb543ab0a882d149@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }
//                for (i = 0; i < num; i++) {  //input grid
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(grid[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(grid[i][j]);
//                            }
//                        } else {
//                            System.out.print(grid[i][j] + "" "");
//                        }
//                    }
//                }
//
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                UP templabel = new UP(num, num);
                templabel.checknum = label.clone();
                int tempc=0;

                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            for (int m = 0; m < num; m++) {
                                for (int l = 0; l < num; l++) {
                                    if (templabel.checknum[m][l] == storeunionpoint.biglabel[i][j]) {
                                        if(label[m][l]<storeunionpoint.smalllabel[i][j])
                                        {
                                            tempc=storeunionpoint.smalllabel[i][j];
                                            storeunionpoint.smalllabel[i][j]=label[m][l];
                                            for(int o=0;o<num;o++)
                                                for(int p=0;p<num;p++)
                                                {
                                                    if(label[o][p]==tempc)
                                                        label[o][p]=storeunionpoint.smalllabel[i][j];
                                                    if(o==m && p==l)
                                                    {
                                                        o=num;
                                                        p=num;
                                                    }
                                                }
                                        }
                                        else
                                            label[m][l]=storeunionpoint.smalllabel[i][j];
                                        
                                        templabel.biglabel[m][l] = storeunionpoint.biglabel[i][j];
                                        templabel.smalllabel[m][l] = storeunionpoint.smalllabel[i][j];
                                    }
                                }
                            }
                            //storeunionpoint.checknum[i][j] = 0;
                        }
                    }
                }

//                                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                                
//                int temppoint = 0;
//                int loopend=0;
//                int x=0;
//                while (loopend!=1) {
//                    for (i = 0; i < num; i++) {  //change bigger label number to smaller label number again
//                        for (j = 0; j < num; j++) {
//                            if (storeunionpoint.checknum[i][j] == 1) {
//                                for (int m = 0; m < num; m++) {
//                                    for (int l = 0; l < num; l++) {
//                                        if (templabel.biglabel[m][l] == storeunionpoint.smalllabel[i][j]) {
//                                            temppoint = templabel.smalllabel[m][l];
//                                            break;
//                                        }
//                                    }
//                                }
//                                if (temppoint != 0) {
//                                    for (int m = 0; m < num; m++) {
//                                        for (int l = 0; l < num; l++) {
//                                            if (label[m][l] == storeunionpoint.smalllabel[i][j]) {
//                                                label[m][l] = temppoint;
//                                                storeunionpoint.checknum[i][j] = 0;
//                                            }
//                                        }
//                                    }
//                                }
//                                else
//                                {
//                                    storeunionpoint.checknum[i][j] = 0;
//                                }
//                                temppoint = 0;
//                                
//                            }
//                        }
//                    }
//                    for (i = 0; i < num; i++) {  //change bigger label number to smaller label number again
//                        for (j = 0; j < num; j++) 
//                        {
//                            if(storeunionpoint.checknum[i][j]==1)
//                            {
//                                x=1;
//                                break;
//                            }
//                        }
//                        if(x==0)
//                            loopend=1;
//                        x=0;
//                    }
//                }

//                for (i = 0; i < num; i++) {  //output final result
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            System.out.println(label[i][j]);
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(label[targetcoord[0] - 1][targetcoord[1] - 1]);
            }
        }
    }

}

@ba59bc6ccdde3a9cfb543ab0a882d149@"
"b03611035","9","1.91","139248","@4d2046e108a771c61e096de1c56a3f28@/*
用JAVA寫出
http://aishack.in/tutorials/labelling-connected-components-example/

1.第一排第一個數字為幾階方陣，第二三個為指定座標
2.再來的數字都代表黑塊
3.給的黑塊不會超出方陣，但是有可能不給
4.回傳指定座標的Label，若為黑塊則傳0

* @author winiel559c
 */
import java.io.FileReader;
import java.io.BufferedReader;


public class LabelCC {
    public static void main(String[] args) throws Exception {
           // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0] ))){
            //IC for initial condition which is given by the first row
            String IC[]=new String[3];
            IC=br.readLine().split("","");
            int order=Integer.parseInt(IC[0]);
           // int x=Integer.parseInt(IC[1]);
            //int y=Integer.parseInt(IC[2]);
            //matrix called clo for blocked sites
            String clo[][]=new String[order*order][2];            
            
            //N-N Grid called opcl，多創一圈待會好處理
            int opcl[][]=new int[order+2][order+2];            
            for(int i=1;i<=order;i++){
                for(int j=1;j<=order;j++){
                    opcl[i][j]=-1;
                }
            }
            
            //New UF object
            UF gg=new UF(order*order);
            
            //read the assigned blocked sites
            String[] readd;
            int a=0;
            while(br.ready()){
                readd=br.readLine().split("","");
                clo[a][0]=readd[0];
                clo[a][1]=readd[1];
                a++;
            }
            //共有a組座標<我剛剛發現的，不設count就是爽
            
            //block the assigned blocked sites
           for(int i=0;i<a;i++){
               int row=Integer.parseInt(clo[i][0]);
               int column=Integer.parseInt(clo[i][1]);
               opcl[row][column]=0;
           }
                              
          //Start our algorithm although I don't even understand it.
           int label=1;
               //Step 1
           for(int row=1;row<=order;row++){
               for(int column=1;column<=order;column++){
                   //if blocked, don't do anything
                   if(opcl[row][column]==0)
                       ;
                   //if only up is labeled
                   else if(opcl[row-1][column]!=0&&opcl[row][column-1]==0){
                       opcl[row][column]=opcl[row-1][column];
                       gg.union((row-2)*order+column-1,(row-1)*order+column-1);
                   }
                   //if only left is labeled
                   else if(opcl[row][column-1]!=0&&opcl[row-1][column]==0){
                       opcl[row][column]=opcl[row][column-1];
                       gg.union((row-1)*order+column-2,(row-1)*order+column-1);                      
                   }
                   //if both up and left are labeled
                   else if(opcl[row][column-1]!=0&&opcl[row-1][column]!=0){
                       opcl[row][column]=opcl[row][column-1];
                       //檢查左跟上的root，取小的自己連過去，把另一個也連過去<<其實可以不用，反正下面還要再喬一次
                       //左小
                            if(gg.find((row-1)*order+column-2)<=(gg.find((row-2)*order+column-1))){
                                 gg.union((row-1)*order+column-2,(row-1)*order+column-1);  
                                 gg.union((row-1)*order+column-1,(row-2)*order+column-1);
                            }
                       //上小
                            else if(gg.find((row-1)*order+column-2)>(gg.find((row-2)*order+column-1))){
                                 gg.union((row-2)*order+column-1,(row-1)*order+column-1);  
                                 gg.union((row-1)*order+column-1,(row-1)*order+column-2);
                            }
                       }     
                   //if neither up nor left is labeled
                   else if(opcl[row][column-1]==0&&opcl[row-1][column]==0){         
                       opcl[row][column]=label;                       
                       label++;                       
                   }
               }
           }
                //Step 2; 自己非黑塊，與其他open block union時，若label不同，取小的
                for(int row=1;row<=order;row++){
                    for(int column=1;column<=order;column++){
                        
                        if(opcl[row][column]!=0){
                            
                            for(int i=row;i>=1;i--){
                                for(int j=order;j>=1;j--){
                                    int id=(i-1)*order+j-1;
                                    if(gg.connected((row-1)*order+column-1,id)){                                    
                                        if(opcl[row][column]<opcl[i][j]){
                                        int x=opcl[row][column];
                                        opcl[i][j]=x;                                        
                                        }
                                        else if(opcl[row][column]>opcl[i][j]){
                                        int x=opcl[i][j];
                                        opcl[row][column]=x;                                        
                                        }
                                }
                            }
                            }
                        }
                   }
                 }
                
        //int ggg=10;
        //System.out.println(gg.connected(1,5));
        
        System.out.println(opcl[Integer.parseInt(IC[1])][Integer.parseInt(IC[2])]);
        
        }
    }

    private static class UF {//UF.union(X,Y)會把Y連給X

        private int[] parent;   // parent[i] = parent of i
        private int[] size;     // size[i] = number of sites in subtree rooted at i
        private int count;      // number of components
        
        public UF(int x) {//constructor
            count=x;
            parent=new int[x];
            size=new int[x];
            for(int i=0;i<count;i++){
                parent[i]=i;
                size[i]=1;
            }           
        }
        
        public int count(){
            return count;
        }
        
        public int find(int p) {
            while (p != parent[p])
                p = parent[p];
            return p;
        }
        
        public boolean connected(int p, int q) {
            return find(p) == find(q);
        }
        
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ) return;
            
        // make smaller root point to larger one
        if (rootP < rootQ) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        }
        else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
        }
    }
    
    
    }
    
@4d2046e108a771c61e096de1c56a3f28@"
"r04945039","9","1.02","125440","@35bd93a49b6a15495dee453c7d0c3f77@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
	
	public boolean[][] matrix;
	public static int[][] idarray;
	public static int size;
	public QuickUnionUF qf;
	public int id=1;

	public LabelCC (int n){
		size=n;
		matrix = new boolean[size][size];
		idarray = new int[size][size];  
		for(boolean row[]: matrix)
			Arrays.fill(row, true);
		qf = new QuickUnionUF(size*size);
	}


	public void Blocked(int x,int y) {
		matrix [x-1][y-1]=false;
	}

	public boolean isOpen(int x,int y){
		return matrix[x-1][y-1];
	}

	private int setID (int i, int j){
		return id;
	}

	public void targetid (int i, int j) {
		if (matrix[i-1][j-1]!=true){
			System.out.println(0);
		}
                else{
                    int ans=idarray[i-1][j-1];
			System.out.println(qf.find(ans));
                }
	}
	

    public void getIndex(int x, int y){
	if(isOpen(x,y)!=false){
        if ( x==1 && isOpen(x,y-1)!=true || y==1 && isOpen(x-1,y)!=true || x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true){
	id++;	
            idarray[x-1][y-1]=setID(x,y);
		
	}
	else {
		if (y==1 && isOpen(x-1,y)==true || x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true){
			idarray[x-1][y-1]=(idarray[x-2][y-1]);
		}
		else{
			if (x==1 && isOpen(x,y-1)==true || x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true) {
				idarray[x-1][y-1]=idarray[x-1][y-2];
			}
			else{

				int a =Math.max((idarray[x-2][y-1]),(idarray[x-1][y-2]));
				int b =Math.min((idarray[x-2][y-1]),(idarray[x-1][y-2]));
				idarray[x-1][y-1]=b;
				qf.union(a,b);
			}
		}
	} 
}
        else
            idarray[x-1][y-1]=0;
    }
        

        public boolean initiation(){
            return matrix[0][0];
        }
        
        
        public static void main(String[] args) throws Exception {
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

         for(String line;(line = br.readLine())!=(null); ){
                    
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
                    
            }
         
         for (int m=1;m<=size;m++){
                      for (int n=1;n<=size;n++){
                          
                          if (m==1&& n==1 &&test.initiation()){
                              idarray[0][0]=1;
                              continue;
                          }
                          else
                              test.getIndex(m, n); 
                        
                      }
         }
            
           
             
            test.targetid(i, j);
            }
    }
	
}
@35bd93a49b6a15495dee453c7d0c3f77@"
"r04945039","8","1","124976","@b1b06c12922fdc2051da3ad6377f8e94@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
	
	public boolean[][] matrix;
	public static int[][] idarray;
	public static int size;
	public QuickUnionUF qf;
                public QuickFindUF QF;
	public int id=1;

	public LabelCC (int n){
		size=n;
		matrix = new boolean[size][size];
		idarray = new int[size][size];  
		for(boolean row[]: matrix)
			Arrays.fill(row, true);
		qf = new QuickUnionUF(size*size);
                QF = new QuickFindUF(size*size);
	}


	public void Blocked(int x,int y) {
		matrix [x-1][y-1]=false;
	}

	public boolean isOpen(int x,int y){
		return matrix[x-1][y-1];
	}

	private int setID (int i, int j){
		return id;
	}

	public void targetid (int i, int j) {
		if (matrix[i-1][j-1]!=true){
			System.out.println(0);
		}
                else{
                    int ans=idarray[i-1][j-1];
		System.out.println(QF.find(ans));                
                }
	}
	

    public void getIndex(int x, int y){
	if(isOpen(x,y)!=false){
        if ( x==1 && isOpen(x,y-1)!=true || y==1 && isOpen(x-1,y)!=true || x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true){
	id++;	
            idarray[x-1][y-1]=setID(x,y);
		
	}
	else {
		if (y==1 && isOpen(x-1,y)==true || x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true){
			idarray[x-1][y-1]=(idarray[x-2][y-1]);
		}
		else{
			if (x==1 && isOpen(x,y-1)==true || x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true) {
				idarray[x-1][y-1]=idarray[x-1][y-2];
			}
			else{

				int a =Math.max((idarray[x-2][y-1]),(idarray[x-1][y-2]));
				int b =Math.min((idarray[x-2][y-1]),(idarray[x-1][y-2]));
				idarray[x-1][y-1]=b;
				qf.union(a,b);
			}
		}
	} 
}
        else
            idarray[x-1][y-1]=0;
    }
        

        public boolean initiation(){
            return matrix[0][0];
        }
        
        
        public static void main(String[] args) throws Exception {
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

         for(String line;(line = br.readLine())!=(null); ){
                    
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
                    
            }
         
         for (int m=1;m<=size;m++){
                      for (int n=1;n<=size;n++){
                          
                          if (m==1&& n==1 &&test.initiation()){
                              idarray[0][0]=1;
                              continue;
                          }
                          else
                              test.getIndex(m, n); 
                        
                      }
         }
            
           
             
            test.targetid(i, j);
            }
    }
	
}
@b1b06c12922fdc2051da3ad6377f8e94@"
"r04631004","7","0.87","138672","@e2cbaad99135653cd3a10f29bcb7939c@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }
                WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF(count * 2);
                int tempsmall;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            ufstruct.union(storeunionpoint.biglabel[i][j], storeunionpoint.smalllabel[i][j]);
                        }
                    }
                }
                int[] unionarray = new int[count * 2];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
                }

                for (i = 1; i < count * 2; i++) {
                    for (j = i + 1; j < count * 2; j++) {
                        if (ufstruct.connected(i, j) == true) {
                            if (unionarray[j] > unionarray[i]) {
                                unionarray[j] = unionarray[i];
                            }
                        }
                    }
                }

                for (k = 1; k < unionarray.length; k++) {
                    for (i = 0; i < num; i++) {
                        for (j = 0; j < num; j++) {

                            if (label[i][j]==k && unionarray[k]!=k) {
                                label[i][j]=unionarray[k];
                            }
                        }
                    }
                }

//                for (i = 0; i < num; i++) {  //input grid
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(grid[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(grid[i][j]);
//                            }
//                        } else {
//                            System.out.print(grid[i][j] + "" "");
//                        }
//                    }
//                }
//
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
//                UP templabel = new UP(num, num);
//                templabel.checknum = label.clone();
//                int tempc = 0;
//
//                for (i = 0; i < num; i++) {  //change bigger label number to smaller label number
//                    for (j = 0; j < num; j++) {
//                        if (storeunionpoint.checknum[i][j] == 1) {
//                            for (int m = 0; m < num; m++) {
//                                for (int l = 0; l < num; l++) {
//                                    if (templabel.checknum[m][l] == storeunionpoint.biglabel[i][j]) {
//                                        if (label[m][l] < storeunionpoint.smalllabel[i][j]) {
//                                            tempc = storeunionpoint.smalllabel[i][j];
//                                            storeunionpoint.smalllabel[i][j] = label[m][l];
//                                            for (int o = 0; o < num; o++) {
//                                                for (int p = 0; p < num; p++) {
//                                                    if (label[o][p] == tempc) {
//                                                        label[o][p] = storeunionpoint.smalllabel[i][j];
//                                                    }
//                                                    if (o == m && p == l) {
//                                                        o = num;
//                                                        p = num;
//                                                    }
//                                                }
//                                            }
//                                        } else {
//                                            label[m][l] = storeunionpoint.smalllabel[i][j];
//                                        }
//
//                                        templabel.biglabel[m][l] = storeunionpoint.biglabel[i][j];
//                                        templabel.smalllabel[m][l] = storeunionpoint.smalllabel[i][j];
//                                    }
//                                }
//                            }
//                            //storeunionpoint.checknum[i][j] = 0;
//                        }
//                    }
//                }

//                                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(label[targetcoord[0] - 1][targetcoord[1] - 1]);
            }
        }
    }

}
@e2cbaad99135653cd3a10f29bcb7939c@"
"r04631004","9","1.37","153648","@5c69cad7db941ae4b73841c9b8e6b7fe@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }
                
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
//                
                
                WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF((num*num)/2+1);

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            ufstruct.union(storeunionpoint.biglabel[i][j], storeunionpoint.smalllabel[i][j]);
                        }
                    }
                }
                int[] unionarray = new int[(num*num)/2+1];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
                }

                for (i = 1; i < unionarray.length; i++) {
                    for (j = i + 1; j < unionarray.length; j++) {
                        if (ufstruct.connected(i, j) == true) {
                            if (unionarray[j] > unionarray[i]) {
                                unionarray[j] = unionarray[i];
                            }
                        }
                    }
                }

                for (k = 1; k < unionarray.length; k++) {
                    for (i = 0; i < num; i++) {
                        for (j = 0; j < num; j++) {

                            if (label[i][j]==k && unionarray[k]!=k) {
                                label[i][j]=unionarray[k];
                            }
                        }
                    }
                }
                
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }


                System.out.println(label[targetcoord[0] - 1][targetcoord[1] - 1]);
            }
        }
    }

}

@5c69cad7db941ae4b73841c9b8e6b7fe@"
"r04631004","9","1.39","155840","@f2ea818beca2fc7d60d1e8c81cc61fa6@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
//                
                WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF((num * num) / 2 + 1);

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            ufstruct.union(storeunionpoint.biglabel[i][j], storeunionpoint.smalllabel[i][j]);
                        }
                    }
                }
                int[] unionarray = new int[(num * num) / 2 + 1];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
                }

                for (i = 1; i < unionarray.length; i++) {
                    for (j = i + 1; j < unionarray.length; j++) {
                        if (ufstruct.connected(i, j) == true) {
                            if (unionarray[j] > unionarray[i]) {
                                unionarray[j] = unionarray[i];
                            } else if (unionarray[j] < unionarray[i]) {
                                for (k = 1; k <= i; k++) {
                                    if (unionarray[k] == unionarray[i]) {
                                        unionarray[k] = unionarray[j];
                                    }
                                }
                            }
                        }
                    }
                }

                for (k = 1; k < unionarray.length; k++) {
                    for (i = 0; i < num; i++) {
                        for (j = 0; j < num; j++) {

                            if (label[i][j] == k && unionarray[k] != k) {
                                label[i][j] = unionarray[k];
                            }
                        }
                    }
                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(label[targetcoord[0] - 1][targetcoord[1] - 1]);
            }
        }
    }

}

@f2ea818beca2fc7d60d1e8c81cc61fa6@"
"r04945039","0","1.04","131024","@1e24599f8c296f7ef33c95ed45d0e11b@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
	
	public boolean[][] matrix;
	public static int[][] idarray;
	public static int size;
	public QuickUnionUF qf;
                
	public int id=1;
                public static Stopwatch stopw;

	public LabelCC (int n){
		size=n;
		matrix = new boolean[size][size];
		idarray = new int[size][size];  
		for(boolean row[]: matrix)
			Arrays.fill(row, true);
		qf = new QuickUnionUF(size*size); 
                                
                                stopw=new Stopwatch();
	}


	public void Blocked(int x,int y) {
		matrix [x-1][y-1]=false;
	}

	public boolean isOpen(int x,int y){
		return matrix[x-1][y-1];
	}

	private int setID (int i, int j){
		return id;
	}

	public void targetid (int i, int j) {
		if (matrix[i-1][j-1]!=true){
			System.out.println(0);
		}
                else{
                    int ans=idarray[i-1][j-1];
		System.out.println(ans);   
                
                }
	}
        
        
        public void RecheckIDarray (){
            for (int r=1;r<=size;r++){
                      for (int t=1;t<=size;t++){
                      int temp = qf.find(idarray[r-1][t-1]);
                      int compare = idarray[r-1][t-1];
                      if (temp!=compare){
                          idarray[r-1][t-1]=temp;
                      }
                      }
                      
             }
        }
	

    public void getIndex(int x, int y){
	if(isOpen(x,y)!=false){
        if ( x==1 && isOpen(x,y-1)!=true || y==1 && isOpen(x-1,y)!=true || x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true){
	id++;	
            idarray[x-1][y-1]=setID(x,y);
		
	}
	else {
		if (y==1 && isOpen(x-1,y)==true || x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true){
			idarray[x-1][y-1]=(idarray[x-2][y-1]);
		}
		else{
			if (x==1 && isOpen(x,y-1)==true || x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true) {
				idarray[x-1][y-1]=idarray[x-1][y-2];
			}
			else{

				int a =Math.max((idarray[x-2][y-1]),(idarray[x-1][y-2]));
				int b =Math.min((idarray[x-2][y-1]),(idarray[x-1][y-2]));
				idarray[x-1][y-1]=b;
				qf.union(a,b);
			}
		}
	} 
}
        else
            idarray[x-1][y-1]=0;
    }
        

        public boolean initiation(){
            return matrix[0][0];
        }
        
        
        public static void main(String[] args) throws Exception {
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

         for(String line;(line = br.readLine())!=(null); ){
                    
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
                    
            }
         
         for (int m=1;m<=size;m++){
                      for (int n=1;n<=size;n++){
                          
                          if (m==1&& n==1 &&test.initiation()){
                              idarray[0][0]=1;
                              continue;
                          }
                          else
                              test.getIndex(m, n); 
                        
                      }
         }
            
           
             test.RecheckIDarray();
            test.targetid(i, j);
            double time= stopw.elapsedTime();
            System.out.println(time);
            }
    }
	
}
@1e24599f8c296f7ef33c95ed45d0e11b@"
"r04631004","10","0.101","148480","@f067fb431a9a20515dc104390125eb49@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
//    public class UP {
//        private int[][] smalllabel;
//        private int[][] biglabel;
//        private int[][] checknum;
//        public UP(int a,int b){
//            smalllabel=new int[a][b];
//            biglabel=new int[a][b];
//            checknum=new int[a][b];
//            for(int i=0;i<a;i++)
//                for(int j=0;j<b;j++)
//                {
//                    smalllabel[i][j]=0;
//                    biglabel[i][j]=0;
//                    checknum[i][j]=0;
//                }
//        }
//
//        
//    }
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                
               // WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF((num * num) / 2 + 1);
                //UF ufstruct = new UF((num * num) / 2 + 1);
                QuickFindUF ufstruct = new QuickFindUF((num * num) / 2 + 1);

                
                
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            ufstruct.union(storeunionpoint.biglabel[i][j],storeunionpoint.smalllabel[i][j] );
                        }
                    }
                }
                int[] unionarray = new int[(num * num) / 2 + 1];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
//                    if(i>0)
//                        System.out.println(i+"" = ""+ufstruct.find(i));
                }
                
                

//                for (i = 1; i < unionarray.length; i++) {
//                    for (j = i + 1; j < unionarray.length; j++) {
//                        if (ufstruct.connected(i, j) == true) {
//                            if (unionarray[j] > unionarray[i]) {
//                                unionarray[j] = unionarray[i];
//                            } else if (unionarray[j] < unionarray[i]) {
//                                for (k = 1; k <= i; k++) {
//                                    if (unionarray[k] == unionarray[i]) {
//                                        unionarray[k] = unionarray[j];
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }

//                for (k = 1; k < unionarray.length; k++) {
//                    for (i = 0; i < num; i++) {
//                        for (j = 0; j < num; j++) {
//
//                            if (label[i][j] == k && unionarray[k] != k) {
//                                label[i][j] = unionarray[k];
//                            }
//                        }
//                    }
//                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(ufstruct.find(label[targetcoord[0] - 1][targetcoord[1] - 1]));
            }
        }
    }

}

@f067fb431a9a20515dc104390125eb49@"
"r04631036","0","0.101","148480","@bfe0e3f35fca06a4073d1d2fed0b75f4@
import java.io.BufferedReader;
import java.io.FileReader;
import edu.princeton.cs.algs4.*;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
               // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                  //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                qf.union(block[i - 1][j], block[i][j - 1]);
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }
            
            
            //System.out.printf(""\n\n"");
            //step2
            for(int i=0;i<size;i++){
                //System.out.printf(""\n"");
                for(int j=0;j<size;j++)
                {
                    if(qf.find(block[i][j])<block[i][j])
                        block[i][j]=qf.find(block[i][j]);
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            System.out.printf(""%d"",block[target[0]-1][target[1]-1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""empty"");
        }
    }
}

@bfe0e3f35fca06a4073d1d2fed0b75f4@"
"r04631036","8","1.04","129056","@78c8de4cbe940c5fe537a3be970e0233@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
               // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                  //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                qf.union(block[i - 1][j], block[i][j - 1]);
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }
            
            
            //System.out.printf(""\n\n"");
            //step2
            for(int i=0;i<size;i++){
                //System.out.printf(""\n"");
                for(int j=0;j<size;j++)
                {
                    if(qf.find(block[i][j])<block[i][j])
                        block[i][j]=qf.find(block[i][j]);
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            System.out.printf(""%d"",block[target[0]-1][target[1]-1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""empty"");
        }
    }
}

@78c8de4cbe940c5fe537a3be970e0233@"
"r04631036","8","1.05","128864","@98915f9ddc4accf55b8caa1ad998a3fd@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
               // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                  //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                qf.union(block[i - 1][j], block[i][j - 1]);
                                qf.union(block[i - 1][j], block[i][j]);
                                qf.union(block[i][j], block[i][j - 1]);
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }
            
            
            //System.out.printf(""\n\n"");
            //step2
            for(int i=0;i<size;i++){
                //System.out.printf(""\n"");
                for(int j=0;j<size;j++)
                {
                    if(qf.find(block[i][j])<block[i][j])
                        block[i][j]=qf.find(block[i][j]);
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            System.out.printf(""%d"",block[target[0]-1][target[1]-1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""empty"");
        }
    }
}

@98915f9ddc4accf55b8caa1ad998a3fd@"
"r04945039","9","1.01","126592","@ce63fe6c363a1e501e1d4470a1825249@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
	
	public static int[][] matrix;
	//public static int[][] idarray;
	public static int size;
	public QuickUnionUF qf;
                
	public int id=1;
                public static Stopwatch stopw;

	public LabelCC (int n){
		size=n;
		matrix = new int[size][size];
		//idarray = new int[size][size];  
		for(int row[]: matrix)
			Arrays.fill(row, 1);
		qf = new QuickUnionUF(size*size); 
                                
                                stopw=new Stopwatch();
	}


	public void Blocked(int x,int y) {
		matrix [x-1][y-1]=0;
	}

	public boolean isOpen(int x,int y){
		return matrix[x-1][y-1]!=0;
	}

	private int setID (int i, int j){
		return id;
	}

	public void targetid (int i, int j) {
            int tar =matrix[i-1][j-1];
		if (tar==0){
			System.out.println(0);
		}
                else{
                    int ans=matrix[i-1][j-1];
		System.out.println(qf.find(ans));   
                
                }
	}
//        public void RecheckID (){
//            
//        }
        

    public void getIndex(int x, int y){
	if(isOpen(x,y)!=false){
        if ( x==1 && isOpen(x,y-1)!=true || y==1 && isOpen(x-1,y)!=true || x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true){
	id++;	
            matrix[x-1][y-1]=setID(x,y);
		
	}
	else {
		if (y==1 && isOpen(x-1,y)==true || x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true){
			matrix[x-1][y-1]=(matrix[x-2][y-1]);
		}
		else{
			if (x==1 && isOpen(x,y-1)==true || x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true) {
				matrix[x-1][y-1]=matrix[x-1][y-2];
			}
			else{

				int a =Math.max((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				int b =Math.min((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				matrix[x-1][y-1]=b;
				qf.union(a,b);
			}
		}
	} 
}
        else
            matrix[x-1][y-1]=0;
    }
        

        public boolean initiation(){
            int ini =matrix[0][0];
            return ini==0;
        }
        
        
        public static void main(String[] args) throws Exception {
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

         for(String line;(line = br.readLine())!=(null); ){
                    
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
                    
            }
         
         for (int m=1;m<=size;m++){
                      for (int n=1;n<=size;n++){
                          
                          if (m==1&& n==1 &&test.initiation()==false){
                              matrix[0][0]=1;
                              continue;
                          }
                          else
                              //System.out.println(m+"",""+n);
                              test.getIndex(m, n); 
                        
                      }
         }
            
           
          
            test.targetid(i, j);
           
            }
    }
	
}
@ce63fe6c363a1e501e1d4470a1825249@"
"r04945039","6","0.53","105536","@ffcbf9b9d5aca5a8c17f2496240798ac@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
	
	public static int[][] matrix;
	//public static int[][] idarray;
	public static int size;
	public QuickUnionUF qf;
                //public QuickFindUF QF;
	public int id=1;
                public static Stopwatch stopw;

	public LabelCC (int n){
		size=n;
		matrix = new int[size][size];
		//idarray = new int[size][size];  
		for(int row[]: matrix)
			Arrays.fill(row, 1);
		qf = new QuickUnionUF(size);                              
                                stopw=new Stopwatch();
	}


	public void Blocked(int x,int y) {
		matrix [x-1][y-1]=0;
	}

	public boolean isOpen(int x,int y){
		return matrix[x-1][y-1]!=0;
	}

	private int setID (int i, int j){
		return id;
	}

	public void targetid (int i, int j) {
            int tar =matrix[i-1][j-1];
		if (tar==0){
			System.out.println(0);
		}
                else{
                    int ans=matrix[i-1][j-1];
		System.out.println(qf.find(ans));   
                
                }
	}
//        public void RecheckID (){
//            for (int r=1;r<=size;r++){
//                for(int t=1;t<=size;t++){
//                    matrix[][]
//                }
//            }
//            
//        }
        

    public void getIndex(int x, int y){
	if(isOpen(x,y)!=false){
        if ( x==1 && isOpen(x,y-1)!=true || y==1 && isOpen(x-1,y)!=true || x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true){
	id++;	
            matrix[x-1][y-1]=setID(x,y);
		
	}
	else {
		if (y==1 && isOpen(x-1,y)==true || x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true){
			matrix[x-1][y-1]=(matrix[x-2][y-1]);
		}
		else{
			if (x==1 && isOpen(x,y-1)==true || x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true) {
				matrix[x-1][y-1]=matrix[x-1][y-2];
			}
			else{

				int a =Math.max((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				int b =Math.min((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				matrix[x-1][y-1]=b;
				qf.union(a,b);
			}
		}
	} 
}
        else
            matrix[x-1][y-1]=0;
    }
        

        public boolean initiation(){
            int ini =matrix[0][0];
            return ini==0;
        }
        
        
        public static void main(String[] args) throws Exception {
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

         for(String line;(line = br.readLine())!=(null); ){
                    
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
                    
            }
         
         for (int m=1;m<=size;m++){
                      for (int n=1;n<=size;n++){
                          
                          if (m==1&& n==1 &&test.initiation()==false){
                              matrix[0][0]=1;
                              continue;
                          }
                          else
                              //System.out.println(m+"",""+n);
                            
                                  test.getIndex(m, n);
                          
                         
                      }
         }
            
           
          test.targetid(i, j);
            
           
            }
    }
	
}
@ffcbf9b9d5aca5a8c17f2496240798ac@"
"r04945039","9","1.01","127520","@e54c40b43070e3465a3690a93db1d0e3@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
	
	public static int[][] matrix;
	//public static int[][] idarray;
	public static int size;
	public QuickUnionUF qf;
                //public QuickFindUF QF;
	public int id=1;
                public static Stopwatch stopw;

	public LabelCC (int n){
		size=n;
		matrix = new int[size][size];
		//idarray = new int[size][size];  
		for(int row[]: matrix)
			Arrays.fill(row, 1);
		qf = new QuickUnionUF(size*size);                              
                                stopw=new Stopwatch();
	}


	public void Blocked(int x,int y) {
		matrix [x-1][y-1]=0;
	}

	public boolean isOpen(int x,int y){
		return matrix[x-1][y-1]!=0;
	}

	private int setID (int i, int j){
		return id;
	}

	public void targetid (int i, int j) {
            int tar =matrix[i-1][j-1];
		if (tar==0){
			System.out.println(0);
		}
                else{
                    int ans=matrix[i-1][j-1];
		System.out.println(qf.find(ans));   
                
                }
	}
//        public void RecheckID (){
//            for (int r=1;r<=size;r++){
//                for(int t=1;t<=size;t++){
//                    matrix[][]
//                }
//            }
//            
//        }
        

    public void getIndex(int x, int y){
	if(isOpen(x,y)!=false){
        if ( x==1 && isOpen(x,y-1)!=true || y==1 && isOpen(x-1,y)!=true || x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true){
	id++;	
            matrix[x-1][y-1]=setID(x,y);
		
	}
	else {
		if (y==1 && isOpen(x-1,y)==true || x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true){
			matrix[x-1][y-1]=(matrix[x-2][y-1]);
		}
		else{
			if (x==1 && isOpen(x,y-1)==true || x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true) {
				matrix[x-1][y-1]=matrix[x-1][y-2];
			}
			else{

				int a =Math.max((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				int b =Math.min((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				matrix[x-1][y-1]=b;
				qf.union(a,b);
			}
		}
	} 
}
        else
            matrix[x-1][y-1]=0;
    }
        

        public boolean initiation(){
            int ini =matrix[0][0];
            return ini==0;
        }
        
        
        public static void main(String[] args) throws Exception {
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

         for(String line;(line = br.readLine())!=(null); ){
                    
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
                    
            }
         
         for (int m=1;m<=size;m++){
                      for (int n=1;n<=size;n++){
                          
                          if (m==1&& n==1 &&test.initiation()==false){
                              matrix[0][0]=1;
                              continue;
                          }
                          else
                              //System.out.println(m+"",""+n);
                            
                                  test.getIndex(m, n);
                          
                         
                      }
         }
            
           
          test.targetid(i, j);
            
           
            }
    }
	
}
@e54c40b43070e3465a3690a93db1d0e3@"
"r04945039","9","1","127328","@e45a087b6e0a92b6f224da8df0040a24@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
	
	public static int[][] matrix;
	//public static int[][] idarray;
	public static int size;
	public QuickUnionUF qf;
                //public QuickFindUF QF;
	public int id=1;
                

	public LabelCC (int n){
		size=n;
		matrix = new int[size][size];
		//idarray = new int[size][size];  
		for(int row[]: matrix)
			Arrays.fill(row, 1);
		qf = new QuickUnionUF(size*size);                              
                                
	}


	public void Blocked(int x,int y) {
		matrix [x-1][y-1]=0;
	}

	public boolean isOpen(int x,int y){
		return matrix[x-1][y-1]!=0;
	}

	private int setID (int i, int j){
		return id;
	}

	public void targetid (int i, int j) {
            int tar =matrix[i-1][j-1];
		if (tar==0){
			System.out.println(0);
		}
                else{
                    int ans=matrix[i-1][j-1];
		System.out.println(qf.find(ans));   
                
                }
	}
//        public void RecheckID (){
//            for (int r=1;r<=size;r++){
//                for(int t=1;t<=size;t++){
//                    matrix[][]
//                }
//            }
//            
//        }
        

    public void getIndex(int x, int y){
	if(isOpen(x,y)!=false){
        if ( x==1 && isOpen(x,y-1)!=true || y==1 && isOpen(x-1,y)!=true || x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true){
	id++;
            matrix[x-1][y-1]=setID(x,y);
		
	}
	else {
		if (y==1 && isOpen(x-1,y)==true || x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true){
			matrix[x-1][y-1]=(matrix[x-2][y-1]);
		}
		else{
			if (x==1 && isOpen(x,y-1)==true || x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true) {
				matrix[x-1][y-1]=matrix[x-1][y-2];
			}
			else{

				int a =Math.max((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				int b =Math.min((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				matrix[x-1][y-1]=b;
				qf.union(a,b);
			}
		}
	} 
}
        else
            matrix[x-1][y-1]=0;
    }
        

        public boolean initiation(){
            int ini =matrix[0][0];
            return ini==0;
        }
        
        
        public static void main(String[] args) throws Exception {
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

         for(String line;(line = br.readLine())!=(null); ){
                    
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
                    
            }
         
         for (int m=1;m<=size;m++){
                      for (int n=1;n<=size;n++){
                          
                          if (m==1&& n==1 &&test.initiation()==false){
                              matrix[0][0]=1;
                              continue;
                          }
                          else
                              //System.out.println(m+"",""+n);
                            
                                  test.getIndex(m, n);
                          
                         
                      }
         }
            
           
          test.targetid(i, j);
            
           
            }
    }
	
}
@e45a087b6e0a92b6f224da8df0040a24@"
"r04631036","0","1.72","201136","@635a8907e05bb1acb8fd4fefec14ba6e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
               // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                  //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            
            //step1
            for (int i = 0; i < size; i++) {
//                System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                qf.union(block[i][j-1], block[i-1][j]);
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
//                    System.out.printf(""%d "", block[i][j]);
                }

            }
            
            
            //System.out.printf(""\n\n"");
            //step2
            for(int i=0;i<size;i++){
                //System.out.printf(""\n"");
                for(int j=0;j<size;j++)
                {
                    if(qf.find(block[i][j])<block[i][j])
                        block[i][j]=qf.find(block[i][j]);
                    //else if(qf.find(block[i][j])>block[i][j])
                        //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
                        for(int i=0;i<size;i++){
                System.out.printf(""\n"");
                for(int j=0;j<size;j++)
                {
                    if(qf.find(block[i][j])<block[i][j])
                        block[i][j]=qf.find(block[i][j]);
                    //else if(qf.find(block[i][j])>block[i][j])
                        //block[i][j]=
                    System.out.printf(""%d "", block[i][j]);
                }
            }

            System.out.printf(""\nroot(6)= %d\n"",qf.find(6));
             System.out.printf(""\nroot(4)= %d\n"",qf.find(4));
            System.out.printf(""%d"",block[target[0]-1][target[1]-1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@635a8907e05bb1acb8fd4fefec14ba6e@"
"r04631004","9","1","148352","@48c6f502557e6295f4a3d1d0814409d9@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
  //                                          System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
    //                                        System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                
               // WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF((num * num) / 2 + 1);
                //UF ufstruct = new UF((num * num) / 2 + 1);
                //QuickFindUF ufstruct = new QuickFindUF((num * num) / 2 + 1);
                QuickUnionUF ufstruct = new QuickUnionUF((num * num) / 2 + 1);

                
                
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            if(ufstruct.find(storeunionpoint.biglabel[i][j])>storeunionpoint.smalllabel[i][j])
                            ufstruct.union(storeunionpoint.biglabel[i][j],storeunionpoint.smalllabel[i][j] );
                            else
                                ufstruct.union(storeunionpoint.smalllabel[i][j],storeunionpoint.biglabel[i][j] );
                        }
                    }
                }
                int[] unionarray = new int[(num * num) / 2 + 1];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
//                    if(i>0)
//                        System.out.println(i+"" = ""+ufstruct.find(i));
                }
                
                

//                for (i = 1; i < unionarray.length; i++) {
//                    for (j = i + 1; j < unionarray.length; j++) {
//                        if (ufstruct.connected(i, j) == true) {
//                            if (unionarray[j] > unionarray[i]) {
//                                unionarray[j] = unionarray[i];
//                            } else if (unionarray[j] < unionarray[i]) {
//                                for (k = 1; k <= i; k++) {
//                                    if (unionarray[k] == unionarray[i]) {
//                                        unionarray[k] = unionarray[j];
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }

//                for (k = 1; k < unionarray.length; k++) {
//                    for (i = 0; i < num; i++) {
//                        for (j = 0; j < num; j++) {
//
//                            if (label[i][j] == k && unionarray[k] != k) {
//                                label[i][j] = unionarray[k];
//                            }
//                        }
//                    }
//                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(ufstruct.find(label[targetcoord[0] - 1][targetcoord[1] - 1]));
            }
        }
    }

}

@48c6f502557e6295f4a3d1d0814409d9@"
"r04631036","8","1.02","136528","@5e0f591c8daf458d10fd74d64f8ac644@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
               // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                  //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            
            //step1
            for (int i = 0; i < size; i++) {
//                System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                qf.union(block[i][j-1], block[i-1][j]);
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
//                    System.out.printf(""%d "", block[i][j]);
                }

            }
            
            
            //System.out.printf(""\n\n"");
            //step2
            for(int i=0;i<size;i++){
                //System.out.printf(""\n"");
                for(int j=0;j<size;j++)
                {
                    if(qf.find(block[i][j])<block[i][j])
                        block[i][j]=qf.find(block[i][j]);
                    //else if(qf.find(block[i][j])>block[i][j])
                        //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
                        for(int i=0;i<size;i++){
                //System.out.printf(""\n"");
                for(int j=0;j<size;j++)
                {
                    if(qf.find(block[i][j])<block[i][j])
                        block[i][j]=qf.find(block[i][j]);
                    //else if(qf.find(block[i][j])>block[i][j])
                        //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(6)= %d\n"",qf.find(6));
            // System.out.printf(""\nroot(4)= %d\n"",qf.find(4));
            System.out.printf(""%d"",block[target[0]-1][target[1]-1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@5e0f591c8daf458d10fd74d64f8ac644@"
"r04631036","9","1.07","138720","@9da9ef58939f7e2297e33e53f575249a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/

            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@9da9ef58939f7e2297e33e53f575249a@"
"b03611023","9","1.37","151344","@8860eb1ad1e002e1f306868df05e1820@
import java.io.FileReader;
import java.io.BufferedReader;
        

public class LabelCC {
    
  
                    
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])) ){
            
            String[] N = br.readLine().split("","");
            
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            int a = Integer.parseInt(N[1]);
            int b = Integer.parseInt(N[2]);
            //System.out.print(a);
            //System.out.print(b);
            int[][] label = new int[n+1][n+1];
            int[][] open = new int[n+1][n+1];
            
            int x;
            int y;
            
            for(x = 1;x<n+1;x++){
                for(y = 1;y<n+1;y++){
                    open[x][y] = 1;
                }
            }
            
           
            
            String buffer;
            String gg = """";
            int i = 0;
            
            buffer = br.readLine();
            while(buffer != null){
                gg = gg.concat(buffer);
                gg = gg.concat("","");
                i++;
                buffer = br.readLine();
            }
            String[] lgg = gg.split("","");
            int[] data = new int[2];
            for(int j = 0;j<2*i;j+=2){
                data[0] = Integer.parseInt(lgg[j]);
                data[1] = Integer.parseInt(lgg[j+1]);              
                open[data[0]][data[1]] = 0;                
            }
            int[] root = new int[n*n+1];
            for(x = 0; x<n*n+1; x++){
                root[x] = x;
            }
            
            int count = 1;
            for(x = 1;x<n+1 ;x++){
                for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                    if(open[x-1][y] == 1 && open[x][y-1] == 1 && label[x][y-1] != label[x-1][y] ){  
                       int d = label[x][y-1];
                       int f = label[x-1][y];
                     /*  while(root[label[x-1][y]] != label[x-1][y]){
                    label[x-1][y] = root[label[x-1][y]];
                }
                        while(root[label[x][y-1]] != label[x][y-1]){
                    label[x][y-1] = root[label[x][y-1]];
                }*/
                        if(label[x][y-1] < label[x-1][y]){
                        label[x][y] = d;
                       // System.out.print(label[x][y]);
                        root[label[x-1][y]] = label[x][y-1];
                        
                        }
                        else{
                             label[x][y] = f;
                           //  System.out.print(label[x][y]);
                             root[label[x][y-1]] = label[x-1][y];
                            
                        }
                    }
                    else if(open[x-1][y] == 1){
                        label[x][y] = label[x-1][y];
                       // System.out.print(label[x][y]);
                       
                    }
                    else if(open[x][y-1] == 1){
                        label[x][y] = label[x][y-1];
                      //  System.out.print(label[x][y]);                       
                    }
                    else {
                        label[x][y] = count;
                        count++;
                      //  System.out.print(label[x][y]);                        
                    }
                }    
                }
            }            
        for(x=1;x<n+1;x++){
            for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                while(root[label[x][y]] != label[x][y]){
                    label[x][y] = root[label[x][y]];
                }
                }
               // System.out.print(label[x][y]);
            }
        }
      /*  for(x = 1;x<count;x++){
            System.out.print(root[x]);
            
        }*/
        System.out.print(label[a][b]);
            
        }
    }
    
    
    
    
    
    
    
}

@8860eb1ad1e002e1f306868df05e1820@"
"b03611041","9","1.02","132720","@c47f55a795ccdeafc0fa10c50a5a6800@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){

            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int ufNum=num*num+(num*num+1)/2+1;
            int temp=(num*num+1)/2+1;
//            System.out.printf(""%d %d\n"",ufNum,temp);
            QuickUnionUF uf=new QuickUnionUF(ufNum);

            if(targetCol==0||targetRow==0||targetCol>num||targetRow>num){
                System.out.printf(""%d"",0);
                return;
            }

            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null){
                String input[]=test.split("","");
                int row=Integer.parseInt(input[0]);
                int col=Integer.parseInt(input[1]);
                matrix[row][col]=false;
            }

//            for(int i=0;i<num+2;i++){
//                for (int j=0;j<num+2;j++){
//                    System.out.printf(""%d "",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    int currentID=(i-1)*num+(j-1)+(num*num+1)/2+1;
                    if(matrix[i][j]==false) continue;
                    else {
                        if (!matrix[i - 1][j] && !matrix[i][j - 1]) {
                            uf.union(currentID, labelNum);
                            labelNum++;
                        } else if (matrix[i - 1][j] && matrix[i][j - 1]) {
                            if (uf.find(currentID - num) > uf.find(currentID - 1))
                                uf.union(currentID, currentID - 1);
                            else uf.union(currentID, currentID - num);
                        } else if (matrix[i - 1][j] == true && matrix[i][j - 1] == false){
                            uf.union(currentID, currentID - num);
                        } else if(matrix[i - 1][j] == false && matrix[i][j - 1] == true){
                            uf.union(currentID, currentID - 1);

//                            if((currentID-temp)%num==0)
//                                uf.union(currentID,currentID-num);
//                            else{
////                                if(uf.find(currentID-num)>uf.find(currentID-1))
//                                    uf.union(currentID,currentID-1);
////                                else uf.union(currentID,currentID-num);

                        }
                    }
                }
            }

//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            for(int i=1;i<num+1;i++){
                for (int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        int currentID=(i-1)*num+(j-1)+temp;
                        if((matrix[i-1][j] && matrix[i][j-1]) && (currentID-temp)%num!=0) {
                            if (uf.find(currentID - num) > uf.find(currentID - 1)){
                                uf.union(currentID - num,currentID -1);
//                                uf.union(currentID,currentID -1);
                            }
                            else{
                                uf.union(currentID - 1,currentID-num);
//                                uf.union(currentID ,currentID-num);
                            }
                        }
                    }
                }
            }

//            System.out.printf(""\n"");
//            for(int i=0;i<num;i++){
//                for (int j=0;j<num;j++){
//                    System.out.printf(""%-4d"",uf.find(i*num+j+(num*num+1)/2+1));
//                }
//                System.out.printf(""\n"");
//            }

            if(uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1)>=temp) {
                System.out.printf(""%d"", 0);
            }else
                System.out.printf(""%d"",uf.find((targetRow-1)*num+(targetCol-1)+(num*num+1)/2+1));

//            System.out.printf(""\n"");
//            QuickUnionUF testUF=new QuickUnionUF(10);
//            testUF.union(2,1);
//            testUF.union(3,1);
//
//            for(int i=0;i<10;i++) {
//                System.out.printf(""%d  "",testUF.find(i));
//            }



        }
    }
}

@c47f55a795ccdeafc0fa10c50a5a6800@"
"r04921028","9","0.98","122096","@91a4e6631a52adda95e23cf792d38d83@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");

        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);

        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}

            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                
                if(M[i][j]==0){
                    if(j==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                    
                    if(i!=0&&j==0){

                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                   
                    if(i==0&&j!=0){

                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                                if(inread==0){
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    if(i!=0&&j!=0){

                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(uf.find(M[i-1][j])>uf.find(M[i][j-1])){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                        
                        
                    }
                    
                
                }
                
                
            }
        }
  
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        
              
        
        
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@91a4e6631a52adda95e23cf792d38d83@"
"r04631034","9","1.47","171280","@754b5ef8cfd7630554b53d8ce98ce0de@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.*;
import java.util.*;
/**
 *
 * @author user
 */
public class LabelCC {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here
          In in = new In(args[0]);
          String[] TopRow =in.readLine().split("","");
          
          String[][] matrix = new String[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];
//          System.out.println(matrix.length);
//          System.out.println(TopRow[0]+"" ""+TopRow[1]+"" ""+TopRow[2]);
          String line;       
//         ArrayList<Integer> Row = new ArrayList<Integer>();
//          ArrayList<Integer> Column = new ArrayList<Integer>();
            while ((line = in.readLine()) != null) {
//                Row.add(Integer.parseInt(line.split("","")[0]));
//               Column.add(Integer.parseInt(line.split("","")[1]));
               matrix[Integer.parseInt(line.split("","")[0])-1][Integer.parseInt(line.split("","")[1])-1]=""0"";
                }
            
//            for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
//                      System.out.print((i+1)+"",""+(j+1)+"" inside ""+matrix[i][j]+""     "");   
//                 }
//                 System.out.println("""");
//            }
            int label=1;
            for(int  i =0 ; i<matrix.length;i++)
            {
                 for(int  j =0 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {
                                   if(i ==0)   //first row
                                   {
                                        if(j==0) // first col
                                        {
                                             matrix[i][j]=Integer.toString(label);
                                        }
                                        else if(matrix[i][j-1]!=""0"")  //left site not block site >> connect
                                        {
                                             matrix[i][j]=matrix[i][j-1];
                                        }
                                        else   
                                        {
                                             matrix[i][j]=Integer.toString(++label);
                                        }
                                   }
                                   else //   another row
                                   {
                                        if(j==0)  //first col
                                        {
                                            if(matrix[i-1][j]!=""0"") // upper row not block site
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }
                                             else
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }
                                        }
                                        else // else col
                                        {
                                             if(matrix[i][j-1] != ""0"" && matrix[i-1][j]==""0"") // connext left col
                                             {
                                                  matrix[i][j]=matrix[i][j-1];
                                             }
                                             if(matrix[i-1][j] != ""0"" && matrix[i][j-1]==""0"") // connext upper row
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }                                            
                                             if(matrix[i][j-1] == ""0"" && matrix[i-1][j]==""0"")
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }                                             
                                              if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                                             {
                                                  if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                                  {
                                                       matrix[i][j]=matrix[i][j-1];
                                                  }
                                                  else
                                                  {
                                                       matrix[i][j]=matrix[i-1][j];
                                                  }
                                             }                                                    
                                        }
                                   }        
                      }
                 }
            }
//            System.out.println(label);
            QuickUnionUF uf = new QuickUnionUF(label+1);
            
           for(int  i =1 ; i<matrix.length;i++)
            {
                 for(int  j =1 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {            
                           if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                           {
                                if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                 {
                                       uf.union(uf.find(Integer.parseInt(matrix[i-1][j])),uf.find(Integer.parseInt(matrix[i][j-1])));
                                  }
                                  else
                                   {
                                        uf.union(uf.find(Integer.parseInt(matrix[i][j-1])),uf.find(Integer.parseInt(matrix[i-1][j])));
                                    }               
                           }
                      }
                 }
            }
            
            
            
            
            
            
            
            
//            System.out.println(""check"");
//            
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      System.out.print(matrix[i][j]+""     "");
//                 }
//                                      System.out.println("""");
//            }
            
            
                        System.out.println(uf.find(Integer.parseInt(matrix[Integer.parseInt(TopRow[1])-1][Integer.parseInt(TopRow[2])-1])));
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
     }
}



@754b5ef8cfd7630554b53d8ce98ce0de@"
"b03704074","9","1.64","164880","@b6c9f0644e7d2e8d29e51bfcf373f011@
public class LabelCC {
    private int[] parent;
    public LabelCC(int N)   //每個仁自己是自己的根
    { parent = new int[N*N];
     for (int i = 0 ; i<N*N ; i++)
         parent[i] = i; }
    
    public int find(int p) //找根
    { while (p != parent[p])
        p = parent[p];
        return p;}
    public boolean connected(int p,int q)  //看是否根相同
    {return find(p)==find(q);}
    
    public void union(int p,int q){  //連結在一起
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        parent[rootP] = rootQ;}//p接到q上
     
            
    public static void main(String[] args) {
       In in = new In(args[0]);
       String[] firstrow = new String[3];
       String[] secondrow = new String[2];
       firstrow = in.readString().split("","");
       int N = Integer.parseInt(firstrow[0]);
       int a = Integer.parseInt(firstrow[1]);
       int b = Integer.parseInt(firstrow[2]);
       int target = (a-1)*N+b;
       //System.out.println(""N為""+N+"" 座標為""+a+"",""+b);
       //System.out.println(""target為""+target);
       
       int[] blockstring = new int[N*N];
       int i = 0;
       while(!in.isEmpty()){
           secondrow = in.readString().split("","");
           a = Integer.parseInt(secondrow[0]);
           b = Integer.parseInt(secondrow[1]);
           blockstring[i] = (a-1)*N + b;
           //System.out.println(""座標為""+a+"",""+b+""轉成""+blockstring[i]);
           if(target == blockstring[i])  {System.out.println(""0"");  return;}
           i++;   
       } 
       //System.out.println(""blockstring.length""+blockstring.length);
       LabelCC labelcc= new LabelCC(N); 
       int[] labelnumber = new int[N*N+1];
       int count = 1;
       //firstpass
       for(i = 1;i<=N*N;i++){
          
          int flag = 0;
          for(int j = 0;blockstring[j]!=0&&j<blockstring.length;j++){
              flag = 1;
              if(i==blockstring[j]){flag = 0; break;}}
          if(flag ==0)continue;
          if(i ==1){labelnumber[i] = count; count++;}
          else if(i <= N){
              if(labelnumber[i-1]!=0 )
                  labelnumber[i] = labelnumber[i-1];
              else {labelnumber[i] = count; count++;}}
          else if (i % N == 1 ){ //最左邊那排
              if(labelnumber[i-N]!=0 )
                  labelnumber[i] = labelnumber[i-N];
              else {labelnumber[i] = count; count++;}}
          
          else{
              if(labelnumber[i-N]!=0 && labelnumber[i-1]==0 )
                  labelnumber[i] = labelnumber[i-N];
              else if(labelnumber[i-N]==0 && labelnumber[i-1]!=0)
                  labelnumber[i] = labelnumber[i-1];
              else if(labelnumber[i-N]==0 && labelnumber[i-1]==0)
                  {labelnumber[i] = count;count++;}
              else//labelnumber[i-N]!=0 && labelnumber[i-1]!=0
                  if(labelnumber[i-N]<labelnumber[i-1]){
                      labelnumber[i] = labelnumber[i-N];
                      labelcc.union(labelnumber[i-1], labelnumber[i-N]);  }//i-1接到i-N上
                  else if(labelnumber[i-N]>labelnumber[i-1]){
                      labelnumber[i] = labelnumber[i-1];
                      labelcc.union(labelnumber[i-N], labelnumber[i-1]);}//i-N接到i-1上
                  else labelnumber[i]= labelnumber[i-1];    
          }
          //System.out.println(""i=""+i+""  labelnumber[i]""+labelnumber[i]);
       }
       
        
     //secondpass  全部改成root的label
       for(i = 1;i<=N*N;i++){
           if (labelnumber[i]==0)  continue;//是block則跳過
           else if(labelcc.find(labelnumber[i])==labelnumber[i]) continue;//自己就是根則跳過
           else //把自己的標籤改成根的
               labelnumber[i] = labelcc.find(labelnumber[i]);
           //System.out.println(""i=""+i+""  labelnumber[i]""+labelnumber[i]);
       }
       System.out.println(labelnumber[target]);
        
        
        
        
        
    }
}

@b6c9f0644e7d2e8d29e51bfcf373f011@"
"b03704074","10","0.163","169232","@6962375eb9c886f66ee3e2178608db07@
public class LabelCC {
    private int[] parent;
    public LabelCC(int N)   //每個仁自己是自己的根
    { parent = new int[N*N];
     for (int i = 0 ; i<N*N ; i++)
         parent[i] = i; }
    
    public int find(int p) //找根
    { while (p != parent[p])
        p = parent[p];
        return p;}
    public boolean connected(int p,int q)  //看是否根相同
    {return find(p)==find(q);}
    
    public void union(int p,int q){  //連結在一起
        int rootP = find(p);
        int rootQ = find(q);
        if(rootP == rootQ)return;
        parent[rootP] = rootQ;}//p接到q上
     
            
    public static void main(String[] args) {
       In in = new In(args[0]);
       String[] firstrow = new String[3];
       String[] secondrow = new String[2];
       firstrow = in.readString().split("","");
       int N = Integer.parseInt(firstrow[0]);
       int a = Integer.parseInt(firstrow[1]);
       int b = Integer.parseInt(firstrow[2]);
       int target = (a-1)*N+b;
       //System.out.println(""N為""+N+"" 座標為""+a+"",""+b);
       //System.out.println(""target為""+target);
       
       int[] blockstring = new int[N*N];
       int i = 0;
       while(!in.isEmpty()){
           secondrow = in.readString().split("","");
           a = Integer.parseInt(secondrow[0]);
           b = Integer.parseInt(secondrow[1]);
           blockstring[i] = (a-1)*N + b;
           //System.out.println(""座標為""+a+"",""+b+""轉成""+blockstring[i]);
           if(target == blockstring[i])  {System.out.println(""0"");  return;}
           i++;   
       } 
       if(blockstring[0]==0){System.out.println(""1"");  return;}//給沒有BLOCK的例外
       //System.out.println(""blockstring.length""+blockstring.length);
       LabelCC labelcc= new LabelCC(N); 
       int[] labelnumber = new int[N*N+1];
       int count = 1;
       //firstpass
       for(i = 1;i<=N*N;i++){
          
          int flag = 0;
          for(int j = 0;blockstring[j]!=0&&j<blockstring.length;j++){
              flag = 1;
              if(i==blockstring[j]){flag = 0; break;}}
          if(flag ==0)continue;
          if(i ==1){labelnumber[i] = count; count++;}
          else if(i <= N){
              if(labelnumber[i-1]!=0 )
                  labelnumber[i] = labelnumber[i-1];
              else {labelnumber[i] = count; count++;}}
          else if (i % N == 1 ){ //最左邊那排
              if(labelnumber[i-N]!=0 )
                  labelnumber[i] = labelnumber[i-N];
              else {labelnumber[i] = count; count++;}}
          
          else{
              if(labelnumber[i-N]!=0 && labelnumber[i-1]==0 )
                  labelnumber[i] = labelnumber[i-N];
              else if(labelnumber[i-N]==0 && labelnumber[i-1]!=0)
                  labelnumber[i] = labelnumber[i-1];
              else if(labelnumber[i-N]==0 && labelnumber[i-1]==0)
                  {labelnumber[i] = count;count++;}
              else//labelnumber[i-N]!=0 && labelnumber[i-1]!=0
                  if(labelnumber[i-N]<labelnumber[i-1]){
                      labelnumber[i] = labelnumber[i-N];
                      labelcc.union(labelnumber[i-1], labelnumber[i-N]);  }//i-1接到i-N上
                  else if(labelnumber[i-N]>labelnumber[i-1]){
                      labelnumber[i] = labelnumber[i-1];
                      labelcc.union(labelnumber[i-N], labelnumber[i-1]);}//i-N接到i-1上
                  else labelnumber[i]= labelnumber[i-1];    
          }
          //System.out.println(""i=""+i+""  labelnumber[i]""+labelnumber[i]);
       }
       
        
     //secondpass  全部改成root的label
       for(i = 1;i<=N*N;i++){
           if (labelnumber[i]==0)  continue;//是block則跳過
           else if(labelcc.find(labelnumber[i])==labelnumber[i]) continue;//自己就是根則跳過
           else //把自己的標籤改成根的
               labelnumber[i] = labelcc.find(labelnumber[i]);
           //System.out.println(""i=""+i+""  labelnumber[i]""+labelnumber[i]);
       }
       System.out.println(labelnumber[target]);
        
        
        
        
        
    }
}

@6962375eb9c886f66ee3e2178608db07@"
"b03611011","9","1.07","132544","@5688b39f90c2826e8b438631036365a4@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static int[] place;
    public static int[] id, count;
    public static int n, number, x;
    private static int[] parent, child;  // parent[i] = parent of i
    private static int[] change;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private static int rootQ, rootP, amount;
    //amount =rank
    //n= length
    //id= if or not
    //cont=>number where it is

    public static void point(int x, int y) {
        number = (x - 1) * n + y;
    }

    public static void UF(int N) {
        if (N < 0) {
            throw new IllegalArgumentException();
        }
        parent = new int[N];
        child = new int[N];
        change = new int[N / 4];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            child[i] = 0;
        }
    }

    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
        }
    }

    public boolean connected(int p, int q) {
        return parent[p] == parent[q];
    }

    public static void union(int p, int q) {
        rootP = parent[p];
        rootQ = parent[q];
        if (rootP == rootQ) {
            return;
        }
        // make root of smaller rank point to root of larger rank
        if (rootP < rootQ) {
            parent[rootQ] = rootP;
        } else if (rootP > rootQ) {
            parent[rootP] = rootQ;
        }
//        count--;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] fund = br.readLine().split("","");
            n = Integer.parseInt(fund[0]);
            place = new int[2];
            place[0] = Integer.parseInt(fund[1]);
            place[1] = Integer.parseInt(fund[2]);
            id = new int[n * n + 2];
            x = 0;
            for (int i = 1; i <= n * n + 1; i++) {
                id[i] = 2;
            }
            count = new int[2];
            String data;
            String[] data1;
            UF(n * n + 2);
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 0;
                union(0, number);
            }
            amount = 1;
            if (id[1] > 0) {
                parent[1] = amount;
                amount++;
            }
            for (int i = 2; i <= n; i++) {
                if (id[i] > 0) {
                    if (id[i - 1] > 0) {
                        union(i, i - 1);
                    } else {
                        parent[i] = amount;
                        amount++;
                    }
                }
            }
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    point(i, j);
                    if (id[number] > 0) {
                        if (j == 1) {
                            if (id[number - n] > 0) {
                                union(number, number - n);
                            } else {
                                parent[number] = amount;
                                amount++;
                            }
                        } else if (id[number - n] > 0 && id[number - 1] > 0) {
                            if (parent[number - n] < parent[number - 1]) {
                                parent[number] = parent[number - n];
                                child[number] = parent[number - 1];
                                change[x] = parent[number - n];
                                x++;
                                change[x] = parent[number - 1];
                                x++;
                            } else if (parent[number - n] > parent[number - 1]) {
                                parent[number] = parent[number - 1];
                                child[number] = parent[number - n];
                                change[x] = parent[number - 1];
                                x++;
                                change[x] = parent[number - n];
                                x++;
                            } else {
                                union(number, number - n);
                                union(number, number - 1);
                            }
                        } else if (id[number - n] > 0) {
                            union(number, number - n);
                        } else {
                            if (id[number - 1] > 0) {
                                union(number, number - 1);
                            } else {
                                parent[number] = amount;
                                amount++;
                            }
                        }
                    }
                }
            }
            for (int i = 1; i <= n; i++) {
                for (int j = 0; j <= n; j++) {
                    point(i, j);
                    for (int k = 0; k < x; k = k + 2) {
                        if (parent[number] == change[k + 1]) {
                            parent[number] = change[k];
                        }
                    }
                }
            }
            point(place[0], place[1]);
            System.out.println(parent[number]);
        }
    }
}

@5688b39f90c2826e8b438631036365a4@"
"r03525008","9","1.03","129184","@97ac7200741cd22edfeb5439ee371a8d@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by 其昌 on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args){

        try {

            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            String[] firstLine = br.readLine().split("","");
            int num = Integer.parseInt(firstLine[0]);
            int targetX = Integer.parseInt(firstLine[1]) - 1; // index 從0開始所以讀出座標之後要-1
            int targetY = Integer.parseInt(firstLine[2]) - 1;

            int labelCount = 1;
            int[][] labelCC = new int[num][num];

            HashMap<Integer,Integer> parentMap = new HashMap<Integer, Integer>();

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = -1;
                }
            }

            while (br.ready()){
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]) - 1; // index 從0開始所以讀出座標之後要-1
                int y = Integer.parseInt(coordinate[1]) - 1;
                labelCC[x][y] = 0;
            }
            br.close();

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    if(labelCC[i][j] != 0){
                        if(i==0 && j==0){
                            labelCC[i][j] = labelCount;
                        } else if(i == 0){
                            int labelLeft = labelCC[i][j-1];
                            labelCC[i][j] = (labelLeft != 0)? labelLeft : ++labelCount;
                        } else if(j == 0){
                            int labelTop = labelCC[i-1][j];
                            labelCC[i][j] = (labelTop != 0)? labelTop : ++labelCount;
                        } else {
                            int labelLeft = labelCC[i][j-1];
                            int labelTop = labelCC[i-1][j];
                            if(labelLeft == 0 && labelTop == 0){
                                labelCC[i][j] = ++labelCount;
                            } else if(labelLeft == 0) {
                                labelCC[i][j] = labelTop;
                            } else if(labelTop == 0) {
                                labelCC[i][j] = labelLeft;
                            } else {
                                labelCC[i][j] = labelLeft;
                                if(labelLeft != labelTop){
                                    int parent = labelTop < labelLeft? labelTop : labelLeft;
                                    int child = labelTop >= labelLeft? labelTop : labelLeft;
                                    parentMap.put(child,parent);
                                }
                            }
                        }
                    }
                }
            }



            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = getRoot(parentMap , labelCC[i][j]);
                }
            }


//            for(Map.Entry entry:parentMap.entrySet()){
//                System.out.println(entry.getKey() + "":"" + entry.getValue());
//            }
//            for(int i = 0 ; i < num ; i++){
//                for(int j = 0 ; j < num ; j++){
//                    System.out.print(labelCC[i][j]+""\t"");
//                }
//                System.out.println("""");
//            }


            System.out.println(labelCC[targetX][targetY]);



        } catch (IOException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }


    public static int getRoot(Map<Integer,Integer> map , int index){
        if(map.containsKey(index)){
            index = map.get(index);
            if(map.containsKey(index))
                index = map.get(index);
        }
        return index;
    }



}

@97ac7200741cd22edfeb5439ee371a8d@"
"r04945009","9","1.05","142608","@7cacd79f93db5b9c558ec20854d81de5@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 *
 * @author hung-wei
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String[] Line1 = br.readLine().split("","");
            int N = Integer.parseInt(Line1[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(Line1[1]);
            target[1] = Integer.parseInt(Line1[2]);
            boolean[][] matrix = new boolean[N+1][N+1];
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    matrix[i][j] = true;
                }
            }
            
            while (br.ready()){
                String[] data = br.readLine().split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                matrix[x][y] = false;
            }
            int[][] label = new int[N][N];
            int Count = 1;
            int Special[] = new int[N*N];
            Special[0] = 1;
            
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    if(matrix[i][j]){
                        if(!matrix[i][j-1] && !matrix[i-1][j]){
                            label[i-1][j-1] = Count;
                            Special[Count] = ++Count;
                        }    
                        else if(!matrix[i][j-1])
                            label[i-1][j-1] = label[i-2][j-1];
                        else if(!matrix[i-1][j])
                            label[i-1][j-1] = label[i-1][j-2];
                        else{
                            if(label[i-2][j-1] < label[i-1][j-2]){
                                label[i-1][j-1] = label[i-2][j-1];
                                Special[label[i-1][j-2]-1] = Special[label[i-2][j-1]-1];
                            }
                            else if(label[i-1][j-2] < label[i-2][j-1]){
                                label[i-1][j-1] = label[i-1][j-2];
                                Special[label[i-2][j-1]-1] = Special[label[i-1][j-2]-1];
                            }
                            else
                                label[i-1][j-1] = label[i-1][j-2];
                        } 
                    }
                }
            }
            for(int i=0; i<Count-1; i++){
                int j = i;
                while(Special[j] != j+1)
                    j = Special[j]-1;
                Special[i] = Special[j];
            }
            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    for(int k=2; k<Count; k++){
                        if(label[i][j] == k)
                            label[i][j] = Special[k-1];
                    }
                }
            }
            System.out.println(label[target[0]-1][target[1]-1]);
        }                 
    }
}

@7cacd79f93db5b9c558ec20854d81de5@"
"r03525008","9","0.97","124752","@65a58c8e031dd8dafb359c3fa0bafb0f@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by 其昌 on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args){

        try {

            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            String[] firstLine = br.readLine().split("","");
            int num = Integer.parseInt(firstLine[0]);
            int targetX = Integer.parseInt(firstLine[1]) - 1; // index 從0開始所以讀出座標之後要-1
            int targetY = Integer.parseInt(firstLine[2]) - 1;

            int labelCount = 1;
            int[][] labelCC = new int[num][num];

            int[] parents = new int[num*num];
            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = i;
            }

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = -1;
                }
            }

            while (br.ready()){
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]) - 1; // index 從0開始所以讀出座標之後要-1
                int y = Integer.parseInt(coordinate[1]) - 1;
                labelCC[x][y] = 0;
            }
            br.close();

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    if(labelCC[i][j] != 0){
                        if(i==0 && j==0){
                            labelCC[i][j] = labelCount;
                        } else if(i == 0){
                            int labelLeft = labelCC[i][j-1];
                            labelCC[i][j] = (labelLeft != 0)? labelLeft : ++labelCount;
                        } else if(j == 0){
                            int labelTop = labelCC[i-1][j];
                            labelCC[i][j] = (labelTop != 0)? labelTop : ++labelCount;
                        } else {
                            int labelLeft = labelCC[i][j-1];
                            int labelTop = labelCC[i-1][j];
                            if(labelLeft == 0 && labelTop == 0){
                                labelCC[i][j] = ++labelCount;
                            } else if(labelLeft == 0) {
                                labelCC[i][j] = labelTop;
                            } else if(labelTop == 0) {
                                labelCC[i][j] = labelLeft;
                            } else {
                                labelCC[i][j] = labelLeft;
                                if(labelLeft != labelTop){
                                    int leftRoot = getRoot(parents , labelLeft);
                                    int topRoot = getRoot(parents , labelTop);
                                    int parent = topRoot < leftRoot? topRoot : leftRoot;
                                    int child = topRoot >= leftRoot? topRoot : leftRoot;
                                    parents[child] = parent;
                                }
                            }
                        }
                    }
                }
            }



            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = getRoot(parents , labelCC[i][j]);
                }
            }

//            for(Map.Entry entry:parentMap.entrySet()){
//                System.out.println(entry.getKey() + "":"" + entry.getValue());
//            }


//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(i+"" "");
//            }
//            System.out.println("""");
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(parents[i]+"" "");
//            }
//            System.out.println("""");

//            for(int i = 0 ; i < num ; i++){
//                for(int j = 0 ; j < num ; j++){
//                    System.out.print(labelCC[i][j]+""\t"");
//                }
//                System.out.println("""");
//            }


            System.out.println(labelCC[targetX][targetY]);



        } catch (IOException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }



    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }




}

@65a58c8e031dd8dafb359c3fa0bafb0f@"
"r04945009","9","1.08","146768","@2b110e44c4f1c96b02bd1b48f8008f62@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 *
 * @author hung-wei
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String[] Line1 = br.readLine().split("","");
            int N = Integer.parseInt(Line1[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(Line1[1]);
            target[1] = Integer.parseInt(Line1[2]);
            boolean[][] matrix = new boolean[N+1][N+1];
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    matrix[i][j] = true;
                }
            }
            
            while (br.ready()){
                String[] data = br.readLine().split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                matrix[x][y] = false;
            }
            int[][] label = new int[N][N];
            int Count = 1;
            int Special[] = new int[N*N+1];
            Special[0] = 1;
            
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    if(matrix[i][j]){
                        if(!matrix[i][j-1] && !matrix[i-1][j]){
                            label[i-1][j-1] = Count;
                            Special[Count] = ++Count;
                        }    
                        else if(!matrix[i][j-1])
                            label[i-1][j-1] = label[i-2][j-1];
                        else if(!matrix[i-1][j])
                            label[i-1][j-1] = label[i-1][j-2];
                        else{
                            if(label[i-2][j-1] < label[i-1][j-2]){
                                label[i-1][j-1] = label[i-2][j-1];
                                Special[label[i-1][j-2]-1] = Special[label[i-2][j-1]-1];
                            }
                            else if(label[i-1][j-2] < label[i-2][j-1]){
                                label[i-1][j-1] = label[i-1][j-2];
                                Special[label[i-2][j-1]-1] = Special[label[i-1][j-2]-1];
                            }
                            else
                                label[i-1][j-1] = label[i-1][j-2];
                        } 
                    }
                }
            }
            for(int i=0; i<Count-1; i++){
                int j = i;
                while(Special[j] != j+1)
                    j = Special[j]-1;
                Special[i] = Special[j];
            }
            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    for(int k=2; k<Count; k++){
                        if(label[i][j] == k)
                            label[i][j] = Special[k-1];
                    }
                }
            }
            System.out.println(label[target[0]-1][target[1]-1]);
        }                 
    }
}

@2b110e44c4f1c96b02bd1b48f8008f62@"
"r03525008","9","0.96","125264","@99fa92d9a74768521442eb8dc536265c@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by 其昌 on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args){

        try {

            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            String[] firstLine = br.readLine().split("","");
            int num = Integer.parseInt(firstLine[0]);
            int targetX = Integer.parseInt(firstLine[1]) - 1; // index 從0開始所以讀出座標之後要-1
            int targetY = Integer.parseInt(firstLine[2]) - 1;

            int labelCount = 1;
            int[][] labelCC = new int[num][num];

            int[] parents = new int[num*num];
            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = i;
            }

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = -1;
                }
            }

            while (br.ready()){
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]) - 1; // index 從0開始所以讀出座標之後要-1
                int y = Integer.parseInt(coordinate[1]) - 1;
                labelCC[x][y] = 0;
            }
            br.close();

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    if(labelCC[i][j] != 0){
                        if(i==0 && j==0){
                            labelCC[i][j] = labelCount;
                        } else if(i == 0){
                            int labelLeft = labelCC[i][j-1];
                            labelCC[i][j] = (labelLeft != 0)? labelLeft : ++labelCount;
                        } else if(j == 0){
                            int labelTop = labelCC[i-1][j];
                            labelCC[i][j] = (labelTop != 0)? labelTop : ++labelCount;
                        } else {
                            int labelLeft = labelCC[i][j-1];
                            int labelTop = labelCC[i-1][j];
                            if(labelLeft == 0 && labelTop == 0){
                                labelCC[i][j] = ++labelCount;
                            } else if(labelLeft == 0) {
                                labelCC[i][j] = labelTop;
                            } else if(labelTop == 0) {
                                labelCC[i][j] = labelLeft;
                            } else {
                                labelCC[i][j] = labelLeft;
                                if(labelLeft != labelTop){
                                    int leftRoot = getRoot(parents , labelLeft);
                                    int topRoot = getRoot(parents , labelTop);
                                    int parent = labelTop < labelLeft? labelTop : labelLeft;
                                    int child = labelTop >= labelLeft? labelTop : labelLeft;
                                    parents[child] = parent;
                                    int parentRoot = topRoot < leftRoot? topRoot : leftRoot;
                                    int childRoot = topRoot >= leftRoot? topRoot : leftRoot;
                                    parents[childRoot] = parentRoot;
                                }
                            }
                        }
                    }
                }
            }



            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = getRoot(parents , labelCC[i][j]);
                }
            }



//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(i+"" "");
//            }
//            System.out.println("""");
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(parents[i]+"" "");
//            }
//            System.out.println("""");
//
//            for(int i = 0 ; i < num ; i++){
//                for(int j = 0 ; j < num ; j++){
//                    System.out.print(labelCC[i][j]+""\t"");
//                }
//                System.out.println("""");
//            }


            System.out.println(labelCC[targetX][targetY]);



        } catch (IOException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }



    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }




}

@99fa92d9a74768521442eb8dc536265c@"
"r04945009","9","1.07","142880","@b6aad3b4a0159b1f6458aabbe6e9036c@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 *
 * @author hung-wei
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String[] Line1 = br.readLine().split("","");
            int N = Integer.parseInt(Line1[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(Line1[1]);
            target[1] = Integer.parseInt(Line1[2]);
            boolean[][] matrix = new boolean[N+1][N+1];
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    matrix[i][j] = true;
                }
            }
            
            while (br.ready()){
                String[] data = br.readLine().split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                matrix[x][y] = false;
            }
            int[][] label = new int[N][N];
            int Count = 1;
            int Special[] = new int[N*N+1];
            Special[0] = 1;
            
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    if(matrix[i][j]){
                        if(!matrix[i][j-1] && !matrix[i-1][j]){
                            label[i-1][j-1] = Count;
                            Special[Count] = ++Count;
                        }    
                        else if(!matrix[i][j-1])
                            label[i-1][j-1] = label[i-2][j-1];
                        else if(!matrix[i-1][j])
                            label[i-1][j-1] = label[i-1][j-2];
                        else{
                            if(label[i-2][j-1] < label[i-1][j-2]){
                                label[i-1][j-1] = label[i-2][j-1];
                                Special[label[i-1][j-2]-1] = Special[label[i-2][j-1]-1];
                            }
                            else if(label[i-1][j-2] < label[i-2][j-1]){
                                label[i-1][j-1] = label[i-1][j-2];
                                Special[label[i-2][j-1]-1] = Special[label[i-1][j-2]-1];
                            }
                            else
                                label[i-1][j-1] = label[i-1][j-2];
                        } 
                    }
                }
            }
//            for(int i=0; i<Count-1; i++){
//                int j = i;
//                while(Special[j] != j+1)
//                    j = Special[j]-1;
//                Special[i] = Special[j];
//            }
            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    for(int k=2; k<Count; k++){
                        if(label[i][j] == k)
                            label[i][j] = Special[k-1];
                    }
                }
            }
            System.out.println(label[target[0]-1][target[1]-1]);
        }                 
    }
}

@b6aad3b4a0159b1f6458aabbe6e9036c@"
"r04945009","9","1.06","143136","@65d25fbf83e7893c286bd0f37b4b61b3@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 *
 * @author hung-wei
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String[] Line1 = br.readLine().split("","");
            int N = Integer.parseInt(Line1[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(Line1[1]);
            target[1] = Integer.parseInt(Line1[2]);
            boolean[][] matrix = new boolean[N+1][N+1];
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    matrix[i][j] = true;
                }
            }
            
            while (br.ready()){
                String[] data = br.readLine().split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                matrix[x][y] = false;
            }
            int[][] label = new int[N][N];
            int Count = 1;
            int Special[] = new int[N*N+1];
            Special[0] = 1;
            
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    if(matrix[i][j]){
                        if(!matrix[i][j-1] && !matrix[i-1][j]){
                            label[i-1][j-1] = Count;
                            Special[Count] = ++Count;
                        }    
                        else if(!matrix[i][j-1])
                            label[i-1][j-1] = label[i-2][j-1];
                        else if(!matrix[i-1][j])
                            label[i-1][j-1] = label[i-1][j-2];
                        else{
                            if(label[i-2][j-1] < label[i-1][j-2]){
                                label[i-1][j-1] = label[i-2][j-1];
                                Special[label[i-1][j-2]-1] = Special[label[i-2][j-1]-1];
                            }
                            else if(label[i-1][j-2] < label[i-2][j-1]){
                                label[i-1][j-1] = label[i-1][j-2];
                                Special[label[i-2][j-1]-1] = Special[label[i-1][j-2]-1];
                            }
                            else
                                label[i-1][j-1] = label[i-1][j-2];
                        } 
                    }
                }
            }

            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    for(int k=2; k<Count; k++){
                        if(label[i][j] == k)
                            label[i][j] = Special[k-1];
                    }
                }
            }
            System.out.println(label[target[0]-1][target[1]-1]);
        }                 
    }
}

@65d25fbf83e7893c286bd0f37b4b61b3@"
"b02611012","9","1","124048","@e1007149e31767083d9ae55fbc9d4980@
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up <= left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[left] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[up] = left;
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + x);

        }
    }

}

@e1007149e31767083d9ae55fbc9d4980@"
"b02611012","9","1","129904","@dcc6ee35739ec1a6477793aa290f8f20@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[left] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + x);

        }
    }

}

@dcc6ee35739ec1a6477793aa290f8f20@"
"r04921051","0","1.25","264256","@773a3824c5695394d8e3b106fd8b1427@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }
          
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
    for (int k = 0; k < 500;k++){
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            //System.out.println(dimension);
            //for (int i=0; i < len; i++)
            //System.out.printf(""(%d,%d)\n"",tree[i][0],tree[i][1]);
            
            
        
            for(int temp = 0; temp < len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
                
    }    
            print(dimension,matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@773a3824c5695394d8e3b106fd8b1427@"
"r04921051","0","2.93","277312","@de8953c98fda75dc2c2be8afb1c74b76@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }
          
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
    for (int k = 0; k < 5;k++){
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            //System.out.println(dimension);
            //for (int i=0; i < len; i++)
            //System.out.printf(""(%d,%d)\n"",tree[i][0],tree[i][1]);
            
            
        
            for(int temp = 0; temp < len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
                
    }    
            print(dimension,matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@de8953c98fda75dc2c2be8afb1c74b76@"
"r04921051","9","2.1","136192","@b1cdcf609e53c87c2ac3c776b7cb7f8a@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            
            
            // store the first integer in variable stringCount (number of announced strings)
            
            int dimension = Integer.parseInt(data[0]);
            int input_x = Integer.parseInt(data[1])-1;
            int input_y = Integer.parseInt(data[2])-1;
            
            
            String[] open_str;
            int[][] matrix = new int[dimension][dimension];
            
            for (int i=0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                 matrix[i][j] = -1;   
                }
            }
                   
            
            int x,y;
            

            while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1;
                matrix[x][y] = 0;                
                }
            
            
            int counter = 1;
            
            for(int i = 0; i < dimension; i++){
                for(int j = 0; j < dimension; j++){
                    if(matrix[i][j] == 0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0){
                        matrix[i][j] = matrix[i-1][j];     
                    }
                    else if(j != 0 && matrix[i][j-1] != 0)
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = counter;
                        counter++;
                    }
                        
                }
            }
          
            int len = 0;
            int[][] tree = new int[dimension*dimension][2];
            
    for (int k = 0; k < 5;k++){
            for(int i=0; i < dimension; i++){
                for(int j=1;j < dimension; j++){
                    if (matrix[i][j] == 0)
                        continue;
                    if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                        if(matrix[i][j] > matrix[i][j-1]){
                            tree[len][1] = matrix[i][j];
                            tree[len][0] = matrix[i][j-1];}
                        else{
                            tree[len][0] = matrix[i][j];
                            tree[len][1] = matrix[i][j-1];}
                        len++;
                    }
                }
            }
            
            //System.out.println(dimension);
            //for (int i=0; i < len; i++)
            //System.out.printf(""(%d,%d)\n"",tree[i][0],tree[i][1]);
            
            
        
            for(int temp = 0; temp < len; temp++){
            for(int i = 0;i < dimension; i++){
                for(int j = 0;j < dimension; j++){
                if(matrix[i][j] == tree[temp][1]){
                    matrix[i][j] = tree[temp][0];
                            
                }    
                }
            }
            }
            
                
    }    
            //print(dimension,matrix);
            
            
            System.out.println(matrix[input_x][input_y]);
            
            }            
            
    }
    
    
    public static void print(int dimension,int matrix[][]){
                for(int i =0; i < dimension; i++){

                for(int j=0; j < dimension; j++){
                    System.out.printf(""%d"",matrix[i][j]);
                    System.out.printf("","");
                }
                
                System.out.println("""");
            }    
    }
    
    
}

@b1cdcf609e53c87c2ac3c776b7cb7f8a@"
"r04631023","8","1","127984","@67b9889f19bf3abefd8a3cbc50b9af7e@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int label ;
            int labelconnect ;
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = 1;

            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    label = Label[N * (x - 1) + y - 1] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - N];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    label = Label[N * (x - 1) + y - N] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    label = Label[N * (x - 1) + y - 1] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - N];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    LabelConnect[label] = Label[N * (x - 1) + y - N];
                                    }
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    label = Label[N * (x - 1) + y - N] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    label = Label[N * (x - 1) + y - 1] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - N];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - N];                                
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    label = Label[N * (x - 1) + y - N] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    label = Label[N * (x - 1) + y - 1] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - N];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    label = Label[N * (x - 1) + y - N] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        }
                    }
                }
            }
            int next = 1 ;
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    while (LabelConnect[Label[N * (x - 1) + y]] != Label[N * (x - 1) + y]) {
                        next = Label[N * (x - 1) + y] ;
                        Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]];
                        if(LabelConnect[next] != LabelConnect[Label[N * (x - 1) + y]]){
                            LabelConnect[next] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }                        
                    }
                }
            }
            /*
            for (int i = 1, Cal = 0; i <= N * N; i++) {
                if (Cal == N - 1) {
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0;
                } else {
                    System.out.printf(""%d "", Label[i]);
                    Cal++;
                }
            }
            */
            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);

        }
    }
}

@67b9889f19bf3abefd8a3cbc50b9af7e@"
"b02611016","0","1.16","152832","@87c1a47ca16a1d89f577c772e40cd35f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
           // System.out.println(""-1"");
            break ;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break ;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                }
                else{
                id[cloumn-1]=label ;
                //   labelcount[label]=labelcount[label]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];}
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   }
                   }
                   }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                 for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
           /*for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                        for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");
                      break labelchange_1;
                      }
                  }
              }
           }*/
         }
     }
 }
          
          
          /*   for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }*/
             System.out.printf("" %d "", id[( x_position-1)*num+ y_position-1] );
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
             
             
             
             
             
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@87c1a47ca16a1d89f577c772e40cd35f@"
"b03611033","6","0.98","125536","@cdda70f4cf40ec9290f79a58c19d1a42@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public boolean[][] matrix;
    public int[][] root;
    public int parent[];
    public LabelCC(int n){
        matrix=new boolean[n][n];
        root=new int[n][n];
        parent=new int[n*n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                matrix[i][j]=true;
                root[i][j]=0;
                parent[i*n+j]=i*n+j;
            }
        }
    }
    
    public void blocked(int x,int y){
        matrix[x][y]=false;
        //StdOut.println(x+"",""+y);
    }
    public void firstrun(int n){
        int rootput=1;
        boolean stop=false;
        for(int j=0;j<n;j++){
            if(matrix[0][j]){
                root[0][j]=rootput;
                stop=true;
            }        
            else{
                if(stop){
                    rootput++;
                    stop=false;
                }
            }   
        }    
        for(int i=1;i<n;i++){
            
            for(int j=0;j<n;j++){
                
                if(matrix[i][j]){
                    if(j==0 || !matrix[i][j-1]){
                        if(matrix[i-1][j]){
                            root[i][j]=root[i-1][j];
                        }
                        else{
                            rootput++;
                            root[i][j]=rootput;
                        }
                    }
                    else{
                        root[i][j]=root[i][j-1];
                        if(matrix[i-1][j] & root[i-1][j]!=root[i][j-1]){
                            if(root[i-1][j]<root[i][j-1])
                                parent[root[i][j-1]]=root[i-1][j];
                            else
                                parent[root[i-1][j]]=root[i][j-1];
                        }
                    }
                     
                }
                
            }
        }
    
    }
    public int find(int x){
        while(x!=parent[x]){
            x=parent[parent[x]];
        }
        return x;
    }
    public void show(int n,int p,int q){
        
       int num=find(root[p][q]);
       StdOut.println(num);
       
       //StdOut.print(pa);
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            String datacut[];
            datacut = data.split("","");
            int N = Integer.parseInt(datacut[0]);  
            int fp = Integer.parseInt(datacut[1]);
            int fq = Integer.parseInt(datacut[2]);
            int p;
            int q;
            LabelCC labelCC = new LabelCC(N);
            
            while((data = br.readLine()) != null){
                datacut=data.split("","");
                p=Integer.parseInt(datacut[0]);
                q=Integer.parseInt(datacut[1]);
                labelCC.blocked(p-1,q-1);
                
            }
            labelCC.firstrun(N);
            labelCC.show(N,fp-1,fq-1);
        }        
    }        
}                


@cdda70f4cf40ec9290f79a58c19d1a42@"
"r04631023","8","1.02","129232","@7cfcf391e9d6f07d7f1035872cd300b8@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int label ;
            int labelconnect ;
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = 1;

            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    label = Label[N * (x - 1) + y - 1] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - N];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    label = Label[N * (x - 1) + y - N] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    label = Label[N * (x - 1) + y - 1] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - N];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;                                    
                                    }
                                    LabelConnect[label] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    label = Label[N * (x - 1) + y - N] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    label = Label[N * (x - 1) + y - 1] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - N];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - N];                                
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    label = Label[N * (x - 1) + y - N] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (Label[N * (x - 1) + y - N] <= Label[N * (x - 1) + y - 1]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    label = Label[N * (x - 1) + y - 1] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - N];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    label = Label[N * (x - 1) + y - N] ;
                                    while(labelconnect != label){
                                        LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                        label = labelconnect ;
                                        labelconnect = LabelConnect[labelconnect] ;
                                    }                                    
                                    LabelConnect[label] = Label[N * (x - 1) + y - 1];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        }
                    }
                }
            }
            int next = 1 ;
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    while (LabelConnect[Label[N * (x - 1) + y]] != Label[N * (x - 1) + y]) {
                        next = Label[N * (x - 1) + y] ;
                        Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]];
                        if(LabelConnect[next] != LabelConnect[Label[N * (x - 1) + y]]){
                            LabelConnect[next] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }                        
                    }
                }
            }
            /*
            for (int i = 1, Cal = 0; i <= N * N; i++) {
                if (Cal == N - 1) {
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0;
                } else {
                    System.out.printf(""%d "", Label[i]);
                    Cal++;
                }
            }
            */
            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);

        }
    }
}

@7cfcf391e9d6f07d7f1035872cd300b8@"
"r04945009","9","0.99","126128","@56ee7f7162c357f38a04756c59933b2d@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 *
 * @author hung-wei
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String[] Line1 = br.readLine().split("","");
            int N = Integer.parseInt(Line1[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(Line1[1]);
            target[1] = Integer.parseInt(Line1[2]);
            boolean[][] matrix = new boolean[N+1][N+1];
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    matrix[i][j] = true;
                }
            }
            
            while (br.ready()){
                String[] data = br.readLine().split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                matrix[x][y] = false;
            }
            int[][] label = new int[N][N];
            int Count = 1;
            int Special[] = new int[N*N+1];
            Special[0] = 0;
            
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    if(matrix[i][j]){
                        if(!matrix[i][j-1] && !matrix[i-1][j]){
                            label[i-1][j-1] = Count;
                            Special[Count] = Count++;
                        }    
                        else if(!matrix[i][j-1])
                            label[i-1][j-1] = label[i-2][j-1];
                        else if(!matrix[i-1][j])
                            label[i-1][j-1] = label[i-1][j-2];
                        else{
                            if(label[i-2][j-1] < label[i-1][j-2]){
                                label[i-1][j-1] = label[i-2][j-1];
                                Special[label[i-1][j-2]] = Special[label[i-2][j-1]];
                            }
                            else if(label[i-1][j-2] < label[i-2][j-1]){
                                label[i-1][j-1] = label[i-1][j-2];
                                Special[label[i-2][j-1]] = Special[label[i-1][j-2]];
                            }
                            else
                                label[i-1][j-1] = label[i-1][j-2];
                        } 
                    }
                }
            }
            for(int i=0; i<Count; i++){
                int j = i;
                while(Special[j] != j)
                    j = Special[j];
                Special[i] = Special[j];
            }
            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    label[i][j] = Special[label[i][j]];                    
                }
            }
            System.out.println(label[target[0]-1][target[1]-1]);
        }                 
    }
}

@56ee7f7162c357f38a04756c59933b2d@"
"b03611033","6","0.99","121488","@a2c9dbe72dc6277910ce52ca0e70ea34@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public boolean[][] matrix;
    public int[][] root;
    public int parent[];
    public LabelCC(int n){
        matrix=new boolean[n][n];
        root=new int[n][n];
        parent=new int[n*n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                matrix[i][j]=true;
                root[i][j]=0;
                parent[i*n+j]=i*n+j;
            }
        }
    }
    
    public void blocked(int x,int y){
        matrix[x][y]=false;
        //StdOut.println(x+"",""+y);
    }
    public void firstrun(int n){
        int rootput=1;
        boolean stop=false;
        for(int j=0;j<n;j++){
            if(matrix[0][j]){
                root[0][j]=rootput;
                stop=true;
            }        
            else{
                if(stop){
                    rootput++;
                    stop=false;
                }
            }   
        }    
        for(int i=1;i<n;i++){
            
            for(int j=0;j<n;j++){
                
                if(matrix[i][j]){
                    if(j==0 || !matrix[i][j-1]){
                        if(matrix[i-1][j]){
                            root[i][j]=root[i-1][j];
                        }
                        else{
                            rootput++;
                            root[i][j]=rootput;
                        }
                    }
                    else{
                        root[i][j]=root[i][j-1];
                        if(matrix[i-1][j] & root[i-1][j]!=root[i][j-1]){
                            if(root[i-1][j]<root[i][j-1])
                                parent[root[i][j-1]]=root[i-1][j];
                            else
                                parent[root[i-1][j]]=root[i][j-1];
                        }
                    }
                     
                }
                
            }
        }
    
    }
    public int find(int x){
        while(x!=parent[x]){
            x=parent[parent[x]];
        }
        return x;
    }
    public void show(int n,int p,int q){
        if(n==1){
            StdOut.println(1);
            return;
        }
       int num=find(root[p][q]);
       StdOut.println(num);
       
       //StdOut.print(pa);
    }
    
    
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            String datacut[];
            datacut = data.split("","");
            int N = Integer.parseInt(datacut[0]);  
            int fp = Integer.parseInt(datacut[1]);
            int fq = Integer.parseInt(datacut[2]);
            int p;
            int q;
            LabelCC labelCC = new LabelCC(N);
            
            while((data = br.readLine()) != null){
                datacut=data.split("","");
                p=Integer.parseInt(datacut[0]);
                q=Integer.parseInt(datacut[1]);
                labelCC.blocked(p-1,q-1);
                
            }
            labelCC.firstrun(N);
            labelCC.show(N,fp-1,fq-1);
        }        
    }        
}                


@a2c9dbe72dc6277910ce52ca0e70ea34@"
"r03525008","6","1.01","124784","@220867d230c6303d9eaeb4060676e00e@import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/15.
 */
public class LabelCC {
    public int dimension;
    public int target_x;
    public int target_y;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;
    public int label_count;


    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //    try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
                String[] first_row=br.readLine().split("","");

                int dimension=Integer.parseInt(first_row[0]);
                int target_x=Integer.parseInt(first_row[1]);
                int target_y=Integer.parseInt(first_row[2]);

            LabelCC labelCC=new LabelCC(dimension,target_x,target_y);
            String line;

            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                labelCC.close_point(x,y);
                //System.out.println(data[0]+"",""+data[1]);
            }
                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j]==null) {
                            labelCC.open_point(i, j);

                        }
                    }
                }
/*                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j].open) {

                            labelCC.nodes[i][j].showNodeinfo();
                        }
                    }
                }*/
            System.out.println(Integer.toString(labelCC.showLabel()));

          /*  for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public LabelCC(int dimension,int target_x,int target_y){
        this.dimension=dimension;
        this.target_x=target_x;
        this.target_y=target_y;
        this.nodes=new Node[dimension][dimension];
        label_count=0;
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
        if(A.root().label<=B.root().label)
            B.root().label=A.root().label;
        else
            A.root().label=B.root().label;
    }

    public void open_point(int x,int y){
        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        boolean add_label1,add_label2;

        nodes[x][y]=new Node(x+1,y+1,true,1,label_count);
        if(!(y<=0)) {
            if (nodes[x][y - 1].open) {
                this.Union(nodes[x][y], nodes[x][y - 1]);
                add_label1=false;
            }
            else
                add_label1=true;
        }
        else
            add_label1=true;

        if(!(x<=0)) {
            if (nodes[x - 1][y].open) {
                this.Union(nodes[x][y], nodes[x-1][y]);
                add_label2=false;
            }
            else
                add_label2=true;
        }
        else
            add_label2=true;
        if(add_label1&add_label2) {
            label_count++;
            nodes[x][y].label=label_count;
        }
    }
    public void close_point(int x,int y){
        nodes[x][y]=new Node(x+1,y+1,false,0,0);
    }

    public int showLabel(){
        return this.nodes[target_x-1][target_y-1].root().label;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;
        public int label;


        public Node(int x,int y,boolean open,int numberOfnode,int label){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
            this.label=label;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode)+""  ""+
                    ""label:""+Integer.toString(this.root().label));
        }

    }

}

@220867d230c6303d9eaeb4060676e00e@"
"r03525008","8","0.98","129888","@66834394649277e78813cc5a7ce267fb@import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/15.
 */
public class LabelCC {
    public int dimension;
    public int target_x;
    public int target_y;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;
    public int label_count;


    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           // try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
                String[] first_row=br.readLine().split("","");

                int dimension=Integer.parseInt(first_row[0]);
                int target_x=Integer.parseInt(first_row[1]);
                int target_y=Integer.parseInt(first_row[2]);

            LabelCC labelCC=new LabelCC(dimension,target_x,target_y);
            String line;

            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                labelCC.close_point(x,y);
                //System.out.println(data[0]+"",""+data[1]);
            }
                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j]==null) {
                            labelCC.open_point(i, j);

                        }
                    }
                }
/*                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j].open) {

                            labelCC.nodes[i][j].showNodeinfo();
                        }
                    }
                }*/
            System.out.println(Integer.toString(labelCC.showLabel()));

          /*  for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public LabelCC(int dimension,int target_x,int target_y){
        this.dimension=dimension;
        this.target_x=target_x;
        this.target_y=target_y;
        this.nodes=new Node[dimension][dimension];
        label_count=0;
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }
        if(A.root().label<=B.root().label)
            B.root().label=A.root().label;
        else
            A.root().label=B.root().label;
    }

    public void open_point(int x,int y){
        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        boolean add_label1,add_label2;

        nodes[x][y]=new Node(x+1,y+1,true,1,label_count);
        if(!(y<=0)) {
            if (nodes[x][y - 1].open) {
                this.Union(nodes[x][y-1], nodes[x][y]);
                add_label1=false;
            }
            else
                add_label1=true;
        }
        else
            add_label1=true;

        if(!(x<=0)) {
            if (nodes[x - 1][y].open) {
                this.Union(nodes[x-1][y], nodes[x][y]);
                add_label2=false;
            }
            else
                add_label2=true;
        }
        else
            add_label2=true;
        if(add_label1&add_label2) {
            label_count++;
            nodes[x][y].label=label_count;
        }
    }
    public void close_point(int x,int y){
        nodes[x][y]=new Node(x+1,y+1,false,0,0);
    }

    public int showLabel(){
        return this.nodes[target_x-1][target_y-1].root().label;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;
        public int label;


        public Node(int x,int y,boolean open,int numberOfnode,int label){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
            this.label=label;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode)+""  ""+
                    ""label:""+Integer.toString(this.root().label));
        }

    }

}

@66834394649277e78813cc5a7ce267fb@"
"r03525008","9","1","127440","@bf8c6830130d055b4e0a70538271df11@import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/15.
 */
public class LabelCC {
    public int dimension;
    public int target_x;
    public int target_y;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;
    public int label_count;


    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
       //     try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
                String[] first_row=br.readLine().split("","");

                int dimension=Integer.parseInt(first_row[0]);
                int target_x=Integer.parseInt(first_row[1]);
                int target_y=Integer.parseInt(first_row[2]);

            LabelCC labelCC=new LabelCC(dimension,target_x,target_y);
            String line;

            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                labelCC.close_point(x,y);
                //System.out.println(data[0]+"",""+data[1]);
            }
                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j]==null) {
                            labelCC.open_point(i, j);

                        }
                    }
                }
/*                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j].open) {

                            labelCC.nodes[i][j].showNodeinfo();
                        }
                    }
                }*/
            System.out.println(Integer.toString(labelCC.showLabel()));

          /*  for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public LabelCC(int dimension,int target_x,int target_y){
        this.dimension=dimension;
        this.target_x=target_x;
        this.target_y=target_y;
        this.nodes=new Node[dimension][dimension];
        label_count=0;
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if(A.root().label<=B.root().label)
                B.root().label=A.root().label;
            else
                A.root().label=B.root().label;

            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }

    }

    public void open_point(int x,int y){
        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        boolean add_label1,add_label2;

        nodes[x][y]=new Node(x+1,y+1,true,1,label_count);
        if(!(y<=0)) {
            if (nodes[x][y - 1].open) {
                this.Union(nodes[x][y-1], nodes[x][y]);
                add_label1=false;
            }
            else
                add_label1=true;
        }
        else
            add_label1=true;

        if(!(x<=0)) {
            if (nodes[x - 1][y].open) {
                this.Union(nodes[x-1][y], nodes[x][y]);
                add_label2=false;
            }
            else
                add_label2=true;
        }
        else
            add_label2=true;
        if(add_label1&add_label2) {
            label_count++;
            nodes[x][y].label=label_count;
        }
    }
    public void close_point(int x,int y){
        nodes[x][y]=new Node(x+1,y+1,false,0,0);
    }

    public int showLabel(){
        return this.nodes[target_x-1][target_y-1].root().label;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;
        public int label;


        public Node(int x,int y,boolean open,int numberOfnode,int label){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
            this.label=label;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode)+""  ""+
                    ""label:""+Integer.toString(this.root().label));
        }

    }

}

@bf8c6830130d055b4e0a70538271df11@"
"r04631023","9","1.02","130208","@3eec591e2290de4e7ea47c5de671d601@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int label;
            int labelconnect;
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = 1;

            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        }
                    }
                }
            }
            int next = 1;
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    while (LabelConnect[Label[N * (x - 1) + y]] != Label[N * (x - 1) + y]) {
                        Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]];
                    }
                }
            }
            /*
             for (int i = 1, Cal = 0; i <= N * N; i++) {
             if (Cal == N - 1) {
             System.out.printf(""%d\n"", Label[i]);
             Cal = 0;
             } else {
             System.out.printf(""%d "", Label[i]);
             Cal++;
             }
             }
             */
            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);

        }
    }
}
@3eec591e2290de4e7ea47c5de671d601@"
"r04228002","9","1.9","143616","@6a7fb72c0ab7b06bdbbe549ada65ab96@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.QuickUnionUF;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            String[] row1 = br.readLine().split("","");
            int SizeNum = Integer.parseInt(row1[0]);
            
            QuickUnionUF uf = new QuickUnionUF(SizeNum*SizeNum);
            int trow=Integer.parseInt(row1[1]);
            int tcol=Integer.parseInt(row1[2]);
            int tid= (trow-1)*SizeNum+tcol-1;
            //tid=51;
            
            ArrayList BlockedList = new ArrayList();
            for (int i = 0; i< i+1;i++){
                String[] row;
                try{
                    row = br.readLine().split("","");
                }
                catch(Exception e){
                    break;
                }
                
                //String[] row = br.readLine().split("","");
                int pr=Integer.parseInt(row[0]);
                int pc=Integer.parseInt(row[1]);
                /*
                if (pr==trow && pc==tcol){
                    System.out.println(0);
                    //break;
                }
                */
                int id = (pr-1)*SizeNum+pc-1;
                BlockedList.add(id);
            }
            
            
            //Start to union
            int[] RootList = new int[SizeNum*SizeNum];
            int MaxLabel=0;
            
            for (int i=0;i<SizeNum*SizeNum;i++){
                int up = i-SizeNum;
                int left = i-1;
                boolean up_blocked = BlockedList.contains(up);
                boolean left_blocked = BlockedList.contains(left);
            
                if (up < 0){
                    up_blocked=true ;
                }
                if (left%SizeNum == SizeNum-1 || left < 0){
                    left_blocked=true;
                }            
               
                if (BlockedList.contains(i)==false){
                    if (up_blocked==true){
                        if (left_blocked==true){
                            MaxLabel++;
                            RootList[i]=MaxLabel;
                        }
                        else{
                            uf.union(i, left);
                        }   
                    }
                    else{
                        if (left_blocked==true){
                            uf.union(i, up);
                        }
                        else{
                            int up_root = uf.find(up);
                            int left_root = uf.find(left);
                            if (up_root <= left_root){
                                uf.union(left,up);
                                uf.union(i,up);
                            }
                            else{
                                uf.union(up,left);
                                uf.union(i,left);
                            }
                        }
                    }
                }
                else{
                    continue;
                }     
            }
            
            int result=uf.find(tid);
            int result2 = RootList[result];
            //System.out.println(Arrays.toString(RootList));
            System.out.println(result2);
        }
    }
    
}

class Root{
    public int ID;
    public int Label;
    public Root(int id,int label){
        int ID;
        ID=id;
        this.ID=id;
        int Label;
        Label=label;
        this.Label=label;
    }
}

@6a7fb72c0ab7b06bdbbe549ada65ab96@"
"r03525008","9","0.98","127952","@546016c3763626d859a59571c5d1c381@import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/15.
 */
public class LabelCC {
    public int dimension;
    public int target_x;
    public int target_y;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;
    public int label_count;


    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
       //     try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
                String[] first_row=br.readLine().split("","");

                int dimension=Integer.parseInt(first_row[0]);
                int target_x=Integer.parseInt(first_row[1]);
                int target_y=Integer.parseInt(first_row[2]);

            LabelCC labelCC=new LabelCC(dimension,target_x,target_y);
            String line;

            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                labelCC.close_point(x,y);
                //System.out.println(data[0]+"",""+data[1]);
            }
                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j]==null) {
                            labelCC.open_point(i, j);

                        }
                    }
                }
/*                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j].open) {

                            labelCC.nodes[i][j].showNodeinfo();
                        }
                    }
                }*/
            System.out.println(Integer.toString(labelCC.showLabel()));

          /*  for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public LabelCC(int dimension,int target_x,int target_y){
        this.dimension=dimension;
        this.target_x=target_x;
        this.target_y=target_y;
        this.nodes=new Node[dimension][dimension];
        label_count=0;
    }
    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if(A.root().label<=B.root().label)
                B.root().label=A.root().label;
            else
                A.root().label=B.root().label;

            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }

    }

    public void open_point(int x,int y){
        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        boolean add_label1,add_label2;

        nodes[x][y]=new Node(x+1,y+1,true,1,label_count);
        if(!(y<=0)) {
            if (nodes[x][y - 1].open) {
                this.Union(nodes[x][y-1], nodes[x][y]);
                add_label1=false;
            }
            else
                add_label1=true;
        }
        else
            add_label1=true;

        if(!(x<=0)) {
            if (nodes[x - 1][y].open) {
                this.Union(nodes[x-1][y], nodes[x][y]);
                add_label2=false;
            }
            else
                add_label2=true;
        }
        else
            add_label2=true;
        if(add_label1&add_label2) {
            label_count++;
            nodes[x][y].label=label_count;
        }
    }
    public void close_point(int x,int y){
        nodes[x][y]=new Node(x+1,y+1,false,0,0);
    }

    public int showLabel(){
        if(this.target_x>dimension||this.target_y>dimension)
            return 0;
        else
        return this.nodes[target_x-1][target_y-1].root().label;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;
        public int label;


        public Node(int x,int y,boolean open,int numberOfnode,int label){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
            this.label=label;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode)+""  ""+
                    ""label:""+Integer.toString(this.root().label));
        }

    }

}

@546016c3763626d859a59571c5d1c381@"
"b01703032","9","1.01","123600","@d184bc5b504882dadffd617825fdd0bd@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

public class LabelCC {
    public static void main(String[] args){

        try {

            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            String[] firstLine = br.readLine().split("","");
            int num = Integer.parseInt(firstLine[0]);
            int targetX = Integer.parseInt(firstLine[1]) - 1; // index 從0開始所以讀出座標之後要-1
            int targetY = Integer.parseInt(firstLine[2]) - 1;

            int labelCount = 1;
            int[][] labelCC = new int[num][num];

            int[] parents = new int[num*num];
            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = i;
            }

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = -1; // 先把labelCC的值都設成-1不然預設值都會是0
                }
            }

            while (br.ready()){
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]) - 1; // index 從0開始所以讀出座標之後要-1
                int y = Integer.parseInt(coordinate[1]) - 1;
                labelCC[x][y] = 0; // 把檔案讀到座標的label設成0
             }
            br.close();

            // 開始填label
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    if(labelCC[i][j] != 0){
                        // 如果這格的label不是0的話才開始做事情
                        if(i==0 && j==0){
                            // 如果這格是(1,1)的話，label=1
                            labelCC[i][j] = labelCount;
                        } else if(i == 0){
                            // 如果這格是(1,X)的話，只檢查左邊
                            int labelLeft = labelCC[i][j-1];
                            labelCC[i][j] = (labelLeft != 0)? labelLeft : ++labelCount;
                        } else if(j == 0){
                            // 如果這格是(X,1)的話，只檢查上面
                            int labelTop = labelCC[i-1][j];
                            labelCC[i][j] = (labelTop != 0)? labelTop : ++labelCount;
                        } else {
                            // 其他格上面和左邊都要檢查
                            int labelLeft = labelCC[i][j-1];
                            int labelTop = labelCC[i-1][j];
                            if(labelLeft == 0 && labelTop == 0){
                                // 上面和左邊均為0的話，label = 下一組group
                                labelCC[i][j] = ++labelCount;
                            } else if(labelLeft == 0) {
                                // 左邊為0的話，label = 上面的label
                                labelCC[i][j] = labelTop;
                            } else if(labelTop == 0) {
                                // 上面為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                            } else {
                                // 均不為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                                if(labelLeft != labelTop){
                                    // 左邊和上面label不相等的話，建立parent和child的關係
                                    int leftRoot = getRoot(parents , labelLeft);
                                    int topRoot = getRoot(parents , labelTop);
                                    int parentRoot = topRoot < leftRoot? topRoot : leftRoot;
                                    int childRoot = topRoot >= leftRoot? topRoot : leftRoot;
                                    parents[childRoot] = parentRoot;
                                }
                            }
                        }
                    }
                }
            }


            // 把值改成parents裡面找到的root
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = getRoot(parents , labelCC[i][j]);
                }
            }


            System.out.println(labelCC[targetX][targetY]);



        } catch (IOException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }



    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }



}
@d184bc5b504882dadffd617825fdd0bd@"
"r04631023","9","1.02","125456","@58ead7ffec2e19957a8250396aff6397@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int label;
            int labelconnect;
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = 1;

            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        }
                    }
                }
            }
/*
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        while (LabelConnect[Label[N * (x - 1) + y]] != Label[N * (x - 1) + y]) {
                            Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]];
                        }
                    }

                }
            }
            /*

            for (int i = 1, Cal = 0; i <= N * N; i++) {
                if (Cal == N - 1) {
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0;
                } else {
                    System.out.printf(""%d "", Label[i]);
                    Cal++;
                }
            }
            */

            System.out.printf(""%d\n"", LabelConnect[Label[N * (Locationx - 1) + Locationy]]);

        }
    }
}

@58ead7ffec2e19957a8250396aff6397@"
"r04631023","9","1.05","125536","@5a84415d397d25a3e0b64aa1122866c8@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int label;
            int labelconnect;
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = 1;

            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        }
                    }
                }
            }

            int next = 1 ;
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    while (LabelConnect[Label[N * (x - 1) + y]] != Label[N * (x - 1) + y]) {
                        next = Label[N * (x - 1) + y] ;
                        Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]];
                        if(LabelConnect[next] != LabelConnect[Label[N * (x - 1) + y]]){
                            LabelConnect[next] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }                        
                    }
                }
            }
            /*

            for (int i = 1, Cal = 0; i <= N * N; i++) {
                if (Cal == N - 1) {
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0;
                } else {
                    System.out.printf(""%d "", Label[i]);
                    Cal++;
                }
            }
            */

            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);

        }
    }
}
@5a84415d397d25a3e0b64aa1122866c8@"
"r03525008","9","1.01","127648","@5f12971f0b83a73da319c17eaff10820@import java.io.BufferedReader;
import java.io.FileReader;
/**
 * Created by User on 2016/3/15.
 */
public class LabelCC {
    public int dimension;
    public int target_x;
    public int target_y;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;
    public int label_count;


    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
        //    try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
                String[] first_row=br.readLine().split("","");

                int dimension=Integer.parseInt(first_row[0]);
                int target_x=Integer.parseInt(first_row[1]);
                int target_y=Integer.parseInt(first_row[2]);

            LabelCC labelCC=new LabelCC(dimension,target_x,target_y);
            String line;

            while ((line=br.readLine())!=null) {
                String[] data = line.split("","");
                int x=Integer.parseInt(data[0]);
                int y=Integer.parseInt(data[1]);
                x=x-1;y=y-1;
                labelCC.close_point(x,y);
                //System.out.println(data[0]+"",""+data[1]);
            }
                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j]==null) {
                            labelCC.open_point(i, j);

                        }
                    }
                }
/*                for(int i=0;i<dimension;i++){
                    for(int j=0;j<dimension;j++){
                        if(labelCC.nodes[i][j].open) {

                            labelCC.nodes[i][j].showNodeinfo();
                        }
                    }
                }*/
            System.out.println(Integer.toString(labelCC.showLabel()));

          /*  for(int i=0; i<dimension;i++){
                for(int j=0;j<dimension;j++){
                    if(percolation.nodes[i][j]!=null)
                    percolation.nodes[i][j].showNodeinfo();
                }
            }*/


/*            if(percolation.isConnect())
                System.out.println(""Connected"");
            else
                System.out.println(""Disconnected"");*/

            br.close();
        }
    }


    public LabelCC(int dimension,int target_x,int target_y){
        this.dimension=dimension;
        this.target_x=target_x;
        this.target_y=target_y;
        this.nodes=new Node[dimension][dimension];
        label_count=0;
    }
/*    public void Union(Node A,Node B){
        if(A.root()!=B.root()) {
            if(A.root().label<=B.root().label)
                B.root().label=A.root().label;
            else
                A.root().label=B.root().label;

            if (B.root().numberOfnode > A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }

    }*/
    public  void  Union(Node A,Node B){
        if(A.root()!=B.root()){
            if(A.root().label<=B.root().label)
                B.root().parent=A.root();
            else
                A.root().parent=B.root();
        }
    }

    public void open_point(int x,int y){
        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        boolean add_label1,add_label2;

        nodes[x][y]=new Node(x+1,y+1,true,1,label_count);
        if(!(y<=0)) {
            if (nodes[x][y - 1].open) {
                this.Union(nodes[x][y-1], nodes[x][y]);
                add_label1=false;
            }
            else
                add_label1=true;
        }
        else
            add_label1=true;

        if(!(x<=0)) {
            if (nodes[x - 1][y].open) {
                this.Union(nodes[x-1][y], nodes[x][y]);
                add_label2=false;
            }
            else
                add_label2=true;
        }
        else
            add_label2=true;
        if(add_label1&add_label2) {
            label_count++;
            nodes[x][y].label=label_count;
        }
    }
    public void close_point(int x,int y){
        nodes[x][y]=new Node(x+1,y+1,false,0,0);
    }

    public int showLabel(){
        if(this.target_x>dimension||this.target_y>dimension)
            return 0;
        else
        return this.nodes[target_x-1][target_y-1].root().label;
    }


    public static class Node {
        public int x,y;
        public Node parent;
        public boolean open;
        public int numberOfnode;
        public int label;


        public Node(int x,int y,boolean open,int numberOfnode,int label){
            this.x=x;
            this.y=y;
            this.parent=this;
            this.open=open;
            this.numberOfnode=numberOfnode;
            this.label=label;
        }
        public Node root(){
            if(this.parent==this){
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            }
            else{
                return this.parent.root();
            }
        }
        public void showNodeinfo(){
            System.out.println(""pos:""+Integer.toString(x)+"",""+Integer.toString(y)+""  ""+String.valueOf(open)+""  ""+
                    ""par:""+Integer.toString(parent.x)+"",""+Integer.toString(parent.y)+""  ""+""root:""+Integer.toString(this.root().parent.x)+
                    "",""+Integer.toString(this.root().parent.y)+""  ""+""numberOfnode:""+Integer.toString(this.root().numberOfnode)+""  ""+
                    ""label:""+Integer.toString(this.root().label));
        }

    }

}

@5f12971f0b83a73da319c17eaff10820@"
"r04631023","9","0.99","128688","@1614db63facbe1c6b439c068320df519@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int label;
            int labelconnect;
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = 1;

            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                    LabelConnect[labelconnect] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                    LabelConnect[labelconnect] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                    LabelConnect[labelconnect] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                    LabelConnect[labelconnect] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                    LabelConnect[labelconnect] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                    LabelConnect[labelconnect] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                if (LabelConnect[Label[N * (x - 1) + y - N]] <= LabelConnect[Label[N * (x - 1) + y - 1]]) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - 1]] ;
                                    LabelConnect[Label[N * (x - 1) + y - 1]] = LabelConnect[Label[N * (x - 1) + y - N]];
                                    LabelConnect[labelconnect] = LabelConnect[Label[N * (x - 1) + y - N]];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    labelconnect = LabelConnect[Label[N * (x - 1) + y - N]] ;
                                    LabelConnect[Label[N * (x - 1) + y - N]] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                    LabelConnect[labelconnect] = LabelConnect[Label[N * (x - 1) + y - 1]];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        }
                    }
                }
            }

            int next = 1 ;
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    while (LabelConnect[Label[N * (x - 1) + y]] != Label[N * (x - 1) + y]) {
                        next = Label[N * (x - 1) + y] ;
                        Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]];
                        if(LabelConnect[next] != LabelConnect[Label[N * (x - 1) + y]]){
                            LabelConnect[next] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }                        
                    }
                }
            }
            
/*
            for (int i = 1, Cal = 0; i <= N * N; i++) {
                if (Cal == N - 1) {
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0;
                } else {
                    System.out.printf(""%d "", Label[i]);
                    Cal++;
                }
            }
            */

            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);

        }
    }
}

@1614db63facbe1c6b439c068320df519@"
"r03525006","2","0.54","104928","@5bfe20ca66c69c9337ab559c8baca3f4@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j-1];
                                if (leftId != -1) {
                                    id[i][j] = id[i][j - 1];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    }
                    else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = leftId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }

                            }
                        }

                    }

                }

            }
//            for (int j = 0; j < num; j++) {
//                for (int i = 0; i < num; i++) {
//                    System.out.print(id[j][i] + "" "");
//                }
//                System.out.println("" "");
//            }

//            System.out.println(idChange.get(2));

            int[] parents = new int[num-1];
            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + "" "");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
            if (targetId != parents[targetId-1])
                System.out.println(parents[targetId-1]);
            else
                System.out.println(targetId);
        }
    }

}
@5bfe20ca66c69c9337ab559c8baca3f4@"
"r03525006","2","0.51","105168","@afea2fc5e34a7c6ab9b6788e4ac18d50@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j-1];
                                if (leftId != -1) {
                                    id[i][j] = id[i][j - 1];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    }
                    else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = leftId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }

                            }
                        }

                    }

                }

            }
//            for (int j = 0; j < num; j++) {
//                for (int i = 0; i < num; i++) {
//                    System.out.print(id[j][i] + "" "");
//                }
//                System.out.println("" "");
//            }

//            System.out.println(idChange.get(2));

            int[] parents = new int[num-1];
            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + "" "");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
            if (targetId != parents[targetId-1]) {
                System.out.println(parents[targetId - 1]);
            } else if (targetId == -1 ) {
                System.out.println(0);
            } else {
                System.out.println(targetId);
            }
        }
    }
}
@afea2fc5e34a7c6ab9b6788e4ac18d50@"
"r03525006","2","0.53","105296","@3908f86a1bcaa35c8e8a503a2f0ab40e@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j-1];
                                if (leftId != -1) {
                                    id[i][j] = id[i][j - 1];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    }
                    else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = leftId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }

                            }
                        }

                    }

                }

            }
//            for (int j = 0; j < num; j++) {
//                for (int i = 0; i < num; i++) {
//                    System.out.print(id[j][i] + "" "");
//                }
//                System.out.println("" "");
//            }

//            System.out.println(idChange.get(2));

            int[] parents = new int[num-1];
            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + "" "");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
            if (targetId != -1) {
                if (targetId != parents[targetId-1]) {
                    System.out.println(parents[targetId - 1]);
                } else {
                    System.out.println(targetId);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@3908f86a1bcaa35c8e8a503a2f0ab40e@"
"b02611016","0","1.16","153648","@df497fb68c0cea088c975aa1dff3bf84@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
           // System.out.println(""-1"");
            break ;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break ;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                }
                else{
                id[cloumn-1]=label ;
                //   labelcount[label]=labelcount[label]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];}
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   }
                   }
                   }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                 for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
           /*for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                        for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");
                      break labelchange_1;
                      }
                  }
              }
           }*/
         }
     }
 }
          
          
          /*   for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }*/
             System.out.printf("" %d "", id[( x_position-1)*num+ y_position-1] );
             System.out.println("""");
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
             
             
             
             
             
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@df497fb68c0cea088c975aa1dff3bf84@"
"r04546014","9","0.99","124912","@985a721ecccaef0c384d0d37aae62cd2@import java.io.BufferedReader;
import java.io.FileReader;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author Jayden
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] title = new String[3];
            title = br.readLine().split("","");
            int num = Integer.valueOf(title[0]);
            int x = Integer.valueOf(title[1]);
            int y = Integer.valueOf(title[2]);
            byte[][] matrix = new byte[num][num];
            int[][] matrixOutput = new int[num][num];
            int familyArrayCount = (int) num * num / 2;
            int[] family = new int[familyArrayCount];
            String[] input = new String[2];
            int a, b;
            //a,b是用來存取使用者輸入的兩個數字
            if (br.ready() == false) {
                System.out.println(1);
                System.exit(0);
                //當什麼資料都沒有時，下方的所有格子一定connect，因此回傳1
            }
            if (num == 1 && br.ready() == true) {
                System.out.println(0);
                System.exit(0);
                //如果是1*1的矩陣，且下方有顯示格子，則表示該格為黑色，因此回傳0
            }
            while (br.ready() == true) {
                input = br.readLine().split("","");
                a = Integer.valueOf(input[0]);
                b = Integer.valueOf(input[1]);
                matrix[a - 1][b - 1] = 1;
                //1代表黑色，0代表白色
            }

            for (int i = 0; i < familyArrayCount; i++) {
                family[i] = i;
            }
            int kk = 1;
            //kk只是用來寫入第一個phase的陣列裡的數字
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    //兩層for迴圈用來跑矩陣裡的每一個數字，當該數字是0則進入下面的if
                    if (matrix[i][j] == 0) {
                        if (i == 0 && j == 0) {
                            matrixOutput[i][j] = kk;
                            kk++;
                            //最左上角的特例
                        } else if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                                //該數字前方數字若有值，則跟他一樣
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                                //前方數字沒有值，就自己寫入一個新的值kk
                            }
                            //第一列的情況
                        } else if (j == 0) {
                            if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                                //該數字上方數字若有值，則跟他一樣
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                                //上方數字沒有值，就自己寫入一個新的值kk
                            }
                            //第一行的情況
                        } //上面三個是將三種例外情形先解決(包含左上方那格，以及第一行及第一列的數)
                        else {
                            if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = Math.min(matrixOutput[i - 1][j], matrixOutput[i][j - 1]);
                                int min = matrixOutput[i][j];
                                int max = Math.max(matrixOutput[i - 1][j], matrixOutput[i][j - 1]);
                                family[max] = min;
                                //若上方和前方都有值，則取最小的
                            } else if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                                //只有上方有值，就跟他一樣
                            } else if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                                //只有前方有值，就跟他一樣
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                                //上方前方都沒有值，就自己寫入一個新的值kk
                            }
                        }
                    }
                }
            }
            if (matrix[x - 1][y - 1] == 1) {
                System.out.println(0);
            } else {
                System.out.println(family[matrixOutput[x - 1][y - 1]]);
            }
        }
        //first phase
    }

}

@985a721ecccaef0c384d0d37aae62cd2@"
"b02611012","9","1.01","129696","@19bde6513984b6c9888da1554d4ef984@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    if( id[left]!=left){
while(id[left] != id[ id[left]]){
id[left] = id[ id[left]];
}
 
}
			id[left] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
  if( id[up]!=up){
while(id[up] != id[ id[up]]){
id[up] = id[ id[up]];
}
 
}
                                   
 id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + x);

        }
    }

}
@19bde6513984b6c9888da1554d4ef984@"
"b02611012","8","0.74","124544","@02ab31d0523b10771b8626a268a2df8a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    if( id[left]!=left){
while(id[left] != id[ id[left]]){
id[left] = id[ id[left]];
}
 
}
			id[id[left]] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
  if( id[up]!=up){
while(id[up] != id[ id[up]]){
id[up] = id[ id[up]];
}
 
}
                                   
 id[id[up]] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + x);

        }
    }

}
@02ab31d0523b10771b8626a268a2df8a@"
"r04546014","9","0.97","122592","@0df021201a92af106526da120db7944e@
import java.io.BufferedReader;
import java.io.FileReader;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Jayden
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] title = new String[3];
            title = br.readLine().split("","");
            int num = Integer.valueOf(title[0]);
            int x = Integer.valueOf(title[1]);
            int y = Integer.valueOf(title[2]);
            byte[][] matrix = new byte[num][num];
            int[][] matrixOutput = new int[num][num];
            int familyArrayCount = (int) num * num / 2;
            int[] family = new int[familyArrayCount];
            String[] input = new String[2];
            int a, b;
            //a,b是用來存取使用者輸入的兩個數字
            if (br.ready() == false) {
                System.out.println(1);
                System.exit(0);
                //當什麼資料都沒有時，下方的所有格子一定connect，因此回傳1
            }

            while (br.ready() == true) {
                input = br.readLine().split("","");
                a = Integer.valueOf(input[0]);
                b = Integer.valueOf(input[1]);
                matrix[a - 1][b - 1] = 1;
                //1代表黑色，0代表白色
            }
            if (matrix[x - 1][y - 1] == 1) {
                System.out.println(0);
                System.exit(0);
                //在這裡直接先檢查一次是否該值為黑色，若是的話就直接斷點，無須繼續做
            }

            for (int i = 0; i < familyArrayCount; i++) {
                family[i] = i;
            }
            int kk = 1;
            //kk只是用來寫入第一個phase的陣列裡的數字
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    //兩層for迴圈用來跑矩陣裡的每一個數字，當該數字是0則進入下面的if
                    if (matrix[i][j] == 0) {
                        if (i == 0 && j == 0) {
                            matrixOutput[i][j] = kk;
                            kk++;
                            //最左上角的特例
                        } else if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                                //該數字前方數字若有值，則跟他一樣
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                                //前方數字沒有值，就自己寫入一個新的值kk
                            }
                            //第一列的情況
                        } else if (j == 0) {
                            if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                                //該數字上方數字若有值，則跟他一樣
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                                //上方數字沒有值，就自己寫入一個新的值kk
                            }
                            //第一行的情況
                        } //上面三個是將三種例外情形先解決(包含左上方那格，以及第一行及第一列的數)
                        else {
                            if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = Math.min(matrixOutput[i - 1][j], matrixOutput[i][j - 1]);
                                int min = matrixOutput[i][j];
                                int max = Math.max(matrixOutput[i - 1][j], matrixOutput[i][j - 1]);
                                family[max] = min;
                                //若上方和前方都有值，則取最小的
                            } else if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                                //只有上方有值，就跟他一樣
                            } else if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                                //只有前方有值，就跟他一樣
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                                //上方前方都沒有值，就自己寫入一個新的值kk
                            }
                        }
                    }
                }
            }
            System.out.println(family[matrixOutput[x - 1][y - 1]]);
        }
    }
}

@0df021201a92af106526da120db7944e@"
"b02611012","0","1.01","129696","@a221036e6c4de4aa4639deda67363ea5@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    if( id[left]!=left){
int root = left;
while(id[root] != id[ id[root]]){
id[root] = id[ id[root]];
}
 
}
			id[id[root]] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
  if( id[up]!=up){
int root = up;
while(id[ root ] != id[ id[ root ]]){
id[ root ] = id[ id[ root ]];
}
 
}
                                   
 id[id[ root ]] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + x);

        }
    }

}
@a221036e6c4de4aa4639deda67363ea5@"
"b02611016","0","1.19","156448","@cc060183258ada87eb355e188a120aa4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
           // System.out.println(""-1"");
            break ;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break ;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                }
                else{
                id[cloumn-1]=label ;
                //   labelcount[label]=labelcount[label]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];}
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   }
                   }
                   }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                 for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
           /*for(int n=0;n<num;n++)
           {if(count[n]==1)
              {for(int p=0;p<num;p++)
                  {if(id[n]==id[(num-1)*num+p])
                      {System.out.printf(""%d,%d\n"",  row,cloumn );
                      
                        for(int q=0;q<num;q++){
                        System.out.printf(""count %d,"", count[q] );
                         }
                       System.out.println("""");
                      break labelchange_1;
                      }
                  }
              }
           }*/
         }
     }
 }
          
          
            /* for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
             System.out.println("""");
             
         }
          else{
             System.out.printf("" %d "", id[(x_position-1)*num+y_position-1] );
             System.out.println("""");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
             
             
             
             
             
         //   br.close();
     //       for(int j=0 ;j<3;j++ )
      //      {for(int k=0;k<3;k++)
      //      { System.out.println( matrix[j][k]);
      //      }}
            
        
            // printf in Java (you should comment out or delete this in your final submission)
         //   System.out.printf(""number of announced strings: dimension of matrix: %d x %d\n"",  num, num);

            /*  now you can write your own solution to hw0
             *  you can follow the instruction described below:
             * 
             *  1. read the rest content of the file
             *  2. store the announce strings (2nd line of the file) in variable announce
             *  3. store the matrix (from the 3rd line to the end of the file) in variable matrix
             *  4. compare the matrix and announce strings (this is the tricky part)
             *  5. output how many 'straight line' are there in the matrix
             * 
             *  [note]
             *  you can use every data structure in standard Java packages (Java 8 supported)
             *  the packages in stdlib.jar and algs4.jar are also available for you to use
             *
             *  [hint]
             *  1. you should check whether Java pass the variable by references or by values.
             *  2. some data structure such as HashSet, HashMap, Arrays, ArrayList, Vector are very
             *     useful for solving problems. 
             */
        }
    }
}


@cc060183258ada87eb355e188a120aa4@"
"b02611016","0","1.16","160304","@94e649fe5e239578dac69859b5365f13@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
           // System.out.println(""-1"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""-1"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                }
                else{
                id[cloumn-1]=label ;
                //   labelcount[label]=labelcount[label]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];}
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   }
                   }
                   }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                 for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
       
         }
     }
 }
            /* for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
             
         }
          else{
             System.out.printf("" %d "", id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@94e649fe5e239578dac69859b5365f13@"
"b02611016","9","1.16","158960","@666fa8ab1fad9d04fbb2c474a8d4fb3f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
           // System.out.println(""-1"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {//System.out.println(""-1"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                }
                else{
                id[cloumn-1]=label ;
                //   labelcount[label]=labelcount[label]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];}
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   }
                   }
                   }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                 for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
       
         }
     }
 }
            /* for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"", id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@666fa8ab1fad9d04fbb2c474a8d4fb3f@"
"r04228002","10","0.19","144864","@a512efbfa1d09cf8c5afd73375ab41ed@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.ArrayList;
//import edu.princeton.cs.algs4.QuickUnionUF;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            String[] row1 = br.readLine().split("","");
            int SizeNum = Integer.parseInt(row1[0]);
            
            //int[] LabelManage = new int[SizeNum*SizeNum];
            QuickUnionUF uf = new QuickUnionUF(SizeNum*SizeNum);
            int trow=Integer.parseInt(row1[1]);
            int tcol=Integer.parseInt(row1[2]);
            int tid= (trow-1)*SizeNum+tcol-1;
            //tid=51;
            
            ArrayList BlockedList = new ArrayList();
            for (int i = 0; i< i+1;i++){
                String[] row;
                try{
                    row = br.readLine().split("","");
                }
                catch(Exception e){
                    break;
                }
                
                //String[] row = br.readLine().split("","");
                int pr=Integer.parseInt(row[0]);
                int pc=Integer.parseInt(row[1]);
                /*
                if (pr==trow && pc==tcol){
                    System.out.println(0);
                    //break;
                }
                */
                int id = (pr-1)*SizeNum+pc-1;
                BlockedList.add(id);
            }
            
            
            //Start to union
            int[] LabelList = new int[SizeNum*SizeNum];
            int MaxLabel=0;
            
            for (int i=0;i<SizeNum*SizeNum;i++){
                int up = i-SizeNum;
                int left = i-1;
                boolean up_blocked = BlockedList.contains(up);
                boolean left_blocked = BlockedList.contains(left);
            
                if (up < 0){
                    up_blocked=true ;
                }
                if (left%SizeNum == SizeNum-1 || left < 0){
                    left_blocked=true;
                }            
               
                if (BlockedList.contains(i)==false){
                    if (up_blocked==true){
                        if (left_blocked==true){
                            MaxLabel++;
                            LabelList[i]=MaxLabel;
                        }
                        else{
                            LabelList[i]=LabelList[left];
                        }   
                    }
                    else{
                        if (left_blocked==true){
                            LabelList[i]=LabelList[up];
                        }
                        else{
                            int up_label=LabelList[up];
                            int left_label=LabelList[left];
                            
                            if (up_label <= left_label){
                                //LabelManage[left_label]=up_label;
                                uf.union(left_label,up_label);
                                LabelList[i]=LabelList[up];
                            }
                            else{
                                //LabelManage[up_label]=left_label;
                                uf.union(up_label,left_label);
                                LabelList[i]=LabelList[left];
                            }
                            
                        }
                    }
                }
                else{
                    continue;
                }     
            }
            
            int result_index=LabelList[tid];
            int result=uf.find(result_index);
            //int result = LabelManage[result_index];
            //System.out.println(Arrays.toString(LabelList));
            //System.out.println(Arrays.toString(LabelManage));
            //System.out.println(result_index);
            System.out.println(result);
        }
    }
    
}

class Root{
    public int ID;
    public int Label;
    public Root(int id,int label){
        int ID;
        ID=id;
        this.ID=id;
        int Label;
        Label=label;
        this.Label=label;
    }
}

@a512efbfa1d09cf8c5afd73375ab41ed@"
"b02611016","9","1.16","155120","@97a6389a77a2f52759a066468cc8bbb2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                }
                else{
                id[cloumn-1]=label ;
                //   labelcount[label]=labelcount[label]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];}
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   }
                   }
                   }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                 for(int u=0;u<(row-1)*num+cloumn-1;u++)
                   {if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
       
         }
     }
 }
            /* for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"", id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@97a6389a77a2f52759a066468cc8bbb2@"
"r03522826","9","1.09","169712","@89a1134d6a22492061f301b467d33d5f@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader (new FileReader (args[0]))){
        
            // Initialization & Read first line
            String [] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);         // Dimension
            int x0 = Integer.parseInt(data[1]);
            int y0 = Integer.parseInt(data[2]);
            int [][] check = new int [N][N];
            String d;
            
            for (int i = 0; i < N; i++){
                for(int j = 0; j < N; j++)
                    check[i][j] = 1;
            }
//            System.out.println(N);
//            System.out.println(x0);
//            System.out.println(y0);
            
            // Readfile the other lines
            while((d = br.readLine()) != null){
                d = d.replaceAll("" "", """");
                String [] data1 = d.split("","");
                int x = Integer.parseInt(data1[0]);
                int y = Integer.parseInt(data1[1]);
                
                check[x-1][y-1] = 0;
                
            }
            
        int label = 1;
        UF uf = new UF(N*N+1);
        int p = 0, q = 0;
        for(int i = 0; i < N; i++)
        {
            for(int j = 0; j < N; j++)
            {
                if(0 != check[i][j])
                {
                    if (0 == i)
                    {
                        if (0 == j)
                            check[i][j] = label++;
                        else
                        {
                            if (0 == check[i][j-1])
                                check[i][j] = label++;
                            else
                                check[i][j] = check[i][j-1];
                        }
                    }
                    else
                    {
                        if (0 == j)
                        {
                            if (0 == check[i-1][j])
                                check[i][j] = label++;
                            else
                                check[i][j] = check[i-1][j];
                        }
                        else
                        {
                            if (0 == check[i-1][j])
                            {
                                if (0 == check[i][j-1])
                                    check[i][j] = label++;
                                else
                                    check[i][j] = check[i][j-1];
                            }
                            else
                            {
                                if (0 == check[i][j-1])
                                    check[i][j] = check[i-1][j];
                                else
                                {
                                    if (check[i][j-1] <= check[i-1][j])
                                    {
                                        check[i][j] = check[i][j-1];
//                                        p = check[i][j-1];
//                                        q = check[i-1][j];
                                        uf.union(check[i][j-1],check[i-1][j]);
                                    }
                                    else
                                    {
                                        check[i][j] = check[i-1][j];
                                        uf.union(check[i-1][j],check[i][j-1]);
                                    }
                                }
                            }
                        }
                            
                    }
                    
                }
                
            }
        }
        
//        for (int i = 0; i < N; i++)
//        {
//            for (int j = 0; j <N; j++)
//                System.out.println(check[i][j]);
//        }
//            System.out.println(label);
//        
        
            for (int i =0; i < N; i++)
            {
                for (int j = 0; j < N; j++)
                {
                    if(0 != check[i][j])
                        check[i][j] = uf.find(check[i][j]);
                }
            }
            
            System.out.println(check[x0-1][y0-1]);
        }
    }
    
}
@89a1134d6a22492061f301b467d33d5f@"
"r03522826","6","0.55","105520","@d8e7ea8aa9bcf899bccab68de66b28d9@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader (new FileReader (args[0]))){
        
            // Initialization & Read first line
            String [] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);         // Dimension
            int x0 = Integer.parseInt(data[1]);
            int y0 = Integer.parseInt(data[2]);
            int [][] check = new int [N][N];
            String d;
            
            for (int i = 0; i < N; i++){
                for(int j = 0; j < N; j++)
                    check[i][j] = 1;
            }
//            System.out.println(N);
//            System.out.println(x0);
//            System.out.println(y0);
            
            // Readfile the other lines
            while((d = br.readLine()) != null){
                d = d.replaceAll("" "", """");
                String [] data1 = d.split("","");
                int x = Integer.parseInt(data1[0]);
                int y = Integer.parseInt(data1[1]);
                
                check[x-1][y-1] = 0;
                
            }
            
        int label = 1;
        UF uf = new UF(N);
        int p = 0, q = 0;
        for(int i = 0; i < N; i++)
        {
            for(int j = 0; j < N; j++)
            {
                if(0 != check[i][j])
                {
                    if (0 == i)
                    {
                        if (0 == j)
                            check[i][j] = label++;
                        else
                        {
                            if (0 == check[i][j-1])
                                check[i][j] = label++;
                            else
                                check[i][j] = check[i][j-1];
                        }
                    }
                    else
                    {
                        if (0 == j)
                        {
                            if (0 == check[i-1][j])
                                check[i][j] = label++;
                            else
                                check[i][j] = check[i-1][j];
                        }
                        else
                        {
                            if (0 == check[i-1][j])
                            {
                                if (0 == check[i][j-1])
                                    check[i][j] = label++;
                                else
                                    check[i][j] = check[i][j-1];
                            }
                            else
                            {
                                if (0 == check[i][j-1])
                                    check[i][j] = check[i-1][j];
                                else
                                {
                                    if (check[i][j-1] <= check[i-1][j])
                                    {
                                        check[i][j] = check[i][j-1];
//                                        p = check[i][j-1];
//                                        q = check[i-1][j];
                                        uf.union(check[i][j-1],check[i-1][j]);
                                    }
                                    else
                                    {
                                        check[i][j] = check[i-1][j];
                                        uf.union(check[i-1][j],check[i][j-1]);
                                    }
                                }
                            }
                        }
                            
                    }
                    
                }
                
            }
        }
        
//        for (int i = 0; i < N; i++)
//        {
//            for (int j = 0; j <N; j++)
//                System.out.println(check[i][j]);
//        }
//            System.out.println(label);
//        
        
            for (int i =0; i < N; i++)
            {
                for (int j = 0; j < N; j++)
                {
                    if(0 != check[i][j])
                        check[i][j] = uf.find(check[i][j]);
                }
            }
            
            System.out.println(check[x0-1][y0-1]);
        }
    }
    
}

@d8e7ea8aa9bcf899bccab68de66b28d9@"
"r03522826","9","1.08","169872","@eced42c3877c8fcca2bcdd7815fd77ea@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader (new FileReader (args[0]))){
        
            // Initialization & Read first line
            String [] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);         // Dimension
            int x0 = Integer.parseInt(data[1]);
            int y0 = Integer.parseInt(data[2]);
            int [][] check = new int [N][N];
//            int [][] parent = new int [N][N];
            String d;
            
            for (int i = 0; i < N; i++){
                for(int j = 0; j < N; j++)
                    check[i][j] = 1;
            }
//            System.out.println(N);
//            System.out.println(x0);
//            System.out.println(y0);
            
            // Readfile the other lines
            while((d = br.readLine()) != null){
                d = d.replaceAll("" "", """");
                String [] data1 = d.split("","");
                int x = Integer.parseInt(data1[0]);
                int y = Integer.parseInt(data1[1]);
                
                check[x-1][y-1] = 0;
                
            }
            
        int label = 1;
        UF uf = new UF(N*N+2);
//        QuickFindUF uf = new QuickFindUF(N*N+1);
        int p = 0, q = 0;
        for(int i = 0; i < N; i++)
        {
            for(int j = 0; j < N; j++)
            {
                if(0 != check[i][j])
                {
                    if (0 == i)
                    {
                        if (0 == j)
                        {
                            check[i][j] = label;
//                            parent[i][j] = label;
                            label += 1;
                        }
                        else
                        {
                            if (0 == check[i][j-1])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i][j-1];
//                                parent[i][j] = parent[i][j-1];
                            }
                        }
                    }
                    else
                    {
                        if (0 == j)
                        {
                            if (0 == check[i-1][j])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i-1][j];
//                                parent[i][j] = parent[i-1][j];
                            }
                        }
                        else
                        {
                            if (0 == check[i-1][j])
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = label;
//                                    parent[i][j] = label;
                                    label += 1;
                                }
                                else
                                {
                                    check[i][j] = check[i][j-1];
//                                    parent[i][j] = parent[i][j-1];
                                }
                            }
                            else
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = check[i-1][j];
//                                    parent[i][j] = parent[i-1][j];
                                }
                                else
                                {
                                    if (check[i][j-1] <= check[i-1][j])
                                    {
                                        check[i][j] = check[i][j-1];
//                                        p = check[i][j-1];
//                                        q = check[i-1][j];
                                        uf.union(check[i][j-1],check[i-1][j]);
                                    }
                                    else
                                    {
                                        check[i][j] = check[i-1][j];
                                        uf.union(check[i-1][j],check[i][j-1]);
                                    }
                                }
                            }
                        }
                            
                    }
                    
                }
                
            }
        }
        
//        for (int i = 0; i < N; i++)
//        {
//            for (int j = 0; j <N; j++)
//                System.out.println(check[i][j]);
//        }
//            System.out.println(label);
//        
        
            for (int i =0; i < N; i++)
            {
                for (int j = 0; j < N; j++)
                {
                    if(0 != check[i][j])
                        check[i][j] = uf.find(check[i][j]);
                }
            }
            
            System.out.println(check[x0-1][y0-1]);
//            for (int i =0; i < N; i++)
//            {
//                for (int j = 0; j < N; j++)
//                {
//                    System.out.println(check[i][j]);
//                }
//            }
        }
    }
    
}
@eced42c3877c8fcca2bcdd7815fd77ea@"
"b02611012","9","1.01","123440","@c79bb0d21c829da22150f9e49c4eeb04@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                int rootu = up;
                                int rootl = left;
                                while(rootu != id[rootu]){
                                    rootu = id[id[rootu]];
                                }
                                while(rootl != id[rootl]){
                                    rootl = id[id[rootl]];
                                }
                                if (rootu < rootl) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[rootl] = rootu;
                                }
                                if (rootu > rootl) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[rootu] = rootl;
                                }
                                if (rootu == rootl) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + x);

        }
    }

}

@c79bb0d21c829da22150f9e49c4eeb04@"
"b02611016","9","1.18","155808","@747ea1a06c4b47930a200aa4a376b067@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.Date;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                }
                else{
                id[cloumn-1]=label ;
                //   labelcount[label]=labelcount[label]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];}
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   for(int u=0;u<num*num;u++)
                   {if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   }
                   }
                   }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                 for(int u=0;u<num*num;u++)
                   {if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
       
         }
     }
 }
            /* for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"", id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@747ea1a06c4b47930a200aa4a376b067@"
"b02611012","9","0.99","128944","@6c73f09eb13ad3e6bb841d051110ddcd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                int rootu = up;
                                int rootl = left;
                                while(rootu != id[rootu]){
                                    rootu = id[id[rootu]];
                                }
                                while(rootl != id[rootl]){
                                    rootl = id[id[rootl]];
                                }
                                if (rootu < rootl) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[rootl] = rootu;
                                }
                                if (rootu > rootl) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[rootu] = rootl;
                                }
                                if (rootu == rootl) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[id[x]];
            }
            System.out.printf("""" + x);

        }
    }

}

@6c73f09eb13ad3e6bb841d051110ddcd@"
"b02611012","9","1.01","125792","@303794f625fd373e0f0dce2c516bd07f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                int rootu = up;
                                int rootl = left;
                                while(rootu != id[rootu]){
                                    rootu = id[rootu];
                                }
                                while(rootl != id[rootl]){
                                    rootl = id[rootl];
                                }
                                if (rootu < rootl) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[rootl] = rootu;
                                }
                                if (rootu > rootl) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[rootu] = rootl;
                                }
                                if (rootu == rootl) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + x);

        }
    }

}

@303794f625fd373e0f0dce2c516bd07f@"
"r04631023","9","1","127744","@aab811021a5ace203b1980b1c6e82ca0@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author SimonHan
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]);
            int Locationx = Integer.parseInt(data[1]);
            int Locationy = Integer.parseInt(data[2]);

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int label;
            int labelconnect;
            int labelL ;
            int labelU ;
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 1) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]);
                int y = Integer.parseInt(Open[1]);
                id[N * (x - 1) + y] = 1;

            }
            if (N == 1) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (x != 1 && x != N && y != 1 && y != N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                
                                label = Label[N * (x - 1) + y - 1] ;
                                labelconnect = LabelConnect[label] ;
                                while(label != labelconnect){
                                    label = LabelConnect[labelconnect] ;
                                    labelconnect = LabelConnect[label] ;
                                }
                                labelL = label ;
                                label = Label[N * (x - 1) + y - N] ;
                                labelconnect = LabelConnect[label] ;
                                while(label != labelconnect){
                                    label = LabelConnect[labelconnect] ;
                                    labelconnect = LabelConnect[label] ;
                                }
                                labelU = label ;
                                if (labelU <= labelL) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[labelL] = LabelConnect[labelU];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[labelU] = LabelConnect[labelL];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1 && y == 1) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else if (x == 1 && y == N) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N && y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                label = Label[N * (x - 1) + y - 1] ;
                                labelconnect = LabelConnect[label] ;
                                while(label != labelconnect){
                                    label = LabelConnect[labelconnect] ;
                                    labelconnect = LabelConnect[label] ;
                                }
                                labelL = label ;
                                label = Label[N * (x - 1) + y - N] ;
                                labelconnect = LabelConnect[label] ;
                                while(label != labelconnect){
                                    label = LabelConnect[labelconnect] ;
                                    labelconnect = LabelConnect[label] ;
                                }
                                labelU = label ;
                                if (labelU <= labelL) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[labelL] = LabelConnect[labelU];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[labelU] = LabelConnect[labelL];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (x == 1) {
                            if (Label[N * (x - 1) + y - 1] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];

                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (x == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                label = Label[N * (x - 1) + y - 1] ;
                                labelconnect = LabelConnect[label] ;
                                while(label != labelconnect){
                                    label = LabelConnect[labelconnect] ;
                                    labelconnect = LabelConnect[label] ;
                                }
                                labelL = label ;
                                label = Label[N * (x - 1) + y - N] ;
                                labelconnect = LabelConnect[label] ;
                                while(label != labelconnect){
                                    label = LabelConnect[labelconnect] ;
                                    labelconnect = LabelConnect[label] ;
                                }
                                labelU = label ;
                                if (labelU <= labelL) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[labelL] = LabelConnect[labelU];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[labelU] = LabelConnect[labelL];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        } else if (y == 1) {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            }
                        } else if (y == N) {
                            if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                                label = Label[N * (x - 1) + y - 1] ;
                                labelconnect = LabelConnect[label] ;
                                while(label != labelconnect){
                                    label = LabelConnect[labelconnect] ;
                                    labelconnect = LabelConnect[label] ;
                                }
                                labelL = label ;
                                label = Label[N * (x - 1) + y - N] ;
                                labelconnect = LabelConnect[label] ;
                                while(label != labelconnect){
                                    label = LabelConnect[labelconnect] ;
                                    labelconnect = LabelConnect[label] ;
                                }
                                labelU = label ;
                                if (labelU <= labelL) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                    LabelConnect[labelL] = LabelConnect[labelU];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                    LabelConnect[labelU] = LabelConnect[labelL];
                                }
                            } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                                Label[N * (x - 1) + y] = count;
                                LabelConnect[count] = count;
                                count++;
                            } else {
                                if (Label[N * (x - 1) + y - N] != 0) {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                } else {
                                    Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                }
                            }
                        }
                    }
                }
            }

            int next = 1 ;
            for (int x = 1; x <= N; x++) {
                for (int y = 1; y <= N; y++) {
                    while (LabelConnect[Label[N * (x - 1) + y]] != Label[N * (x - 1) + y]) {
                        next = Label[N * (x - 1) + y] ;
                        Label[N * (x - 1) + y] = LabelConnect[Label[N * (x - 1) + y]];
                        if(LabelConnect[next] != LabelConnect[Label[N * (x - 1) + y]]){
                            LabelConnect[next] = LabelConnect[Label[N * (x - 1) + y]] ;
                        }                        
                    }
                }
            }
            /*
            for (int i = 1, Cal = 0; i <= N * N; i++) {
                if (Cal == N - 1) {
                    System.out.printf(""%d\n"", Label[i]);
                    Cal = 0;
                } else {
                    System.out.printf(""%d "", Label[i]);
                    Cal++;
                }
            }
            */

            System.out.printf(""%d\n"", Label[N * (Locationx - 1) + Locationy]);

        }
    }
}
@aab811021a5ace203b1980b1c6e82ca0@"
"b02611012","9","0.99","123792","@3e9a286a1da1f490ebaa9a555609c220@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                int rootu = up;
                                int rootl = left;
                                while(rootu != id[rootu]){
                                    rootu = id[rootu];
                                }
                                while(rootl != id[rootl]){
                                    rootl = id[rootl];
                                }
                                if (rootu < rootl) {
                                    //matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[rootl] = rootu;
                                }
                                if (rootu > rootl) {
                                    //matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[rootu] = rootl;
                                }
//                                if (rootu == rootl) {
//                                    matrix[gx][gy] = matrix[gx][gy - 1];
//                                }
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[left] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + x);

        }
    }

}

@3e9a286a1da1f490ebaa9a555609c220@"
"b02611028","10","0.101","121872","@7b4963aef8c8aa0bbf4061a522bb80a2@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N + 2][N + 2];
            for (int i = 0; i < N + 2; i++) {
                for (int j = 0; j < N + 2; j++) {
                    matrix[i][j] = 1;
                    if (i == 0 || j == 0 || i == N + 1 || j == N + 1) {
                        matrix[i][j] = 0;
                    }
                }
            }
            //finish maps
            int ready = 1;
            if (!br.ready()) {
                ready++;
            }
            while (ready == 1) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0]][ordinarynum[1]] = 0;

                if (!br.ready()) {
                    break;
                }

            }
            /*for (int i = 0; i < N + 2; i++) {
                for (int j = 0; j < N + 2; j++) {
                    System.out.print(matrix[i][j] + ""　　 "");
                }
                System.out.printf(""%n"");
            }*/

            QuickUnionUF uf = new QuickUnionUF(N * N + 1);
            int count = 1;
            for (int i = 0; i < N + 2; i++) {
                for (int j = 0; j < N + 2; j++) {
                    if (matrix[i][j] == 1) {

                        if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                            matrix[i][j] = count;
                            count++;
                            continue;
                        }
                        if (matrix[i][j - 1] != 0) {
                            matrix[i][j] = matrix[i][j - 1];

                        }
                        if (matrix[i - 1][j] != 0) {
                            matrix[i][j] = matrix[i - 1][j];

                        }
                        if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                            matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                            uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]), Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                        }
                    }
                }
            }

            /*for (int i = 0; i < N+2; i++) {
                for (int j = 0; j < N+2; j++) {
                    System.out.print(uf.find(matrix[i][j]) + ""　　 "");
                }
                System.out.printf(""%n"");
            }*/
            //if(matrix[target[0]-1][target[1]-1]==0)System.out.print(0);
            System.out.print(uf.find(matrix[target[0]][target[1]]));

        }
    }
}

@7b4963aef8c8aa0bbf4061a522bb80a2@"
"b02611012","9","1.01","125376","@3a251d550e0458248ce82a3283a8d580@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[left] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
//            while (id[x] != x) {
//                x = id[x];
//            }
            System.out.printf("""" + id[x]);

        }
    }

}

@3a251d550e0458248ce82a3283a8d580@"
"b02611016","9","1.18","156544","@95706cb9454d454e0b9f85b43b276992@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                }
                else{
                id[cloumn-1]=label ;
                //   labelcount[label]=labelcount[label]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];}
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]<=id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   for(int u=0;u<num*num;u++)
                   {if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   }
                   }
                   }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                 for(int u=0;u<num*num;u++)
                   {if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
       
         }
     }
 }
            /* for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"", id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@95706cb9454d454e0b9f85b43b276992@"
"b02611028","10","0.101","128304","@33113dd7e5a81ebe9f79dfcc6937f4cf@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            int[][] matrix = new int[N + 2][N + 2];
            for (int i = 0; i < N + 2; i++) {
                for (int j = 0; j < N + 2; j++) {
                    matrix[i][j] = 1;
                    if (i == 0 || j == 0 || i == N + 1 || j == N + 1) {
                        matrix[i][j] = 0;
                    }
                }
            }
            //finish maps
            int ready = 1;
            if (!br.ready()) {
                ready++;
            }
            while (ready == 1) {
                String[] ordinary = br.readLine().split("","");
                int[] ordinarynum = new int[2];
                ordinarynum[0] = Integer.parseInt(ordinary[0]);
                ordinarynum[1] = Integer.parseInt(ordinary[1]);
                matrix[ordinarynum[0]][ordinarynum[1]] = 0;

                if (!br.ready()) {
                    break;
                }
            }
            QuickUnionUF uf = new QuickUnionUF(N * N);
            int count = 1;
            for (int i = 0; i < N + 2; i++) {
                for (int j = 0; j < N + 2; j++) {
                    if (matrix[i][j] == 1) {

                        if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                            matrix[i][j] = count;
                            count++;
                            continue;
                        }
                        if (matrix[i][j - 1] != 0) {
                            matrix[i][j] = matrix[i][j - 1];

                        }
                        if (matrix[i - 1][j] != 0) {
                            matrix[i][j] = matrix[i - 1][j];

                        }
                        if (matrix[i][j - 1] != 0 && matrix[i - 1][j] != 0) {
                            matrix[i][j] = Math.min(matrix[i][j - 1], matrix[i - 1][j]);
                            uf.union(Math.max(matrix[i][j - 1], matrix[i - 1][j]), Math.min(matrix[i][j - 1], matrix[i - 1][j]));
                        }
                    }
                }
            }
            System.out.print(uf.find(matrix[target[0]][target[1]]));
        }
    }
}

@33113dd7e5a81ebe9f79dfcc6937f4cf@"
"b02611012","9","1.01","127248","@9f48045008e447c2a7f6ad25b4c88cbf@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[left] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
//            while (id[x] != x) {
//                x = id[x];
//            }
            System.out.printf("""" + id[x]);

        }
    }

}

@9f48045008e447c2a7f6ad25b4c88cbf@"
"r04631023","9","1.01","128288","@31c9042503ec90bd47e4d32db1cdfacc@import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]) + 2;
            int Locationx = Integer.parseInt(data[1]) + 1;
            int Locationy = Integer.parseInt(data[2]) + 1;

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int[] LabelConnect = new int[N * N + 1];
            int label;
            int labelconnect;
            int labelL;
            int labelU;
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 3) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]) + 1;
                int y = Integer.parseInt(Open[1]) + 1;
                id[N * (x - 1) + y] = 1;

            }
            if (N == 3) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 2; x <= N - 1; x++) {
                for (int y = 2; y <= N - 1; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {

                            label = Label[N * (x - 1) + y - 1];
                            labelconnect = LabelConnect[label];
                            while (label != labelconnect) {
                                label = LabelConnect[labelconnect];
                                labelconnect = LabelConnect[label];
                            }
                            labelL = label;
                            label = Label[N * (x - 1) + y - N];
                            labelconnect = LabelConnect[label];
                            while (label != labelconnect) {
                                label = LabelConnect[labelconnect];
                                labelconnect = LabelConnect[label];
                            }
                            labelU = label;
                            if (labelU <= labelL) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                                LabelConnect[labelL] = LabelConnect[labelU];
                            } else {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                                LabelConnect[labelU] = LabelConnect[labelL];
                            }
                        } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                            Label[N * (x - 1) + y] = count;
                            LabelConnect[count] = count;
                            count++;
                        } else {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                            }
                        }
                    }
                }
            }
            label = Label[N * (Locationx - 1) + Locationy];
            labelconnect = LabelConnect[label];
            while (label != labelconnect) {
                label = LabelConnect[labelconnect];
                labelconnect = LabelConnect[label];
            }

            System.out.printf(""%d\n"", label);

        }
    }
}

@31c9042503ec90bd47e4d32db1cdfacc@"
"b02611012","9","1.03","127776","@4619198c02c532fcd35e193646b3f00e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[left] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + id[x]);

        }
    }

}

@4619198c02c532fcd35e193646b3f00e@"
"b02611016","0","1.91","282080","@796a280c1ad5027c71b9a69ee6862c44@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;}
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                 for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
       
         }
     }
 }
             for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@796a280c1ad5027c71b9a69ee6862c44@"
"b02611016","9","1.09","156864","@c86195a66d45326df227d7d753d53595@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;}
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                 for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
               }
               }
                //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                 /*  if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k1]==0){break;}
                          if(id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                         labelcount[k1]=labelcount[k1]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   else if (matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {k2=id[(row-1)*num+cloumn];
                    for(int j=0;j<num*num;j++)
                      {if(labelcount[k2]==0){break;}
                          if(id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k2]=labelcount[k2]-1;
                        }
                      }
                     //id[(row-1)*num+cloumn]=id[(row-2)*num+cloumn-1];                  
                   }
                    else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   { k3=id[(row)*num+cloumn-1];
                       for(int j=0;j<num*num;j++)
                      {if(labelcount[k3]==0){break;}
                          if(id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                         labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        labelcount[k3]=labelcount[k3]-1;
                        
                        }
                      }
                    // id[(row)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   }   
                     
                    else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k2=id[(row-1)*num+cloumn];
                      int k12=labelcount[k1]+labelcount[k2];
                       for(int j=0;j<num*num;j++)
                      {if(k12==0){break;}
                          if(id[j]==k1||id[j]==k2)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k12=k12-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                      else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
                   {  k1=id[(row-1)*num+cloumn-2];
                      k3=id[(row)*num+cloumn-1];
                      int k13=labelcount[k1]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k13==0){break;}
                          if(id[j]==k1||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k13=k13-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                   
                       else if(matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {  k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k23=labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k23==0){break;}
                          if(id[j]==k2||id[j]==k3)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k23=k23-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }
                          else if(matrix[row-1][cloumn-1]==1&&matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   {   k1=id[(row-1)*num+cloumn-2];
                       k2=id[(row-1)*num+cloumn];
                      k3=id[(row)*num+cloumn-1];
                      int k123=labelcount[k1]+labelcount[k2]+labelcount[k3];
                       for(int j=0;j<num*num;j++)
                      {if(k123==0){break;}
                          if(id[j]==k2||id[j]==k3||id[j]==k1)
                        {id[j]=id[(row-2)*num+cloumn-1];
                        labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1;
                        k123=k123-1;
                        }
                      }
                     //id[(row-1)*num+cloumn-2]=id[(row-2)*num+cloumn-1];
                   }*/
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 /*  if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]!=1)
                   { k4=id[(row-1)*num+cloumn];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k4]==0){break;}
                         if(id[f]==k4)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k4]=labelcount[k4]-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                   if(matrix[row-1][cloumn+1]!=1&matrix[row][cloumn]==1)
                   { k5=id[(row)*num+cloumn-1];
                       for(int f=0;f<num*num;f++)
                     {if(labelcount[k5]==0){break;}
                         if(id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        labelcount[k5]=labelcount[k5]-1;
                        }
                     }
                   //id[(row)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   }
                    if(matrix[row-1][cloumn+1]==1&&matrix[row][cloumn]==1)
                   { k4=id[(row-1)*num+cloumn];
                     k5=id[(row)*num+cloumn-1];
                     int k45=labelcount[k4]+labelcount[k5];
                       for(int f=0;f<num*num;f++)
                     {if(k45==0){break;}
                         if(id[f]==k4||id[f]==k5)
                        {id[f]=id[(row-1)*num+cloumn-2];
                        labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                        k45=k45-1;
                        }
                     }
                  // id[(row-1)*num+cloumn]=id[(row-1)*num+cloumn-2];
                   }
                    */
               }
            /*   else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn];
                labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                 if(matrix[row][cloumn]==1)
                 { k6=id[row*num+cloumn-1];
                     for(int m=0;m<num*num;m++)
                   {if(labelcount[k6]==0){break;}
                       if(id[m]==k6)
                     {id[m]=id[(row-1)*num+cloumn];
                     labelcount[id[(row-1)*num+cloumn]]=labelcount[id[(row-1)*num+cloumn]]+1;
                     labelcount[k6]=labelcount[k6]-1;
                     }
                   }
                 }
               //  id[row*num+cloumn-1]=id[(row-1)*num+cloumn];
               }
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]!=1&&matrix[row-1][cloumn+1]!=1&&matrix[row][cloumn]==1)
               {id[(row-1)*num+cloumn-1]=id[row*num+cloumn-1];
               labelcount[id[row*num+cloumn-1]]=labelcount[id[row*num+cloumn-1]]+1;
               }*/
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         
       
         }
     }
 }
          /*   for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@c86195a66d45326df227d7d753d53595@"
"r04631023","9","1.02","125024","@f6ece629a26c079b0b4727079c86ddd6@import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]) + 2;
            int Locationx = Integer.parseInt(data[1]) + 1;
            int Locationy = Integer.parseInt(data[2]) + 1;

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];
            UF uf = new UF(N * N + 1);

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 3) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]) + 1;
                int y = Integer.parseInt(Open[1]) + 1;
                id[N * (x - 1) + y] = 1;

            }
            if (N == 3) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 2; x <= N - 1; x++) {
                for (int y = 2; y <= N - 1; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                            if (Label[N * (x - 1) + y - N] < Label[N * (x - 1) + y - 1]) {
                                uf.union(Label[N * (x - 1) + y - N], Label[N * (x - 1) + y - 1]);
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                uf.union(Label[N * (x - 1) + y - 1], Label[N * (x - 1) + y - N]);
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                            }
                        } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                            Label[N * (x - 1) + y] = count;
                            count++;
                        } else {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                            }
                        }
                    }
                }
            }
            System.out.printf(""%d\n"", uf.find(Label[N*(Locationx-1)+Locationy]));

        }
    }
}
@f6ece629a26c079b0b4727079c86ddd6@"
"b02611012","9","0.99","124672","@0a472b7ee101563fc315b03ac98e305c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    id[left] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1 && y == 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1 && x == 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[x];
            }
            System.out.printf("""" + id[x]);

        }
    }

}

@0a472b7ee101563fc315b03ac98e305c@"
"b02611012","9","1","125952","@93946021632b635dbd25d6342d953e99@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }

            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                //if (matrix[gx][gy - 1] < matrix[gx][gy]) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                //}
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                int rootu = up;
                                int rootl = left;
                                while(rootu != id[rootu]){
                                    rootu = id[id[rootu]];
                                }
                                while(rootl != id[rootl]){
                                    rootl = id[id[rootl]];
                                }
                                if (rootu < rootl) {
                                    matrix[gx][gy] = rootu;
                                    id[rootl] = rootu;
                                }
                                if (rootu > rootl) {
                                    matrix[gx][gy] = rootl;
                                    id[rootu] = rootl;
                                }
                                if (rootu == rootl) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
            while (id[x] != x) {
                x = id[id[x]];
            }
            System.out.printf("""" + x);

        }
    }

}

@93946021632b635dbd25d6342d953e99@"
"b02611023","10","0.093","121520","@d6f9c90f0bb186ce7adc91f4440c0dac@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {

    public static int[] sec_pass;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);      // target row
            int t_col = Integer.parseInt(data[2]);      // targer column
            
            int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];

            String[] lines = new String[2];
            sec_pass = new int[num * num + 1];

            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {
                    cc[num * (i - 1) + (j - 1)] = num * (i - 1) + (j - 1);  //標上 0~(N-1)
                    matrix[i][j] = 1;
                }
            }

            for (int i = 0; i < num * num + 1; i++) {
                sec_pass[i] = i;
            }

            while (br.ready()) {
                lines = br.readLine().split("","");
                int row = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                cc[num * (row - 1) + (col - 1)] = 0;        //block 標為0
                matrix[row][col] = 0;                       //block 標為0
            }

            int count = 1;                                  //紀錄 label

            for (int i = 1; i <= num; i++) {

                for (int j = 1; j <= num; j++) {

                    int position = num * (i - 1) + (j - 1);

                    if (matrix[i][j] == 0) {
                        continue;
                    } 
                    //找 上、左 皆不是Block
                    else if ((matrix[i][j] - matrix[i - 1][j] == 0) && (matrix[i][j] - matrix[i][j - 1] == 0)) {
                        // 上 < 左
                        if (cc[num * (i - 2) + (j - 1)] < cc[num * (i - 1) + (j - 2)]) {
                            cc[position] = cc[num * (i - 2) + (j - 1)];
                            union(cc[num * (i - 1) + (j - 2)], cc[position]);
                        } 
                        // 左 > 上
                        else if (cc[num * (i - 2) + (j - 1)] > cc[num * (i - 1) + (j - 2)]) {
                            cc[position] = cc[num * (i - 1) + (j - 2)];
                            union(cc[num * (i - 2) + (j - 1)], cc[position]);
                        } 
                        // 左 == 上  隨意給左或上的值
                        else {
                            cc[position] = cc[num * (i - 2) + (j - 1)];
                        }
                        
                    } 
                    //上 跟 左 都是Block --> label
                    else if ((matrix[i][j] - matrix[i - 1][j] == 1) && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[position] = count;
                        count++;
                    } 
                    //左邊有值 --> 值 = 左邊
                    else if (matrix[i][j] - matrix[i - 1][j] == 0 && (matrix[i][j] - matrix[i][j - 1] == 1)) {
                        cc[position] = cc[num * (i - 2) + (j - 1)];
                    } 
                    //上面有值 --> 值 = 上面
                    else {
                        cc[position] = cc[num * (i - 1) + (j - 2)];
                    }

                }
            }

            for (int i = 0; i < num * num; i++) {
                if (cc[i] != 0) {
                    cc[i] = find(cc[i]);
                }
            }

            System.out.println(cc[num * (t_row - 1) + (t_col - 1)]);

        }
    }

    public static int find(int p) {
        while (p != sec_pass[p]) {
            p = sec_pass[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        sec_pass[rootP] = rootQ;
    }

}

@d6f9c90f0bb186ce7adc91f4440c0dac@"
"r04631023","10","0.101","130880","@3013fac1a940d31b257d2e03b3b1ce4b@import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] data = br.readLine().split("","");

            // store the first integer in variable stringCount (number of announced strings)
            int N = Integer.parseInt(data[0]) + 2;
            int Locationx = Integer.parseInt(data[1]) + 1;
            int Locationy = Integer.parseInt(data[2]) + 1;

            // printf in Java (you should comment out or delete this in your final submission           
            int[] id = new int[N * N + 1];
            int[] Label = new int[N * N + 1];
            int count = 1;
            String Data = new String();
            String[] Open = new String[2];
            QuickUnionUF uf = new QuickUnionUF(N * N + 1);

            while ((Data = br.readLine()) != null) {
                Open = Data.split("","");
                if (N == 3) {
                    System.out.printf(""%d\n"", 0);
                    return;
                }
                int x = Integer.parseInt(Open[0]) + 1;
                int y = Integer.parseInt(Open[1]) + 1;
                id[N * (x - 1) + y] = 1;

            }
            if (N == 3) {
                System.out.printf(""%d\n"", 1);
                return;
            }
            for (int x = 2; x <= N - 1; x++) {
                for (int y = 2; y <= N - 1; y++) {
                    if (id[N * (x - 1) + y] == 0) {
                        if (Label[N * (x - 1) + y - N] != 0 && Label[N * (x - 1) + y - 1] != 0) {
                            if (Label[N * (x - 1) + y - N] < Label[N * (x - 1) + y - 1]) {
                                uf.union(Label[N * (x - 1) + y - 1], Label[N * (x - 1) + y - N]);
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                uf.union(Label[N * (x - 1) + y - N], Label[N * (x - 1) + y - 1]);
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                            }
                        } else if (Label[N * (x - 1) + y - N] == 0 && Label[N * (x - 1) + y - 1] == 0) {
                            Label[N * (x - 1) + y] = count;
                            count++;
                        } else {
                            if (Label[N * (x - 1) + y - N] != 0) {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - N];
                            } else {
                                Label[N * (x - 1) + y] = Label[N * (x - 1) + y - 1];
                            }
                        }
                    }
                }
            }            
            System.out.printf(""%d\n"", uf.find(Label[N*(Locationx-1)+Locationy]));
        }
    }
}
@3013fac1a940d31b257d2e03b3b1ce4b@"
"b02611023","10","0.098","124976","@f2f3e95b0c2fcb886bdc6dbfbd07c34b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {

    public static int[] sec_pass;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);      // target row
            int t_col = Integer.parseInt(data[2]);      // targer column
            
            //int cc[] = new int[num * num];
            int matrix[][] = new int[num + 2][num + 2];

            String[] lines = new String[2];
            sec_pass = new int[num * num + 1];

            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {
                    matrix[i][j] = 1;
                }
            }

            for (int i = 0; i < num * num + 1; i++) {
                sec_pass[i] = i;
            }

            while (br.ready()) {
                lines = br.readLine().split("","");
                int row = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                matrix[row][col] = 0;                       //block 標為0
            }

            int count = 1;                                  //紀錄 label

            for (int i = 1; i <= num; i++) {

                for (int j = 1; j <= num; j++) {

                    if (matrix[i][j] == 0) {
                        continue;
                    } 
                    //找 上、左 皆不是Block
                    else if (matrix[i - 1][j] != 0 && matrix[i][j - 1] != 0) {
                        // 上 < 左
                        if (matrix[i][j - 1] < matrix[i - 1][j]) { 
                            matrix[i][j] = matrix[i][j-1];
                            union(matrix[i - 1][j] , matrix[i][j - 1]);
                        } 
                        // 左 > 上
                        else if (matrix[i][j - 1] > matrix[i - 1][j]) {    
                            matrix[i][j] = matrix[i - 1][j];
                            union(matrix[i][j - 1] , matrix[i - 1][j]);
                        } 
                        // 左 == 上  隨意給左或上的值
                        else {
                            matrix[i][j] = matrix[i][j - 1];
                        }
                        
                    } 
                    //上 跟 左 都是Block --> label
                    else if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                        matrix[i][j] = count;
                        count++;
                    } 
                    //上面有值 --> 值 = 上面
                    else if (matrix[i - 1][j] == 0 && matrix[i][j - 1] != 0) {
                        matrix[i][j] = matrix[i][j - 1];
                    } 
                    //左邊有值 --> 值 = 左邊
                    else {
                        matrix[i][j] = matrix[i - 1][j];
                    }

                }
            }

            for (int i = 1; i <= num; i++) {
                for(int j = 1; j <= num; j ++){
                    if (matrix[i][j] != 0) {
                    matrix[i][j] = find(matrix[i][j]);
                    }
                }                
            }
            
            /*for (int i = 1; i <= num; i++) {
                for(int j = 1; j <= num; j ++){
                    System.out.print(matrix[i][j] + "" "");
                }                
                System.out.println();
            }*/

            System.out.println(matrix[t_row][t_col]);

        }
    }

    public static int find(int p) {
        while (p != sec_pass[p]) {
            p = sec_pass[p];
        }
        return p;
    }

    public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) {
            return;
        }
        sec_pass[rootP] = rootQ;
    }

}

@f2f3e95b0c2fcb886bdc6dbfbd07c34b@"
"b02611012","0","0.098","124976","@9c4397882a70d6b4af20cabf06a2c2ca@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import edu.princeton.cs.algs4.QuickFindUF;
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }
            QuickFindUF uf = new QuickFindUF (gridsize*gridsize);
            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    uf.union( matrix[gx - 1][gy],matrix[gx][gy - 1]);
                                    id[left] = up;
                                }
                                if (up > left) {
                                    uf.union( matrix[gx][gy],matrix[gx - 1][gy]);
                                    id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }

           
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    if (matrix[i][j] != 0 && matrix[i][j] != uf.find(matrix[i][j])) {
                        matrix[i][j] = uf.find(matrix[i][j]);
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
//            while (id[x] != x) {
//                x = id[x];
//            }
            System.out.printf("""" + x);

        }
    }

}

@9c4397882a70d6b4af20cabf06a2c2ca@"
"b02611012","5","1.04","129712","@4b323c081ccd750d87e0ff8dfd914d64@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }
            QuickFindUF uf = new QuickFindUF (gridsize*gridsize);
            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    uf.union( matrix[gx - 1][gy],matrix[gx][gy - 1]);
                                    id[left] = up;
                                }
                                if (up > left) {
                                    uf.union( matrix[gx][gy],matrix[gx - 1][gy]);
                                    id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }

           
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    if (matrix[i][j] != 0 && matrix[i][j] != uf.find(matrix[i][j])) {
                        matrix[i][j] = uf.find(matrix[i][j]);
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
//            while (id[x] != x) {
//                x = id[x];
//            }
            System.out.printf("""" + x);

        }
    }

}

@4b323c081ccd750d87e0ff8dfd914d64@"
"b02611012","5","1.08","134688","@87229fcf8ee0a9f9ca753188784eec9c@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }
            QuickFindUF uf = new QuickFindUF (gridsize*gridsize);
            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up < left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    uf.union( matrix[gx - 1][gy],matrix[gx][gy - 1]);
                                    id[left] = up;
                                }
                                if (up > left) {
                                    uf.union( matrix[gx][gy - 1],matrix[gx - 1][gy]);
                                    id[up] = left;
                                }
                                if (up == left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }

           
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    if (matrix[i][j] != 0 && matrix[i][j] != uf.find(matrix[i][j])) {
                        matrix[i][j] = uf.find(matrix[i][j]);
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
//            while (id[x] != x) {
//                x = id[x];
//            }
            System.out.printf("""" + x);

        }
    }

}

@87229fcf8ee0a9f9ca753188784eec9c@"
"b02611012","9","1.04","129712","@ba67e6e4f403900035346425e91418eb@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }
            QuickFindUF uf = new QuickFindUF(gridsize * gridsize);
            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up <= left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    uf.union(matrix[gx][gy - 1], matrix[gx - 1][gy]);
                                    id[left] = up;
                                }
                                if (up > left) {
                                    uf.union(matrix[gx - 1][gy], matrix[gx][gy - 1]);
                                    id[up] = left;
                                }
//                                if (up == left) {
//                                    matrix[gx][gy] = matrix[gx - 1][gy];
//                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }

            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    if (matrix[i][j] != 0 && matrix[i][j] != uf.find(matrix[i][j])) {
                        matrix[i][j] = uf.find(matrix[i][j]);
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
//            while (id[x] != x) {
//                x = id[x];
//            }
            System.out.printf("""" + x);

        }
    }

}

@ba67e6e4f403900035346425e91418eb@"
"b02611012","0","0","0","@72b52573f5003a2a7f69c0b8500721c2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = -1;
                }
            }
            QuickFindUF uf = new QuickFindUF(gridsize * gridsize);
            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up <= left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    uf.union(matrix[gx][gy - 1], matrix[gx - 1][gy]);
                                    id[left] = up;
                                }
                                if (up > left) {
                                    uf.union(matrix[gx - 1][gy], matrix[gx][gy - 1]);
                                    id[up] = left;
                                }
//                                if (up == left) {
//                                    matrix[gx][gy] = matrix[gx - 1][gy];
//                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }

            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    if (matrix[i][j] != 0 && matrix[i][j] != uf.find(matrix[i][j])) {
                        matrix[i][j] = uf.find(matrix[i][j]);
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
//            while (id[x] != x) {
//                x = id[x];
//            }
            System.out.printf("""" + x);

        }
    }

}

@72b52573f5003a2a7f69c0b8500721c2@"
"b02611012","9","1.06","130096","@675a9888909c02c41259ffbab0c1dfd1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }
            QuickFindUF uf = new QuickFindUF(gridsize * gridsize);
            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up <= left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    uf.union(matrix[gx][gy - 1], matrix[gx - 1][gy]);
                                    id[left] = up;
                                }
                                if (up > left) {
                                    uf.union(matrix[gx - 1][gy], matrix[gx][gy - 1]);
                                    id[up] = left;
                                }
//                                if (up == left) {
//                                    matrix[gx][gy] = matrix[gx - 1][gy];
//                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1 && y == 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1 && x == 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }

            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    if (matrix[i][j] != 0 && matrix[i][j] != uf.find(matrix[i][j])) {
                        matrix[i][j] = uf.find(matrix[i][j]);
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
//            while (id[x] != x) {
//                x = id[x];
//            }
            System.out.printf("""" + x);

        }
    }

}

@675a9888909c02c41259ffbab0c1dfd1@"
"b02611023","10","0.099","125712","@733c41f51f9962fc8ce04a6e852606da@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
import java.io.*;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = new String[3];
            data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int t_row = Integer.parseInt(data[1]);      // target row
            int t_col = Integer.parseInt(data[2]);      // targer column

            int matrix[][] = new int[num + 2][num + 2];

            String[] lines = new String[2];
            
            QuickUnionUF uf = new QuickUnionUF(num*num);

            for (int i = 1; i <= num; i++) {
                for (int j = 1; j <= num; j++) {
                    matrix[i][j] = 1;
                }
            }

            while (br.ready()) {
                lines = br.readLine().split("","");
                int row = Integer.parseInt(lines[0]);
                int col = Integer.parseInt(lines[1]);
                matrix[row][col] = 0;                       //block 標為0
            }

            int count = 1;                                  //紀??label

            for (int i = 1; i <= num; i++) {

                for (int j = 1; j <= num; j++) {

                    if (matrix[i][j] == 0) {
                        continue;
                    }
                    //??上、左 ?��??�Block
                    else if (matrix[i - 1][j] != 0 && matrix[i][j - 1] != 0) {
                        // �?< �?
                        if (matrix[i][j - 1] < matrix[i - 1][j]) {
                            matrix[i][j] = matrix[i][j-1];
                            uf.union(matrix[i - 1][j] , matrix[i][j - 1]);
                        }
                        // �?> �?
                        else if (matrix[i][j - 1] > matrix[i - 1][j]) {
                            matrix[i][j] = matrix[i - 1][j];
                            uf.union(matrix[i][j - 1] , matrix[i - 1][j]);
                        }
                        // �?== �? ?��?給左?��??��?
                        else {
                            matrix[i][j] = matrix[i][j - 1];
                        }

                    }
                    //�?�?�??�是Block --> label
                    else if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                        matrix[i][j] = count;
                        count++;
                    }
                    //上面?��?--> ??= 上面
                    else if (matrix[i - 1][j] == 0 && matrix[i][j - 1] != 0) {
                        matrix[i][j] = matrix[i][j - 1];
                    }
                    //左�??��?--> ??= 左�?
                    else {
                        matrix[i][j] = matrix[i - 1][j];
                    }

                }
            }

            for (int i = 1; i <= num; i++) {
                for(int j = 1; j <= num; j ++){
                    if (matrix[i][j] != 0) {
                    matrix[i][j] = uf.find(matrix[i][j]);
                    }
                }
            }

            System.out.println(matrix[t_row][t_col]);

        }
    }
}

@733c41f51f9962fc8ce04a6e852606da@"
"b02611012","10","0.103","132032","@5789cc708282032216cc4cb9671cb11b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author user
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int gridsize = Integer.parseInt(data[0]);

            int targetx = Integer.parseInt(data[1]);
            int targety = Integer.parseInt(data[2]);
            int[][] matrix = new int[gridsize][gridsize];
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    matrix[i][j] = 1;
                }
            }
            QuickFindUF uf = new QuickFindUF(gridsize * gridsize);
            String str = null;
            int[] id = new int[gridsize * gridsize];
            while ((str = br.readLine()) != null) {
                String tempArray[] = str.split("","");
                int x = Integer.parseInt(tempArray[0]);
                int y = Integer.parseInt(tempArray[1]);
                matrix[x - 1][y - 1] = 0;
            }
            for (int i = 0; i < gridsize * gridsize; i++) {
                id[i] = i;
            }
            int labelcount = 1;
            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    int x = i + 1;
                    int y = j + 1;
                    int gx = i;
                    int gy = j;
                    if (matrix[gx][gy] == 1) {

                        if (x > 1 && y > 1) {
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] == 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            }
                            if (matrix[gx][gy - 1] != 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            }
                            if (matrix[gx - 1][gy] != 0 && matrix[gx][gy - 1] != 0) {
                                int up = matrix[gx - 1][gy];
                                int left = matrix[gx][gy - 1];
                                if (up <= left) {
                                    matrix[gx][gy] = matrix[gx - 1][gy];
                                    uf.union(matrix[gx][gy - 1], matrix[gx - 1][gy]);
                                    id[left] = up;
                                }
                                if (up > left) {
                                    matrix[gx][gy] = matrix[gx][gy - 1];
                                    uf.union(matrix[gx - 1][gy], matrix[gx][gy - 1]);
                                    id[up] = left;
                                }
//                                if (up == left) {
//                                    matrix[gx][gy] = matrix[gx - 1][gy];
//                                }
                            }
                            if (matrix[gx][gy - 1] == 0 && matrix[gx - 1][gy] == 0) {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (x > 1 && y == 1) {
                            if (matrix[gx - 1][gy] != 0) {
                                matrix[gx][gy] = matrix[gx - 1][gy];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }

                        } else if (y > 1 && x == 1) {
                            if (matrix[gx][gy - 1] != 0) {
                                matrix[gx][gy] = matrix[gx][gy - 1];
                            } else {
                                matrix[gx][gy] = labelcount;
                                labelcount++;
                            }
                        } else {
                            matrix[gx][gy] = labelcount;
                            labelcount++;
                        }
                    }
                }
            }

            for (int i = 0; i < gridsize; i++) {
                for (int j = 0; j < gridsize; j++) {
                    if (matrix[i][j] != 0 && matrix[i][j] != uf.find(matrix[i][j])) {
                        matrix[i][j] = uf.find(matrix[i][j]);
                    }
                }
            }
            int x = matrix[targetx - 1][targety - 1];
//            while (id[x] != x) {
//                x = id[x];
//            }
            System.out.printf("""" + x);

        }
    }

}

@5789cc708282032216cc4cb9671cb11b@"
"r04631006","9","1.1","140208","@57a5447b070398fc83581dec2c0d39d6@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            num = num + 2;
            QuickFindUF qf = new QuickFindUF(num * num);

            int[] outla = new int[2];
            outla[0] = Integer.parseInt(a[1]);
            outla[1] = Integer.parseInt(a[2]);

            int[][] ma = new int[num][num];
            int[][] CC = new int[num][num];

            String loca0;
            String[] loca;
            int x;
            int y;
            int c = 1;

            while (!((loca0 = br.readLine()) == null)) {
                loca = loca0.split("","");
                x = Integer.parseInt(loca[0]);
                y = Integer.parseInt(loca[1]);
                ma[x][y] = 1;
                if (x==outla[0] && y==outla[1]){
                    System.out.printf(""%d"", 0);
                    return;
                }
            }
            for (int i = 0; i < num; i++) {
                if (i == 0 || i == num) {
                    for (int j = 0; j < num; j++) {
                        ma[i][j] = 1;
                    }
                }
            }
            for (int j = 0; j < num; j++) {
                if (j == 0 || j == num) {
                    for (int i = 0; i < num; i++) {
                        ma[i][j] = 1;
                    }
                }
            }
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.printf(""%d"", ma[i][j]);
//                }
//            }

            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                    if (ma[i][j] == 0) {
                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
                            qf.union(i * num + j, (i - 1) * num + j);
                            if (qf.find(i * num + (j - 1)) > qf.find((i - 1) * num + (j))) {
                                qf.union(i * num + j, (i - 1) * num + (j));
                                qf.union(i * num + (j - 1), i * num + j);
                            } else {
                                qf.union(i * num + j, i * num + (j - 1));
                                qf.union((i - 1) * num + (j), i * num + j);
                            }

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
                            qf.union(i * num + j, i * num + (j - 1));

                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
                            qf.union(i * num + j, (i - 1) * num + j);
                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = c;
                            c = c + 1;
                        }

                    }

                }
            }
            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                   if(CC[i][j]!=0){
                      if((i * num + j)==qf.find(outla[0]*num+outla[1])){
                          System.out.printf(""%d"", CC[i][j]);
                      }
                   }
                }
            }
            
            
            
            
            
        }
    }
}

@57a5447b070398fc83581dec2c0d39d6@"
"r04631006","9","1.12","141136","@71a41de4a5a48178ce557af560a0f428@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            num = num + 2;
            QuickFindUF qf = new QuickFindUF(num * num);

            int[] outla = new int[2];
            outla[0] = Integer.parseInt(a[1]);
            outla[1] = Integer.parseInt(a[2]);

            int[][] ma = new int[num][num];
            int[][] CC = new int[num][num];

            String loca0;
            String[] loca;
            int x;
            int y;
            int c = 1;

            while (!((loca0 = br.readLine()) == null)) {
                loca = loca0.split("","");
                x = Integer.parseInt(loca[0]);
                y = Integer.parseInt(loca[1]);
                ma[x][y] = 1;
                if (x == outla[0] && y == outla[1]) {
                    System.out.printf(""%d"", 0);
                    return;
                }
            }
            for (int i = 0; i < num; i++) {
                if (i == 0 || i == num) {
                    for (int j = 0; j < num; j++) {
                        ma[i][j] = 1;
                    }
                }
            }
            for (int j = 0; j < num; j++) {
                if (j == 0 || j == num) {
                    for (int i = 0; i < num; i++) {
                        ma[i][j] = 1;
                    }
                }
            }

            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                    if (ma[i][j] == 0) {
                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
                            qf.union(i * num + j, (i - 1) * num + j);
                            if (qf.find(i * num + (j - 1)) > qf.find((i - 1) * num + (j))) {
                                qf.union(i * num + j, (i - 1) * num + (j));
                                qf.union(i * num + (j - 1), i * num + j);
                            } else {
                                qf.union(i * num + j, i * num + (j - 1));
                                qf.union((i - 1) * num + (j), i * num + j);
                            }

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
                            qf.union(i * num + j, i * num + (j - 1));

                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
                            qf.union(i * num + j, (i - 1) * num + j);
                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = c;
                            c = c + 1;
                        }

                    }

                }
            }
            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                    if (CC[i][j] != 0) {
                        if ((i * num + j) == qf.find(outla[0] * num + outla[1])) {
                            System.out.printf(""%d"", CC[i][j]);
                        }
                    }
                }
            }

        }
    }
}

@71a41de4a5a48178ce557af560a0f428@"
"b02611026","9","1.09","138144","@8b67259c5bdab638977a6b7462dac9b8@
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;

public class LabelCC {

    class My_QuickUnionUF {

        public int[] id;

        public My_QuickUnionUF(int N) {
            id = new int[N];
            for (int i = 0; i < N; i++) {
                id[i] = i;
            }
        }

        public int num(int N) {
            return id[N];
        }

        private int root(int i) {
            while (i != id[i]) {
                i = id[i];
            }
            return i;
        }

        public boolean connected(int p, int q) {
            return root(p) == root(q);
        }

        public void union(int p, int q) {
            int i = root(p);
            int j = root(q);
            id[i] = j;
        }
    }

    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            //read and record the information of the matrix size and the targeted site
            String[] info = br.readLine().split("","");

            int matrix_length = Integer.parseInt(info[0]);
            int matrix_size = matrix_length * matrix_length;
            int target_x = Integer.parseInt(info[1]) - 1;
            int target_y = Integer.parseInt(info[2]) - 1;
            int child;

            //Create a matrx in order to mark the blocked site
            int[][] markmatrix = new int[matrix_length][matrix_length];
            for (int i = 0; i < matrix_length; i++) {
                for (int j = 0; j < matrix_length; j++) {
                    markmatrix[i][j] = -1;
                }
            }

            LabelCC LCC = new LabelCC();
            My_QuickUnionUF uf = LCC.new My_QuickUnionUF(matrix_size);

            //set the blocked site to 0
            while (br.ready()) {
                String[] blocked = br.readLine().split("","");
                if (blocked == null) {
                    break;
                }
                int x = Integer.parseInt(blocked[0]) - 1;
                int y = Integer.parseInt(blocked[1]) - 1;

                markmatrix[x][y] = 0;
            }

            int IDnum = 1;
            for (int i = 0; i < matrix_length; i++) {
                for (int j = 0; j < matrix_length; j++) {
                    //左上角
                    if (i == 0 && j == 0) {
                        if (markmatrix[i][j] == 0) {
                            continue;
                        } else {
                            markmatrix[i][j] = IDnum;
                            IDnum++;
                        }
                    } //上排
                    else if (i == 0 && j != 0) {
                        if (markmatrix[i][j] == 0) {
                            continue;
                        } else if (markmatrix[i][j - 1] == 0) {
                            markmatrix[i][j] = IDnum;
                            IDnum++;
                        } else {
                            markmatrix[i][j] = markmatrix[i][j - 1];
                        }
                    } //左排
                    else if (i != 0 && j == 0) {
                        if (markmatrix[i][j] == 0) {
                            continue;
                        } else if (markmatrix[i - 1][j] == 0) {
                            markmatrix[i][j] = IDnum;
                            IDnum++;
                        } else {
                            markmatrix[i][j] = markmatrix[i - 1][j];
                        }

                    } else {
                        if (markmatrix[i][j] == 0) {
                            continue;
                        } else {
                            //上>左
                            if (markmatrix[i - 1][j] > markmatrix[i][j - 1]) {
                                child = markmatrix[i - 1][j];
                                //左 = 0
                                if (markmatrix[i][j - 1] == 0) {
                                    markmatrix[i][j] = markmatrix[i - 1][j];
                                } else {
                                    markmatrix[i][j] = markmatrix[i][j - 1];
                                    
//                                    System.out.printf(""+ \n"");
//                                    System.out.printf(""i:%d "" + ""j:%d \n"", i, j);
                                    for (int m = 0; m < matrix_length; m++) {
                                        for (int n = 0; n < matrix_length; n++) {
                                            if (markmatrix[m][n] == child) {
                                                markmatrix[m][n] = markmatrix[i][j];
//                                                System.out.printf(""m:%d "" + ""n:%d \n"", m, n);
//                                                System.out.printf(""%d\n"", markmatrix[1][5]);
//                                                System.out.printf(""%d\n"", markmatrix[0][5]);
//                                                System.out.printf(""%d\n"", markmatrix[i-1][j]);
                                            }

                                        }
                                    }
                                }
                            }
                            //上<左
                            if (markmatrix[i - 1][j] < markmatrix[i][j - 1]) {
                                child = markmatrix[i][j - 1];
                                //上=0
                                if (markmatrix[i - 1][j] == 0) {
                                    markmatrix[i][j] = markmatrix[i][j - 1];
                                } else {
                                    markmatrix[i][j] = markmatrix[i - 1][j];
//                                    System.out.printf(""+ \n"");
//                                    System.out.printf(""i:%d "" + ""j:%d \n"", i, j);
                                    for (int m = 0; m < matrix_length; m++) {
                                        for (int n = 0; n < matrix_length; n++) {
                                            if (markmatrix[m][n] == child) {
                                                markmatrix[m][n] = markmatrix[i][j];
//                                                System.out.printf(""m:%d "" + ""n:%d \n"", m, n);
                                            }
                                        }
                                    }
                                    
                                }
                            }
                            //上=左
                            if (markmatrix[i - 1][j] == markmatrix[i][j - 1]) {
                                if (markmatrix[i - 1][j] == 0) {
                                    markmatrix[i][j] = IDnum;
                                    IDnum++;
                                } else {
                                    markmatrix[i][j] = markmatrix[i - 1][j];
                                }
                            }
                        }
                    }
                }

            }

//            System.out.printf(""%d , "", matrix_length);
//            System.out.printf(""%d , "", target_x);
//            System.out.printf(""%d \n"", target_y);
//            for (int i = 0; i < matrix_length; i++) {
//                for (int j = 0; j < matrix_length; j++) {
//                    System.out.printf(""%2d "", markmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            
            System.out.printf(""%d"", markmatrix[target_x][target_y]);
        } catch (IOException ex) {
            System.out.printf(""Failed to open the file"");
        }
    }
}

@8b67259c5bdab638977a6b7462dac9b8@"
"b02611016","9","1.25","155712","@341db1ee916068eee0c7c325c993f0d6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                //labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
               // labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                    //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   //labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
               // labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
              // labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }
for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1)
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { k1=id[(row-1)*num+cloumn-2];
                    //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {//if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   //labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  // labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {//if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   //labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   //labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}
           /*  for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@341db1ee916068eee0c7c325c993f0d6@"
"b02611016","0","2.15","264224","@b6ac84772a4c57566dc00dbb6758340d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }
for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1)
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { k1=id[(row-1)*num+cloumn-2];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}
             for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@b6ac84772a4c57566dc00dbb6758340d@"
"b02611016","9","1.33","155600","@f534f7bdcdad1c3e901f23da70576967@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }
for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1)
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { k1=id[(row-1)*num+cloumn-2];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}
        /*     for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
        
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
            br.close();
        }
    }
}

@f534f7bdcdad1c3e901f23da70576967@"
"r03522826","7","1.09","170064","@3ce8fef90de000b0a54d1e221022ef15@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader (new FileReader (args[0]))){
        
            // Initialization & Read first line
            String [] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);         // Dimension
            int x0 = Integer.parseInt(data[1]);
            int y0 = Integer.parseInt(data[2]);
            int [][] check = new int [N][N];
//            int [][] parent = new int [N][N];
            String d;
            
            for (int i = 0; i < N; i++){
                for(int j = 0; j < N; j++)
                    check[i][j] = 1;
            }
//            System.out.println(N);
//            System.out.println(x0);
//            System.out.println(y0);
            
            // Readfile the other lines
            while((d = br.readLine()) != null){
                d = d.replaceAll("" "", """");
                String [] data1 = d.split("","");
                int x = Integer.parseInt(data1[0]);
                int y = Integer.parseInt(data1[1]);
                
                check[x-1][y-1] = 0;
                
            }
            
        int label = 1;
        UF uf = new UF(N*N+2);
//        QuickFindUF uf = new QuickFindUF(N*N+1);
        int p = 0, q = 0;
        for(int i = 0; i < N; i++)
        {
            for(int j = 0; j < N; j++)
            {
                if(0 != check[i][j])
                {
                    if (0 == i)
                    {
                        if (0 == j)
                        {
                            check[i][j] = label;
//                            parent[i][j] = label;
                            label += 1;
                        }
                        else
                        {
                            if (0 == check[i][j-1])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i][j-1];
//                                parent[i][j] = parent[i][j-1];
                            }
                        }
                    }
                    else
                    {
                        if (0 == j)
                        {
                            if (0 == check[i-1][j])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i-1][j];
//                                parent[i][j] = parent[i-1][j];
                            }
                        }
                        else
                        {
                            if (0 == check[i-1][j])
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = label;
//                                    parent[i][j] = label;
                                    label += 1;
                                }
                                else
                                {
                                    check[i][j] = check[i][j-1];
//                                    parent[i][j] = parent[i][j-1];
                                }
                            }
                            else
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = check[i-1][j];
//                                    parent[i][j] = parent[i-1][j];
                                }
                                else
                                {
                                    if (check[i][j-1] < check[i-1][j])
                                    {
                                        check[i][j] = check[i][j-1];
//                                        p = check[i][j-1];
//                                        q = check[i-1][j];
                                        uf.union(check[i][j-1],check[i-1][j]);
                                    }
                                    else if (check[i][j-1] > check[i-1][j])
                                    {
                                        check[i][j] = check[i-1][j];
                                        uf.union(check[i-1][j],check[i][j-1]);
                                    }
                                }
                            }
                        }
                            
                    }
                    
                }
                
            }
        }
        
//        for (int i = 0; i < N; i++)
//        {
//            for (int j = 0; j <N; j++)
//                System.out.println(check[i][j]);
//        }
//            System.out.println(label);
//        
        
            for (int i =0; i < N; i++)
            {
                for (int j = 0; j < N; j++)
                {
                    if(0 != check[i][j])
                        check[i][j] = uf.find(check[i][j]);
                }
            }
            
            System.out.println(check[x0-1][y0-1]);
//            for (int i =0; i < N; i++)
//            {
//                for (int j = 0; j < N; j++)
//                {
//                    System.out.println(check[i][j]);
//                }
//            }
        }
    }
    
}

@3ce8fef90de000b0a54d1e221022ef15@"
"b02611016","9","1.38","160336","@b2b8d3e076e4668d6ba232a42e9c61e1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }
for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1)
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { k1=id[(row-1)*num+cloumn-2];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}
        /*     for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
         if(x_position>num||y_position>num)
          { System.out.printf(""0"");
          
          }
         else{
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
         }
            br.close();
        }
    }
}

@b2b8d3e076e4668d6ba232a42e9c61e1@"
"r03723070","6","1.03","131904","@b0b8d0aa7f5084f28719851375595791@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */
public class LabelCC {
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = 0;
          data0 = br.readLine();
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   //System.out.printf(""if it is an open data[%d][%d] is %d\n"",i,j,data[i][j]);
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);  
                           connect[p] = q;
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   }
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    /*if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      //int p = Math.max(data[i][j-1],data[i-1][j]);
                      //int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           //connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }*/
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       } 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       /*for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }  
       }*/ 
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
       for(int i =1;i<=count;i++){
           if(data[ans[0]][ans[1]] == i && connect[i] !=0)
           data[ans[0]][ans[1]] = connect[i];
           if(data[ans[0]][ans[1]] == i && connect[i] ==0)
           data[ans[0]][ans[1]] = data[ans[0]][ans[1]] ;
       }
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    
@b0b8d0aa7f5084f28719851375595791@"
"b02611016","9","1.35","157744","@b2b8d3e076e4668d6ba232a42e9c61e1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }
for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1)
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { k1=id[(row-1)*num+cloumn-2];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}
        /*     for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
         if(x_position>num||y_position>num)
          { System.out.printf(""0"");
          
          }
         else{
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
         }
            br.close();
        }
    }
}

@b2b8d3e076e4668d6ba232a42e9c61e1@"
"r03522826","9","1.08","165040","@8404c8dde2e3af2324f957659f4a2315@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader (new FileReader (args[0]))){
        
            // Initialization & Read first line
            String [] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);         // Dimension
            int x0 = Integer.parseInt(data[1]);
            int y0 = Integer.parseInt(data[2]);
            int [][] check = new int [N][N];
//            int [][] parent = new int [N][N];
            String d;
            
            for (int i = 0; i < N; i++){
                for(int j = 0; j < N; j++)
                    check[i][j] = 1;
            }
//            System.out.println(N);
//            System.out.println(x0);
//            System.out.println(y0);
            
            // Readfile the other lines
            while((d = br.readLine()) != null){
                d = d.replaceAll("" "", """");
                String [] data1 = d.split("","");
                int x = Integer.parseInt(data1[0]);
                int y = Integer.parseInt(data1[1]);
                
                check[x-1][y-1] = 0;
                
            }
            
        int label = 1;
        UF uf = new UF((N*N)/2+2);
//        QuickFindUF uf = new QuickFindUF(N*N+1);
        int p = 0, q = 0;
        for(int i = 0; i < N; i++)
        {
            for(int j = 0; j < N; j++)
            {
                if(0 != check[i][j])    // Not block
                {
                    if (0 == i)     // First row
                    {
                        if (0 == j)  // First row & column
                        {
                            check[i][j] = label;
//                            parent[i][j] = label;
                            label += 1;
                        }
                        else  // First row and the other columns
                        {
                            if (0 == check[i][j-1])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i][j-1];
//                                parent[i][j] = parent[i][j-1];
                            }
                        }
                    }
                    else
                    {
                        if (0 == j)
                        {
                            if (0 == check[i-1][j])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i-1][j];
//                                parent[i][j] = parent[i-1][j];
                            }
                        }
                        else
                        {
                            if (0 == check[i-1][j])
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = label;
//                                    parent[i][j] = label;
                                    label += 1;
                                }
                                else
                                {
                                    check[i][j] = check[i][j-1];
//                                    parent[i][j] = parent[i][j-1];
                                }
                            }
                            else
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = check[i-1][j];
//                                    parent[i][j] = parent[i-1][j];
                                }
                                else
                                {
                                    if (check[i][j-1] <= check[i-1][j])
                                    {
                                        check[i][j] = check[i][j-1];
//                                        p = check[i][j-1];
//                                        q = check[i-1][j];
                                        uf.union(check[i][j-1],check[i-1][j]);
                                    }
                                    else
                                    {
                                        check[i][j] = check[i-1][j];
                                        uf.union(check[i-1][j],check[i][j-1]);
                                    }
                                }
                            }
                        }
                            
                    }
                    
                }
                
            }
        }
        
//        for (int i = 0; i < N; i++)
//        {
//            for (int j = 0; j <N; j++)
//                System.out.println(check[i][j]);
//        }
//            System.out.println(label);
//        
        
            for (int i =0; i < N; i++)
            {
                for (int j = 0; j < N; j++)
                {
                    if(0 != check[i][j])
                        check[i][j] = uf.find(check[i][j]);
                }
            }
            
            System.out.println(check[x0-1][y0-1]);
//            for (int i =0; i < N; i++)
//            {
//                for (int j = 0; j < N; j++)
//                {
//                    System.out.println(check[i][j]);
//                }
//            }
        }
    }
    
}

@8404c8dde2e3af2324f957659f4a2315@"
"r03522826","9","1.09","168288","@e74d10b5e180b40ac88959cdfe94f1ec@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader (new FileReader (args[0]))){
        
            // Initialization & Read first line
            String [] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);         // Dimension
            int x0 = Integer.parseInt(data[1]);
            int y0 = Integer.parseInt(data[2]);
            int [][] check = new int [N][N];
//            int [][] parent = new int [N][N];
            String d;
            
            for (int i = 0; i < N; i++){
                for(int j = 0; j < N; j++)
                    check[i][j] = 1;
            }
//            System.out.println(N);
//            System.out.println(x0);
//            System.out.println(y0);
            
            // Readfile the other lines
            while((d = br.readLine()) != null){
                d = d.replaceAll("" "", """");
                String [] data1 = d.split("","");
                int x = Integer.parseInt(data1[0]);
                int y = Integer.parseInt(data1[1]);
                
                check[x-1][y-1] = 0;
                
            }
            
        int label = 1;
        UF uf = new UF((N*N)/2+2);
//        QuickFindUF uf = new QuickFindUF(N*N+1);
//        int p = 0, q = 0;
        for(int i = 0; i < N; i++)
        {
            for(int j = 0; j < N; j++)
            {
                if(0 != check[i][j])    // Not block
                {
                    if (0 == i)     // First row
                    {
                        if (0 == j)  // First row & column
                        {
                            check[i][j] = label;
//                            parent[i][j] = label;
                            label += 1;
                        }
                        else  // First row and the other columns
                        {
                            if (0 == check[i][j-1])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i][j-1];
//                                parent[i][j] = parent[i][j-1];
                            }
                        }
                    }
                    else
                    {
                        if (0 == j)
                        {
                            if (0 == check[i-1][j])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i-1][j];
//                                parent[i][j] = parent[i-1][j];
                            }
                        }
                        else
                        {
                            if (0 == check[i-1][j])
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = label;
//                                    parent[i][j] = label;
                                    label += 1;
                                }
                                else
                                {
                                    check[i][j] = check[i][j-1];
//                                    parent[i][j] = parent[i][j-1];
                                }
                            }
                            else
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = check[i-1][j];
//                                    parent[i][j] = parent[i-1][j];
                                }
                                else
                                {
                                    if (check[i][j-1] <= check[i-1][j])
                                    {
                                        check[i][j] = check[i][j-1];
//                                        p = check[i][j-1];
//                                        q = check[i-1][j];
                                        uf.union(check[i][j-1],check[i-1][j]);
                                    }
                                    else
                                    {
                                        check[i][j] = check[i-1][j];
                                        uf.union(check[i-1][j],check[i][j-1]);
                                    }
                                }
                            }
                        }
                            
                    }
                    
                }
                
            }
        }
        
//        for (int i = 0; i < N; i++)
//        {
//            for (int j = 0; j <N; j++)
//                System.out.println(check[i][j]);
//        }
//            System.out.println(label);
//        
        
            for (int i =0; i < N; i++)
            {
                for (int j = 0; j < N; j++)
                {
                    if(0 != check[i][j]&&check[i][j] != uf.find(check[i][j]))
                        check[i][j] = uf.find(check[i][j]);
                }
            }
            
            System.out.println(check[x0-1][y0-1]);
//            for (int i =0; i < N; i++)
//            {
//                for (int j = 0; j < N; j++)
//                {
//                    System.out.println(check[i][j]);
//                }
//            }
        }
    }
    
}

@e74d10b5e180b40ac88959cdfe94f1ec@"
"b03611033","6","0.97","126336","@d0b75b2c6f75a2d40868e22308fdd6b3@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public int[][] root;
    public int parent[];
    public LabelCC(int n){
        root=new int[n][n];
        parent=new int[n*n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                root[i][j]=1;
                parent[i*n+j]=i*n+j;
            }
        }
    }
    
    public void blocked(int x,int y){
        root[x][y]=0;
    }
    public void firstrun(int n){
        int rootput=1;
        boolean stop=false;
        for(int j=0;j<n;j++){
            if(root[0][j]!=0){
                root[0][j]=rootput;
                stop=true;
            }        
            else{
                if(stop){
                    rootput++;
                    stop=false;
                }
            }   
        }    
        for(int i=1;i<n;i++){
            for(int j=0;j<n;j++){
                if(root[i][j]!=0){
                    if(j==0 || root[i][j-1]==0){
                        if(root[i-1][j]!=0){
                            root[i][j]=root[i-1][j];
                        }
                        else{
                            rootput++;
                            root[i][j]=rootput;
                        }
                    }
                    else{
                        root[i][j]=root[i][j-1];
                        if(root[i-1][j]!=0 & root[i-1][j]!=root[i][j-1]){
                            if(root[i-1][j]<root[i][j-1])
                                parent[root[i][j-1]]=root[i-1][j];
                            else
                                parent[root[i-1][j]]=root[i][j-1];
                        }
                    }
                     
                }
            }
        }
    }
    public int find(int x){
        while(x!=parent[x]){
            x=parent[parent[x]];
        }
        return x;
    }
    public void show(int n,int p,int q){
        if(n==1){
            StdOut.println(root[0][0]);
            return;
        }
       StdOut.println(find(root[p][q]));
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            String datacut[];
            datacut = data.split("","");
            int N = Integer.parseInt(datacut[0]);  
            int fp = Integer.parseInt(datacut[1]);
            int fq = Integer.parseInt(datacut[2]);
            int p;
            int q;
            LabelCC labelCC = new LabelCC(N);
            
            while((data = br.readLine()) != null){
                datacut=data.split("","");
                p=Integer.parseInt(datacut[0]);
                q=Integer.parseInt(datacut[1]);
                labelCC.blocked(p-1,q-1);
            }
            labelCC.firstrun(N);
            labelCC.show(N,fp-1,fq-1);
        }        
    }        
}                


@d0b75b2c6f75a2d40868e22308fdd6b3@"
"r03522826","10","0.11","166640","@e1158ea841e02e175c77baef889a90d5@import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author stonebreaker
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception{
        
        try(BufferedReader br = new BufferedReader (new FileReader (args[0]))){
        
            // Initialization & Read first line
            String [] data = br.readLine().split("","");
            int N = Integer.parseInt(data[0]);         // Dimension
            int x0 = Integer.parseInt(data[1]);
            int y0 = Integer.parseInt(data[2]);
            int [][] check = new int [N][N];
//            int [][] parent = new int [N][N];
            String d;
            
            for (int i = 0; i < N; i++){
                for(int j = 0; j < N; j++)
                    check[i][j] = 1;
            }
//            System.out.println(N);
//            System.out.println(x0);
//            System.out.println(y0);
            
            // Readfile the other lines
            while((d = br.readLine()) != null){
                d = d.replaceAll("" "", """");
                String [] data1 = d.split("","");
                int x = Integer.parseInt(data1[0]);
                int y = Integer.parseInt(data1[1]);
                
                check[x-1][y-1] = 0;
                
            }
            
        int label = 1;
//        UF uf = new UF((N*N)/2+2);
        QuickFindUF uf = new QuickFindUF(N*N/2+1);
//        int p = 0, q = 0;
        for(int i = 0; i < N; i++)
        {
            for(int j = 0; j < N; j++)
            {
                if(0 != check[i][j])    // Not block
                {
                    if (0 == i)     // First row
                    {
                        if (0 == j)  // First row & column
                        {
                            check[i][j] = label;
//                            parent[i][j] = label;
                            label += 1;
                        }
                        else  // First row and the other columns
                        {
                            if (0 == check[i][j-1])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i][j-1];
//                                parent[i][j] = parent[i][j-1];
                            }
                        }
                    }
                    else
                    {
                        if (0 == j)
                        {
                            if (0 == check[i-1][j])
                            {
                                check[i][j] = label;
//                                parent[i][j] = label;
                                label += 1;
                            }
                            else
                            {
                                check[i][j] = check[i-1][j];
//                                parent[i][j] = parent[i-1][j];
                            }
                        }
                        else
                        {
                            if (0 == check[i-1][j])
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = label;
//                                    parent[i][j] = label;
                                    label += 1;
                                }
                                else
                                {
                                    check[i][j] = check[i][j-1];
//                                    parent[i][j] = parent[i][j-1];
                                }
                            }
                            else
                            {
                                if (0 == check[i][j-1])
                                {
                                    check[i][j] = check[i-1][j];
//                                    parent[i][j] = parent[i-1][j];
                                }
                                else
                                {
                                    if (check[i][j-1] <= check[i-1][j])
                                    {
                                        check[i][j] = check[i][j-1];
//                                        p = check[i][j-1];
//                                        q = check[i-1][j];
//                                        uf.union(check[i][j-1],check[i-1][j]);
                                        uf.union(check[i-1][j],check[i][j-1]);
                                    }
                                    else
                                    {
                                        check[i][j] = check[i-1][j];
//                                        uf.union(check[i-1][j],check[i][j-1]);
                                         uf.union(check[i][j-1],check[i-1][j]);
                                    }
                                }
                            }
                        }
                            
                    }
                    
                }
                
            }
        }
        
//        for (int i = 0; i < N; i++)
//        {
//            for (int j = 0; j <N; j++)
//                System.out.println(check[i][j]);
//        }
//            System.out.println(label);
//        
        
            for (int i =0; i < N; i++)
            {
                for (int j = 0; j < N; j++)
                {
                    if(0 != check[i][j])
                        check[i][j] = uf.find(check[i][j]);
                }
            }
            
            System.out.println(check[x0-1][y0-1]);
//            for (int i =0; i < N; i++)
//            {
//                for (int j = 0; j < N; j++)
//                {
//                    System.out.println(check[i][j]);
//                }
//            }
        }
    }
    
}

@e1158ea841e02e175c77baef889a90d5@"
"r03723070","5","1","126976","@77de5e3dd4ea94adaea3bf8cfcc419c2@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = 0;
          data0 = br.readLine();
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                   else if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       if(data[i][j-1]>0 && data[i-1][j] > 0 ){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                           if(connect[p]!=0)
                           connect[p] = Math.min(q,connect[p]);
                           else
                               connect[p] = q;
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   }
                   //else 
                       //data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                    /*if(data[i][j-1] != data[i-1][j] && data[i][j-1]*data[i-1][j] > 0){
                      //int p = Math.max(data[i][j-1],data[i-1][j]);
                      //int q = Math.min(data[i][j-1],data[i-1][j]);                                                       
                           //record [min-1][max]
                           //System.out.printf(""connect p is %d, q is %d \n"",p,q);
                           //connect[p] = q;
                           //System.out.printf(""connect[%d] is %d ; and i is %d j is %d\n"",p,connect[p],i,j);
               }*/
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       /*for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       }*/ 
       //print all connect
       /*for (int i =0;i<N+1;i++){
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       /*for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }  
       }*/ 
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
       /*for(int i =1;i<=count;i++){
           if(data[ans[0]][ans[1]] == i && connect[i] !=0)
           data[ans[0]][ans[1]] = connect[i];
           if(data[ans[0]][ans[1]] == i && connect[i] ==0)
           data[ans[0]][ans[1]] = data[ans[0]][ans[1]] ;
       }*/
        System.out.printf(""%d\n"",data[ans[0]][ans[1]]);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    
@77de5e3dd4ea94adaea3bf8cfcc419c2@"
"r03723070","8","1","129488","@12c84f1e8f7369b7492213a1ea962689@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = 0;
          data0 = br.readLine();
       }
       // show first step the metric
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N){
               System.out.printf(""\n"", data[i][j]);
                 
               }
           }
       }*/
       
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       
                       if(data[i][j-1]>0 && data[i-1][j] > 0){
                           data[i][j] = data[i][j-1];
                           if(data[i-1][j]!=data[i][j-1]){
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                           if(connect[p]!=0)
                           connect[p] = Math.min(q,connect[p]);
                           else
                               connect[p] = q;
                           }
                           
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       // print the connect
       /*for (int i =1;i<=count;i++){
           //System.out.printf(""connect[%d] is %d\n"",i,connect[i]);         
           //change the root to the smallest
           for(int j=1;j<=count;j++ ){
               if(connect[j]==i && connect[i]!=0){                  
                   connect[j] = connect[i];
                   //System.out.printf(""!!!connect[%d] is %d\n"",i,connect[i]);
               }
           }
       }*/ 
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       // modify it into the correct group
       //int [] fff = new int [2];
       /*for(int i =1;i<=count;i++){
           //BinarySearch BS =  new BinarySearch;
           
        for(int j =1;j<N+1;j++ ){
               for(int k =1; k<N+1 ;k++){
                if(data[j][k] == i &&connect[i]!=0) {
                //match data[j][k] min to others max
                //System.out.printf("" data[%d][%d] equal to connect[%d]\n"",i,j,data[i][j],i-1);
                data[j][k] = connect[i];
                
                // change it into the less one
                 //System.out.printf("" data[%d][%d] chage to %d\n"",i,j,data[i][j]); 
               }  
            }   
           }  
       }*/ 
        //System.out.printf(""ans[0] is %d ans[1] is %d\n"",ans[0],ans[1]);
       //print the result metrix
       
        //System.out.printf(""data[%d][%d] is %d\n"",ans[0],ans[1],data[ans[0]][ans[1]]);
       /*for(int i =1;i<=count;i++){
           if(data[ans[0]][ans[1]] == i && connect[i] !=0)
           data[ans[0]][ans[1]] = connect[i];
           if(data[ans[0]][ans[1]] == i && connect[i] ==0)
           data[ans[0]][ans[1]] = data[ans[0]][ans[1]] ;
       }*/
       int finalans =data[ans[0]][ans[1]] ;
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       
        System.out.printf(""%d\n"",finalans);
        

//print the result metrix
        /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
               System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }*/
       }
       }
    
@12c84f1e8f7369b7492213a1ea962689@"
"b03611033","9","1.02","123936","@4d6880c1d58a68e3c1698955b3a8150e@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public int[][] root;
    public int parent[];
    public LabelCC(int n){
        root=new int[n][n];
        parent=new int[n*n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                root[i][j]=1;
                parent[i*n+j]=i*n+j;
            }
        }
    }
    
    public void blocked(int x,int y){
        root[x][y]=0;
    }
    public void firstrun(int n){
        int rootput=1;
        boolean stop=false;
        for(int j=0;j<n;j++){
            if(root[0][j]!=0){
                root[0][j]=rootput;
                stop=true;
            }        
            else{
                if(stop){
                    rootput++;
                    stop=false;
                }
            }   
        }    
        for(int i=1;i<n;i++){
            for(int j=0;j<n;j++){
                if(root[i][j]!=0){
                    if(j==0 || root[i][j-1]==0){
                        if(root[i-1][j]!=0){
                            root[i][j]=root[i-1][j];
                        }
                        else{
                            if(stop){
                                rootput++;
                            }
                            root[i][j]=rootput;
                            stop=true;
                        }
                    }
                    else{
                        root[i][j]=root[i][j-1];
                        if(root[i-1][j]!=0 & root[i-1][j]!=root[i][j-1]){
                            if(root[i-1][j]<root[i][j-1])
                                parent[root[i][j-1]]=root[i-1][j];
                            else
                                parent[root[i-1][j]]=root[i][j-1];
                        }
                    }
                     
                }
            }
        }
    }
    public int find(int x){
        while(x!=parent[x]){
            x=parent[parent[x]];
        }
        return x;
    }
    public void show(int n,int p,int q){
        if(n==1){
            StdOut.println(root[0][0]);
            return;
        }
       StdOut.println(find(root[p][q]));
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            String datacut[];
            datacut = data.split("","");
            int N = Integer.parseInt(datacut[0]);  
            int fp = Integer.parseInt(datacut[1]);
            int fq = Integer.parseInt(datacut[2]);
            int p;
            int q;
            LabelCC labelCC = new LabelCC(N);
            
            while((data = br.readLine()) != null){
                datacut=data.split("","");
                p=Integer.parseInt(datacut[0]);
                q=Integer.parseInt(datacut[1]);
                labelCC.blocked(p-1,q-1);
            }
            labelCC.firstrun(N);
            labelCC.show(N,fp-1,fq-1);
        }        
    }        
}                


@4d6880c1d58a68e3c1698955b3a8150e@"
"r03723070","0","1.74","229296","@34f80ef6dc16a733f23d8229fb51f943@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = 0;
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       
                       if(data[i][j-1]>0 && data[i-1][j] > 0){
                           data[i][j] = data[i][j-1];
                           if(data[i-1][j]!=data[i][j-1]){
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                           if(connect[p]!=0)
                           connect[p] = Math.min(q,connect[p]);
                           else
                               connect[p] = q;
                           }
                           
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }
       //print all connect
       for (int i =0;i<N*N;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }     
       int finalans =data[ans[0]][ans[1]] ;
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       
        System.out.printf(""%d\n"",finalans);
        
       }
       }
    
@34f80ef6dc16a733f23d8229fb51f943@"
"r03723070","8","1.02","125408","@fe9d86c708dc4c1c60e17414648376ff@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = 0;
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++ ){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);
                       
                       if(data[i][j-1]>0 && data[i-1][j] > 0){
                           data[i][j] = data[i][j-1];
                           if(data[i-1][j]!=data[i][j-1]){
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                           if(connect[p]!=0)
                           connect[p] = Math.min(q,connect[p]);
                           else
                               connect[p] = q;
                           }
                           
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       } */    
       int finalans =data[ans[0]][ans[1]] ;
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       
        System.out.printf(""%d\n"",finalans);
        
       }
       }
    
@fe9d86c708dc4c1c60e17414648376ff@"
"r04631026","5","0.99","121424","@a117a38a62c7529b08255852b2bd3b96@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] Initial = br.readLine().split("","");
            //Set the matrix size
            int Num = Integer.parseInt(Initial[0]);
            //Target point
//            int X = Integer.parseInt(Initial[1]);
//            int Y = Integer.parseInt(Initial[2]);
            int[][] matrix = new int[Num][Num];
            int AreaNum = 1;
            for (int i=0;i<Num;i++){
                for (int j=0;j<Num;j++){
                    matrix[i][j] = 1;
                }
            }
            while (br.ready()){
                String[] Position = br.readLine().split("","");
                matrix[Integer.parseInt(Position[0])-1][Integer.parseInt(Position[1])-1]=0;
            }
            //Set first row
            for (int i=0;i<Num;i++){
                if (matrix[0][i]==0){
                    AreaNum++;
                    continue;
                }
                else {
                    matrix[0][i]= AreaNum;
                }
            }
//            System.out.println(AreaNum);
            boolean CheckStat = false;
            
//            System.out.println(AreaNum);
            for (int i=1;i<Num;i++){
                for (int j=0;j<Num;j++){
                    if (matrix[i][j]==0){continue;}
                    //Set first column
                    if (j==0){
                        if (matrix[i-1][j]!=0){
                            matrix[i][j] = matrix[i-1][j];
                            CheckStat = false;
                        }
                        else{
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                            CheckStat = true;
                        }
                    }
                    else{
                        //Check left
                        if (matrix[i][j-1]==0 && matrix[i-1][j]==0){
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]!=0){
                            //Top is smaller
                            if (matrix[i][j-1]>matrix[i-1][j]){
                                matrix[i][j]=matrix[i-1][j];
                            }
                            //Left is smaller
                            else{
                                matrix[i][j]=matrix[i][j-1];
                            }
                        }
                        else if(matrix[i][j-1]==0 && matrix[i-1][j]!=0){
                            matrix[i][j]=matrix[i-1][j];                           
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]==0){
                            matrix[i][j]=matrix[i][j-1];
                        }
                        else{
                            if (CheckStat){
                                AreaNum++;
                                matrix[i][j]=AreaNum;
                                CheckStat = true;
                            }
                            else{
                                matrix[i][j]=AreaNum;
                            }
                        }
                    }
                }
            }
            
            //Print all value in matrix
//            for (int i=0;i<Num;i++){
//                for (int j=0;j<Num;j++){
//                    System.out.print(matrix[i][j]);
//                }
//            }
//            System.out.println("""");
            System.out.println(matrix[Integer.parseInt(Initial[1])-1][Integer.parseInt(Initial[2])-1]);
        }        
    }
}
@a117a38a62c7529b08255852b2bd3b96@"
"r03723070","9","0.99","126800","@6cb8c3424c6b6958122086aa795c5724@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               data[i][j] = -1;
           }
       }
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = 0;
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=0){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                       if(data[i][j-1]>0 && data[i-1][j] > 0){
                           data[i][j] = data[i][j-1];
                           if(data[i-1][j]!=data[i][j-1]){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           
                           if(connect[q]!=0)
                           connect[p] = connect[q];
                           else
                               connect[p] = q;
                           
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                       }
                           
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/    
       int finalans =data[ans[0]][ans[1]] ;
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       
        System.out.printf(""%d\n"",finalans);
        
       }
       }
    
@6cb8c3424c6b6958122086aa795c5724@"
"b03611033","7","0.63","126928","@6eca8e59162dc93b808879c21292402b@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public int[][] root;
    public int parent[];
    public LabelCC(int n){
        root=new int[n][n];
        parent=new int[n*n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                root[i][j]=1;
                parent[i*n+j]=i*n+j;
            }
        }
    }
    public void blocked(int x,int y){
        root[x][y]=0;
    }
    public void firstrun(int n){
        int rootput=1;
        boolean stop=false;
        for(int j=0;j<n;j++){
            if(root[0][j]!=0){
                root[0][j]=rootput;
                stop=true;
            }        
            else{
                if(stop){
                    rootput++;
                    stop=false;
                }
            }   
        }    
        for(int i=1;i<n;i++){
            for(int j=0;j<n;j++){
                if(root[i][j]!=0){
                    if(j==0 || root[i][j-1]==0){
                        if(root[i-1][j]!=0){
                            root[i][j]=root[i-1][j];
                        }
                        else{
                            if(stop)
                                rootput++;
                            root[i][j]=rootput;
                            stop=true;
                        }
                    }
                    else{
                        root[i][j]=root[i][j-1];
                        if(root[i-1][j]!=0 & root[i-1][j]!=root[i][j-1]){
                            if(find(root[i-1][j])<find(root[i][j-1]))
                                parent[root[i][j-1]]=root[i-1][j];
                            else        
                                parent[root[i-1][j]]=root[i][j-1];                            
                        }
                    } 
                }
            }
        }
    }
    public int find(int x){
        while(x!=parent[x]){
            x=parent[parent[x]];
        }
        return x;
    }
    public void show(int n,int p,int q){
        if(n==1){
            StdOut.println(root[0][0]);
            return;
        }
       StdOut.println(find(root[p][q]));
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            String datacut[];
            datacut = data.split("","");
            int N = Integer.parseInt(datacut[0]);  
            int fp = Integer.parseInt(datacut[1]);
            int fq = Integer.parseInt(datacut[2]);
            int p;
            int q;
            LabelCC labelCC = new LabelCC(N);
            while((data = br.readLine()) != null){
                datacut=data.split("","");
                p=Integer.parseInt(datacut[0]);
                q=Integer.parseInt(datacut[1]);
                labelCC.blocked(p-1,q-1);
            }
            labelCC.firstrun(N);
            labelCC.show(N,fp-1,fq-1);
        }        
    }        
}                


@6eca8e59162dc93b808879c21292402b@"
"r03723070","9","1","125968","@5da659c0541619562f6423fc73063bed@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                   if(data[i][j-1]>0 || data[i-1][j] > 0 ){
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                       if(data[i][j-1]>0 && data[i-1][j] > 0){
                           data[i][j] = data[i][j-1];
                           if(data[i-1][j]!=data[i][j-1]){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           
                           if(connect[q]!=0)
                           connect[p] = connect[q];
                           else
                               connect[p] = q;
                           
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                       }
                           
                       }
                       else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   }
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/   
       int finalans =data[ans[0]][ans[1]] ;
       
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       if(data[ans[0]][ans[1]]==-1)
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
       }
    

@5da659c0541619562f6423fc73063bed@"
"b03611033","7","0.63","127952","@7c682ebb76443e636c01db11711f908a@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public int[][] root;
    public int parent[];
    public LabelCC(int n){
        root=new int[n][n];
        parent=new int[n*n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                root[i][j]=1;
                parent[i*n+j]=i*n+j;
            }
        }
    }
    public void blocked(int x,int y){
        root[x][y]=0;
    }
    public void firstrun(int n){
        int rootput=1;
        boolean stop=false;
        for(int j=0;j<n;j++){
            if(root[0][j]!=0){
                root[0][j]=rootput;
                stop=true;
            }        
            else{
                if(stop){
                    rootput++;
                    stop=false;
                }
            }   
        }    
        for(int i=1;i<n;i++){
            for(int j=0;j<n;j++){
                if(root[i][j]!=0){
                    if(j==0 || root[i][j-1]==0){
                        if(root[i-1][j]!=0){
                            root[i][j]=root[i-1][j];
                        }
                        else{
                            if(stop)
                                rootput++;
                            root[i][j]=rootput;
                            stop=true;
                        }
                    }
                    else{
                        root[i][j]=root[i][j-1];
                        if(root[i-1][j]!=0 & root[i-1][j]!=root[i][j-1]){
                            if(root[i-1][j]!=parent[root[i-1][j]] || root[i][j-1]!=parent[root[i][j-1]]){
                                if(find(root[i-1][j])<find(root[i][j-1])){
                                    parent[root[i][j-1]]=root[i-1][j];
                                    //root[i][j]=root[i-1][j];
                                }
                                else{        
                                    parent[root[i-1][j]]=root[i][j-1];
                                    //root[i][j]=root[i][j-1];
                                }
                            }
                            else{
                                if(root[i-1][j]<root[i][j-1]){
                                    parent[root[i][j-1]]=root[i-1][j];
                                    //root[i][j]=root[i-1][j];
                                }
                                else{        
                                    parent[root[i-1][j]]=root[i][j-1];
                                    //root[i][j]=root[i][j-1];
                                }
                            }
                        }
                    } 
                }
            }
        }
    }
    public int find(int x){
        while(x!=parent[x]){
            x=parent[parent[x]];
        }
        return x;
    }
    public void show(int n,int p,int q){
        if(n==1){
            StdOut.println(root[0][0]);
            return;
        }
       StdOut.println(find(root[p][q]));
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            String datacut[];
            datacut = data.split("","");
            int N = Integer.parseInt(datacut[0]);  
            int fp = Integer.parseInt(datacut[1]);
            int fq = Integer.parseInt(datacut[2]);
            int p;
            int q;
            LabelCC labelCC = new LabelCC(N);
            while((data = br.readLine()) != null){
                datacut=data.split("","");
                p=Integer.parseInt(datacut[0]);
                q=Integer.parseInt(datacut[1]);
                labelCC.blocked(p-1,q-1);
            }
            labelCC.firstrun(N);
            labelCC.show(N,fp-1,fq-1);
        }        
    }        
}                


@7c682ebb76443e636c01db11711f908a@"
"r03723070","9","0.99","126976","@a97e727ed1dbefe71301cdd6853e599e@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                    else if(data[i][j-1]>0 && data[i-1][j] > 0){
                           data[i][j] = data[i][j-1];
                           if(data[i-1][j]!=data[i][j-1]){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           
                           if(connect[q]!=0)
                           connect[p] = connect[q];
                           else
                               connect[p] = q;
                           
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                       }
                           
                       }
                    else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/   
       int finalans =data[ans[0]][ans[1]] ;
       
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       if(data[ans[0]][ans[1]]==-1)
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
       }
    

@a97e727ed1dbefe71301cdd6853e599e@"
"r03723070","0","1.04","127760","@76a38ebc4fc314a46aef31d4f7d1b6e5@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       /*for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                    else if(data[i][j-1]>0 && data[i-1][j] > 0){
                           data[i][j] = data[i][j-1];
                           if(data[i-1][j]!=data[i][j-1]){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           
                           if(connect[q]!=0)
                           connect[p] = connect[q];
                           else
                               connect[p] = q;
                           
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                       }
                           
                       }
                    else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }*/
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/   
       int finalans =data[ans[0]][ans[1]] ;
       
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       if(data[ans[0]][ans[1]]==-1)
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
       }
    

@76a38ebc4fc314a46aef31d4f7d1b6e5@"
"b02611016","9","1.09","161728","@73f86838ed9f9fddeb2e7ab995ddb61d@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }
for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1&&(id[(row-2)*num+cloumn-1]!=id[(row-1)*num+cloumn-2]))
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { k1=id[(row-1)*num+cloumn-2];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}
        /*     for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
         if(x_position>num||y_position>num)
          { System.out.printf(""0"");
          
          }
         else{
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[(x_position-1)*num+y_position-1] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
         }
            br.close();
        }
    }
}

@73f86838ed9f9fddeb2e7ab995ddb61d@"
"r03723070","9","1","125440","@5a0276d9a18fa21bbb79a0e57a9fae0b@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                    else if(data[i][j-1]>0 && data[i-1][j] > 0){
                           data[i][j] = data[i][j-1];
                           if(data[i-1][j]!=data[i][j-1]){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           
                           if(connect[q]!=0)
                           connect[p] = connect[q];
                           else
                               connect[p] = q;
                           
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                       }
                           
                       }
                    else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]] ;
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
       }
    


@5a0276d9a18fa21bbb79a0e57a9fae0b@"
"r04945025","9","1.5","172656","@d21644bc73ccda6aebe35fa85fae4690@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.*;
import java.util.*;
/**
 *
 * @author user
 */
public class LabelCC {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here
          In in = new In(args[0]);
          String[] TopRow =in.readLine().split("","");
          
          String[][] matrix = new String[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];

          String line;       

          while ((line = in.readLine()) != null) {
              matrix[Integer.parseInt(line.split("","")[0])-1][Integer.parseInt(line.split("","")[1])-1]=""0"";
          }
            

            int label=1;
            for(int  i =0 ; i<matrix.length;i++)
            {
                 for(int  j =0 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {
                                   if(i ==0)   //first row
                                   {
                                        if(j==0) // first col
                                        {
                                             matrix[i][j]=Integer.toString(label);
                                        }
                                        else if(matrix[i][j-1]!=""0"")  //left site not block site >> connect
                                        {
                                             matrix[i][j]=matrix[i][j-1];
                                        }
                                        else   
                                        {
                                             matrix[i][j]=Integer.toString(++label);
                                        }
                                   }
                                   else //   another row
                                   {
                                        if(j==0)  //first col
                                        {
                                            if(matrix[i-1][j]!=""0"") // upper row not block site
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }
                                             else
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }
                                        }
                                        else // else col
                                        {
                                             if(matrix[i][j-1] != ""0"" && matrix[i-1][j]==""0"") // connext left col
                                             {
                                                  matrix[i][j]=matrix[i][j-1];
                                             }
                                             if(matrix[i-1][j] != ""0"" && matrix[i][j-1]==""0"") // connext upper row
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }                                            
                                             if(matrix[i][j-1] == ""0"" && matrix[i-1][j]==""0"")
                                             {
                                                  matrix[i][j]=Integer.toString(++label);
                                             }                                             
                                              if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                                             {
                                                  if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                                  {
                                                       matrix[i][j]=matrix[i][j-1];
                                                  }
                                                  else
                                                  {
                                                       matrix[i][j]=matrix[i-1][j];
                                                  }
                                             }                                                    
                                        }
                                   }        
                      }
                 }
            }

            QuickUnionUF uf = new QuickUnionUF(label+1);
            
           for(int  i =1 ; i<matrix.length;i++)
            {
                 for(int  j =1 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=""0"") // not block site
                      {            
                           if(matrix[i][j-1] != ""0"" && matrix[i-1][j]!=""0"")
                           {
                                if(Integer.parseInt(matrix[i][j-1]) < Integer.parseInt(matrix[i-1][j]))
                                 {
                                       uf.union(Integer.parseInt(matrix[i-1][j]),Integer.parseInt(matrix[i][j-1]));
                                  }
                                  else
                                   {
                                        uf.union(Integer.parseInt(matrix[i][j-1]),Integer.parseInt(matrix[i-1][j]));
                                    }               
                           }
                      }
                 }
            }
            
            
            
            
            
            
            
            
//            System.out.println(""check"");
//            
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      System.out.print(matrix[i][j]+""     "");
//                 }
//                                      System.out.println("""");
//            }
            
            
                        System.out.println(uf.find(Integer.parseInt(matrix[Integer.parseInt(TopRow[1])-1][Integer.parseInt(TopRow[2])-1])));
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
     }
}

@d21644bc73ccda6aebe35fa85fae4690@"
"r03723070","9","1","125824","@620d5e86f360e59a34813a9bb383cadf@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                    else if(data[i][j-1]>0 && data[i-1][j] > 0){
                           data[i][j] = data[i][j-1];
                           if(data[i-1][j]!=data[i][j-1]){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           
                           if(connect[q]!=0)
                           connect[p] = connect[q];
                           else
                               connect[p] = q;
                           
                           if(connect[q]!=0)
                           connect[q] = Math.min(q,connect[q]);
                           else
                               connect[q] = q;
                       }
                           
                       }
                    else{
                           data[i][j] = Math.max(data[i][j-1],data[i-1][j]);
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    


@620d5e86f360e59a34813a9bb383cadf@"
"b03611041","9","1.05","128368","@44c01650dec42dd133af319567911f7a@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int label[][]=new int[num+2][num+2];
            WeightedQuickUnionUF uf=new WeightedQuickUnionUF(num*num/2+1);


            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null) {
                String input[] = test.split("","");
                int row = Integer.parseInt(input[0]);
                int col = Integer.parseInt(input[1]);
                matrix[row][col] = false;
            }
//
//            for(int i=0;i<num+2;i++){
//                for(int j=0;j<num+2;j++){
//                    System.out.printf(""%3d"",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//
//            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for(int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        if(matrix[i-1][j]==false && matrix[i][j-1]==false){
                            label[i][j]=labelNum;
                            labelNum++;
                        }else{
                            if((label[i-1][j]>label[i][j-1] || label[i-1][j]==0) && label[i][j-1]!=0){
                                label[i][j]=label[i][j-1];
                            }else{
                                label[i][j]=label[i-1][j];
                            }
                        }
                    }
                }
            }

//            for(int i=0;i<num+2;i++){
//                for(int j=0;j<num+2;j++){
//                    {
//                        System.out.printf(""%3d"", uf.find(label[i][j]));
//                    }
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");

            for(int i=1;i<num+1;i++){
                for(int j=1;j<num+1;j++){
                    if(matrix[i][j]==false || label[i][j - 1] == 0 || label[i - 1][j] == 0)continue;
                    else {
                        if (label[i][j - 1] > label[i - 1][j]) {
                            uf.union(uf.find(label[i - 1][j]),label[i][j-1]);
                        } else {
                            uf.union( uf.find(label[i][j-1]),label[i -1 ][j]);
                        }
                    }
//                    for(int m=0;m<num+2;m++){
//                        for(int n=0;n<num+2;n++){
//                            {
//                                System.out.printf(""%3d"", uf.find(label[m][n]));
//                            }
//                        }
//                        System.out.printf(""\n"");
//                    }
//                    System.out.printf(""\n"");

                }
            }
//
//            for(int i=0;i<num+2;i++){
//                for(int j=0;j<num+2;j++){
//                    {
//                        System.out.printf(""%3d"", uf.find(label[i][j]));
//                    }
//                }
//                System.out.printf(""\n"");
//            }
            System.out.printf(""%d"", uf.find(label[targetRow][targetCol]));

        }
    }
}

@44c01650dec42dd133af319567911f7a@"
"b03611041","10","0.102","130976","@9a8cfc8dc554cc9985dd2b79dc617577@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by Sunny on 3/11/16.
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {

        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String test,FirstLine[]=br.readLine().split("","");
            int num=Integer.parseInt(FirstLine[0]);
            int targetRow=Integer.parseInt(FirstLine[1]);
            int targetCol=Integer.parseInt(FirstLine[2]);
            boolean matrix[][]=new boolean[num+2][num+2];
            int label[][]=new int[num+2][num+2];
            QuickUnionUF uf=new QuickUnionUF(num*num/2+1);


            //init
            for(int i=0;i<num+2;i++){
                for (int j=0;j<num+2;j++){
                    if(i==0||i==num+1 || j==0||j==num+1)
                        matrix[i][j]=false;
                    else
                        matrix[i][j]=true;
                }
            }
            //read file and build matrix
            while((test=br.readLine())!=null) {
                String input[] = test.split("","");
                int row = Integer.parseInt(input[0]);
                int col = Integer.parseInt(input[1]);
                matrix[row][col] = false;
            }
//
//            for(int i=0;i<num+2;i++){
//                for(int j=0;j<num+2;j++){
//                    System.out.printf(""%3d"",matrix[i][j]?1:0);
//                }
//                System.out.printf(""\n"");
//            }
//
//            System.out.printf(""\n"");

            int labelNum=1;
            for(int i=1;i<num+1;i++){
                for(int j=1;j<num+1;j++){
                    if(matrix[i][j]==false)continue;
                    else{
                        if(matrix[i-1][j]==false && matrix[i][j-1]==false){
                            label[i][j]=labelNum;
                            labelNum++;
                        }else{
                            if((label[i-1][j]>label[i][j-1] || label[i-1][j]==0) && label[i][j-1]!=0){
                                label[i][j]=label[i][j-1];
                            }else{
                                label[i][j]=label[i-1][j];
                            }
                        }
                    }
                }
            }

//            for(int i=0;i<num+2;i++){
//                for(int j=0;j<num+2;j++){
//                    {
//                        System.out.printf(""%3d"", uf.find(label[i][j]));
//                    }
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");

            for(int i=1;i<num+1;i++){
                for(int j=1;j<num+1;j++){
                    if(matrix[i][j]==false || label[i][j - 1] == 0 || label[i - 1][j] == 0)continue;
                    else {
                        if (label[i][j - 1] > label[i - 1][j]) {
                            uf.union(label[i][j-1],uf.find(label[i - 1][j]));
                        } else {
                            uf.union( label[i -1 ][j],uf.find(label[i][j-1]));
                        }
                    }
//                    for(int m=0;m<num+2;m++){
//                        for(int n=0;n<num+2;n++){
//                            {
//                                System.out.printf(""%3d"", uf.find(label[m][n]));
//                            }
//                        }
//                        System.out.printf(""\n"");
//                    }
//                    System.out.printf(""\n"");

                }
            }
//
//            for(int i=0;i<num+2;i++){
//                for(int j=0;j<num+2;j++){
//                    {
//                        System.out.printf(""%3d"", uf.find(label[i][j]));
//                    }
//                }
//                System.out.printf(""\n"");
//            }
            System.out.printf(""%d"", uf.find(label[targetRow][targetCol]));

        }
    }
}

@9a8cfc8dc554cc9985dd2b79dc617577@"
"r04631006","8","1.04","132080","@955d6a4e712cdf58eff1a0feec7af33d@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            num = num + 2;
            QuickFindUF qf = new QuickFindUF(num * num);

            int[] outla = new int[2];
            outla[0] = Integer.parseInt(a[1]);
            outla[1] = Integer.parseInt(a[2]);

            int[][] ma = new int[num][num];
            int[][] CC = new int[num][num];

            String loca0;
            String[] loca;
            int x;
            int y;
            int c = 1;

            while (!((loca0 = br.readLine()) == null)) {
                loca = loca0.split("","");
                x = Integer.parseInt(loca[0]);
                y = Integer.parseInt(loca[1]);
                ma[x][y] = 1;
                if (x == outla[0] && y == outla[1]) {
                    System.out.printf(""%d"", 0);
                    return;
                }
            }
            for (int i = 0; i < num; i++) {
                if (i == 0 || i == num) {
                    for (int j = 0; j < num; j++) {
                        ma[i][j] = 1;
                    }
                }
            }
            for (int j = 0; j < num; j++) {
                if (j == 0 || j == num) {
                    for (int i = 0; i < num; i++) {
                        ma[i][j] = 1;
                    }
                }
            }
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.printf(""%d"", ma[i][j]);
//                }
//            }

            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                    if (ma[i][j] == 0) {
//                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                            if (qf.find(i * num + (j - 1)) > qf.find((i - 1) * num + (j))) {
//                                qf.union(i * num + j, (i - 1) * num + (j));
//                                qf.union(i * num + (j - 1), i * num + j);
//                            } else {
//                                qf.union(i * num + j, i * num + (j - 1));
//                                qf.union((i - 1) * num + (j), i * num + j);
//                            }
//
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, i * num + (j - 1));
//
//                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
//                            CC[i][j] = c;
//                            c = c + 1;
                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
                            if (CC[i - 1][j] < CC[i][j - 1]) {
                                qf.union(CC[i][j], CC[i - 1][j]);
                                CC[i][j] = CC[i - 1][j];
                            } else {
                                qf.union(CC[i][j], CC[i][j - 1]);
                                CC[i][j] = CC[i][j - 1];
                            }

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
                            qf.union(CC[i][j], CC[i][j-1]);
                            CC[i][j] = CC[i][j - 1];
                            

                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
                           qf.union(CC[i][j], CC[i-1][j]);
                           CC[i][j] = CC[i-1][j ];
                            
                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = c;
                            c = c + 1;

                        }

                    }

                }
            }
            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                    if (CC[i][j] != 0) {
                        if ((i * num + j) == qf.find(outla[0] * num + outla[1])) {
                            System.out.printf(""%d"", CC[i][j]);
                        }
                    }
                }
            }

        }
    }
}

@955d6a4e712cdf58eff1a0feec7af33d@"
"r04631006","8","1.04","134400","@145a85a929bd7b952ed1e4cc3c27f438@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            num = num + 2;
            QuickFindUF qf = new QuickFindUF(num * num);

            int[] outla = new int[2];
            outla[0] = Integer.parseInt(a[1]);
            outla[1] = Integer.parseInt(a[2]);

            int[][] ma = new int[num][num];
            int[][] CC = new int[num][num];

            String loca0;
            String[] loca;
            int x;
            int y;
            int c = 1;

            while (!((loca0 = br.readLine()) == null)) {
                loca = loca0.split("","");
                x = Integer.parseInt(loca[0]);
                y = Integer.parseInt(loca[1]);
                ma[x][y] = 1;
                if (x == outla[0] && y == outla[1]) {
                    System.out.printf(""%d"", 0);
                    return;
                }
            }
            for (int i = 0; i < num; i++) {
                if (i == 0 || i == num) {
                    for (int j = 0; j < num; j++) {
                        ma[i][j] = 1;
                    }
                }
            }
            for (int j = 0; j < num; j++) {
                if (j == 0 || j == num) {
                    for (int i = 0; i < num; i++) {
                        ma[i][j] = 1;
                    }
                }
            }
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.printf(""%d"", ma[i][j]);
//                }
//            }

            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                    if (ma[i][j] == 0) {
//                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                            if (qf.find(i * num + (j - 1)) > qf.find((i - 1) * num + (j))) {
//                                qf.union(i * num + j, (i - 1) * num + (j));
//                                qf.union(i * num + (j - 1), i * num + j);
//                            } else {
//                                qf.union(i * num + j, i * num + (j - 1));
//                                qf.union((i - 1) * num + (j), i * num + j);
//                            }
//
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, i * num + (j - 1));
//
//                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
//                            CC[i][j] = c;
//                            c = c + 1;
                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
                            if (CC[i - 1][j] < CC[i][j - 1]) {
                                qf.union(CC[i][j], CC[i - 1][j]);
                                CC[i][j] = CC[i - 1][j];
                            } else {
                                qf.union(CC[i][j], CC[i][j - 1]);
                                CC[i][j] = CC[i][j - 1];
                            }

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
                            qf.union(CC[i][j], CC[i][j-1]);
                            CC[i][j] = CC[i][j - 1];
                            

                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
                           qf.union(CC[i][j], CC[i-1][j]);
                           CC[i][j] = CC[i-1][j ];
                            
                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = c;
                            c = c + 1;

                        }

                    }

                }
            }
//            for (int i = 1; i < num - 1; i++) {
//                for (int j = 1; j < num - 1; j++) {
//                    if (CC[i][j] != 0) {
//                        if ((i * num + j) == qf.find(outla[0] * num + outla[1])) {
                            System.out.printf(""%d"", CC[outla[0]][outla[1]]);
//                        }
//                    }
//                }
//            }

        }
    }
}

@145a85a929bd7b952ed1e4cc3c27f438@"
"r04631034","9","1.48","172688","@977a421f4494f47a7df2d04b1022e908@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.*;
import java.util.*;
/**
 *
 * @author user
 */
public class LabelCC {

     /**
      * @param args the command line arguments
      */
     public static void main(String[] args) {
          // TODO code application logic here
          In in = new In(args[0]);
          String[] TopRow =in.readLine().split("","");
          
          int[][] matrix = new int[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];
//          System.out.println(matrix.length);
//          System.out.println(TopRow[0]+"" ""+TopRow[1]+"" ""+TopRow[2]);
          String line;       
//         ArrayList<Integer> Row = new ArrayList<Integer>();
//          ArrayList<Integer> Column = new ArrayList<Integer>();
            while ((line = in.readLine()) != null) {
//                Row.add(Integer.parseInt(line.split("","")[0]));
//               Column.add(Integer.parseInt(line.split("","")[1]));
               matrix[Integer.parseInt(line.split("","")[0])-1][Integer.parseInt(line.split("","")[1])-1]=-1;
                }
            
//            for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
//                      System.out.print((i+1)+"",""+(j+1)+"" inside ""+matrix[i][j]+""     "");   
//                 }
//                 System.out.println("""");
//            }
            int label=1;
            for(int  i =0 ; i<matrix.length;i++)
            {
                 for(int  j =0 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=-1) // not block site
                      {
                                   if(i ==0)   //first row
                                   {
                                        if(j==0) // first col
                                        {
                                             matrix[i][j]=label;
                                        }
                                        else if(matrix[i][j-1]!=-1)  //left site not block site >> connect
                                        {
                                             matrix[i][j]=matrix[i][j-1];
                                        }
                                        else   
                                        {
                                             matrix[i][j]=++label;
                                        }
                                   }
                                   else //   another row
                                   {
                                        if(j==0)  //first col
                                        {
                                            if(matrix[i-1][j]!=-1) // upper row not block site
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }
                                             else
                                             {
                                                  matrix[i][j]=++label;
                                             }
                                        }
                                        else // else col
                                        {
                                             if(matrix[i][j-1] != -1 && matrix[i-1][j]==-1) // connext left col
                                             {
                                                  matrix[i][j]=matrix[i][j-1];
                                             }
                                             if(matrix[i-1][j] != -1 && matrix[i][j-1]==-1) // connext upper row
                                             {
                                                  matrix[i][j]=matrix[i-1][j];
                                             }                                            
                                             if(matrix[i][j-1] == -1 && matrix[i-1][j]==-1)
                                             {
                                                  matrix[i][j]=++label;
                                             }                                             
                                              if(matrix[i][j-1] != -1 && matrix[i-1][j]!=-1)
                                             {
                                                  if(matrix[i][j-1] < matrix[i-1][j])
                                                  {
                                                       matrix[i][j]=matrix[i][j-1];
                                                  }
                                                  else
                                                  {
                                                       matrix[i][j]=matrix[i-1][j];
                                                  }
                                             }                                                    
                                        }
                                   }        
                      }
                 }
            }
//            System.out.println(label);
            QuickUnionUF uf = new QuickUnionUF(label+1);
            
           for(int  i =1 ; i<matrix.length;i++)
            {
                 for(int  j =1 ; j<matrix.length;j++)
                 {
                      if(matrix[i][j]!=-1) // not block site
                      {            
                           if(matrix[i][j-1] != -1 && matrix[i-1][j]!=-1)
                           {
                                if(matrix[i][j-1] < matrix[i-1][j])
                                 {
                                       uf.union(matrix[i-1][j],matrix[i][j-1]);
                                  }
                                  else
                                   {
                                        uf.union(matrix[i][j-1],matrix[i-1][j]);
                                    }               
                           }
                      }
                 }
            }
            
            
            
            
            
            
            
            
//            System.out.println(""check"");
            
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      System.out.print(matrix[i][j]+""     "");
////                      if(matrix[i][j]==""0"")
////                                     System.out.print("" check "");
//                 }
//                                      System.out.println("""");
//            }
            
            
                        System.out.println(uf.find(matrix[Integer.parseInt(TopRow[1])-1][Integer.parseInt(TopRow[2])-1]));
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
     }
}


@977a421f4494f47a7df2d04b1022e908@"
"r04631006","8","1.03","130976","@171f2155a6d17d976b46dee33c58fee3@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            num = num + 2;
            QuickFindUF qf = new QuickFindUF(num * num);

            int[] outla = new int[2];
            outla[0] = Integer.parseInt(a[1]);
            outla[1] = Integer.parseInt(a[2]);

            int[][] ma = new int[num][num];
            int[][] CC = new int[num][num];

            String loca0;
            String[] loca;
            int x;
            int y;
            int c = 1;

            while (!((loca0 = br.readLine()) == null)) {
                loca = loca0.split("","");
                x = Integer.parseInt(loca[0]);
                y = Integer.parseInt(loca[1]);
                ma[x][y] = 1;
                if (x == outla[0] && y == outla[1]) {
                    System.out.printf(""%d"", 0);
                    return;
                }
            }
            for (int i = 0; i < num; i++) {
                if (i == 0 || i == num) {
                    for (int j = 0; j < num; j++) {
                        ma[i][j] = 1;
                    }
                }
            }
            for (int j = 0; j < num; j++) {
                if (j == 0 || j == num) {
                    for (int i = 0; i < num; i++) {
                        ma[i][j] = 1;
                    }
                }
            }
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.printf(""%d"", ma[i][j]);
//                }
//            }

            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                    if (ma[i][j] == 0) {
//                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                            if (qf.find(i * num + (j - 1)) > qf.find((i - 1) * num + (j))) {
//                                qf.union(i * num + j, (i - 1) * num + (j));
//                                qf.union(i * num + (j - 1), i * num + j);
//                            } else {
//                                qf.union(i * num + j, i * num + (j - 1));
//                                qf.union((i - 1) * num + (j), i * num + j);
//                            }
//
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, i * num + (j - 1));
//
//                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
//                            CC[i][j] = c;
//                            c = c + 1;
                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
                            if (CC[i - 1][j] < CC[i][j - 1]) {
                                CC[i][j] = CC[i - 1][j];
                                qf.union(CC[i][j], CC[i - 1][j]);
                              
//                                 System.out.printf(""%d\n"", CC[i][j]);
                            } else {
                                CC[i][j] = CC[i][j - 1];
                                qf.union(CC[i][j], CC[i][j - 1]);
                                
                                
//                                 System.out.printf(""%d\n"", CC[i][j]);
                            }

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
                            CC[i][j] = CC[i][j - 1];
                            qf.union(CC[i][j], CC[i][j - 1]);
                            
//                            System.out.printf(""%d\n"", CC[i][j]);

                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = CC[i - 1][j];
                            qf.union(CC[i][j], CC[i - 1][j]);
                            
//                            System.out.printf(""%d\n"", CC[i][j]);

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = c;
                            c = c + 1;
//                            System.out.printf(""%d\n"", CC[i][j]);

                        }

                    }

                }
            }
//            for (int i = 1; i < num - 1; i++) {
//                for (int j = 1; j < num - 1; j++) {
//                    if (CC[i][j] != 0) {
//                        if ((i * num + j) == qf.find(outla[0] * num + outla[1])) {
           System.out.printf(""%d"", qf.find(CC[outla[0]][outla[1]]));
//                        }
//                    }
//                }
//            }
//
//            for (int i = 1; i < num - 1; i++) {
//                for (int j = 1; j < num - 1; j++) {
//
//                    System.out.printf(""%d"", CC[i][j]);
//
//                }
//                System.out.printf(""\n"");
//            }

        }
    }
}

@171f2155a6d17d976b46dee33c58fee3@"
"r04631006","0","1.66","210464","@a08f5db3f6f162c09cf96272c778717e@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            num = num + 2;
            QuickFindUF qf = new QuickFindUF(num * num);

            int[] outla = new int[2];
            outla[0] = Integer.parseInt(a[1]);
            outla[1] = Integer.parseInt(a[2]);

            int[][] ma = new int[num][num];
            int[][] CC = new int[num][num];

            String loca0;
            String[] loca;
            int x;
            int y;
            int c = 1;

            while (!((loca0 = br.readLine()) == null)) {
                loca = loca0.split("","");
                x = Integer.parseInt(loca[0]);
                y = Integer.parseInt(loca[1]);
                ma[x][y] = 1;
                if (x == outla[0] && y == outla[1]) {
                    System.out.printf(""%d"", 0);
                    return;
                }
            }
            for (int i = 0; i < num; i++) {
                if (i == 0 || i == num) {
                    for (int j = 0; j < num; j++) {
                        ma[i][j] = 1;
                    }
                }
            }
            for (int j = 0; j < num; j++) {
                if (j == 0 || j == num) {
                    for (int i = 0; i < num; i++) {
                        ma[i][j] = 1;
                    }
                }
            }
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.printf(""%d"", ma[i][j]);
//                }
//            }

            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                    if (ma[i][j] == 0) {
//                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                            if (qf.find(i * num + (j - 1)) > qf.find((i - 1) * num + (j))) {
//                                qf.union(i * num + j, (i - 1) * num + (j));
//                                qf.union(i * num + (j - 1), i * num + j);
//                            } else {
//                                qf.union(i * num + j, i * num + (j - 1));
//                                qf.union((i - 1) * num + (j), i * num + j);
//                            }
//
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, i * num + (j - 1));
//
//                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
//                            CC[i][j] = c;
//                            c = c + 1;
                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
                            if (CC[i - 1][j] < CC[i][j - 1]) {
                                CC[i][j] = CC[i - 1][j];
                                qf.union(CC[i][j-1], CC[i][j]);
                              
//                                 System.out.printf(""%d\n"", CC[i][j]);
                            } else {
                                CC[i][j] = CC[i][j - 1];
                                qf.union(CC[i - 1][j], CC[i][j]);
                                
                                
//                                 System.out.printf(""%d\n"", CC[i][j]);
                            }

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
                            CC[i][j] = CC[i][j - 1];
                            qf.union(CC[i][j], CC[i][j - 1]);
                            
//                            System.out.printf(""%d\n"", CC[i][j]);

                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = CC[i - 1][j];
                            qf.union(CC[i][j], CC[i - 1][j]);
                            
//                            System.out.printf(""%d\n"", CC[i][j]);

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = c;
                            c = c + 1;
//                            System.out.printf(""%d\n"", CC[i][j]);

                        }

                    }

                }
            }
//            for (int i = 1; i < num - 1; i++) {
//                for (int j = 1; j < num - 1; j++) {
//                    if (CC[i][j] != 0) {
//                        if ((i * num + j) == qf.find(outla[0] * num + outla[1])) {
           System.out.printf(""%d\n"", qf.find(CC[outla[0]][outla[1]]));
//                        }
//                    }
//                }
//            }
//
            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {

                    System.out.printf(""%d"", CC[i][j]);

                }
                System.out.printf(""\n"");
            }

        }
    }
}

@a08f5db3f6f162c09cf96272c778717e@"
"r04631006","10","0.107","132944","@21b45c8134bb186394b963cbc5a12107@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] a = br.readLine().split("","");
            int num = Integer.parseInt(a[0]);
            num = num + 2;
            QuickFindUF qf = new QuickFindUF(num * num);

            int[] outla = new int[2];
            outla[0] = Integer.parseInt(a[1]);
            outla[1] = Integer.parseInt(a[2]);

            int[][] ma = new int[num][num];
            int[][] CC = new int[num][num];

            String loca0;
            String[] loca;
            int x;
            int y;
            int c = 1;

            while (!((loca0 = br.readLine()) == null)) {
                loca = loca0.split("","");
                x = Integer.parseInt(loca[0]);
                y = Integer.parseInt(loca[1]);
                ma[x][y] = 1;
                if (x == outla[0] && y == outla[1]) {
                    System.out.printf(""%d"", 0);
                    return;
                }
            }
            for (int i = 0; i < num; i++) {
                if (i == 0 || i == num) {
                    for (int j = 0; j < num; j++) {
                        ma[i][j] = 1;
                    }
                }
            }
            for (int j = 0; j < num; j++) {
                if (j == 0 || j == num) {
                    for (int i = 0; i < num; i++) {
                        ma[i][j] = 1;
                    }
                }
            }
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.printf(""%d"", ma[i][j]);
//                }
//            }

            for (int i = 1; i < num - 1; i++) {
                for (int j = 1; j < num - 1; j++) {
                    if (ma[i][j] == 0) {
//                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                            if (qf.find(i * num + (j - 1)) > qf.find((i - 1) * num + (j))) {
//                                qf.union(i * num + j, (i - 1) * num + (j));
//                                qf.union(i * num + (j - 1), i * num + j);
//                            } else {
//                                qf.union(i * num + j, i * num + (j - 1));
//                                qf.union((i - 1) * num + (j), i * num + j);
//                            }
//
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
//                            qf.union(i * num + j, i * num + (j - 1));
//
//                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
//                            qf.union(i * num + j, (i - 1) * num + j);
//                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
//                            CC[i][j] = c;
//                            c = c + 1;
                        if (ma[i - 1][j] == 0 && ma[i][j - 1] == 0) {
                            if (CC[i - 1][j] < CC[i][j - 1]) {
                                CC[i][j] = CC[i - 1][j];
                                qf.union(CC[i][j-1], CC[i][j]);
                              
//                                 System.out.printf(""%d\n"", CC[i][j]);
                            } else {
                                CC[i][j] = CC[i][j - 1];
                                qf.union(CC[i - 1][j], CC[i][j]);
                                
                                
//                                 System.out.printf(""%d\n"", CC[i][j]);
                            }

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] == 0) {
                            CC[i][j] = CC[i][j - 1];
                            qf.union(CC[i][j], CC[i][j - 1]);
                            
//                            System.out.printf(""%d\n"", CC[i][j]);

                        } else if (ma[i - 1][j] == 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = CC[i - 1][j];
                            qf.union(CC[i][j], CC[i - 1][j]);
                            
//                            System.out.printf(""%d\n"", CC[i][j]);

                        } else if (ma[i - 1][j] != 0 && ma[i][j - 1] != 0) {
                            CC[i][j] = c;
                            c = c + 1;
//                            System.out.printf(""%d\n"", CC[i][j]);

                        }

                    }

                }
            }
//            for (int i = 1; i < num - 1; i++) {
//                for (int j = 1; j < num - 1; j++) {
//                    if (CC[i][j] != 0) {
//                        if ((i * num + j) == qf.find(outla[0] * num + outla[1])) {
           System.out.printf(""%d\n"", qf.find(CC[outla[0]][outla[1]]));
//                        }
//                    }
//                }
//            }
//
//            for (int i = 1; i < num - 1; i++) {
//                for (int j = 1; j < num - 1; j++) {
//
//                    System.out.printf(""%d"", CC[i][j]);
//
//                }
//                System.out.printf(""\n"");
//            }

        }
    }
}

@21b45c8134bb186394b963cbc5a12107@"
"b02611016","8","1.06","140240","@954f1f81358a65ec2db21993588c061e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.QuickUnionUF;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            QuickUnionUF uf=new QuickUnionUF(num*num);
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                uf.union(cloumn-1, cloumn-2);
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   uf.union((row-1)*num+cloumn-1, (row-1)*num+cloumn-2);
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
               uf.union((row-1)*num+cloumn-1, (row-1)*num+cloumn-2);
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }

/*for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1&&(id[(row-2)*num+cloumn-1]!=id[(row-1)*num+cloumn-2]))
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
            k1=id[(row-1)*num+cloumn-2];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}*/
  /*           for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
         if(x_position>num||y_position>num)
          { System.out.printf(""0"");
          
          }
         else{
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[ uf.find((x_position-1)*num+y_position-1)] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
         }
            br.close();
        }
    }
}

@954f1f81358a65ec2db21993588c061e@"
"r04921074","9","1","125248","@12ab0e37b664fec6eaa52d2daa446880@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class LabelCC {    
    public static void main(String[] args) throws IOException{    
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
    
    String[] inf = br.readLine().split("","");
    int N =  Integer.parseInt(inf[0]); //N is scale of grids
    int[][] matrix;
            matrix = new int[N+1][N+1];
    
    UF uf = new UF(N*N/2);        
            
    int[] target;
          target = new int[2];
   
    target[0] =  Integer.parseInt(inf[1]);         //_______type:location of target = (target[0],target[1])______
    target[1] =  Integer.parseInt(inf[2]);         //store value of target    
    
    int row = 0; //max of element is n*n  // store for input X-axis in order of [i]
    int column = 0; //max of element is n*n  // store for input Y-axis in order of [i]
    int counting = 0;
    
    for(int x=1; x<N+1; x++){
        for(int y=1; y<N+1; y++){
           matrix[x][y]=1; 
        }
    }
   
//....................................specify the block grids ** scale of n **-------------------------------
     while (br.ready()){
         String[] num = br.readLine().split("","");
         
         row = Integer.parseInt(num[0]);     //asume a metrix is way as  M[row][column]
         column = Integer.parseInt(num[1]);
         
         matrix[row][column]=0;
             
    }//end of while (and input function part)

//------------------------------------first path** scale of N^2 **------------------------------------------- 
        int lable = 0;
        for(int y=1; y<N+1; y++){
            for(int x=1; x<N+1; x++){
                if(matrix[y][x]!=0){
                    
                    if( (matrix[y][x-1]==0)&&(matrix[y-1][x]==0) ){
                        lable++ ;
                        matrix[y][x] = lable;
                    }//slave if(1)  ----create new lable
                    if( (matrix[y][x-1]==matrix[y-1][x])&&(matrix[y-1][x]!=0) ){
                        matrix[y][x] = matrix[y][x-1];
                    }//slave if(2)  ----lable follower (type1)
                    if( ((matrix[y][x-1]==0) || (matrix[y-1][x]==0)) && ((matrix[y][x-1]!=0) || (matrix[y-1][x]!=0)) ){
                        matrix[y][x] = Math.max(matrix[y-1][x],matrix[y][x-1]);
                    }//slave if(3)  ----lable follower (type2)
                    if( matrix[y][x-1]!=0 && matrix[y-1][x]!=0 && (matrix[y][x-1]!= matrix[y-1][x]) ){
                        matrix[y][x] = Math.min(matrix[y-1][x],matrix[y][x-1]);
                        uf.union(Math.min(matrix[y-1][x],matrix[y][x-1]), Math.max(matrix[y-1][x],matrix[y][x-1]));
                    }//slave if(4)  ----lable chooser  (cc is needed)
                 
                }//end of master if
            
                else matrix[y][x]=0;   //master else
            }//end of for-x
        }//end of for-y
//-------------------------------------------------------------------------------------------------------------
    /*    for(int y=1; y<N+1; y++){
            System.out.printf(""\n"");
            for(int x=1; x<N+1; x++){
                System.out.print(matrix[y][x]+"" ""); 
            }
        } //print matrix*/
        
        if( (matrix[target[0]][target[1]]>0)&&(N!=1) ){
            System.out.println(uf.find(matrix[target[0]][target[1]]));
        }
        if( (matrix[target[0]][target[1]]==0)&&(N!=1)){
            System.out.println(0);
        }
        if(N==1){
            if(target[0]==0){
                System.out.println(1);
            }
            else System.out.println(0);
        }
        /*    if((5|0)==1){
                System.out.println(""Hello"");
            }*/

            }//end of try
        }//end of main
    
}//end of class

@12ab0e37b664fec6eaa52d2daa446880@"
"b02611016","9","1.04","144800","@507051906cb200c55188a49d57339760@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.QuickUnionUF;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            QuickUnionUF uf=new QuickUnionUF(num*num);
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                uf.union(cloumn-1, cloumn-2);
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   uf.union((row-1)*num+cloumn-2, (row-2)*num+cloumn-1);
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   uf.union((row-2)*num+cloumn-1, (row-1)*num+cloumn-2);
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
               uf.union((row-1)*num+cloumn-1, (row-1)*num+cloumn-2);
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }

/*for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1&&(id[(row-2)*num+cloumn-1]!=id[(row-1)*num+cloumn-2]))
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
            k1=id[(row-1)*num+cloumn-2];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}*/
  /*           for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
         if(x_position>num||y_position>num)
          { System.out.printf(""0"");
          
          }
         else{
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[ uf.find((x_position-1)*num+y_position-1)] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
         }
            br.close();
        }
    }
}

@507051906cb200c55188a49d57339760@"
"r04631034","9","1.46","173760","@df066a6f950e9f8022ac0351453d72d0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.*;

import java.util.*;

/**
 *
 * @author user
 */
public class LabelCC {

          /**
           * @param args the command line arguments
           */
          public static void main(String[] args) {
                    // TODO code application logic here
                    In in = new In(args[0]);
                    String[] TopRow = in.readLine().split("","");

                    int[][] matrix = new int[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];
//          System.out.println(matrix.length);
//          System.out.println(TopRow[0]+"" ""+TopRow[1]+"" ""+TopRow[2]);
                    String line;
//         ArrayList<Integer> Row = new ArrayList<Integer>();
//          ArrayList<Integer> Column = new ArrayList<Integer>();
                    while ((line = in.readLine()) != null) {
//                Row.add(Integer.parseInt(line.split("","")[0]));
//               Column.add(Integer.parseInt(line.split("","")[1]));
                              matrix[Integer.parseInt(line.split("","")[0]) - 1][Integer.parseInt(line.split("","")[1]) - 1] = -1;
                    }

//            for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
//                      System.out.print((i+1)+"",""+(j+1)+"" inside ""+matrix[i][j]+""     "");   
//                 }
//                 System.out.println("""");
//            }
                    int label = 1;
                    for (int i = 0; i < matrix.length; i++) {
                              for (int j = 0; j < matrix.length; j++) {
                                        if (matrix[i][j] != -1) // not block site
                                        {
                                                  if (i == 0) //first row
                                                  {
                                                            if (j == 0) // first col
                                                            {
                                                                      matrix[i][j] = label;
                                                            } else if (matrix[i][j - 1] != -1) //left site not block site >> connect
                                                            {
                                                                      matrix[i][j] = matrix[i][j - 1];
                                                            } else {
                                                                      matrix[i][j] = ++label;
                                                            }
                                                  } else //   another row
                                                  {
                                                            if (j == 0) //first col
                                                            {
                                                                      if (matrix[i - 1][j] != -1) // upper row not block site
                                                                      {
                                                                                matrix[i][j] = matrix[i - 1][j];
                                                                      } else {
                                                                                matrix[i][j] = ++label;
                                                                      }
                                                            } else // else col
                                                            {
                                                                      if (matrix[i][j - 1] != -1 && matrix[i - 1][j] == -1) // connext left col
                                                                      {
                                                                                matrix[i][j] = matrix[i][j - 1];
                                                                      }
                                                                      if (matrix[i - 1][j] != -1 && matrix[i][j - 1] == -1) // connext upper row
                                                                      {
                                                                                matrix[i][j] = matrix[i - 1][j];
                                                                      }
                                                                      if (matrix[i][j - 1] == -1 && matrix[i - 1][j] == -1) {
                                                                                matrix[i][j] = ++label;
                                                                      }
                                                                      if (matrix[i][j - 1] != -1 && matrix[i - 1][j] != -1) {
                                                                                if (matrix[i][j - 1] < matrix[i - 1][j]) {
                                                                                          matrix[i][j] = matrix[i][j - 1];
                                                                                } else {
                                                                                          matrix[i][j] = matrix[i - 1][j];
                                                                                }
                                                                      }
                                                            }
                                                  }
                                        }
                              }
                    }
//            System.out.println(label);
                    QuickUnionUF uf = new QuickUnionUF(label + 1);

                    for (int i = 1; i < matrix.length; i++) {
                              for (int j = 1; j < matrix.length; j++) {
                                        if (matrix[i][j] != -1) // not block site
                                        {
                                                  if (matrix[i][j - 1] != -1 && matrix[i - 1][j] != -1) {
                                                            if (matrix[i][j - 1] < matrix[i - 1][j]) {
                                                                      uf.union(matrix[i - 1][j], matrix[i][j - 1]);
                                                            } else {
                                                                      uf.union(matrix[i][j - 1], matrix[i - 1][j]);
                                                            }
                                                  }
                                        }
                              }
                    }

//            System.out.println(""check"");
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      System.out.print(matrix[i][j]+""     "");
//                      if(matrix[i][j]==""0"")
////                                     System.out.print("" zz
//                 }
//                                      System.out.println("""");
//            }
                    System.out.println(uf.find(matrix[Integer.parseInt(TopRow[1]) - 1][Integer.parseInt(TopRow[2]) - 1]));

          }
}

@df066a6f950e9f8022ac0351453d72d0@"
"r04631036","0","1.74","203888","@72244938eee58c5794945b9680790deb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(target[0]==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/

            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@72244938eee58c5794945b9680790deb@"
"r04631036","0","1.73","203408","@4921123b68bb5eb1455b459c2792b472@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/

            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@4921123b68bb5eb1455b459c2792b472@"
"r04631036","9","1.06","139920","@462f3f592db7cb8c071fcb9c537e96bf@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/

            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@462f3f592db7cb8c071fcb9c537e96bf@"
"r04631021","0","1.74","203888","@c0b36623778db0a8e89211628b3802af@
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
import edu.princeton.cs.algs4.UF ;
        
/**
 *
 * @author 林康維
 */
public class LabelCC {


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
           File file = new File(args[0]);
           int Drow , Dcol ;
           try{
               Scanner File_in = new Scanner(file) ; 
String num[] = File_in . nextLine() . split("","");
               int Dim = Integer . parseInt (num [0]) ;
               int ansrow = Integer . parseInt (num[1]) ;
               int anscol = Integer . parseInt (num[2]) ;
               boolean[][] matrix = new boolean [Dim][Dim] ;
               UF uf = new UF( Dim*Dim ) ; 
               for ( int i = 0 ; i < Dim ; i++){
                   for(int j = 0 ; j <Dim ; j++){
                   matrix [i][j] = true ;
                   }
               }
               while(true){
                   String Black = File_in.nextLine() ;
                   String[] mat = Black.split("","") ;
                   Drow = Integer . parseInt (mat[0]) -1 ;
                   Dcol = Integer . parseInt (mat[1]) -1 ;
                   matrix [Drow][Dcol] = false ;
                   if(!File_in.hasNextLine())
                       break ;
               }
               int [][] A = new int [Dim][Dim];
               int count = 1 ;
               for (int i = 0 ; i < Dim ; i++){
                   for (int j = 0 ; j < Dim ;j ++){
                   A [i][j] = 0 ;
                   }
               }
               if ( matrix [0][0] == true){
                   A [0][0] = 1 ;
                   count += 1 ;
               }
               for ( int i = 1 ; i < Dim ; i++){
                   if (matrix [0][i] == true){
                   if (A[0][i-1] != 0){
                   A[0][i] = A[0][i-1] ; 
                   uf.union(i,i-1);
                   }
                   else if (A[0][i-1]  ==0)  {
                       A [0][i] = count ;
                       count += 1 ;
                   }
               }
               }
               
               for ( int i = 1 ; i < Dim   ; i++){
                   for ( int j =0 ; j < Dim  ; j++){
                       if (j ==0 ){
                           if (matrix [i][j] == true){
                               if (A[i-1][j] != 0) {
                                   A [i][j] = A [i-1][j] ;
uf.union( i * Dim + j , ( i - 1 ) * Dim + j );
                               }
                               else{
                                   A[i][j] = count ;
                                   count += 1 ;
                               }
                           }
                       }
                       else if (j != 0){
                       if ( matrix[i][j] == true ){
                           if( A [i-1] [j] != 0 && A [i] [j-1] != 0){
                               if(A [i-1] [j] > A [i] [j-1]){
                               
                                   A [i] [j] = A [i] [j-1] ; 
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);       
                               }
                               else if (A [i-1] [j] < A [i] [j-1]){
                                   
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               else {
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               }
                           else if ( A [i-1] [j] != 0 && A [i] [j-1] ==0){
                               A [i] [j] = A [i-1] [j] ;
                               uf.union( i * Dim + j , (i-1) * Dim + j);
                           }
                           else if ( A [i-1] [j] == 0 && A [i] [j-1] !=0){
                               A [i] [j] = A [i] [j-1] ;
                               uf.union( i * Dim + j , i * Dim + j - 1);
                           }
                           else {
                               A [i] [j] = count ;
                               count += 1 ;
                           }
                           
                           }
                       }
               }
               }
               for(int i = 0 ; i < Dim ; i ++){
                   for(int j = 0 ; j < Dim ;j++){
                       for(int k = i ; k < Dim ; k++){
                           for(int l = 0; l < Dim ; l++){
if ( uf.connected (i * Dim + j , k * Dim+ l) && A[i][j] != A[k][l] ) {
                               A[k][l] = A[i][j] ;
                               }
                           }
                       }
                   }
               }
               System.out.println (A[ansrow-1][anscol-1]) ;
               /*System.out.println(ansrow) ;
               System.out.println(anscol) ;
               for (int i=0;i<8;i++){
                   //System.out.println(uf.find(i));
                   for(int j =0;j<8;j++){
                       
                   System.out.println(A[i][j]);
                   System.out.println(uf.find(i*Dim+j)) ;
                   System.out.println(matrix[i][j]) ;
                   }
                   System.out.println(""\n"") ;
               }*/
                       }
           catch(IOException e){
            System.out.println(""error!""); 
        }
    }
    
}

@c0b36623778db0a8e89211628b3802af@"
"r04631021","8","2.9","175840","@bd79fb80ba4116df1a90a3ca40673dd5@import java.io.IOException;
import java.io.*;
import java.util.Scanner;
        
/**
 *
 * @author 林康維
 */
public class LabelCC {


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
           File file = new File(args[0]);
           int Drow , Dcol ;
           try{
               Scanner File_in = new Scanner(file) ; 
String num[] = File_in . nextLine() . split("","");
               int Dim = Integer . parseInt (num [0]) ;
               int ansrow = Integer . parseInt (num[1]) ;
               int anscol = Integer . parseInt (num[2]) ;
               boolean[][] matrix = new boolean [Dim][Dim] ;
               UF uf = new UF( Dim*Dim ) ; 
               for ( int i = 0 ; i < Dim ; i++){
                   for(int j = 0 ; j <Dim ; j++){
                   matrix [i][j] = true ;
                   }
               }
               while(true){
                   String Black = File_in.nextLine() ;
                   String[] mat = Black.split("","") ;
                   Drow = Integer . parseInt (mat[0]) -1 ;
                   Dcol = Integer . parseInt (mat[1]) -1 ;
                   matrix [Drow][Dcol] = false ;
                   if(!File_in.hasNextLine())
                       break ;
               }
               int [][] A = new int [Dim][Dim];
               int count = 1 ;
               for (int i = 0 ; i < Dim ; i++){
                   for (int j = 0 ; j < Dim ;j ++){
                   A [i][j] = 0 ;
                   }
               }
               if ( matrix [0][0] == true){
                   A [0][0] = 1 ;
                   count += 1 ;
               }
               for ( int i = 1 ; i < Dim ; i++){
                   if (matrix [0][i] == true){
                   if (A[0][i-1] != 0){
                   A[0][i] = A[0][i-1] ; 
                   uf.union(i,i-1);
                   }
                   else if (A[0][i-1]  ==0)  {
                       A [0][i] = count ;
                       count += 1 ;
                   }
               }
               }
               
               for ( int i = 1 ; i < Dim   ; i++){
                   for ( int j =0 ; j < Dim  ; j++){
                       if (j ==0 ){
                           if (matrix [i][j] == true){
                               if (A[i-1][j] != 0) {
                                   A [i][j] = A [i-1][j] ;
uf.union( i * Dim + j , ( i - 1 ) * Dim + j );
                               }
                               else{
                                   A[i][j] = count ;
                                   count += 1 ;
                               }
                           }
                       }
                       else if (j != 0){
                       if ( matrix[i][j] == true ){
                           if( A [i-1] [j] != 0 && A [i] [j-1] != 0){
                               if(A [i-1] [j] > A [i] [j-1]){
                               
                                   A [i] [j] = A [i] [j-1] ; 
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);       
                               }
                               else if (A [i-1] [j] < A [i] [j-1]){
                                   
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               else {
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               }
                           else if ( A [i-1] [j] != 0 && A [i] [j-1] ==0){
                               A [i] [j] = A [i-1] [j] ;
                               uf.union( i * Dim + j , (i-1) * Dim + j);
                           }
                           else if ( A [i-1] [j] == 0 && A [i] [j-1] !=0){
                               A [i] [j] = A [i] [j-1] ;
                               uf.union( i * Dim + j , i * Dim + j - 1);
                           }
                           else {
                               A [i] [j] = count ;
                               count += 1 ;
                           }
                           
                           }
                       }
               }
               }
               for(int i = 0 ; i < Dim ; i ++){
                   for(int j = 0 ; j < Dim ;j++){
                       for(int k = i ; k < Dim ; k++){
                           for(int l = 0; l < Dim ; l++){
if ( uf.connected (i * Dim + j , k * Dim+ l) && A[i][j] != A[k][l] ) {
                               A[k][l] = A[i][j] ;
                               }
                           }
                       }
                   }
               }
               System.out.println (A[ansrow-1][anscol-1]) ;
               /*System.out.println(ansrow) ;
               System.out.println(anscol) ;
               for (int i=0;i<8;i++){
                   //System.out.println(uf.find(i));
                   for(int j =0;j<8;j++){
                       
                   System.out.println(A[i][j]);
                   System.out.println(uf.find(i*Dim+j)) ;
                   System.out.println(matrix[i][j]) ;
                   }
                   System.out.println(""\n"") ;
               }*/
                       }
           catch(IOException e){
            System.out.println(""error!""); 
        }
    }
    
}

@bd79fb80ba4116df1a90a3ca40673dd5@"
"b99611017","6","1.32","190448","@4c3079070bbb2dd9254b6da7857a981a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
import java.io.*;
import java.util.Scanner;


public class LabelCC {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            String[] given = token[0].split("","");

            int[] x = new int[token.length - 1];

            int[] y = new int[token.length - 1];

            int size = Integer.parseInt(given[0]);

            int a = Integer.parseInt(given[1]) - 1;

            int b = Integer.parseInt(given[2]) - 1;         //a given site

            for (int i = 0; i < token.length - 1; i++) {

                String[] site = token[i + 1].split("","");

                x[i] = Integer.parseInt(site[0]);

                y[i] = Integer.parseInt(site[1]);

            }

            int[][] map = new int[size][size];

            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    map[i][j] = 1;
                }
            }

            for (int i = 0; i < x.length; i++) {
                map[x[i] - 1][y[i] - 1] = 0;
            }                                      //mapping

            //scanning
            int label = 1;

            for (int i = 0; i < size; i++) //row 1 : special case
            {
                if (i == 0) //[0][0]
                {
                    if (map[0][i] != 0) {
                        map[0][i] = label;
                    } else if (map[0][i] == 0) {
                        map[0][i] = 0;
                    }
                } else {
                    if (map[0][i] == 0) {
                        map[0][i] = 0;
                        label++;
                    } else {
                        map[0][i] = label;
                    }

                }

            }

            for (int i = 1; i < size; i++) {                //other rows

                for (int j = 0; j < size; j++) {

                    if (j == 0) {
                        if (map[i - 1][j] == 0 && map[i][j] != 0) //column 1 special case
                        {
                            label++;
                            map[i][j] = label;
                        } else if (map[i - 1][j] != 0 && map[i][j] != 0) {
                            map[i][j] = map[i - 1][j];
                        }
                    } else {

                        if (map[i - 1][j] == 0 && map[i][j - 1] == 0 && map[i][j] != 0) {
                            label++;
                            map[i][j] = label;
                        } else if (map[i - 1][j] != 0 && map[i][j - 1] == 0 && map[i][j] != 0) {
                            map[i][j] = map[i - 1][j];
                        } else if (map[i - 1][j] == 0 && map[i][j - 1] != 0 && map[i][j] != 0) {
                            map[i][j] = map[i][j - 1];
                        } else if (map[i - 1][j] != 0 && map[i][j - 1] != 0 && map[i][j] != 0) {

                            if (map[i - 1][j] > map[i][j - 1]) {
                                map[i][j] = map[i][j - 1];
                            } else if (map[i - 1][j] < map[i][j - 1]) {
                                map[i][j] = map[i - 1][j];
                            } else if (map[i - 1][j] == map[i][j - 1]) {
                                map[i][j] = map[i - 1][j];
                            }
                        }

                    }

                }
            }
            // start connecting
            QuickUnionUF LC=new QuickUnionUF(size*size);
            
            for(int i=0;i<size*size;i++)
            {
                if(i/size==0&&i%size==0)
                {
                    ;
                }
                else if(i/size==0&&i%size!=0)
                {
                    if(map[i/size][i%size-1]==map[i/size][i%size])
                    {
                        LC.union(i, i-1);
                    }
                 
                }
                else if(i%size==0&&i/size!=0)
                {
                    if(map[i/size-1][i%size]==map[i/size][i%size])
                    {
                        LC.union(i, i-size);
                    }
                }
                
                else if(i/size!=0&&i%size!=0)
                {
                    if(map[i/size][i%size-1]==map[i/size][i%size])
                    {
                        LC.union(i, i-1);
                    }
                    
                    if(map[i/size-1][i%size]==map[i/size][i%size])
                    {
                        LC.union(i, i-size);
                    }
                }
            }
            
            //start merging
            
            for(int i=0;i<size*size;i++)
            {
                if(i/size==0&&i%size==0)      //    ( 0 , 0 )
                {
                    ;
                }
                else if(i/size==0&&i%size!=0)    //row 1
                {
                    if(map[i/size][i%size]>map[i/size][i%size-1]&&map[i/size][i%size-1]>0)
                    {
                        LC.union(i,i-1);
                    }
                    
                    else if(map[i/size][i%size-1]>map[i/size][i%size]&&map[i/size][i%size]>0)
                    {
                        LC.union(i-1,i);
                    }
                }
                
                else if(i%size==0&&i/size!=0)    //column 1
                {
                    if(map[i/size][i%size]>map[i/size-1][i%size]&&map[i/size-1][i%size]>0)
                    {
                        LC.union(i,i-size);
                    }
                    
                    else if(map[i/size-1][i%size]>map[i/size][i%size]&&map[i/size][i%size]>0)
                    {
                        LC.union(i-size,i);
                    }
                }
                else if(i%size!=0&&i/size!=0)
                {
                    if(map[i/size][i%size]>map[i/size-1][i%size]&&map[i/size-1][i%size]>0)
                    {
                        LC.union(i,i-size);
                    }
                    
                    else if(map[i/size-1][i%size]>map[i/size][i%size]&&map[i/size][i%size]>0)
                    {
                        LC.union(i-size,i);
                    }
                    
                    if(map[i/size][i%size]>map[i/size][i%size-1]&&map[i/size][i%size-1]>0)
                    {
                        LC.union(i,i-1);
                    }
                    
                    else if(map[i/size][i%size-1]>map[i/size][i%size]&&map[i/size][i%size]>0)
                    {
                        LC.union(i-1,i);
                    }
                }
            }
            
            int ans=LC.find(a*size+b);
            
            System.out.print(map[ans/size][ans%size]);
            
        } catch (RuntimeException e) {

            throw e;
        }
    }
}

@4c3079070bbb2dd9254b6da7857a981a@"
"r04631021","9","3.06","181728","@22c47125313012743fab3a7608354882@
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
        
/**
 *
 * @author 林康維
 */
public class LabelCC {


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
           File file = new File(args[0]);
           int Drow , Dcol ;
           try{
               Scanner File_in = new Scanner(file) ; 
String num[] = File_in . nextLine() . split("","");
               int Dim = Integer . parseInt (num [0]) ;
               int ansrow = Integer . parseInt (num[1]) ;
               int anscol = Integer . parseInt (num[2]) ;
               boolean[][] matrix = new boolean [Dim][Dim] ;
               UF uf = new UF( Dim*Dim ) ; 
               for ( int i = 0 ; i < Dim ; i++){
                   for(int j = 0 ; j <Dim ; j++){
                   matrix [i][j] = true ;
                   }
               }
               while(File_in.hasNextLine()){
                   String Black = File_in.nextLine() ;
                   String[] mat = Black.split("","") ;
                   Drow = Integer . parseInt (mat[0]) -1 ;
                   Dcol = Integer . parseInt (mat[1]) -1 ;
                   matrix [Drow][Dcol] = false ;
                   /*if(!File_in.hasNextLine())
                       break ;*/
               }
               int [][] A = new int [Dim][Dim];
               int count = 1 ;
               for (int i = 0 ; i < Dim ; i++){
                   for (int j = 0 ; j < Dim ;j ++){
                   A [i][j] = 0 ;
                   }
               }
               if ( matrix [0][0] == true){
                   A [0][0] = 1 ;
                   count += 1 ;
               }
               for ( int i = 1 ; i < Dim ; i++){
                   if (matrix [0][i] == true){
                   if (A[0][i-1] != 0){
                   A[0][i] = A[0][i-1] ; 
                   uf.union(i,i-1);
                   }
                   else if (A[0][i-1]  ==0)  {
                       A [0][i] = count ;
                       count += 1 ;
                   }
               }
               }
               
               for ( int i = 1 ; i < Dim   ; i++){
                   for ( int j =0 ; j < Dim  ; j++){
                       if (j ==0 ){
                           if (matrix [i][j] == true){
                               if (A[i-1][j] != 0) {
                                   A [i][j] = A [i-1][j] ;
uf.union( i * Dim + j , ( i - 1 ) * Dim + j );
                               }
                               else{
                                   A[i][j] = count ;
                                   count += 1 ;
                               }
                           }
                       }
                       else if (j != 0){
                       if ( matrix[i][j] == true ){
                           if( A [i-1] [j] != 0 && A [i] [j-1] != 0){
                               if(A [i-1] [j] > A [i] [j-1]){
                               
                                   A [i] [j] = A [i] [j-1] ; 
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);       
                               }
                               else if (A [i-1] [j] < A [i] [j-1]){
                                   
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               else {
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               }
                           else if ( A [i-1] [j] != 0 && A [i] [j-1] ==0){
                               A [i] [j] = A [i-1] [j] ;
                               uf.union( i * Dim + j , (i-1) * Dim + j);
                           }
                           else if ( A [i-1] [j] == 0 && A [i] [j-1] !=0){
                               A [i] [j] = A [i] [j-1] ;
                               uf.union( i * Dim + j , i * Dim + j - 1);
                           }
                           else {
                               A [i] [j] = count ;
                               count += 1 ;
                           }
                           
                           }
                       }
               }
               }
               for(int i = 0 ; i < Dim ; i ++){
                   for(int j = 0 ; j < Dim ;j++){
                       for(int k = i ; k < Dim ; k++){
                           for(int l = 0; l < Dim ; l++){
if ( uf.connected (i * Dim + j , k * Dim+ l) && A[i][j] != A[k][l] ) {
                               A[k][l] = A[i][j] ;
                               }
                           }
                       }
                   }
               }
               System.out.println (A[ansrow-1][anscol-1]) ;
               /*System.out.println(ansrow) ;
               System.out.println(anscol) ;
               for (int i=0;i<8;i++){
                   //System.out.println(uf.find(i));
                   for(int j =0;j<8;j++){
                       
                   System.out.println(A[i][j]);
                   System.out.println(uf.find(i*Dim+j)) ;
                   System.out.println(matrix[i][j]) ;
                   }
                   System.out.println(""\n"") ;
               }*/
                       }
           catch(IOException e){
            System.out.println(""error!""); 
        }
    }
    
}

@22c47125313012743fab3a7608354882@"
"r04631004","0","1.25","155504","@a8f900490ccc32ccbcf0eafbec752d32@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            //                                          System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            //                                        System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }

                for (i = 0; i < num; i++) {  //output first label
                    for (j = 0; j < num; j++) {
                        if (j == num - 1) {
                            if (i == num - 1) {
                                System.out.println(label[i][j]);
                                System.out.println("""");
                            } else {
                                System.out.println(label[i][j]);
                            }
                        } else {
                            System.out.print(label[i][j] + "" "");
                        }
                    }
                }
                // WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF((num * num) / 2 + 1);
                //UF ufstruct = new UF((num * num) / 2 + 1);
                //QuickFindUF ufstruct = new QuickFindUF((num * num) / 2 + 1);
                QuickUnionUF ufstruct = new QuickUnionUF((num * num) / 2 + 1);

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            if (ufstruct.find(storeunionpoint.biglabel[i][j]) > storeunionpoint.smalllabel[i][j]) {
                                ufstruct.union(storeunionpoint.biglabel[i][j], storeunionpoint.smalllabel[i][j]);
                            } else {
                                ufstruct.union(storeunionpoint.smalllabel[i][j], storeunionpoint.biglabel[i][j]);
                            }
                        }
                    }
                }
                int[] unionarray = new int[(num * num) / 2 + 1];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
//                    if(i>0)
//                        System.out.println(i+"" = ""+ufstruct.find(i));
                }

//                for (i = 1; i < unionarray.length; i++) {
//                    for (j = i + 1; j < unionarray.length; j++) {
//                        if (ufstruct.connected(i, j) == true) {
//                            if (unionarray[j] > unionarray[i]) {
//                                unionarray[j] = unionarray[i];
//                            } else if (unionarray[j] < unionarray[i]) {
//                                for (k = 1; k <= i; k++) {
//                                    if (unionarray[k] == unionarray[i]) {
//                                        unionarray[k] = unionarray[j];
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }
//                for (k = 1; k < unionarray.length; k++) {
//                    for (i = 0; i < num; i++) {
//                        for (j = 0; j < num; j++) {
//
//                            if (label[i][j] == k && unionarray[k] != k) {
//                                label[i][j] = unionarray[k];
//                            }
//                        }
//                    }
//                }
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(ufstruct.find(label[targetcoord[0] - 1][targetcoord[1] - 1]));
            }
        }
    }

}

@a8f900490ccc32ccbcf0eafbec752d32@"
"r04631004","9","1.01","143376","@c1ada03d2c4102d0a0f6810e3e67fa7f@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            //                                          System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            //                                        System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                // WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF((num * num) / 2 + 1);
                //UF ufstruct = new UF((num * num) / 2 + 1);
                //QuickFindUF ufstruct = new QuickFindUF((num * num) / 2 + 1);
                QuickUnionUF ufstruct = new QuickUnionUF((num * num) / 2 + 1);

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            if (ufstruct.find(storeunionpoint.biglabel[i][j]) > storeunionpoint.smalllabel[i][j]) {
                                ufstruct.union(storeunionpoint.biglabel[i][j], storeunionpoint.smalllabel[i][j]);
                            } else {
                                ufstruct.union(storeunionpoint.smalllabel[i][j], storeunionpoint.biglabel[i][j]);
                            }
                        }
                    }
                }
                int[] unionarray = new int[(num * num) / 2 + 1];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
//                    if(i>0)
//                        System.out.println(i+"" = ""+ufstruct.find(i));
                }

//                for (i = 1; i < unionarray.length; i++) {
//                    for (j = i + 1; j < unionarray.length; j++) {
//                        if (ufstruct.connected(i, j) == true) {
//                            if (unionarray[j] > unionarray[i]) {
//                                unionarray[j] = unionarray[i];
//                            } else if (unionarray[j] < unionarray[i]) {
//                                for (k = 1; k <= i; k++) {
//                                    if (unionarray[k] == unionarray[i]) {
//                                        unionarray[k] = unionarray[j];
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }
//                for (k = 1; k < unionarray.length; k++) {
//                    for (i = 0; i < num; i++) {
//                        for (j = 0; j < num; j++) {
//
//                            if (label[i][j] == k && unionarray[k] != k) {
//                                label[i][j] = unionarray[k];
//                            }
//                        }
//                    }
//                }
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(ufstruct.find(label[targetcoord[0] - 1][targetcoord[1] - 1]));
            }
        }
    }

}

@c1ada03d2c4102d0a0f6810e3e67fa7f@"
"r04631025","0","1.01","143376","@db120bd40a364bfe68368d403ded71ee@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package LabelCC;

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    UF uf;

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        label = 1;
        N = n;
        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 0;
        }

    }
    public void newunion (int n){
        uf =new UF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(matrix[x-1][y]!=-1&& matrix[x][y-1]!=-1){
                uf.union(id[matrix[x-1][y]]-1,id[matrix[x][y-1]]-1);
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=100;
        matrix[x - 1][y - 1] = -1;
    }
    
    public int getlabel (int x ,int y){
        return uf.find(id[matrix[x-1][y-1]]);
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            id[matrix[x][y]] = label;
        } else {
            if (x == 0&&matrix[x][y]!=-1) {
                if (matrix[x][y - 1] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x][y-1]];
                }
            }
            if (y == 0&&matrix[x][y]!=-1) {
                if (matrix[x - 1][y] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x - 1][y]];
                }
            }
            if (matrix[x][y] != -1 && x != 0 && y != 0) {
                if (matrix[x - 1][y] != -1 && matrix[x][y - 1] != -1) {
                    if (id[matrix[x - 1][y]] > id[matrix[x][y - 1]]) {
                        id[matrix[x][y]] = id[matrix[x][y - 1]];
                    }
                    else{
                        id[matrix[x][y]]=id[matrix[x-1][y]];
                    }
                }else if(matrix[x-1][y]!=-1 && matrix[x][y-1]==-1){
                    id[matrix[x][y]]=id[matrix[x-1][y]];
                }else if(matrix[x-1][y]==-1 && matrix[x][y-1]!=-1){
                    id[matrix[x][y]]=id[matrix[x][y-1]];
                }else{
                    label++;
                    id[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@db120bd40a364bfe68368d403ded71ee@"
"b02611016","9","1.06","140368","@d19e9da08229fa7ff4e46fe118ebe8d1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.QuickUnionUF;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            QuickUnionUF uf=new QuickUnionUF(num*num);
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                uf.union(cloumn-1, cloumn-2);
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
                uf.union((row-1)*num+cloumn-2, (row-2)*num+cloumn-1);
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   uf.union((row-1)*num+cloumn-2, (row-2)*num+cloumn-1);
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   uf.union((row-2)*num+cloumn-1, (row-1)*num+cloumn-2);
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
               uf.union((row-1)*num+cloumn-1, (row-1)*num+cloumn-2);
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }

/*for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1&&(id[(row-2)*num+cloumn-1]!=id[(row-1)*num+cloumn-2]))
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
            k1=id[(row-1)*num+cloumn-2];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}*/
  /*           for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
         if(x_position>num||y_position>num)
          { System.out.printf(""0"");
          
          }
         else{
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[ uf.find((x_position-1)*num+y_position-1)] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
         }
            br.close();
        }
    }
}

@d19e9da08229fa7ff4e46fe118ebe8d1@"
"r04631025","0","1.25","155504","@d665f56dae0e11be504daedbfa9fde33@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package LabelCC;

/**
 *
 * @author Tim
 */
import edu.princeton.cs.algs4.UF;
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    UF uf;

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        label = 1;
        N = n;
        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 0;
        }

    }
    public void newunion (int n){
        uf =new UF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(matrix[x-1][y]!=-1&& matrix[x][y-1]!=-1){
                uf.union(id[matrix[x-1][y]]-1,id[matrix[x][y-1]]-1);
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=100;
        matrix[x - 1][y - 1] = -1;
    }
    
    public int getlabel (int x ,int y){
        return uf.find(id[matrix[x-1][y-1]]);
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            id[matrix[x][y]] = label;
        } else {
            if (x == 0&&matrix[x][y]!=-1) {
                if (matrix[x][y - 1] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x][y-1]];
                }
            }
            if (y == 0&&matrix[x][y]!=-1) {
                if (matrix[x - 1][y] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x - 1][y]];
                }
            }
            if (matrix[x][y] != -1 && x != 0 && y != 0) {
                if (matrix[x - 1][y] != -1 && matrix[x][y - 1] != -1) {
                    if (id[matrix[x - 1][y]] > id[matrix[x][y - 1]]) {
                        id[matrix[x][y]] = id[matrix[x][y - 1]];
                    }
                    else{
                        id[matrix[x][y]]=id[matrix[x-1][y]];
                    }
                }else if(matrix[x-1][y]!=-1 && matrix[x][y-1]==-1){
                    id[matrix[x][y]]=id[matrix[x-1][y]];
                }else if(matrix[x-1][y]==-1 && matrix[x][y-1]!=-1){
                    id[matrix[x][y]]=id[matrix[x][y-1]];
                }else{
                    label++;
                    id[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@d665f56dae0e11be504daedbfa9fde33@"
"r04631025","0","1.01","143376","@54559f8063e2791fecf7eda053adb5c2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package LabelCC;

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    UF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        label = 1;
        N = n;
        uf= new UF(n);
        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 0;
        }

    }
//    public void newunion (int n){
//        uf =new UF(label);        
//    }
//    public void child(int x,int y){
//        if(x!=0&&y!=0){
//            if(matrix[x-1][y]!=-1&& matrix[x][y-1]!=-1){
//                uf.union(id[matrix[x-1][y]]-1,id[matrix[x][y-1]]-1);
//            }
//        }
//    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=100;
        matrix[x - 1][y - 1] = -1;
    }
    
//    public int getlabel (int x ,int y){
//        return uf.find(id[matrix[x-1][y-1]]);
//    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            id[matrix[x][y]] = label;
        } else {
            if (x == 0&&matrix[x][y]!=-1) {
                if (matrix[x][y - 1] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x][y-1]];
                }
            }
            if (y == 0&&matrix[x][y]!=-1) {
                if (matrix[x - 1][y] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x - 1][y]];
                }
            }
            if (matrix[x][y] != -1 && x != 0 && y != 0) {
                if (matrix[x - 1][y] != -1 && matrix[x][y - 1] != -1) {
                    if (id[matrix[x - 1][y]] > id[matrix[x][y - 1]]) {
                        id[matrix[x][y]] = id[matrix[x][y - 1]];
                    }
                    else{
                        id[matrix[x][y]]=id[matrix[x-1][y]];
                    }
                }else if(matrix[x-1][y]!=-1 && matrix[x][y-1]==-1){
                    id[matrix[x][y]]=id[matrix[x-1][y]];
                }else if(matrix[x-1][y]==-1 && matrix[x][y-1]!=-1){
                    id[matrix[x][y]]=id[matrix[x][y-1]];
                }else{
                    label++;
                    id[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
//            LC.newunion(N);
//            for(int i=0;i<N;i++){
//                for(int j=0;j<N;j++){
//                    LC.child(i,j);
//                }
//            }
//            int answer=LC.getlabel(destx, desty);
//            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@54559f8063e2791fecf7eda053adb5c2@"
"r04631025","0","1.06","140368","@0836d10ef978f928a9585bf712299928@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package LabelCC;

/**
 *
 * @author Tim
 */

import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    QuickFindUF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        label = 1;
        N = n;

        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 0;
        }

    }
    public void newunion (int n){
        uf =new QuickFindUF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(matrix[x-1][y]!=-1&& matrix[x][y-1]!=-1){
                uf.union(id[matrix[x-1][y]]-1,id[matrix[x][y-1]]-1);
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=100;
        matrix[x - 1][y - 1] = -1;
    }
    
    public int getlabel (int x ,int y){
        return uf.find(id[matrix[x-1][y-1]]);
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            id[matrix[x][y]] = label;
        } else {
            if (x == 0&&matrix[x][y]!=-1) {
                if (matrix[x][y - 1] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x][y-1]];
                }
            }
            if (y == 0&&matrix[x][y]!=-1) {
                if (matrix[x - 1][y] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x - 1][y]];
                }
            }
            if (matrix[x][y] != -1 && x != 0 && y != 0) {
                if (matrix[x - 1][y] != -1 && matrix[x][y - 1] != -1) {
                    if (id[matrix[x - 1][y]] > id[matrix[x][y - 1]]) {
                        id[matrix[x][y]] = id[matrix[x][y - 1]];
                    }
                    else{
                        id[matrix[x][y]]=id[matrix[x-1][y]];
                    }
                }else if(matrix[x-1][y]!=-1 && matrix[x][y-1]==-1){
                    id[matrix[x][y]]=id[matrix[x-1][y]];
                }else if(matrix[x-1][y]==-1 && matrix[x][y-1]!=-1){
                    id[matrix[x][y]]=id[matrix[x][y-1]];
                }else{
                    label++;
                    id[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@0836d10ef978f928a9585bf712299928@"
"r04631013","0","1.25","155504","@8601f07fb556710a15a09ce629b41ac8@
import java.io.FileReader;
import java.io.BufferedReader;

public class LableCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {
            String[] data = br.readLine().split("","");

            int num = Integer.parseInt(data[0]);

            int[][] matrix = new int[num + 1][num + 1];
            int target_row = Integer.parseInt(data[1]);
            int target_col = Integer.parseInt(data[2]);
            // System.out.printf(""%d %d %d"", num, target_row, target_col);
            // creat a zero- matrix with bigger size(one more row and col)
            for (int i = 0; i < num + 1; i++) {
                for (int j = 0; j < num + 1; j++) {
                    matrix[i][j] = 0;
                }
            }
            //creat a one-matrix
            for (int i = 1; i < num + 1; i++) {
                for (int j = 1; j < num + 1; j++) {
                    matrix[i][j] = 1;
                }
            }
            //the bolcked site is zero
            String line;
            while ((line = br.readLine()) != null) {
                if (line.isEmpty()) {
                    System.out.print(""-1"");
                    break;
                }
                String[] readnum = line.split("","");
                int row = Integer.parseInt(readnum[0]);
                int col = Integer.parseInt(readnum[1]);
                matrix[row][col] = 0;
            }
            // first run
            int initial = 0;
            QuickUnionUF uf = new QuickUnionUF(num * num + 4);
            for (int i = 1; i < matrix.length; i++) {
                for (int j = 1; j < matrix[0].length; j++) {
                    if (matrix[i][j] != 0) {
                        if (matrix[i][j - 1] == 0 && matrix[i - 1][j] == 0) {
                            initial = initial + 1;
                            matrix[i][j] = initial;
                        } else if (matrix[i][j - 1] == 0 && matrix[i - 1][j] != 0) {
                            matrix[i][j] = matrix[i - 1][j];
                        } else if (matrix[i][j - 1] != 0 && matrix[i - 1][j] == 0) {
                            matrix[i][j] = matrix[i][j - 1];
                        } else {
                            int a = matrix[i][j - 1];
                            int b = matrix[i - 1][j];
                            if (a > b) {
                                matrix[i][j] = b;
                                uf.union(a, b);
                            } else {
                                matrix[i][j] = a;
                                uf.union(b, a);
                            }

                        }
                    }
                }
            }

            // print rhe matrix
            int kkk = matrix[target_row][target_col];
            int rooo;
            rooo = uf.find(kkk);
            System.out.print(rooo);
//            for (int i = 0; i < matrix.length; i++) {
//                for (int j = 0; j < matrix[0].length; j++) {
//                    System.out.print(matrix[i][j] + "" "");
//                }
//                System.out.print(""\n"");
//            }
        }
    }
}

@8601f07fb556710a15a09ce629b41ac8@"
"r04631013","10","0.098","124560","@12d321bc60d7635a4ef1b118b0e2443c@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader((args[0])))) {
            String[] data = br.readLine().split("","");

            int num = Integer.parseInt(data[0]);

            int[][] matrix = new int[num + 1][num + 1];
            int target_row = Integer.parseInt(data[1]);
            int target_col = Integer.parseInt(data[2]);
            // System.out.printf(""%d %d %d"", num, target_row, target_col);
            // creat a zero- matrix with bigger size(one more row and col)
            for (int i = 0; i < num + 1; i++) {
                for (int j = 0; j < num + 1; j++) {
                    matrix[i][j] = 0;
                }
            }
            //creat a one-matrix
            for (int i = 1; i < num + 1; i++) {
                for (int j = 1; j < num + 1; j++) {
                    matrix[i][j] = 1;
                }
            }
            //the bolcked site is zero
            String line;
            while ((line = br.readLine()) != null) {
                if (line.isEmpty()) {
                    System.out.print(""-1"");
                    break;
                }
                String[] readnum = line.split("","");
                int row = Integer.parseInt(readnum[0]);
                int col = Integer.parseInt(readnum[1]);
                matrix[row][col] = 0;
            }
            // first run
            int initial = 0;
            QuickUnionUF uf = new QuickUnionUF(num * num + 4);
            for (int i = 1; i < matrix.length; i++) {
                for (int j = 1; j < matrix[0].length; j++) {
                    if (matrix[i][j] != 0) {
                        if (matrix[i][j - 1] == 0 && matrix[i - 1][j] == 0) {
                            initial = initial + 1;
                            matrix[i][j] = initial;
                        } else if (matrix[i][j - 1] == 0 && matrix[i - 1][j] != 0) {
                            matrix[i][j] = matrix[i - 1][j];
                        } else if (matrix[i][j - 1] != 0 && matrix[i - 1][j] == 0) {
                            matrix[i][j] = matrix[i][j - 1];
                        } else {
                            int a = matrix[i][j - 1];
                            int b = matrix[i - 1][j];
                            if (a > b) {
                                matrix[i][j] = b;
                                uf.union(a, b);
                            } else {
                                matrix[i][j] = a;
                                uf.union(b, a);
                            }

                        }
                    }
                }
            }

            // print rhe matrix
            int kkk = matrix[target_row][target_col];
            int rooo;
            rooo = uf.find(kkk);
            System.out.print(rooo);
//            for (int i = 0; i < matrix.length; i++) {
//                for (int j = 0; j < matrix[0].length; j++) {
//                    System.out.print(matrix[i][j] + "" "");
//                }
//                System.out.print(""\n"");
//            }
        }
    }
}

@12d321bc60d7635a4ef1b118b0e2443c@"
"r04631025","0","1.06","140368","@7d5c22e0dcf45d6349735b1e31664628@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package LabelCC;

/**
 *
 * @author Tim
 */
import edu.princeton.cs.algs4.QuickFindUF;
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    QuickFindUF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        label = 1;
        N = n;
           

        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 0;
        }

    }
    public void newunion (int n){
        uf =new QuickFindUF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(matrix[x-1][y]!=-1&& matrix[x][y-1]!=-1){
                uf.union(id[matrix[x-1][y]]-1,id[matrix[x][y-1]]-1);
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=100;
        matrix[x - 1][y - 1] = -1;
    }
    
    public int getlabel (int x ,int y){
        return uf.find(id[matrix[x-1][y-1]]);
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            id[matrix[x][y]] = label;
        } else {
            if (x == 0&&matrix[x][y]!=-1) {
                if (matrix[x][y - 1] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x][y-1]];
                }
            }
            if (y == 0&&matrix[x][y]!=-1) {
                if (matrix[x - 1][y] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x - 1][y]];
                }
            }
            if (matrix[x][y] != -1 && x != 0 && y != 0) {
                if (matrix[x - 1][y] != -1 && matrix[x][y - 1] != -1) {
                    if (id[matrix[x - 1][y]] > id[matrix[x][y - 1]]) {
                        id[matrix[x][y]] = id[matrix[x][y - 1]];
                    }
                    else{
                        id[matrix[x][y]]=id[matrix[x-1][y]];
                    }
                }else if(matrix[x-1][y]!=-1 && matrix[x][y-1]==-1){
                    id[matrix[x][y]]=id[matrix[x-1][y]];
                }else if(matrix[x-1][y]==-1 && matrix[x][y-1]!=-1){
                    id[matrix[x][y]]=id[matrix[x][y-1]];
                }else{
                    label++;
                    id[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@7d5c22e0dcf45d6349735b1e31664628@"
"r04631025","0","1.06","140368","@920c145899e2c141f3a2fc35bb9cfd91@

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    QuickFindUF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        label = 1;
        N = n;
           

        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 0;
        }

    }
    public void newunion (int n){
        uf =new QuickFindUF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(matrix[x-1][y]!=-1&& matrix[x][y-1]!=-1){
                uf.union(id[matrix[x-1][y]]-1,id[matrix[x][y-1]]-1);
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=100;
        matrix[x - 1][y - 1] = -1;
    }
    
    public int getlabel (int x ,int y){
        return uf.find(id[matrix[x-1][y-1]]);
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            id[matrix[x][y]] = label;
        } else {
            if (x == 0&&matrix[x][y]!=-1) {
                if (matrix[x][y - 1] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x][y-1]];
                }
            }
            if (y == 0&&matrix[x][y]!=-1) {
                if (matrix[x - 1][y] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x - 1][y]];
                }
            }
            if (matrix[x][y] != -1 && x != 0 && y != 0) {
                if (matrix[x - 1][y] != -1 && matrix[x][y - 1] != -1) {
                    if (id[matrix[x - 1][y]] > id[matrix[x][y - 1]]) {
                        id[matrix[x][y]] = id[matrix[x][y - 1]];
                    }
                    else{
                        id[matrix[x][y]]=id[matrix[x-1][y]];
                    }
                }else if(matrix[x-1][y]!=-1 && matrix[x][y-1]==-1){
                    id[matrix[x][y]]=id[matrix[x-1][y]];
                }else if(matrix[x-1][y]==-1 && matrix[x][y-1]!=-1){
                    id[matrix[x][y]]=id[matrix[x][y-1]];
                }else{
                    label++;
                    id[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@920c145899e2c141f3a2fc35bb9cfd91@"
"r04631025","3","0.74","135072","@fbb0eb8ace4e39be2bc7b2911135ef9a@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    QuickFindUF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        label = 1;
        N = n;
           

        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 0;
        }

    }
    public void newunion (int n){
        uf =new QuickFindUF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(matrix[x-1][y]!=-1&& matrix[x][y-1]!=-1){
                uf.union(id[matrix[x-1][y]]-1,id[matrix[x][y-1]]-1);
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=100;
        matrix[x - 1][y - 1] = -1;
    }
    
    public int getlabel (int x ,int y){
        return uf.find(id[matrix[x-1][y-1]]);
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            id[matrix[x][y]] = label;
        } else {
            if (x == 0&&matrix[x][y]!=-1) {
                if (matrix[x][y - 1] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x][y-1]];
                }
            }
            if (y == 0&&matrix[x][y]!=-1) {
                if (matrix[x - 1][y] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x - 1][y]];
                }
            }
            if (matrix[x][y] != -1 && x != 0 && y != 0) {
                if (matrix[x - 1][y] != -1 && matrix[x][y - 1] != -1) {
                    if (id[matrix[x - 1][y]] > id[matrix[x][y - 1]]) {
                        id[matrix[x][y]] = id[matrix[x][y - 1]];
                    }
                    else{
                        id[matrix[x][y]]=id[matrix[x-1][y]];
                    }
                }else if(matrix[x-1][y]!=-1 && matrix[x][y-1]==-1){
                    id[matrix[x][y]]=id[matrix[x-1][y]];
                }else if(matrix[x-1][y]==-1 && matrix[x][y-1]!=-1){
                    id[matrix[x][y]]=id[matrix[x][y-1]];
                }else{
                    label++;
                    id[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@fbb0eb8ace4e39be2bc7b2911135ef9a@"
"b02611016","10","0.104","142352","@ba7edb5edbf47c7a459a0b5f71fc5172@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.QuickUnionUF;
/**
 *
 * @author Lab304
 */
public class LabelCC {
 public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){          
            // read a line and split by ','
            String[] data = br.readLine().split("","");                    
            // store the second integer in variable num (dimension of matrix: num * num)           
            int num = Integer.parseInt(data[0]);         
            int x_position=Integer.parseInt(data[1]); 
            int y_position=Integer.parseInt(data[2]); 
            QuickUnionUF uf=new QuickUnionUF(num*num);
            // initilization of a String array in Java
            int[][] matrix = new int[num+1][num+2];
            int [] id=new int[num*num];
            int[] count=new int[num*num] ;
            int[] labelcount=new int[num*num+5] ;
            int label=1;
            int k1=0,k2=0,k3=0,k4=0,k5=0,k6=0;
            //Date date = new Date();
            for(int x=0;x<num;x++)
            {for(int y=1;y<num+1;y++)
            {matrix[x][y]=1;
            }
            }
            
            search: 
            for(int i=0;i<num*num;i++){
            String datalocation = br.readLine();
            if (datalocation==null) {
            //System.out.println(""0"");
            break search;
            }
            
            int row = Integer.parseInt(datalocation.split("","")[0]);         
            int cloumn = Integer.parseInt(datalocation.split("","")[1]);   
            if(row>num||cloumn>num||row<1||cloumn<1)
            {System.out.println(""0"");
            break search;
            }            
         //   System.out.printf("" %d  %d\n"", row ,cloumn );
           matrix[row-1][cloumn]=0;
           
           
     }
            
labelchange_1:           
 for(int row=1;row<num+1;row++){        
     for(int cloumn=1;cloumn<num+1;cloumn++){
         
         if(matrix[row-1][cloumn]==1){
            if (row==1){ 
                
                if(matrix[row-1][cloumn-1]==1){
                id[cloumn-1]=id[cloumn-2];
                uf.union(cloumn-1, cloumn-2);
                labelcount[id[cloumn-2]]=labelcount[id[cloumn-2]]+1 ;
                }
                else{
                id[cloumn-1]=label ;
                labelcount[id[cloumn-1]]=labelcount[id[cloumn-1]]+1 ;      
               label=label+1 ;
                }
                
             }
         
                
           else{
               if(matrix[row-2][cloumn]==1)
               {if(matrix[row-1][cloumn-1]!=1){
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                   uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
               }
               else if(matrix[row-1][cloumn-1]==1)
               {if(id[(row-2)*num+cloumn-1]==id[(row-1)*num+cloumn-2])
               {id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
               uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
                uf.union((row-1)*num+cloumn-2, (row-2)*num+cloumn-1);
               labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ;
               }
               
                  else if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
               {k1=id[(row-1)*num+cloumn-2];
                   id[(row-1)*num+cloumn-1]=id[(row-2)*num+cloumn-1];
                     uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
                   uf.union((row-1)*num+cloumn-2, (row-2)*num+cloumn-1);
                   
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                  /* for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }*/
               }
               
               else{k2=id[(row-2)*num+cloumn-1];
                   id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
                   uf.union((row-1)*num+cloumn-1, (row-1)*num+cloumn-2);
                   uf.union((row-2)*num+cloumn-1, (row-1)*num+cloumn-2);
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
               /*  for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }*/
               }
               }
                
                   
               }
               
               else if(matrix[row-2][cloumn]!=1&&matrix[row-1][cloumn-1]==1)
               {id[(row-1)*num+cloumn-1]=id[(row-1)*num+cloumn-2];
               uf.union((row-1)*num+cloumn-1, (row-1)*num+cloumn-2);
                labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
              //  labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1;
                 
               }
            
               else
               {id[(row-1)*num+cloumn-1]=label;
               labelcount[id[(row-1)*num+cloumn-1]]=labelcount[id[(row-1)*num+cloumn-1]]+1;
               label=label+1;
               }
           }
         }
     }
 }

/*for(int row=2;row<num+1;row++){
for(int cloumn=1;cloumn<num+1;cloumn++)
{if(matrix[row-1][cloumn]==1)
        {if(matrix[row-2][cloumn]==1&&matrix[row-1][cloumn-1]==1&&(id[(row-2)*num+cloumn-1]!=id[(row-1)*num+cloumn-2]))
        {if(id[(row-2)*num+cloumn-1]<id[(row-1)*num+cloumn-2])
        { uf.union((row-1)*num+cloumn-1, (row-2)*num+cloumn-1);
            k1=id[(row-1)*num+cloumn-2];
                    labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   for(int u=0;u<num*num;u++)
                   {if(labelcount[k1]==0){break;}
                       if(id[u]==k1)
                   {id[u]=id[(row-2)*num+cloumn-1];
                   labelcount[id[(row-2)*num+cloumn-1]]=labelcount[id[(row-2)*num+cloumn-1]]+1 ; 
                   labelcount[k1]=labelcount[k1]-1;
                   }
                   }
        }
        else 
        {  k2=id[(row-2)*num+cloumn-1];
            for(int u=0;u<num*num;u++)
                   {if(labelcount[k2]==0){break;}
                       if(id[u]==k2)
                   {id[u]=id[(row-1)*num+cloumn-2];
                   labelcount[id[(row-1)*num+cloumn-2]]=labelcount[id[(row-1)*num+cloumn-2]]+1 ; 
                   labelcount[k2]=labelcount[k2]-1;
                   
                   }
                   }
        }
        }
         
            
        }
}
}*/
  /*           for(int q=1;q<num+1;q++){
                 for(int w=1;w<num+1;w++){
           System.out.printf(""data %d, "", id[(q-1)*num+w-1] );
                 }
                 System.out.println("""");
           }
              System.out.printf("" %d,%d "", x_position,y_position );
             System.out.println("""");*/
         if(x_position>num||y_position>num)
          { System.out.printf(""0"");
          
          }
         else{
          if(id[(x_position-1)*num+y_position-1]==0){    System.out.printf(""0"");
            // System.out.println("""");
         }
          else{
             System.out.printf(""%d"",id[ uf.find((x_position-1)*num+y_position-1)] );
            // System.out.println("""");
          }
          if(x_position==0||y_position==0)
          { System.out.printf(""0"");}
          // System.out.printf(""%d,%d,%d,%d,%d, %d "", k1,k2,k3,k4,k5,k6 );
          // System.out.println("""");
         }
            br.close();
        }
    }
}

@ba7edb5edbf47c7a459a0b5f71fc5172@"
"r04631025","3","0.74","133440","@fbb0eb8ace4e39be2bc7b2911135ef9a@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    QuickFindUF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        label = 1;
        N = n;
           

        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 0;
        }

    }
    public void newunion (int n){
        uf =new QuickFindUF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(matrix[x-1][y]!=-1&& matrix[x][y-1]!=-1){
                uf.union(id[matrix[x-1][y]]-1,id[matrix[x][y-1]]-1);
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=100;
        matrix[x - 1][y - 1] = -1;
    }
    
    public int getlabel (int x ,int y){
        return uf.find(id[matrix[x-1][y-1]]);
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            id[matrix[x][y]] = label;
        } else {
            if (x == 0&&matrix[x][y]!=-1) {
                if (matrix[x][y - 1] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x][y-1]];
                }
            }
            if (y == 0&&matrix[x][y]!=-1) {
                if (matrix[x - 1][y] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x - 1][y]];
                }
            }
            if (matrix[x][y] != -1 && x != 0 && y != 0) {
                if (matrix[x - 1][y] != -1 && matrix[x][y - 1] != -1) {
                    if (id[matrix[x - 1][y]] > id[matrix[x][y - 1]]) {
                        id[matrix[x][y]] = id[matrix[x][y - 1]];
                    }
                    else{
                        id[matrix[x][y]]=id[matrix[x-1][y]];
                    }
                }else if(matrix[x-1][y]!=-1 && matrix[x][y-1]==-1){
                    id[matrix[x][y]]=id[matrix[x-1][y]];
                }else if(matrix[x-1][y]==-1 && matrix[x][y-1]!=-1){
                    id[matrix[x][y]]=id[matrix[x][y-1]];
                }else{
                    label++;
                    id[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@fbb0eb8ace4e39be2bc7b2911135ef9a@"
"r04945009","10","0.102","129440","@16ca00682a4fc90daeaf83bb6608a748@
import java.io.BufferedReader;
import java.io.FileReader;


/**
 *
 * @author hung-wei
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    
    
    
    public static void main(String[] args) throws Exception {

        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])))
        {
            String[] Line1 = br.readLine().split("","");
            int N = Integer.parseInt(Line1[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(Line1[1]);
            target[1] = Integer.parseInt(Line1[2]);
            boolean[][] matrix = new boolean[N+1][N+1];
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    matrix[i][j] = true;
                }
            }
            
            while (br.ready()){
                String[] data = br.readLine().split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                matrix[x][y] = false;
            }
            int[][] label = new int[N][N];
            int Count = 1;
            int Count2 = 0;
            int Special[] = new int[N*N+1];
            Special[0] = 0;
            
            for(int i=1; i<N+1; i++){
                for(int j=1; j<N+1; j++){
                    if(matrix[i][j]){
                        if(!matrix[i][j-1] && !matrix[i-1][j]){
                            label[i-1][j-1] = Count++;
                        }    
                        else if(!matrix[i][j-1])
                            label[i-1][j-1] = label[i-2][j-1];
                        else if(!matrix[i-1][j])
                            label[i-1][j-1] = label[i-1][j-2];
                        else{
                            if(label[i-2][j-1] < label[i-1][j-2]){
                                label[i-1][j-1] = label[i-2][j-1];
                                Special[2*Count2] = label[i-1][j-2]; 
                                Special[2*Count2+1] = label[i-2][j-1]; Count2++;
                            }
                            else if(label[i-1][j-2] < label[i-2][j-1]){
                                label[i-1][j-1] = label[i-1][j-2];
                                Special[2*Count2] = label[i-2][j-1]; 
                                Special[2*Count2+1] = label[i-1][j-2]; Count2++;
                            }
                            else
                                label[i-1][j-1] = label[i-1][j-2];
                        } 
                    }
                }
            }
            QuickFindUF GO = new QuickFindUF(Count);
            for(int i=0; i<Count2; i++){
                GO.union(Special[2*i],Special[2*i+1]);
            }
            for(int i=0; i<N; i++){
                for(int j=0; j<N; j++){
                    label[i][j] = GO.find(label[i][j]);                    
                }
            }
            System.out.println(label[target[0]-1][target[1]-1]);
        }                 
    }
}

@16ca00682a4fc90daeaf83bb6608a748@"
"b03611023","10","0.138","156848","@96b3da543aa032f46d2005ec6b619982@
import java.io.FileReader;
import java.io.BufferedReader;
        

public class LabelCC {
    
  
                    
    
    public static void main(String[] args) throws Exception{
        try(BufferedReader br = new BufferedReader(new FileReader(args[0])) ){
            
            String[] N = br.readLine().split("","");
            
            int n = Integer.parseInt(N[0]);
           // System.out.print(n);
            int a = Integer.parseInt(N[1]);
            int b = Integer.parseInt(N[2]);
            //System.out.print(a);
            //System.out.print(b);
            int[][] label = new int[n+1][n+1];
            int[][] open = new int[n+1][n+1];
            
            int x;
            int y;
            
            for(x = 1;x<n+1;x++){
                for(y = 1;y<n+1;y++){
                    open[x][y] = 1;
                }
            }
            
           
            
            String buffer;
            String gg = """";
            int i = 0;
            
            buffer = br.readLine();
            while(buffer != null){
                gg = gg.concat(buffer);
                gg = gg.concat("","");
                i++;
                buffer = br.readLine();
            }
            String[] lgg = gg.split("","");
            int[] data = new int[2];
            for(int j = 0;j<2*i;j+=2){
                data[0] = Integer.parseInt(lgg[j]);
                data[1] = Integer.parseInt(lgg[j+1]);              
                open[data[0]][data[1]] = 0;                
            }
            int[] root = new int[n*n+1];
            for(x = 0; x<n*n+1; x++){
                root[x] = x;
            }
            
            int count = 1;
            for(x = 1;x<n+1 ;x++){
                for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                    if(open[x-1][y] == 1 && open[x][y-1] == 1 && label[x][y-1] != label[x-1][y] ){  
                       int d = label[x][y-1];
                       int f = label[x-1][y];
                       while(root[label[x-1][y]] != label[x-1][y]){
                    label[x-1][y] = root[label[x-1][y]];
                }
                        while(root[label[x][y-1]] != label[x][y-1]){
                    label[x][y-1] = root[label[x][y-1]];
                }
                        if(d < f){
                        label[x][y] = d;
                       // System.out.print(label[x][y]);
                        root[label[x-1][y]] = label[x][y-1];
                        
                        }
                        else{
                             label[x][y] = f;
                           //  System.out.print(label[x][y]);
                             root[label[x][y-1]] = label[x-1][y];
                            
                        }
                    }
                    else if(open[x-1][y] == 1){
                        label[x][y] = label[x-1][y];
                       // System.out.print(label[x][y]);
                       
                    }
                    else if(open[x][y-1] == 1){
                        label[x][y] = label[x][y-1];
                      //  System.out.print(label[x][y]);                       
                    }
                    else {
                        label[x][y] = count;
                        count++;
                      //  System.out.print(label[x][y]);                        
                    }
                }    
                }
            }            
        for(x=1;x<n+1;x++){
            for(y = 1;y<n+1;y++){
                if(open[x][y] == 1){
                while(root[label[x][y]] != label[x][y]){
                    label[x][y] = root[label[x][y]];
                }
                }
               // System.out.print(label[x][y]);
            }
        }
      /*  for(x = 1;x<count;x++){
            System.out.print(root[x]);
            
        }*/
        System.out.print(label[a][b]);
            
        }
    }
    
    
    
    
    
    
    
}

@96b3da543aa032f46d2005ec6b619982@"
"b01b01039","0","2.21","265248","@4ba5c1b2c3b83ef7608682c3dc5c03fe@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = b;
	}
	
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%5d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}

	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}

	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			Stack<Integer> up_st = new Stack<Integer>();
			Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col,false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								up_st.push(lcc.up_label(row,col));
								left_st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			lcc.both_print();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(up_st.size() != 0){
				int up = up_st.pop();
				int left = left_st.pop();
				System.out.println(up + "" "" + left);
				uf_l.union(up, left);
				uf_l.label_change(up, left);
			}
			uf_l.print_lable();
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
		}
	}	
}

class uf_label extends QuickUnionUF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		if(label[p]>label[q]){
			label[p] = label[q];
		}else{
			label[q] = label[p];
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[N];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
}
@4ba5c1b2c3b83ef7608682c3dc5c03fe@"
"b01b01039","9","1.04","123440","@c86702b233c4cadf48c90be4d0d939ee@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = b;
	}
	
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%5d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}

	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}

	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			Stack<Integer> up_st = new Stack<Integer>();
			Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col,false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								up_st.push(lcc.up_label(row,col));
								left_st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.both_print();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(up_st.size() != 0){
				int up = up_st.pop();
				int left = left_st.pop();
				//System.out.println(up + "" "" + left);
				uf_l.union(up, left);
				uf_l.label_change(up, left);
			}
			//uf_l.print_lable();
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
		}
	}	
}

class uf_label extends QuickUnionUF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		if(label[p]>label[q]){
			label[p] = label[q];
		}else{
			label[q] = label[p];
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[N];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
}
@c86702b233c4cadf48c90be4d0d939ee@"
"b01b01039","9","1","128784","@c76289cd14f13ff794a5a1a920e55614@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = b;
	}
	
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%5d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}

	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}

	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			Stack<Integer> up_st = new Stack<Integer>();
			Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								up_st.push(lcc.up_label(row,col));
								left_st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.both_print();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(up_st.size() != 0){
				int up = up_st.pop();
				int left = left_st.pop();
				//System.out.println(up + "" "" + left);
				uf_l.union(up, left);
				uf_l.label_change(up, left);
			}
			//uf_l.print_lable();
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
		}
	}	
}

class uf_label extends UF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		if(label[p]>label[q]){
			label[p] = label[q];
		}else{
			label[q] = label[p];
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[N];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
}
@c76289cd14f13ff794a5a1a920e55614@"
"r04631004","9","1.03","146976","@f30ed0a49dc767bdbde173bdb4e58d13@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */

    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
  //                                          System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
    //                                        System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                
               // WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF((num * num) / 2 + 1);
                //UF ufstruct = new UF((num * num) / 2 + 1);
                //QuickFindUF ufstruct = new QuickFindUF((num * num) / 2 + 1);
                QuickUnionUF ufstruct = new QuickUnionUF((num * num) / 2 + 1);

                
                
                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            if(ufstruct.find(storeunionpoint.biglabel[i][j])>ufstruct.find(storeunionpoint.smalllabel[i][j]))
                            ufstruct.union(storeunionpoint.biglabel[i][j],storeunionpoint.smalllabel[i][j] );
                            else
                                ufstruct.union(storeunionpoint.smalllabel[i][j],storeunionpoint.biglabel[i][j] );
                        }
                    }
                }
                int[] unionarray = new int[(num * num) / 2 + 1];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
//                    if(i>0)
//                        System.out.println(i+"" = ""+ufstruct.find(i));
                }
                
                

//                for (i = 1; i < unionarray.length; i++) {
//                    for (j = i + 1; j < unionarray.length; j++) {
//                        if (ufstruct.connected(i, j) == true) {
//                            if (unionarray[j] > unionarray[i]) {
//                                unionarray[j] = unionarray[i];
//                            } else if (unionarray[j] < unionarray[i]) {
//                                for (k = 1; k <= i; k++) {
//                                    if (unionarray[k] == unionarray[i]) {
//                                        unionarray[k] = unionarray[j];
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }

//                for (k = 1; k < unionarray.length; k++) {
//                    for (i = 0; i < num; i++) {
//                        for (j = 0; j < num; j++) {
//
//                            if (label[i][j] == k && unionarray[k] != k) {
//                                label[i][j] = unionarray[k];
//                            }
//                        }
//                    }
//                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(ufstruct.find(label[targetcoord[0] - 1][targetcoord[1] - 1]));
            }
        }
    }

}

@f30ed0a49dc767bdbde173bdb4e58d13@"
"b01b01039","7","0.67","127168","@8c45a98fc8ca4cd463541d4bc1044395@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = b;
	}
	
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%5d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}

	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}

	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            long time1, time2, time3, time4;
			//time1 = System.currentTimeMillis();
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			
			//Stack<Integer> up_st = new Stack<Integer>();
			//Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			int[] up = new int[num/2];
			int[] left = new int[num/2];
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			//time2 = System.currentTimeMillis();
			int CC_N = 0;
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								up[CC_N] = lcc.up_label(row,col);
								left[CC_N] = lcc.left_label(row,col);
								CC_N++;
								//up_st.push(lcc.up_label(row,col));
								//left_st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.both_print();
			//time3 = System.currentTimeMillis();
			uf_label uf_l = new uf_label(lcc.now_label());
			/*while(up_st.size() != 0){
				int up = up_st.pop();
				int left = left_st.pop();
				System.out.println(up + "" "" + left);
				uf_l.union(up, left);
				uf_l.label_change(up, left);
			}*/
			for(int idx = 0; idx < CC_N; idx++){
				uf_l.union(up[idx], left[idx]);
				uf_l.label_change(up[idx], left[idx]);
			}
			
			//uf_l.print_lable();
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
			/*time4 = System.currentTimeMillis();
			System.out.println(""=========== Time Cost ==========="");
			System.out.println(time2 - time1);
			System.out.println(time3 - time2);
			System.out.println(time4 - time3);*/
		}
	}	
}

class uf_label extends UF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		if(label[p]>label[q]){
			label[p] = label[q];
		}else{
			label[q] = label[p];
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[N];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
}
@8c45a98fc8ca4cd463541d4bc1044395@"
"b01b01039","8","0.76","125488","@6b9d25cec64cfe2533dd272872dbe769@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = b;
	}
	
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%5d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}

	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}

	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            long time1, time2, time3, time4;
			//time1 = System.currentTimeMillis();
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			
			//Stack<Integer> up_st = new Stack<Integer>();
			//Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			int[] up = new int[num];
			int[] left = new int[num];
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			//time2 = System.currentTimeMillis();
			int CC_N = 0;
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								up[CC_N] = lcc.up_label(row,col);
								left[CC_N] = lcc.left_label(row,col);
								CC_N++;
								//up_st.push(lcc.up_label(row,col));
								//left_st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.both_print();
			//time3 = System.currentTimeMillis();
			uf_label uf_l = new uf_label(lcc.now_label());
			/*while(up_st.size() != 0){
				int up = up_st.pop();
				int left = left_st.pop();
				System.out.println(up + "" "" + left);
				uf_l.union(up, left);
				uf_l.label_change(up, left);
			}*/
			for(int idx = 0; idx < CC_N; idx++){
				uf_l.union(up[idx], left[idx]);
				uf_l.label_change(up[idx], left[idx]);
			}
			
			//uf_l.print_lable();
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
			/*time4 = System.currentTimeMillis();
			System.out.println(""=========== Time Cost ==========="");
			System.out.println(time2 - time1);
			System.out.println(time3 - time2);
			System.out.println(time4 - time3);*/
		}
	}	
}

class uf_label extends UF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		if(label[p]>label[q]){
			label[p] = label[q];
		}else{
			label[q] = label[p];
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[N];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
}
@6b9d25cec64cfe2533dd272872dbe769@"
"b01b01039","9","1.01","124592","@a43aa4cd0c228fd48183abe23fca8db5@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = node[row][col] & b;
	}
	
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%5d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}

	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}

	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            //long time1, time2, time3, time4;
			//time1 = System.currentTimeMillis();
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			
			Stack<Integer> st = new Stack<Integer>();
			//Stack<Integer> up_st = new Stack<Integer>();
			//Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			//int[] up = new int[num];
			//int[] left = new int[num];
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			//time2 = System.currentTimeMillis();
			//int CC_N = 0;
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								/*
								up[CC_N] = lcc.up_label(row,col);
								left[CC_N] = lcc.left_label(row,col);
								CC_N++;
								
								up_st.push(lcc.up_label(row,col));
								left_st.push(lcc.left_label(row,col));
								*/
								st.push(lcc.up_label(row,col));
								st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.both_print();
			//time3 = System.currentTimeMillis();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(st.size() != 0){
				int up = st.pop();//up_st.pop();
				int left = st.pop();//left_st.pop();
				//System.out.println(up + "" "" + left);
				if(!uf_l.connected(up, left)){
					uf_l.union(up, left);
					uf_l.label_change(up, left);
				}
			}
			/*for(int idx = 0; idx < CC_N; idx++){
				if(!uf_l.connected(up[idx], left[idx])){
					System.out.println(up[idx]+ "" "" + left[idx]);
					uf_l.union(up[idx], left[idx]);
					uf_l.label_change(up[idx], left[idx]);
				}
			}*/
			
			//uf_l.print_lable();
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
			/*time4 = System.currentTimeMillis();
			System.out.println(""=========== Time Cost ==========="");
			System.out.println(time2 - time1);
			System.out.println(time3 - time2);
			System.out.println(time4 - time3);*/
		}
	}	
}

class uf_label extends UF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		if(label[p]>label[q]){
			label[p] = label[q];
		}else{
			label[q] = label[p];
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[N];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
}
@a43aa4cd0c228fd48183abe23fca8db5@"
"r04631041","9","1.01","127808","@ad7ed620668376b3949e9d3de81c97b3@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author USER
 */
public class LabelCC {
//--------------------------API QuickUnionUF----------------------------------//
     private static int[] parent;  // parent[i] = parent of i
    private  static int count;     // number of components
    private  static int counter;
    public static void constr(int N) {
        counter=0;
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }
 public static int count() {
        return count;
    }
   public static int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }
   private static void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
      public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ; 
        count--;
    }
//------------------------Self define function--------------------------------//
      public static void first_pass(int[][] m ,int row, int column, int size){
          if (m[row][column]!=0){
           if (m[row-1][column]==0 && m[row][column-1]==0){
             counter++;
             m[row][column]=counter;
           }
           else if(m[row-1][column]!=0 && m[row][column-1]==0){
             m[row][column]=m[row-1][column];
             union((row-1)*size+column-1,(row-2)*size+column-1);
           }
           else if(m[row-1][column]==0 && m[row][column-1]!=0){
             m[row][column]=m[row][column-1];
             union((row-1)*size+column-1,(row-1)*size+column-2); 
           }
           else if (m[row-1][column]!=0 && m[row][column-1]!=0){
               if (m[row-1][column]<m[row][column-1]){
                   m[row][column]=m[row-1][column];
                   union((row-1)*size+column-1,(row-2)*size+column-1);
                   union((row-1)*size+column-2,(row-2)*size+column-1);
               }
               else if(m[row-1][column]>m[row][column-1]){
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
                   union((row-2)*size+column-1,(row-1)*size+column-2);
               }
               else{
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
               }
           }
          }
      }
      public static void second_pass (int[][] m,int row, int column, int size){
          int temp=find((row-1)*size+column-1);
          if (m[row][column]!=m[(temp/size)+1][(temp%size)+1])
          {
                if (m[(temp/size)+1][(temp%size)+1]<m[row][column]){
                m[row][column]=m[(temp/size)+1][(temp%size)+1];
                union((row-1)*size+column-1,temp);
                }
                
           }
      }
  public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          constr(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
         
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
//--------------------------First pass operation------------------------------//
          for(int i=1 ; i<size+1 ;i++)
              for (int j=1 ; j<size+1 ; j++)
              first_pass(matrix,i,j,size);
//---------------------------Second pass operation----------------------------//         
          for(int i=1 ; i<size+1 ;i++){
              for (int j=1 ; j<size+1 ; j++){
              if (matrix[i][j]!=0)
                  second_pass(matrix,i,j,size);
              }
          }
//          for (int i=0 ; i<size+2 ; i++){
//              for (int j=0 ; j<size+2 ; j++){
//                  System.out.print(matrix[i][j]+""\t"");
//              }
//                  System.out.println("""");
//          }
              System.out.println(matrix[assignrow][assigncolumn]);
       }
  }
}
  
@ad7ed620668376b3949e9d3de81c97b3@"
"r04945025","9","1.01","126848","@d5bb48fe43a2e5a3b80bbfaa91ca13c2@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
    
    public static int[][] matrix;
    public static int size;
    public QuickUnionUF qf;
    public int id=1;
                

    public LabelCC (int n){
        size=n;
        matrix = new int[size][size]; 
        for(int row[]: matrix)
            Arrays.fill(row, 1);
        qf = new QuickUnionUF(size*size);                                                 
    }


    public void Blocked(int x,int y) {
        matrix [x-1][y-1]=0;
    }

    public boolean isOpen(int x,int y){
        return matrix[x-1][y-1]!=0;
    }

    private int setID (int x, int y){
        return id;
    }

    public void targetid (int i, int j) {
        int tar = matrix[i-1][j-1];
        if (tar==0){
            System.out.println(0);
        }
        else{
            System.out.println(qf.find(tar));   
        }
    }

    public void getIndex(int x, int y){
        if(isOpen(x,y)){
            if ((x==1 && isOpen(x,y-1)!=true ) || (y==1 && isOpen(x-1,y)!=true) || (x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true)){
                id++;
                matrix[x-1][y-1]=setID(x,y); 
            }
            else {
                if ((y==1 && isOpen(x-1,y)==true) || (x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true)){
                    matrix[x-1][y-1]=(matrix[x-2][y-1]);
                }
                else{
                    if ((x==1 && isOpen(x,y-1)==true) || (x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true)) {
                        matrix[x-1][y-1]=matrix[x-1][y-2];
                    }
                    else{
                        int a =Math.max((matrix[x-2][y-1]),(matrix[x-1][y-2]));
                        int b =Math.min((matrix[x-2][y-1]),(matrix[x-1][y-2]));
                        matrix[x-1][y-1]=b;
                        qf.union(a,b);
                    }
                }
            }     
        }
        else{
            matrix[x-1][y-1]=0;
        }
    }
        

    public boolean initiation(){
        int ini = matrix[0][0];
        return ini == 0;
    }
        
        
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

            for(String line;(line = br.readLine())!=(null); ){
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
            }
         
            for (int m=1;m<=size;m++){
                for (int n=1;n<=size;n++){      
                    if (m==1&& n==1 &&test.initiation()==false){
                        matrix[0][0]=1;
                        continue;
                    }
                    else{
                        test.getIndex(m, n);
                    }                  
                }
            }  
            test.targetid(i, j);
        }
    }
}
@d5bb48fe43a2e5a3b80bbfaa91ca13c2@"
"r04945025","3","1.03","123136","@63466a6d563a559827d9ac6821a1ad78@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
    
    public static int[][] matrix;
    public static int size;
    public QuickUnionUF qf;
    public int id=0;
                

    public LabelCC (int n){
        size=n;
        matrix = new int[size][size]; 
        for(int row[]: matrix)
            Arrays.fill(row, 1);
        qf = new QuickUnionUF(size*size);                                                 
    }


    public void Blocked(int x,int y) {
        matrix [x-1][y-1]=0;
    }

    public boolean isOpen(int x,int y){
        return matrix[x-1][y-1]!=0;
    }

    private int setID (int x, int y){
        return id;
    }

    public void targetid (int i, int j) {
        int tar = matrix[i-1][j-1];
        if (tar==0){
            System.out.println(0);
        }
        else{
            System.out.println(qf.find(tar));   
        }
    }

    public void getIndex(int x, int y){
        if(isOpen(x,y)){
            if ((x==1 && isOpen(x,y-1)!=true ) || (y==1 && isOpen(x-1,y)!=true) || (x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true)){
                id++;
                matrix[x-1][y-1]=setID(x,y); 
            }
            else {
                if ((y==1 && isOpen(x-1,y)==true) || (x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true)){
                    matrix[x-1][y-1]=(matrix[x-2][y-1]);
                }
                else{
                    if ((x==1 && isOpen(x,y-1)==true) || (x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true)) {
                        matrix[x-1][y-1]=matrix[x-1][y-2];
                    }
                    else{
                        int a =Math.max((matrix[x-2][y-1]),(matrix[x-1][y-2]));
                        int b =Math.min((matrix[x-2][y-1]),(matrix[x-1][y-2]));
                        matrix[x-1][y-1]=b;
                        qf.union(a,b);
                    }
                }
            }     
        }
        else{
            matrix[x-1][y-1]=0;
        }
    }
        

    public boolean initiation(){
        int ini = matrix[0][0];
        return ini == 0;
    }
        
        
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

            for(String line;(line = br.readLine())!=(null); ){
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
            }
         
            for (int m=1;m<=size;m++){
                for (int n=1;n<=size;n++){      
                    if (m==1&& n==1 &&test.initiation()==false){
                        matrix[0][0]=1;
                        continue;
                    }
                    else{
                        test.getIndex(m, n);
                    }                  
                }
            }  
            test.targetid(i, j);
        }
    }
}
@63466a6d563a559827d9ac6821a1ad78@"
"b01b01039","8","1","127856","@4b540815cb77dbf4ba921ebd905e9e60@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	/*
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	*/
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = node[row][col] & b;
	}
	/*
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	*/
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	/*
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%5d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	*/
	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}
	/*
	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	*/
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            long time1, time2, time3, time4;
			//time1 = System.nanoTime();
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			
			Stack<Integer> st = new Stack<Integer>();
			//Stack<Integer> up_st = new Stack<Integer>();
			//Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			//time2 = System.nanoTime();
			//int CC_N = 0;
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								st.push(lcc.up_label(row,col));
								st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.both_print();
			//time3 = System.nanoTime();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(st.size() != 0){
				int up = st.pop();
				int left = st.pop();
				//System.out.println(up + "" "" + left);
				if(!uf_l.connected(up, left)){
					uf_l.union(up, left);
					uf_l.label_change(up, left);
				}
			}
			//uf_l.print_lable();
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
			/*time4 = System.nanoTime();
			System.out.println(""=========== Time Cost ==========="");
			System.out.println(time2 - time1);
			System.out.println(time3 - time2);
			System.out.println(time4 - time3);*/
		}
	}	
}

class uf_label extends UF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		if(label[p]>label[q] && find(p)==p){
			label[p] = label[q];
		}else if(find(q)==q){
			label[q] = label[p];
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[find(N)];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
}
@4b540815cb77dbf4ba921ebd905e9e60@"
"r04631034","10","0.147","172016","@78663535d41c4f7ed56aaadd6fafd82c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//import edu.princeton.cs.algs4.*;

import java.util.*;

/**
 *
 * @author user
 */
public class LabelCC {

          /**
           * @param args the command line arguments
           */
          public static void main(String[] args) {
                    // TODO code application logic here
                    In in = new In(args[0]);
                    String[] TopRow = in.readLine().split("","");

                    int[][] matrix = new int[Integer.parseInt(TopRow[0])][Integer.parseInt(TopRow[0])];
//          System.out.println(matrix.length);
//          System.out.println(TopRow[0]+"" ""+TopRow[1]+"" ""+TopRow[2]);
                    String line;
//         ArrayList<Integer> Row = new ArrayList<Integer>();
//          ArrayList<Integer> Column = new ArrayList<Integer>();
                    while ((line = in.readLine()) != null) {
//                Row.add(Integer.parseInt(line.split("","")[0]));
//               Column.add(Integer.parseInt(line.split("","")[1]));
                              matrix[Integer.parseInt(line.split("","")[0]) - 1][Integer.parseInt(line.split("","")[1]) - 1] = -1;
                    }

//            for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
//                      System.out.print((i+1)+"",""+(j+1)+"" inside ""+matrix[i][j]+""     "");   
//                 }
//                 System.out.println("""");
//            }
                    int label = 0;
                    for (int i = 0; i < matrix.length; i++) {
                              for (int j = 0; j < matrix.length; j++) {
                                        if (matrix[i][j] == -1) continue;
                                        else// not block site
                                        {
                                                  if (i == 0) //first row
                                                  {
                                                            if (j == 0) // first col
                                                            {
                                                                      matrix[i][j] = ++label;
                                                            } else if (matrix[i][j - 1] != -1) //left site not block site >> connect
                                                            {
                                                                      matrix[i][j] = matrix[i][j - 1];
                                                            } else {
                                                                      matrix[i][j] = ++label;
                                                            }
                                                  } else //   another row
                                                  {
                                                            if (j == 0) //first col
                                                            {
                                                                      if (matrix[i - 1][j] != -1) // upper row not block site
                                                                      {
                                                                                matrix[i][j] = matrix[i - 1][j];
                                                                      } else {
                                                                                matrix[i][j] = ++label;
                                                                      }
                                                            } else // else col
                                                            {
                                                                      if (matrix[i][j - 1] != -1 && matrix[i - 1][j] == -1) // connext left col
                                                                      {
                                                                                matrix[i][j] = matrix[i][j - 1];
                                                                      }
                                                                      else if (matrix[i - 1][j] != -1 && matrix[i][j - 1] == -1) // connext upper row
                                                                      {
                                                                                matrix[i][j] = matrix[i - 1][j];
                                                                      }
                                                                      else if (matrix[i][j - 1] == -1 && matrix[i - 1][j] == -1) {
                                                                                matrix[i][j] = ++label;
                                                                      }
                                                                      else if (matrix[i][j - 1] != -1 && matrix[i - 1][j] != -1) {
                                                                                if (matrix[i][j - 1] < matrix[i - 1][j]) {
                                                                                          matrix[i][j] = matrix[i][j - 1];
                                                                                } else {
                                                                                          matrix[i][j] = matrix[i - 1][j];
                                                                                }
                                                                      }
                                                            }
                                                  }
                                        }
                              }
                    }
//            System.out.println(label);
                    QuickUnionUF uf = new QuickUnionUF(label + 1);

                    for (int i = 1; i < matrix.length; i++) {
                              for (int j = 1; j < matrix.length; j++) {
                                        if (matrix[i][j] == -1) continue;
                                        else// not block site
                                        {
                                                  if (matrix[i][j - 1] != -1 && matrix[i - 1][j] != -1) {
                                                            if (matrix[i][j - 1] < matrix[i - 1][j]) {
                                                                      uf.union(matrix[i - 1][j], matrix[i][j - 1]);
                                                            } else {
                                                                      uf.union(matrix[i][j - 1], matrix[i - 1][j]);
                                                            }
                                                  }
                                        }
                              }
                    }

//            System.out.println(""check"");
//                        for(int  i =0 ; i<matrix.length;i++)
//            {
//                 for(int  j =0 ; j<matrix.length;j++)
//                 {
////                      System.out.print((i+1)+"",""+(j+1)+"" is ""+matrix[i][j]+""         "");   
//                      if(matrix[i][j] == -1){
//                                System.out.print(""-1   "");
//                      }
//                      else{
//                      System.out.print(matrix[i][j]+""     "");
//                      }
//                      }
//                                      System.out.println("""");
//            }
                    System.out.println(uf.find(matrix[Integer.parseInt(TopRow[1]) - 1][Integer.parseInt(TopRow[2]) - 1]));

          }
}

@78663535d41c4f7ed56aaadd6fafd82c@"
"r04631021","0","1.01","127808","@915ba16a1029105542a7b2ad1f455db3@
import edu.princeton.cs.algs4.UF ;
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
        
/**
 *
 * @author 林康維
 */
public class LabelCC {


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
           File file = new File(args[0]);
           int Drow , Dcol ;
           try{
               Scanner File_in = new Scanner(file) ; 
String num[] = File_in . nextLine() . split("","");
               int Dim = Integer . parseInt (num [0]) ;
               int ansrow = Integer . parseInt (num[1]) ;
               int anscol = Integer . parseInt (num[2]) ;
               boolean[][] matrix = new boolean [Dim][Dim] ;
               UF uf = new UF( Dim*Dim ) ; 
               for ( int i = 0 ; i < Dim ; i++){
                   for(int j = 0 ; j <Dim ; j++){
                   matrix [i][j] = true ;
                   }
               }
               while(File_in.hasNextLine()){
                   String Black = File_in.nextLine() ;
                   String[] mat = Black.split("","") ;
                   Drow = Integer . parseInt (mat[0]) -1 ;
                   Dcol = Integer . parseInt (mat[1]) -1 ;
                   matrix [Drow][Dcol] = false ;
                   /*if(!File_in.hasNextLine())
                       break ;*/
               }
               int [][] A = new int [Dim][Dim];
               int count = 1 ;
               for (int i = 0 ; i < Dim ; i++){
                   for (int j = 0 ; j < Dim ;j ++){
                   A [i][j] = 0 ;
                   }
               }
               if ( matrix [0][0] == true){
                   A [0][0] = 1 ;
                   count += 1 ;
               }
               for ( int i = 1 ; i < Dim ; i++){
                   if (matrix [0][i] == true){
                   if (A[0][i-1] != 0){
                   A[0][i] = A[0][i-1] ; 
                   uf.union(i,i-1);
                   }
                   else if (A[0][i-1]  ==0)  {
                       A [0][i] = count ;
                       count += 1 ;
                   }
               }
               }
               
               for ( int i = 1 ; i < Dim   ; i++){
                   for ( int j =0 ; j < Dim  ; j++){
                       if (j ==0 ){
                           if (matrix [i][j] == true){
                               if (A[i-1][j] != 0) {
                                   A [i][j] = A [i-1][j] ;
uf.union( i * Dim + j , ( i - 1 ) * Dim + j );
                               }
                               else{
                                   A[i][j] = count ;
                                   count += 1 ;
                               }
                           }
                       }
                       else if (j != 0){
                       if ( matrix[i][j] == true ){
                           if( (A [i-1] [j] != 0) && (A [i] [j-1] != 0)){
                               if((A [i-1] [j]) > (A [i] [j-1])){
                               
                                   A [i] [j] = A [i] [j-1] ; 
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);       
                               }
                               else if ((A [i-1] [j]) < (A [i] [j-1])){
                                   
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               else {
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               }
                           else if ( (A [i-1] [j] != 0) && (A [i] [j-1] ==0)){
                               A [i] [j] = A [i-1] [j] ;
                               uf.union( i * Dim + j , (i-1) * Dim + j);
                           }
                           else if ( (A [i-1] [j] == 0) && (A [i] [j-1] !=0)){
                               A [i] [j] = A [i] [j-1] ;
                               uf.union( i * Dim + j , i * Dim + j - 1);
                           }
                           else {
                               A [i] [j] = count ;
                               count += 1 ;
                           }
                           
                           }
                       }
               }
               }
               for(int i = 0 ; i < Dim ; i ++){
                   for(int j = 0 ; j < Dim ;j++){
                       for(int k = i ; k < Dim ; k++){
                           for(int l = 0; l < Dim ; l++){
if ( (uf.connected (i * Dim + j , k * Dim+ l)) && (A[i][j] != A[k][l]) ) {
                               A[k][l] = A[i][j] ;
                               }
                           }
                       }
                   }
               }
               System.out.println (A[ansrow-1][anscol-1]) ;
               /*System.out.println(ansrow) ;
               System.out.println(anscol) ;
               for (int i=0;i<8;i++){
                   //System.out.println(uf.find(i));
                   for(int j =0;j<8;j++){
                       
                   System.out.println(A[i][j]);
                   System.out.println(uf.find(i*Dim+j)) ;
                   System.out.println(matrix[i][j]) ;
                   }
                   System.out.println(""\n"") ;
               }*/
                       }
           catch(IOException e){
            System.out.println(""error!""); 
        }
    }
    
}

@915ba16a1029105542a7b2ad1f455db3@"
"r04631021","9","2.97","176560","@bb87328f0d7951227c9d2ed7505a245e@
import java.io.IOException;
import java.io.*;
import java.util.Scanner;
        
/**
 *
 * @author 林康維
 */
public class LabelCC {


    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
           File file = new File(args[0]);
           int Drow , Dcol ;
           try{
               Scanner File_in = new Scanner(file) ; 
String num[] = File_in . nextLine() . split("","");
               int Dim = Integer . parseInt (num [0]) ;
               int ansrow = Integer . parseInt (num[1]) ;
               int anscol = Integer . parseInt (num[2]) ;
               boolean[][] matrix = new boolean [Dim][Dim] ;
               UF uf = new UF( Dim*Dim ) ; 
               for ( int i = 0 ; i < Dim ; i++){
                   for(int j = 0 ; j <Dim ; j++){
                   matrix [i][j] = true ;
                   }
               }
               while(File_in.hasNextLine()){
                   String Black = File_in.nextLine() ;
                   String[] mat = Black.split("","") ;
                   Drow = Integer . parseInt (mat[0]) -1 ;
                   Dcol = Integer . parseInt (mat[1]) -1 ;
                   matrix [Drow][Dcol] = false ;
                   /*if(!File_in.hasNextLine())
                       break ;*/
               }
               int [][] A = new int [Dim][Dim];
               int count = 1 ;
               for (int i = 0 ; i < Dim ; i++){
                   for (int j = 0 ; j < Dim ;j ++){
                   A [i][j] = 0 ;
                   }
               }
               if ( matrix [0][0] == true){
                   A [0][0] = 1 ;
                   count += 1 ;
               }
               for ( int i = 1 ; i < Dim ; i++){
                   if (matrix [0][i] == true){
                   if (A[0][i-1] != 0){
                   A[0][i] = A[0][i-1] ; 
                   uf.union(i,i-1);
                   }
                   else if (A[0][i-1]  ==0)  {
                       A [0][i] = count ;
                       count += 1 ;
                   }
               }
               }
               
               for ( int i = 1 ; i < Dim   ; i++){
                   for ( int j =0 ; j < Dim  ; j++){
                       if (j ==0 ){
                           if (matrix [i][j] == true){
                               if (A[i-1][j] != 0) {
                                   A [i][j] = A [i-1][j] ;
uf.union( i * Dim + j , ( i - 1 ) * Dim + j );
                               }
                               else{
                                   A[i][j] = count ;
                                   count += 1 ;
                               }
                           }
                       }
                       else if (j != 0){
                       if ( matrix[i][j] == true ){
                           if( (A [i-1] [j] != 0) && (A [i] [j-1] != 0)){
                               if((A [i-1] [j]) > (A [i] [j-1])){
                               
                                   A [i] [j] = A [i] [j-1] ; 
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);       
                               }
                               else if ((A [i-1] [j]) < (A [i] [j-1])){
                                   
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               else {
                                   A [i] [j] = A [i-1] [j] ;
uf.union( i * Dim + j , i * Dim + j - 1);
uf.union( i * Dim + j , (i-1) * Dim + j);
                               }
                               }
                           else if ( (A [i-1] [j] != 0) && (A [i] [j-1] ==0)){
                               A [i] [j] = A [i-1] [j] ;
                               uf.union( i * Dim + j , (i-1) * Dim + j);
                           }
                           else if ( (A [i-1] [j] == 0) && (A [i] [j-1] !=0)){
                               A [i] [j] = A [i] [j-1] ;
                               uf.union( i * Dim + j , i * Dim + j - 1);
                           }
                           else {
                               A [i] [j] = count ;
                               count += 1 ;
                           }
                           
                           }
                       }
               }
               }
               for(int i = 0 ; i < Dim ; i ++){
                   for(int j = 0 ; j < Dim ;j++){
                       for(int k = i ; k < Dim ; k++){
                           for(int l = 0; l < Dim ; l++){
if ( (uf.connected (i * Dim + j , k * Dim+ l)) && (A[i][j] != A[k][l]) ) {
                               A[k][l] = A[i][j] ;
                               }
                           }
                       }
                   }
               }
               System.out.println (A[ansrow-1][anscol-1]) ;
               /*System.out.println(ansrow) ;
               System.out.println(anscol) ;
               for (int i=0;i<8;i++){
                   //System.out.println(uf.find(i));
                   for(int j =0;j<8;j++){
                       
                   System.out.println(A[i][j]);
                   System.out.println(uf.find(i*Dim+j)) ;
                   System.out.println(matrix[i][j]) ;
                   }
                   System.out.println(""\n"") ;
               }*/
                       }
           catch(IOException e){
            System.out.println(""error!""); 
        }
    }
    
}

@bb87328f0d7951227c9d2ed7505a245e@"
"r04631041","10","0.098","129840","@89b3e51154bf6dbb9024f39473a0c88b@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author USER
 */
public class LabelCC {
//--------------------------API QuickUnionUF----------------------------------//
     private static int[] parent;  // parent[i] = parent of i
    private  static int count;     // number of components
    private  static int counter;
    public static void constr(int N) {
        counter=0;
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }
 public static int count() {
        return count;
    }
   public static int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }
   private static void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
      public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ; 
        count--;
    }
//------------------------Self define function--------------------------------//
      public static void first_pass(int[][] m ,int row, int column, int size){
          if (m[row][column]!=0){
           if (m[row-1][column]==0 && m[row][column-1]==0){
             counter++;
             m[row][column]=counter;
           }
           else if(m[row-1][column]!=0 && m[row][column-1]==0){
             m[row][column]=m[row-1][column];
             union((row-1)*size+column-1,(row-2)*size+column-1);
           }
           else if(m[row-1][column]==0 && m[row][column-1]!=0){
             m[row][column]=m[row][column-1];
             union((row-1)*size+column-1,(row-1)*size+column-2); 
           }
           else if (m[row-1][column]!=0 && m[row][column-1]!=0){
               if (m[row-1][column]<m[row][column-1]){
                   m[row][column]=m[row-1][column];
                   union((row-1)*size+column-1,(row-2)*size+column-1);
                   union((row-1)*size+column-2,(row-2)*size+column-1);
               }
               else if(m[row-1][column]>m[row][column-1]){
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
                   union((row-2)*size+column-1,(row-1)*size+column-2);
               }
               else{
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
               }
           }
          }
      }
      public static void second_pass (int[][] m,int row, int column, int size){
          int temp=find((row-1)*size+column-1);
          if (m[row][column]!=m[(temp/size)+1][(temp%size)+1])
          {
                if (m[(temp/size)+1][(temp%size)+1]<m[row][column]){
                m[row][column]=m[(temp/size)+1][(temp%size)+1];
                union((row-1)*size+column-1,temp);
                }
                
           }
      }
      public static void printtt(int row,int column,int size,int[][] m)
      {
      int temp=find((row-1)*size+column-1); 
      System.out.println(m[(temp/size)+1][(temp%size)+1]);
      }
  public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          constr(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
         
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
//--------------------------First pass operation------------------------------//
          for(int i=1 ; i<size+1 ;i++)
              for (int j=1 ; j<size+1 ; j++)
              first_pass(matrix,i,j,size);
//---------------------------Second pass operation----------------------------//         
          for(int i=1 ; i<size+1 ;i++){
              for (int j=1 ; j<size+1 ; j++){
              if (matrix[i][j]!=0)
                  second_pass(matrix,i,j,size);
              }
          }
//          for (int i=0 ; i<size+2 ; i++){
//              for (int j=0 ; j<size+2 ; j++){
//                  System.out.print(matrix[i][j]+""\t"");
//              }
//                  System.out.println("""");
//          }
              printtt(assignrow,assigncolumn,size,matrix);
             
       }
  }
}
@89b3e51154bf6dbb9024f39473a0c88b@"
"r03525008","0","1.24","150048","@9eaf60d1be3361089cc7704b2ae42a87@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * Created by 其昌 on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args){

        try {

            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            String[] firstLine = br.readLine().split("","");
            int num = Integer.parseInt(firstLine[0]);
            int targetX = Integer.parseInt(firstLine[1]) - 1; // index 從0開始所以讀出座標之後要-1
            int targetY = Integer.parseInt(firstLine[2]) - 1;

            int labelCount = 1;
            int[][] labelCC = new int[num][num];

            int[] parents = new int[num*num];
            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = i;
            }

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = -1; // 先把labelCC的值都設成-1不然預設值都會是0
                }
            }

            while (br.ready()){
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]) - 1; // index 從0開始所以讀出座標之後要-1
                int y = Integer.parseInt(coordinate[1]) - 1;
                labelCC[x][y] = 0; // 把檔案讀到座標的label設成0
             }
            br.close();

            // 開始填label
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    if(labelCC[i][j] != 0){
                        // 如果這格的label不是0的話才開始做事情
                        if(i==0 && j==0){
                            // 如果這格是(1,1)的話，label=1
                            labelCC[i][j] = labelCount;
                        } else if(i == 0){
                            // 如果這格是(1,X)的話，只檢查左邊
                            int labelLeft = labelCC[i][j-1];
                            labelCC[i][j] = (labelLeft != 0)? labelLeft : ++labelCount;
                        } else if(j == 0){
                            // 如果這格是(X,1)的話，只檢查上面
                            int labelTop = labelCC[i-1][j];
                            labelCC[i][j] = (labelTop != 0)? labelTop : ++labelCount;
                        } else {
                            // 其他格上面和左邊都要檢查
                            int labelLeft = labelCC[i][j-1];
                            int labelTop = labelCC[i-1][j];
                            if(labelLeft == 0 && labelTop == 0){
                                // 上面和左邊均為0的話，label = 下一組group
                                labelCC[i][j] = ++labelCount;
                            } else if(labelLeft == 0) {
                                // 左邊為0的話，label = 上面的label
                                labelCC[i][j] = labelTop;
                            } else if(labelTop == 0) {
                                // 上面為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                            } else {
                                // 均不為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                                if(labelLeft != labelTop){
                                    // 左邊和上面label不相等的話，建立parent和child的關係
                                    int leftRoot = getRoot(parents , labelLeft);
                                    int topRoot = getRoot(parents , labelTop);
                                    int parentRoot = topRoot < leftRoot? topRoot : leftRoot;
                                    int childRoot = topRoot >= leftRoot? topRoot : leftRoot;
                                    parents[childRoot] = parentRoot;
                                }
                            }
                        }
                    } else if(i==0 && j==0){
                        labelCount--;
                    }
                }
            }


            // 把值改成parents裡面找到的root
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = getRoot(parents , labelCC[i][j]);
                }
            }


//            // 印出parents的對照表
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(i+"" "");
//            }
//            System.out.println("""");
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(parents[i]+"" "");
//            }
//            System.out.println("""");
            // 印出整個labelCC
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    System.out.print(labelCC[i][j]+""\t"");
                }
                System.out.println("""");
            }

            // 印出target的label
            System.out.println(labelCC[targetX][targetY]);

        } catch (IOException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }


    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }




}

@9eaf60d1be3361089cc7704b2ae42a87@"
"r03525008","9","0.99","123488","@affc7f0067b3b0158948a83f94be8f92@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * Created by 其昌 on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args){

        try {

            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            String[] firstLine = br.readLine().split("","");
            int num = Integer.parseInt(firstLine[0]);
            int targetX = Integer.parseInt(firstLine[1]) - 1; // index 從0開始所以讀出座標之後要-1
            int targetY = Integer.parseInt(firstLine[2]) - 1;

            int labelCount = 1;
            int[][] labelCC = new int[num][num];

            int[] parents = new int[num*num];
            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = i;
            }

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = -1; // 先把labelCC的值都設成-1不然預設值都會是0
                }
            }

            while (br.ready()){
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]) - 1; // index 從0開始所以讀出座標之後要-1
                int y = Integer.parseInt(coordinate[1]) - 1;
                labelCC[x][y] = 0; // 把檔案讀到座標的label設成0
             }
            br.close();

            // 開始填label
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    if(labelCC[i][j] != 0){
                        // 如果這格的label不是0的話才開始做事情
                        if(i==0 && j==0){
                            // 如果這格是(1,1)的話，label=1
                            labelCC[i][j] = labelCount;
                        } else if(i == 0){
                            // 如果這格是(1,X)的話，只檢查左邊
                            int labelLeft = labelCC[i][j-1];
                            labelCC[i][j] = (labelLeft != 0)? labelLeft : ++labelCount;
                        } else if(j == 0){
                            // 如果這格是(X,1)的話，只檢查上面
                            int labelTop = labelCC[i-1][j];
                            labelCC[i][j] = (labelTop != 0)? labelTop : ++labelCount;
                        } else {
                            // 其他格上面和左邊都要檢查
                            int labelLeft = labelCC[i][j-1];
                            int labelTop = labelCC[i-1][j];
                            if(labelLeft == 0 && labelTop == 0){
                                // 上面和左邊均為0的話，label = 下一組group
                                labelCC[i][j] = ++labelCount;
                            } else if(labelLeft == 0) {
                                // 左邊為0的話，label = 上面的label
                                labelCC[i][j] = labelTop;
                            } else if(labelTop == 0) {
                                // 上面為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                            } else {
                                // 均不為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                                if(labelLeft != labelTop){
                                    // 左邊和上面label不相等的話，建立parent和child的關係
                                    int leftRoot = getRoot(parents , labelLeft);
                                    int topRoot = getRoot(parents , labelTop);
                                    int parentRoot = topRoot < leftRoot? topRoot : leftRoot;
                                    int childRoot = topRoot >= leftRoot? topRoot : leftRoot;
                                    parents[childRoot] = parentRoot;
                                }
                            }
                        }
                    } else if(i==0 && j==0){
                        labelCount--;
                    }
                }
            }


            // 把值改成parents裡面找到的root
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = getRoot(parents , labelCC[i][j]);
                }
            }


//            // 印出parents的對照表
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(i+"" "");
//            }
//            System.out.println("""");
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(parents[i]+"" "");
//            }
//            System.out.println("""");
//            // 印出整個labelCC
//            for(int i = 0 ; i < num ; i++){
//                for(int j = 0 ; j < num ; j++){
//                    System.out.print(labelCC[i][j]+""\t"");
//                }
//                System.out.println("""");
//            }

            // 印出target的label
            System.out.println(labelCC[targetX][targetY]);

        } catch (IOException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }


    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }




}

@affc7f0067b3b0158948a83f94be8f92@"
"b01b01039","9","1.01","128048","@5d04cee21f4fbaad4cc38d268e532806@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	/*
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	*/
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = node[row][col] & b;
	}
	/*
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	*/
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}
	
	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            long time1, time2, time3, time4;
			//time1 = System.nanoTime();
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			
			Stack<Integer> st = new Stack<Integer>();
			//Stack<Integer> up_st = new Stack<Integer>();
			//Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			//time2 = System.nanoTime();
			//int CC_N = 0;
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								st.push(lcc.up_label(row,col));
								st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.label_print();
			//time3 = System.nanoTime();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(st.size() != 0){
				int up = st.pop();
				int left = st.pop();
				//System.out.println(up + "" "" + left);
				if(!uf_l.connected(up, left)){
					uf_l.label_change(up, left);
					uf_l.union(up, left);
					//uf_l.print_lable();
					//uf_l.print_root();
				}
			}
			//System.out.println();
			//uf_l.print_lable();
			//uf_l.print_root();
			
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
			/*time4 = System.nanoTime();
			System.out.println(""=========== Time Cost ==========="");
			System.out.println(time2 - time1);
			System.out.println(time3 - time2);
			System.out.println(time4 - time3);*/
		}
	}	
}

class uf_label extends UF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		int p_l = label[find(p)];
		int q_l = label[find(q)];
		//System.out.println(p_l + "" "" + q_l);
		if(p_l > q_l){
			label[find(p)] = q_l;
		}else{
			label[find(q)] = p_l;
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[find(N)];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
	
	public void print_root(){
		for(int id = 0; id < label.length; id++){
			System.out.printf(""%d "", find(id));
		}
		System.out.printf(""\n"");
	}
}
@5d04cee21f4fbaad4cc38d268e532806@"
"r03525008","9","0.95","125312","@ab2ad918a47c167a956c32cc2799ca16@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * Created by 其昌 on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args){

        try {

            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            String[] firstLine = br.readLine().split("","");
            int num = Integer.parseInt(firstLine[0]);
            int targetX = Integer.parseInt(firstLine[1]) - 1; // index 從0開始所以讀出座標之後要-1
            int targetY = Integer.parseInt(firstLine[2]) - 1;

            int labelCount = 1;
            int[][] labelCC = new int[num][num];

            int[] parents = new int[num*num];
            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = i;
            }

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = -1; // 先把labelCC的值都設成-1不然預設值都會是0
                }
            }

            while (br.ready()){
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]) - 1; // index 從0開始所以讀出座標之後要-1
                int y = Integer.parseInt(coordinate[1]) - 1;
                labelCC[x][y] = 0; // 把檔案讀到座標的label設成0
             }
            br.close();

            // 開始填label
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    if(labelCC[i][j] != 0){
                        // 如果這格的label不是0的話才開始做事情
                        if(i==0 && j==0){
                            // 如果這格是(1,1)的話，label=1
                            labelCC[i][j] = labelCount;
                        } else if(i == 0){
                            // 如果這格是(1,X)的話，只檢查左邊
                            int labelLeft = labelCC[i][j-1];
                            labelCC[i][j] = (labelLeft != 0)? labelLeft : ++labelCount;
                        } else if(j == 0){
                            // 如果這格是(X,1)的話，只檢查上面
                            int labelTop = labelCC[i-1][j];
                            labelCC[i][j] = (labelTop != 0)? labelTop : ++labelCount;
                        } else {
                            // 其他格上面和左邊都要檢查
                            int labelLeft = labelCC[i][j-1];
                            int labelTop = labelCC[i-1][j];
                            if(labelLeft == 0 && labelTop == 0){
                                // 上面和左邊均為0的話，label = 下一組group
                                labelCC[i][j] = ++labelCount;
                            } else if(labelLeft == 0) {
                                // 左邊為0的話，label = 上面的label
                                labelCC[i][j] = labelTop;
                            } else if(labelTop == 0) {
                                // 上面為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                            } else {
                                // 均不為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                                if(labelLeft != labelTop){
                                    // 左邊和上面label不相等的話，建立parent和child的關係
                                    int leftRoot = getRoot(parents , labelLeft);
                                    int topRoot = getRoot(parents , labelTop);
                                    int parentRoot = topRoot < leftRoot? topRoot : leftRoot;
                                    int childRoot = topRoot >= leftRoot? topRoot : leftRoot;
                                    parents[childRoot] = parentRoot;
                                }
                            }
                        }
                    } else {
                        if(i==0 && j==0){
                            labelCount--;
                        }
                    }
                }
            }


            // 把值改成parents裡面找到的root
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = getRoot(parents , labelCC[i][j]);
                }
            }


//            // 印出parents的對照表
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(i+"" "");
//            }
//            System.out.println("""");
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(parents[i]+"" "");
//            }
//            System.out.println("""");
//            // 印出整個labelCC
//            for(int i = 0 ; i < num ; i++){
//                for(int j = 0 ; j < num ; j++){
//                    System.out.print(labelCC[i][j]+""\t"");
//                }
//                System.out.println("""");
//            }

            // 印出target的label
            System.out.println(labelCC[targetX][targetY]);

        } catch (IOException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }


    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }




}

@ab2ad918a47c167a956c32cc2799ca16@"
"b01b01039","9","1.02","125920","@2433cfd8fee60d5d6b053ba3a40eb72e@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	/*
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	*/
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = node[row][col] & b;
	}
	/*
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	*/
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}
	
	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            long time1, time2, time3, time4;
			//time1 = System.nanoTime();
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			
			Stack<Integer> st = new Stack<Integer>();
			//Stack<Integer> up_st = new Stack<Integer>();
			//Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			//time2 = System.nanoTime();
			//int CC_N = 0;
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								st.push(lcc.up_label(row,col));
								st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.label_print();
			//time3 = System.nanoTime();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(st.size() != 0){
				int up = st.pop();
				int left = st.pop();
				//System.out.println(up + "" "" + left);
				if(!uf_l.connected(up, left)){
					uf_l.label_change(up, left);
					uf_l.union(up, left);
					//uf_l.print_lable();
					//uf_l.print_root();
				}
			}
			//System.out.println();
			//uf_l.print_lable();
			//uf_l.print_root();
			
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
			/*time4 = System.nanoTime();
			System.out.println(""=========== Time Cost ==========="");
			System.out.println(time2 - time1);
			System.out.println(time3 - time2);
			System.out.println(time4 - time3);*/
		}
	}	
}

class uf_label extends UF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		int p_l = label[find(p)];
		int q_l = label[find(q)];
		//System.out.println(p_l + "" "" + q_l);
		if(p_l > q_l){
			label[find(p)] = q_l;
			label[p] = q_l;
			label[q] = q_l;
		}else{
			label[find(q)] = p_l;
			label[p] = p_l;
			label[q] = p_l;
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[find(N)];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
	
	public void print_root(){
		for(int id = 0; id < label.length; id++){
			System.out.printf(""%d "", find(id));
		}
		System.out.printf(""\n"");
	}
}
@2433cfd8fee60d5d6b053ba3a40eb72e@"
"r04631004","9","1","147920","@890916f5b969b66b6838684a9f432566@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            //                                          System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            //                                        System.out.println(storeunionpoint.biglabel[i][j]+"" ""+storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                // WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF((num * num) / 2 + 1);
                //UF ufstruct = new UF((num * num) / 2 + 1);
                //QuickFindUF ufstruct = new QuickFindUF((num * num) / 2 + 1);
                QuickUnionUF ufstruct = new QuickUnionUF((num * num) / 2 + 1);

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) {
                            if (ufstruct.find(storeunionpoint.biglabel[i][j]) > ufstruct.find(storeunionpoint.smalllabel[i][j])) {
                                ufstruct.union(ufstruct.find(storeunionpoint.biglabel[i][j]), ufstruct.find(storeunionpoint.smalllabel[i][j]));
                            } else {
                                ufstruct.union(ufstruct.find(storeunionpoint.smalllabel[i][j]), ufstruct.find(storeunionpoint.biglabel[i][j]));
                            }
                        }
                    }
                }
                int[] unionarray = new int[(num * num) / 2 + 1];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
//                    if(i>0)
//                        System.out.println(i+"" = ""+ufstruct.find(i));
                }

//                for (i = 1; i < unionarray.length; i++) {
//                    for (j = i + 1; j < unionarray.length; j++) {
//                        if (ufstruct.connected(i, j) == true) {
//                            if (unionarray[j] > unionarray[i]) {
//                                unionarray[j] = unionarray[i];
//                            } else if (unionarray[j] < unionarray[i]) {
//                                for (k = 1; k <= i; k++) {
//                                    if (unionarray[k] == unionarray[i]) {
//                                        unionarray[k] = unionarray[j];
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }
//                for (k = 1; k < unionarray.length; k++) {
//                    for (i = 0; i < num; i++) {
//                        for (j = 0; j < num; j++) {
//
//                            if (label[i][j] == k && unionarray[k] != k) {
//                                label[i][j] = unionarray[k];
//                            }
//                        }
//                    }
//                }
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(ufstruct.find(label[targetcoord[0] - 1][targetcoord[1] - 1]));

            }
        }
    }

}
@890916f5b969b66b6838684a9f432566@"
"r04631004","10","0.102","142672","@8edd92535f900d4a0fbe02a0e39e2f38@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;

/**
 *
 * @author Po-Lin
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {

        // read file from args[0] in Java 7 style
        try (BufferedReader labelcc_file = new BufferedReader(new FileReader(args[0]))) {

            BufferedReader temp = new BufferedReader(new FileReader(args[0]));
            // read a line and split by ','
            String[] data;
            if (temp.readLine() != null) {

                data = labelcc_file.readLine().split("","");

                int num = Integer.parseInt(data[0]); //num of grid
                int[] targetcoord = new int[2];
                targetcoord[0] = Integer.parseInt(data[1]); //store row of target coord
                targetcoord[1] = Integer.parseInt(data[2]); //store col of target coord

                //System.out.println(""Target :"" + targetcoord[0] + "" "" + targetcoord[1]);
                int[][] grid = new int[num][num];  //create num*num grid
                int[] input_coord = new int[2];
                while (temp.readLine() != null) //add coord to grid
                {
                    data = labelcc_file.readLine().split("","");
                    input_coord[0] = Integer.parseInt(data[0]) - 1;
                    input_coord[1] = Integer.parseInt(data[1]) - 1;
                    grid[input_coord[0]][input_coord[1]] = 1;
                }
                int i, j, k;

                int[][] label = new int[num][num];  //create a array to store label
                int labelnum = 1;
                int tempcheck = 0;
                int newnumcheck = 0;

                class UP {

                    int[][] smalllabel;
                    int[][] biglabel;
                    int[][] checknum;

                    public UP(int a, int b) {
                        smalllabel = new int[a][b];
                        biglabel = new int[a][b];
                        checknum = new int[a][b];
                        for (int i = 0; i < a; i++) {
                            for (int j = 0; j < b; j++) {
                                smalllabel[i][j] = 0;
                                biglabel[i][j] = 0;
                                checknum[i][j] = 0;
                            }
                        }
                    }

                }

                UP storeunionpoint = new UP(num, num);
                int count = 0;

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (grid[i][j] == 0) {
                            if (j - 1 >= 0 && j - 1 < num - 1) //check left point
                            {
                                if (grid[i][j - 1] == 0) {
                                    label[i][j] = label[i][j - 1];
                                    tempcheck = 1;
                                    newnumcheck = 1;
                                }
                            }

                            if (i - 1 >= 0 && i - 1 < num - 1) //check top point
                            {
                                if (grid[i - 1][j] == 0) {
                                    if (tempcheck == 1) //if left point is also connected
                                    {
                                        if (label[i][j] > label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i][j];
                                            storeunionpoint.smalllabel[i][j] = label[i - 1][j];
                                            label[i][j] = label[i - 1][j];
                                            //System.out.println(storeunionpoint.biglabel[i][j] + "" "" + storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        } else if (label[i][j] < label[i - 1][j]) {
                                            storeunionpoint.checknum[i][j] = 1;
                                            storeunionpoint.biglabel[i][j] = label[i - 1][j];
                                            storeunionpoint.smalllabel[i][j] = label[i][j];
                                            //System.out.println(storeunionpoint.biglabel[i][j] + "" "" + storeunionpoint.smalllabel[i][j]);
                                            newnumcheck = 1;
                                            count++;
                                        }
                                    } else {
                                        label[i][j] = label[i - 1][j];
                                        newnumcheck = 1;
                                    }
                                }
                            }
                            if (newnumcheck == 0) {
                                label[i][j] = labelnum;
                                labelnum++;
                            }
                        } else {
                            label[i][j] = 0;
                        }
                        tempcheck = 0;
                        newnumcheck = 0;
                    }
                }

//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                // WeightedQuickUnionUF ufstruct = new WeightedQuickUnionUF((num * num) / 2 + 1);
                //UF ufstruct = new UF((num * num) / 2 + 1);
                //QuickFindUF ufstruct = new QuickFindUF((num * num) / 2 + 1);
                QuickUnionUF ufstruct = new QuickUnionUF((num * num) / 2 + 1);

                for (i = 0; i < num; i++) {
                    for (j = 0; j < num; j++) {
                        if (storeunionpoint.checknum[i][j] == 1) 
                            //if (storeunionpoint.biglabel[i][j] > storeunionpoint.smalllabel[i][j]) {
                                ufstruct.union(storeunionpoint.biglabel[i][j], storeunionpoint.smalllabel[i][j]);
                            //} else {
                              //  ufstruct.union(storeunionpoint.smalllabel[i][j], storeunionpoint.biglabel[i][j]);
                            //}
                        }
                    }
                
                int[] unionarray = new int[(num * num) / 2 + 1];
                for (i = 0; i < unionarray.length; i++) {
                    unionarray[i] = i;
//                    if(i>0)
//                        System.out.println(i+"" = ""+ufstruct.find(i));
                }

//                for (i = 1; i < unionarray.length; i++) {
//                    for (j = i + 1; j < unionarray.length; j++) {
//                        if (ufstruct.connected(i, j) == true) {
//                            if (unionarray[j] > unionarray[i]) {
//                                unionarray[j] = unionarray[i];
//                            } else if (unionarray[j] < unionarray[i]) {
//                                for (k = 1; k <= i; k++) {
//                                    if (unionarray[k] == unionarray[i]) {
//                                        unionarray[k] = unionarray[j];
//                                    }
//                                }
//                            }
//                        }
//                    }
//                }
//                for (k = 1; k < unionarray.length; k++) {
//                    for (i = 0; i < num; i++) {
//                        for (j = 0; j < num; j++) {
//
//                            if (label[i][j] == k && unionarray[k] != k) {
//                                label[i][j] = unionarray[k];
//                            }
//                        }
//                    }
//                }
//                for (i = 0; i < num; i++) {  //output first label
//                    for (j = 0; j < num; j++) {
//                        if (j == num - 1) {
//                            if (i == num - 1) {
//                                System.out.println(label[i][j]);
//                                System.out.println("""");
//                            } else {
//                                System.out.println(label[i][j]);
//                            }
//                        } else {
//                            System.out.print(label[i][j] + "" "");
//                        }
//                    }
//                }
                System.out.println(ufstruct.find(label[targetcoord[0] - 1][targetcoord[1] - 1]));

            }
        }
    }

}

@8edd92535f900d4a0fbe02a0e39e2f38@"
"r04945039","10","0.099","129632","@3448a82cb500a433a21e9f6d0a34ab67@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;


public class LabelCC {
	
	public static int[][] matrix;
	//public static int[][] idarray;
	public static int size;
	public QuickUnionUF qf;
                //public QuickFindUF QF;
	public static int id=1;
                

	public LabelCC (int n){
		size=n;
		matrix = new int[size][size];
		//idarray = new int[size][size];  
		for(int row[]: matrix)
			Arrays.fill(row, 1);
		qf = new QuickUnionUF(size*size);                              
                                
	}


	public void Blocked(int x,int y) {
		matrix [x-1][y-1]=0;
	}

	public boolean isOpen(int x,int y){
		return matrix[x-1][y-1]!=0;
	}

	private int setID (int i, int j){
		return id;
	}

	public void targetid (int i, int j) {
            int tar =matrix[i-1][j-1];
		if (tar==0){
			System.out.println(0);
		}
                else{
                    int ans=matrix[i-1][j-1];
		System.out.println(qf.find(ans));   
                
                }
	}


    public void getIndex(int x, int y){
	if(isOpen(x,y)!=false){
        if ( x==1 && isOpen(x,y-1)!=true || y==1 && isOpen(x-1,y)!=true || x!=1 && y!=1 && isOpen(x-1,y)!=true && isOpen(x,y-1)!=true){
	id++;
            matrix[x-1][y-1]=setID(x,y);
		
	}
	else {
		if (y==1 && isOpen(x-1,y)==true || x!=1 &&y!=1 && isOpen(x-1,y)==true && isOpen(x,y-1)!=true){
			matrix[x-1][y-1]=(matrix[x-2][y-1]);
		}
		else{
			if (x==1 && isOpen(x,y-1)==true || x!=1 && y!=1 && isOpen(x,y-1)==true && isOpen(x-1,y)!=true) {
				matrix[x-1][y-1]=matrix[x-1][y-2];
			}
			else{

				int a =Math.max((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				int b =Math.min((matrix[x-2][y-1]),(matrix[x-1][y-2]));
				matrix[x-1][y-1]=b;
				qf.union(a,b);
			}
		}
	} 
}
        else
            matrix[x-1][y-1]=0;
    }
        

        public boolean initiation(){
            int ini =matrix[0][0];
            return ini==0;
        }
        
        
        public static void main(String[] args) throws Exception {
            try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] hintline=br.readLine().split("","");
            int input = Integer.parseInt(hintline[0]);
            int i = Integer.parseInt(hintline[1]);
            int j= Integer.parseInt(hintline[2]);
            LabelCC test = new LabelCC(input);
            

         for(String line;(line = br.readLine())!=(null); ){
                    
                    String[] coordinate=line.split("","");
                    int x = Integer.parseInt(coordinate[0]);        
                    int y = Integer.parseInt(coordinate[1]);
                    test.Blocked(x, y);
                    
            }
         
         for (int m=1;m<=size;m++){
                      for (int n=1;n<=size;n++){
                          
                          if (m==1&& n==1 &&test.initiation()==false){
                              matrix[0][0]=1;
                              continue;
                          }
                          else
                              if(m==1&&n==1&&test.initiation()==true){
                                  id=id-1;
                              }
                              //System.out.println(m+"",""+n);
                            else
                                  test.getIndex(m, n);
                          
                         
                      }
         }
            
           
          test.targetid(i, j);
            
           
            }
    }
	
}
@3448a82cb500a433a21e9f6d0a34ab67@"
"r03525008","9","0.97","123872","@6bc180f3574f10126ff8dc33b67363fc@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * Created by 其昌 on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args){

        try {

            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            String[] firstLine = br.readLine().split("","");
            int num = Integer.parseInt(firstLine[0]);
            int targetX = Integer.parseInt(firstLine[1]) - 1; // index 從0開始所以讀出座標之後要-1
            int targetY = Integer.parseInt(firstLine[2]) - 1;

            int labelCount = 1;
            int[][] labelCC = new int[num][num];

            int[] parents = new int[num*num];
            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = i;
            }

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = -1; // 先把labelCC的值都設成-1不然預設值都會是0
                }
            }

            while (br.ready()){
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]) - 1; // index 從0開始所以讀出座標之後要-1
                int y = Integer.parseInt(coordinate[1]) - 1;
                labelCC[x][y] = 0; // 把檔案讀到座標的label設成0
             }
            br.close();

            // 開始填label
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    if(labelCC[i][j] != 0){
                        // 如果這格的label不是0的話才開始做事情
                        if(i==0 && j==0){
                            // 如果這格是(1,1)的話，label=1
                            labelCC[i][j] = labelCount;
                        } else if(i == 0){
                            // 如果這格是(1,X)的話，只檢查左邊
                            int labelLeft = labelCC[i][j-1];
                            labelCC[i][j] = (labelLeft != 0)? labelLeft : ++labelCount;
                        } else if(j == 0){
                            // 如果這格是(X,1)的話，只檢查上面
                            int labelTop = labelCC[i-1][j];
                            labelCC[i][j] = (labelTop != 0)? labelTop : ++labelCount;
                        } else {
                            // 其他格上面和左邊都要檢查
                            int labelLeft = labelCC[i][j-1];
                            int labelTop = labelCC[i-1][j];
                            if(labelLeft == 0 && labelTop == 0){
                                // 上面和左邊均為0的話，label = 下一組group
                                labelCC[i][j] = ++labelCount;
                            } else if(labelLeft == 0) {
                                // 左邊為0的話，label = 上面的label
                                labelCC[i][j] = labelTop;
                            } else if(labelTop == 0) {
                                // 上面為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                            } else {
                                // 均不為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                                if(labelLeft != labelTop){
                                    // 左邊和上面label不相等的話，建立parent和child的關係
                                    int leftRoot = getRoot(parents , labelLeft);
                                    int topRoot = getRoot(parents , labelTop);
                                    int parentRoot = topRoot < leftRoot? topRoot : leftRoot;
                                    int childRoot = topRoot >= leftRoot? topRoot : leftRoot;
                                    parents[childRoot] = parentRoot;
                                }
                            }
                        }
                    } else {
                        if(i==0 && j==0){
                            labelCount--;
                        }
                    }
                }
            }


            // 把值改成parents裡面找到的root
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = getRoot(parents , labelCC[i][j]);
                }
            }

//            // 印出parents的對照表
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(i+"" "");
//            }
//            System.out.println("""");
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(parents[i]+"" "");
//            }
//            System.out.println("""");
//            // 印出整個labelCC
//            for(int i = 0 ; i < num ; i++){
//                for(int j = 0 ; j < num ; j++){
//                    System.out.print(labelCC[i][j]+""\t"");
//                }
//                System.out.println("""");
//            }

            // 印出target的label
            System.out.println(labelCC[targetX][targetY]);

        } catch (IOException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }


    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }




}

@6bc180f3574f10126ff8dc33b67363fc@"
"r03525008","9","0.98","124192","@3b27b9d204562279109c6a2861d97e98@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * Created by 其昌 on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args){

        try {

            BufferedReader br = new BufferedReader(new FileReader(args[0]));
            String[] firstLine = br.readLine().split("","");
            int num = Integer.parseInt(firstLine[0]);
            int targetX = Integer.parseInt(firstLine[1]) - 1; // index 從0開始所以讀出座標之後要-1
            int targetY = Integer.parseInt(firstLine[2]) - 1;

            int labelCount = 0;
            int[][] labelCC = new int[num][num];

            int[] parents = new int[num*num];
            for(int i = 0 ; i < parents.length ; i++){
                parents[i] = i;
            }

            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = -1; // 先把labelCC的值都設成-1不然預設值都會是0
                }
            }

            while (br.ready()){
                String[] coordinate = br.readLine().split("","");
                int x = Integer.parseInt(coordinate[0]) - 1; // index 從0開始所以讀出座標之後要-1
                int y = Integer.parseInt(coordinate[1]) - 1;
                labelCC[x][y] = 0; // 把檔案讀到座標的label設成0
             }
            br.close();

            // 開始填label
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    if(labelCC[i][j] != 0){
                        // 如果這格的label不是0的話才開始做事情
                        if(i==0 && j==0){
                            // 如果這格是(1,1)的話，label=1
                            labelCC[i][j] = ++labelCount;
                        } else if(i == 0){
                            // 如果這格是(1,X)的話，只檢查左邊
                            int labelLeft = labelCC[i][j-1];
                            labelCC[i][j] = (labelLeft != 0)? labelLeft : ++labelCount;
                        } else if(j == 0){
                            // 如果這格是(X,1)的話，只檢查上面
                            int labelTop = labelCC[i-1][j];
                            labelCC[i][j] = (labelTop != 0)? labelTop : ++labelCount;
                        } else {
                            // 其他格上面和左邊都要檢查
                            int labelLeft = labelCC[i][j-1];
                            int labelTop = labelCC[i-1][j];
                            if(labelLeft == 0 && labelTop == 0){
                                // 上面和左邊均為0的話，label = 下一組group
                                labelCC[i][j] = ++labelCount;
                            } else if(labelLeft == 0) {
                                // 左邊為0的話，label = 上面的label
                                labelCC[i][j] = labelTop;
                            } else if(labelTop == 0) {
                                // 上面為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                            } else {
                                // 均不為0的話，label = 左邊的label
                                labelCC[i][j] = labelLeft;
                                if(labelLeft != labelTop){
                                    // 左邊和上面label不相等的話，建立parent和child的關係
                                    int leftRoot = getRoot(parents , labelLeft);
                                    int topRoot = getRoot(parents , labelTop);
                                    int parentRoot = topRoot < leftRoot? topRoot : leftRoot;
                                    int childRoot = topRoot >= leftRoot? topRoot : leftRoot;
                                    parents[childRoot] = parentRoot;
                                }
                            }
                        }
                    }
                }
            }

            // 把值改成parents裡面找到的root
            for(int i = 0 ; i < num ; i++){
                for(int j = 0 ; j < num ; j++){
                    labelCC[i][j] = getRoot(parents , labelCC[i][j]);
                }
            }

//            // 印出parents的對照表
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(i+"" "");
//            }
//            System.out.println("""");
//            for(int i = 0 ; i < 10 ; i++){
//                System.out.print(parents[i]+"" "");
//            }
//            System.out.println("""");
//            // 印出整個labelCC
//            for(int i = 0 ; i < num ; i++){
//                for(int j = 0 ; j < num ; j++){
//                    System.out.print(labelCC[i][j]+""\t"");
//                }
//                System.out.println("""");
//            }

            // 印出target的label
            System.out.println(labelCC[targetX][targetY]);

        } catch (IOException e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }


    public static int getRoot(int[] parents , int index){
        while(parents[index]!=index)
            index = parents[index];
        return index;
    }




}

@3b27b9d204562279109c6a2861d97e98@"
"r04631026","6","1.07","132304","@436f057629f3ebcf41672f982b33c9d4@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] Initial = br.readLine().split("","");
            //Set the matrix size
            int Num = Integer.parseInt(Initial[0]);
            //Target point
//            int X = Integer.parseInt(Initial[1]);
//            int Y = Integer.parseInt(Initial[2]);
            int[][] matrix = new int[Num][Num];
            int AreaNum = 1;
            for (int i=0;i<Num;i++){
                for (int j=0;j<Num;j++){
                    matrix[i][j] = 1;
                }
            }
            while (br.ready()){
                String[] Position = br.readLine().split("","");
                matrix[Integer.parseInt(Position[0])-1][Integer.parseInt(Position[1])-1]=0;
            }
            //Set first row
            for (int i=0;i<Num;i++){
                if (matrix[0][i]==0){
                    AreaNum++;
                    continue;
                }
                else {
                    matrix[0][i]= AreaNum;
                }
            }
//            System.out.println(AreaNum);
            boolean CheckStat = false;
            
//            System.out.println(AreaNum);
            for (int i=1;i<Num;i++){
                for (int j=0;j<Num;j++){
                    if (matrix[i][j]==0){continue;}
                    //Set first column
                    if (j==0){
                        if (matrix[i-1][j]!=0){
                            matrix[i][j] = matrix[i-1][j];
                            CheckStat = false;
                        }
                        else{
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                            CheckStat = true;
                        }
                    }
                    else{
                        //Check left
                        if (matrix[i][j-1]==0 && matrix[i-1][j]==0){
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]!=0){
                            //Top is smaller
                            if (matrix[i][j-1]>matrix[i-1][j]){
                                matrix[i][j]=matrix[i-1][j];
                            }
                            //Left is smaller
                            else{
                                matrix[i][j]=matrix[i][j-1];
                            }
                        }
                        else if(matrix[i][j-1]==0 && matrix[i-1][j]!=0){
                            matrix[i][j]=matrix[i-1][j];                           
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]==0){
                            matrix[i][j]=matrix[i][j-1];
                        }
                        else{
                            if (CheckStat){
                                AreaNum++;
                                matrix[i][j]=AreaNum;
                                CheckStat = true;
                            }
                            else{
                                matrix[i][j]=AreaNum;
                            }
                        }
                    }
                }
            }
            
            //Print all value in matrix
            for (int i=1;i<Num;i++){
                for (int j=1;j<Num;j++){
                    if (matrix[i-1][j]!=0 && matrix[i][j]!=0){                        
                        if (matrix[i-1][j]!=matrix[i][j] && matrix[i-1][j]>matrix[i][j]){
                            for (int a=0;a<Num;a++){
                                for (int b=0;b<Num;b++){
                                    if (matrix[a][b]==matrix[i-1][j]){
                                        matrix[a][b]=matrix[i][j];
                                    }                                   
                                }
                            }
                        }
                    }
                    if (matrix[i][j-1]!=0 && matrix[i][j]!=0){
                        if (matrix[i][j-1]!=matrix[i][j] && matrix[i][j-1]>matrix[i][j]){
                            for (int a=0;a<Num;a++){
                                for (int b=0;b<Num;b++){
                                    if (matrix[a][b]==matrix[i][j-1]){
                                        matrix[a][b]=matrix[i][j];
                                    }
                                    else {continue;}
                                }
                            }
                        }
                    }
//                    System.out.print(matrix[i][j]);
                }
            }
            for (int i=0;i<Num;i++){
                for (int j=0;j<Num;j++){
//                    System.out.print(matrix[i][j]);
                }
            }
//            System.out.println("""");
            System.out.println(matrix[Integer.parseInt(Initial[1])-1][Integer.parseInt(Initial[2])-1]);
        }        
    }
}
@436f057629f3ebcf41672f982b33c9d4@"
"r04631026","6","1.14","139744","@7e66e57635b8f6257857a29de438627b@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] Initial = br.readLine().split("","");
            //Set the matrix size
            int Num = Integer.parseInt(Initial[0]);
            //Target point
//            int X = Integer.parseInt(Initial[1]);
//            int Y = Integer.parseInt(Initial[2]);
            int[][] matrix = new int[Num][Num];
            int AreaNum = 1;
            for (int i=0;i<Num;i++){
                for (int j=0;j<Num;j++){
                    matrix[i][j] = 1;
                }
            }
            while (br.ready()){
                String[] Position = br.readLine().split("","");
                matrix[Integer.parseInt(Position[0])-1][Integer.parseInt(Position[1])-1]=0;
            }
            //Set first row
            for (int i=0;i<Num;i++){
                if (matrix[0][i]==0){
                    AreaNum++;
//                    continue;
                }
                else {
                    matrix[0][i]= AreaNum;
                }
            }
            boolean CheckStat = false;
            for (int i=1;i<Num;i++){
                for (int j=0;j<Num;j++){
                    if (matrix[i][j]==0){continue;}
                    //Set first column
                    if (j==0){
                        if (matrix[i-1][j]!=0){
                            matrix[i][j] = matrix[i-1][j];
                            CheckStat = false;
                        }
                        else{
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                            CheckStat = true;
                        }
                    }
                    else{
                        //Check left
                        if (matrix[i][j-1]==0 && matrix[i-1][j]==0){
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]!=0){
                            //Top is smaller
                            if (matrix[i][j-1]>matrix[i-1][j]){
                                matrix[i][j]=matrix[i-1][j];
                            }
                            //Left is smaller
                            else{
                                matrix[i][j]=matrix[i][j-1];
                            }
                        }
                        else if(matrix[i][j-1]==0 && matrix[i-1][j]!=0){
                            matrix[i][j]=matrix[i-1][j];                           
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]==0){
                            matrix[i][j]=matrix[i][j-1];
                        }
                        else{
                            if (CheckStat){
                                AreaNum++;
                                matrix[i][j]=AreaNum;
                                CheckStat = true;
                            }
                            else{
                                matrix[i][j]=AreaNum;
                            }
                        }
                    }
                }
            }           
            //Print all value in matrix
            for (int i=1;i<Num;i++){
                for (int j=1;j<Num;j++){
                    if (matrix[i-1][j]!=0 && matrix[i][j]!=0){                        
                        if (matrix[i-1][j]!=matrix[i][j] && matrix[i-1][j]>matrix[i][j]){
                            for (int a=0;a<Num;a++){
                                for (int b=0;b<Num;b++){
                                    if (matrix[a][b]==matrix[i-1][j]){
                                        matrix[a][b]=matrix[i][j];
                                    }                                   
                                }
                            }
                        }
                    }
                    if (matrix[i][j-1]!=0 && matrix[i][j]!=0){
                        if (matrix[i][j-1]!=matrix[i][j] && matrix[i][j-1]>matrix[i][j]){
                            for (int a=0;a<Num;a++){
                                for (int b=0;b<Num;b++){
                                    if (matrix[a][b]==matrix[i][j-1]){
                                        matrix[a][b]=matrix[i][j];
                                    }
                                }
                            }
                        }
                    }
//                    System.out.print(matrix[i][j]);
                }
            }
//            System.out.println("""");
            System.out.println(matrix[Integer.parseInt(Initial[1])-1][Integer.parseInt(Initial[2])-1]);
        }        
    }
}
@7e66e57635b8f6257857a29de438627b@"
"r04631026","3","1.09","137216","@71ff8a7ce846bf5689432d26aa6e1f87@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] Initial = br.readLine().split("","");
            //Set the matrix size
            int Num = Integer.parseInt(Initial[0]);
            //Target point
            int[][] matrix = new int[Num][Num];
            int AreaNum = 1;
            for (int i=0;i<Num;i++){
                for (int j=0;j<Num;j++){
                    matrix[i][j] = 1;
                }
            }
            while (br.ready()){
                String[] Position = br.readLine().split("","");
                matrix[Integer.parseInt(Position[0])-1][Integer.parseInt(Position[1])-1]=0;
            }
            //Set first row
            for (int i=0;i<Num;i++){
                if (matrix[0][i]==0){
                    AreaNum++;
//                    continue;
                }
                else {
                    matrix[0][i]= AreaNum;
                }
            }
            boolean CheckStat = false;
            for (int i=1;i<Num;i++){
                for (int j=0;j<Num;j++){
                    if (matrix[i][j]==0){continue;}
                    //Set first column
                    if (j==0){
                        if (matrix[i-1][j]!=0){
                            matrix[i][j] = matrix[i-1][j];
                            CheckStat = false;
                        }
                        else{
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                            CheckStat = true;
                        }
                    }
                    else{
                        //Check left
                        if (matrix[i][j-1]==0 && matrix[i-1][j]==0){
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]!=0){
                            //Top is smaller
                            if (matrix[i][j-1]>matrix[i-1][j]){
                                matrix[i][j]=matrix[i-1][j];
                            }
                            //Left is smaller
                            else{
                                matrix[i][j]=matrix[i][j-1];
                            }
                        }
                        else if(matrix[i][j-1]==0 && matrix[i-1][j]!=0){
                            matrix[i][j]=matrix[i-1][j];                           
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]==0){
                            matrix[i][j]=matrix[i][j-1];
                        }
                        else{
                            if (CheckStat){
                                AreaNum++;
                                matrix[i][j]=AreaNum;
                                CheckStat = true;
                            }
                            else{
                                matrix[i][j]=AreaNum;
                            }
                        }
                    }
                }
            }           
            //Print all value in matrix
            for (int f=0; f<4;f++){
                for (int i=1;i<Num;i++){
                    for (int j=1;j<Num;j++){
                        if (matrix[i-1][j]!=0 && matrix[i][j]!=0){                        
                            if (matrix[i-1][j]!=matrix[i][j] && matrix[i-1][j]>matrix[i][j]){
                                for (int a=0;a<Num;a++){
                                    for (int b=0;b<Num;b++){
                                        if (matrix[a][b]==matrix[i-1][j]){
                                            matrix[a][b]=matrix[i][j];
                                        }                                   
                                    }
                                }
                            }
                        }
                        if (matrix[i][j-1]!=0 && matrix[i][j]!=0){
                            if (matrix[i][j-1]!=matrix[i][j] && matrix[i][j-1]>matrix[i][j]){
                                for (int a=0;a<Num;a++){
                                    for (int b=0;b<Num;b++){
                                        if (matrix[a][b]==matrix[i][j-1]){
                                            matrix[a][b]=matrix[i][j];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            System.out.println(matrix[Integer.parseInt(""1"")-1][Integer.parseInt(""3"")-1]);
        }        
    }
}
@71ff8a7ce846bf5689432d26aa6e1f87@"
"r04631026","3","1.07","137232","@4883c42b3a4853c910075ea7b2a28563@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] Initial = br.readLine().split("","");
            //Set the matrix size
            int Num = Integer.parseInt(Initial[0]);
            //Target point
            int[][] matrix = new int[Num][Num];
            int AreaNum = 1;
            for (int i=0;i<Num;i++){
                for (int j=0;j<Num;j++){
                    matrix[i][j] = 1;
                }
            }
            while (br.ready()){
                String[] Position = br.readLine().split("","");
                matrix[Integer.parseInt(Position[0])-1][Integer.parseInt(Position[1])-1]=0;
            }
            //Set first row
            for (int i=0;i<Num;i++){
                if (matrix[0][i]==0){
                    AreaNum++;
//                    continue;
                }
                else {
                    matrix[0][i]= AreaNum;
                }
            }
            boolean CheckStat = false;
            for (int i=1;i<Num;i++){
                for (int j=0;j<Num;j++){
                    if (matrix[i][j]==0){continue;}
                    //Set first column
                    if (j==0){
                        if (matrix[i-1][j]!=0){
                            matrix[i][j] = matrix[i-1][j];
                            CheckStat = false;
                        }
                        else{
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                            CheckStat = true;
                        }
                    }
                    else{
                        //Check left
                        if (matrix[i][j-1]==0 && matrix[i-1][j]==0){
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]!=0){
                            //Top is smaller
                            if (matrix[i][j-1]>matrix[i-1][j]){
                                matrix[i][j]=matrix[i-1][j];
                            }
                            //Left is smaller
                            else{
                                matrix[i][j]=matrix[i][j-1];
                            }
                        }
                        else if(matrix[i][j-1]==0 && matrix[i-1][j]!=0){
                            matrix[i][j]=matrix[i-1][j];                           
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]==0){
                            matrix[i][j]=matrix[i][j-1];
                        }
                        else{
                            if (CheckStat){
                                AreaNum++;
                                matrix[i][j]=AreaNum;
                                CheckStat = true;
                            }
                            else{
                                matrix[i][j]=AreaNum;
                            }
                        }
                    }
                }
            }           
            //Print all value in matrix
            for (int f=0; f<2;f++){
                for (int i=1;i<Num;i++){
                    for (int j=1;j<Num;j++){
                        if (matrix[i-1][j]!=0 && matrix[i][j]!=0){                        
                            if (matrix[i-1][j]!=matrix[i][j] && matrix[i-1][j]>matrix[i][j]){
                                for (int a=0;a<Num;a++){
                                    for (int b=0;b<Num;b++){
                                        if (matrix[a][b]==matrix[i-1][j]){
                                            matrix[a][b]=matrix[i][j];
                                        }                                   
                                    }
                                }
                            }
                        }
                        if (matrix[i][j-1]!=0 && matrix[i][j]!=0){
                            if (matrix[i][j-1]!=matrix[i][j] && matrix[i][j-1]>matrix[i][j]){
                                for (int a=0;a<Num;a++){
                                    for (int b=0;b<Num;b++){
                                        if (matrix[a][b]==matrix[i][j-1]){
                                            matrix[a][b]=matrix[i][j];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            System.out.println(matrix[Integer.parseInt(""1"")-1][Integer.parseInt(""3"")-1]);
        }        
    }
}
@4883c42b3a4853c910075ea7b2a28563@"
"r04631026","6","1.09","133392","@b9e361c84f5c97250b0404311ef287bc@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] Initial = br.readLine().split("","");
            //Set the matrix size
            int Num = Integer.parseInt(Initial[0]);
            //Target point
            int[][] matrix = new int[Num][Num];
            int AreaNum = 1;
            for (int i=0;i<Num;i++){
                for (int j=0;j<Num;j++){
                    matrix[i][j] = 1;
                }
            }
            while (br.ready()){
                String[] Position = br.readLine().split("","");
                matrix[Integer.parseInt(Position[0])-1][Integer.parseInt(Position[1])-1]=0;
            }
            //Set first row
            for (int i=0;i<Num;i++){
                if (matrix[0][i]==0){
                    AreaNum++;
//                    continue;
                }
                else {
                    matrix[0][i]= AreaNum;
                }
            }
            boolean CheckStat = false;
            for (int i=1;i<Num;i++){
                for (int j=0;j<Num;j++){
                    if (matrix[i][j]==0){continue;}
                    //Set first column
                    if (j==0){
                        if (matrix[i-1][j]!=0){
                            matrix[i][j] = matrix[i-1][j];
                            CheckStat = false;
                        }
                        else{
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                            CheckStat = true;
                        }
                    }
                    else{
                        //Check left
                        if (matrix[i][j-1]==0 && matrix[i-1][j]==0){
                            AreaNum++;
                            matrix[i][j]=AreaNum;
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]!=0){
                            //Top is smaller
                            if (matrix[i][j-1]>matrix[i-1][j]){
                                matrix[i][j]=matrix[i-1][j];
                            }
                            //Left is smaller
                            else{
                                matrix[i][j]=matrix[i][j-1];
                            }
                        }
                        else if(matrix[i][j-1]==0 && matrix[i-1][j]!=0){
                            matrix[i][j]=matrix[i-1][j];                           
                        }
                        else if(matrix[i][j-1]!=0 && matrix[i-1][j]==0){
                            matrix[i][j]=matrix[i][j-1];
                        }
                        else{
                            if (CheckStat){
                                AreaNum++;
                                matrix[i][j]=AreaNum;
                                CheckStat = true;
                            }
                            else{
                                matrix[i][j]=AreaNum;
                            }
                        }
                    }
                }
            }           
            //Print all value in matrix
            for (int test=0;test<4;test++){
                for (int i=1;i<Num;i++){
                    for (int j=1;j<Num;j++){
                        if (matrix[i-1][j]!=0 && matrix[i][j]!=0){                        
                            if (matrix[i-1][j]!=matrix[i][j] && matrix[i-1][j]>matrix[i][j]){
                                for (int a=0;a<Num;a++){
                                    for (int b=0;b<Num;b++){
                                        if (matrix[a][b]==matrix[i-1][j]){
                                            matrix[a][b]=matrix[i][j];
                                        }                                   
                                    }
                                }
                            }
                        }
                        if (matrix[i][j-1]!=0 && matrix[i][j]!=0){
                            if (matrix[i][j-1]!=matrix[i][j] && matrix[i][j-1]>matrix[i][j]){
                                for (int a=0;a<Num;a++){
                                    for (int b=0;b<Num;b++){
                                        if (matrix[a][b]==matrix[i][j-1]){
                                            matrix[a][b]=matrix[i][j];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            System.out.println(matrix[Integer.parseInt(Initial[1])-1][Integer.parseInt(Initial[2])-1]);
        }        
    }
}
@b9e361c84f5c97250b0404311ef287bc@"
"r04921028","9","1","122528","@576d09aed144cb18a4baf5b1eb615559@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    
                    if(j==0&&j==0){
                        M[i][j]=1;
                    } 
                   
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            
                            count++;
                            M[i][j]=count;  
                            
                        }
                    }
                   
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                                
                                    count++;
                                    M[i][j] = count; 
                                
                            }
                        }
                    }
                     
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){                      
                            count++;
                            M[i][j] = count; 
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        
              
        
        
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@576d09aed144cb18a4baf5b1eb615559@"
"r04921028","9","0.99","124496","@670aaafcaf79ded7597bc87586c445fb@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                        
                        
                    }
                    
                
                }
                
                
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        
              
        
        
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@670aaafcaf79ded7597bc87586c445fb@"
"r04921028","9","1.01","124048","@670aaafcaf79ded7597bc87586c445fb@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    if(i!=0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; }
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    if(i!=0&&j!=0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }
                        
                        
                    }
                    
                
                }
                
                
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        }
        
              
        
        
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@670aaafcaf79ded7597bc87586c445fb@"
"b03611033","9","0.98","125760","@1e5cc183efd6b1a41aac9cc3f8d1099e@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public int[][] root;
    public int parent[];
    public LabelCC(int n){
        root=new int[n][n];
        parent=new int[n*n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                root[i][j]=1;
                parent[i*n+j]=i*n+j;
            }
        }
    }
    public void blocked(int x,int y){
        root[x][y]=0;
    }
    public void firstrun(int n){
        int rootput=1;
        boolean stop=false;
        for(int j=0;j<n;j++){
            if(root[0][j]!=0){
                root[0][j]=rootput;
                stop=true;
            }        
            else{
                if(stop){
                    rootput++;
                    stop=false;
                }
            }   
        }    
        for(int i=1;i<n;i++){
            for(int j=0;j<n;j++){
                if(root[i][j]!=0){
                    if(j==0 || root[i][j-1]==0){
                        if(root[i-1][j]!=0){
                            root[i][j]=root[i-1][j];
                        }
                        else{
                            if(stop)
                                rootput++;
                            root[i][j]=rootput;
                            stop=true;
                        }
                    }
                    else{
                        root[i][j]=root[i][j-1];
                        if(root[i-1][j]!=0 & root[i-1][j]!=root[i][j-1]){
                          if(root[i-1][j]<root[i][j-1]){
                                parent[root[i][j-1]]=root[i-1][j];
                                root[i][j]=root[i-1][j];
                            }
                                else{
                                parent[root[i-1][j]]=root[i][j-1];
                                root[i][j]=root[i][j-1];
                            }
                        }
                    } 
                }
            }
        }
    }
    public int find(int x){
        while(x!=parent[x]){
            x=parent[parent[x]];
        }
        return x;
    }
    public void show(int n,int p,int q){
        if(n==1){
            StdOut.println(root[0][0]);
            return;
        }
       StdOut.println(find(root[p][q]));
    }
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String data = br.readLine();
            String datacut[];
            datacut = data.split("","");
            int N = Integer.parseInt(datacut[0]);  
            int fp = Integer.parseInt(datacut[1]);
            int fq = Integer.parseInt(datacut[2]);
            int p;
            int q;
            LabelCC labelCC = new LabelCC(N);
            while((data = br.readLine()) != null){
                datacut=data.split("","");
                p=Integer.parseInt(datacut[0]);
                q=Integer.parseInt(datacut[1]);
                labelCC.blocked(p-1,q-1);
            }
            labelCC.firstrun(N);
            labelCC.show(N,fp-1,fq-1);
        }        
    }        
}                


@1e5cc183efd6b1a41aac9cc3f8d1099e@"
"b99611017","6","1.34","190912","@25e8ad2a0ecf120a6b2756760be46436@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
import java.io.*;
import java.util.Scanner;

public class LabelCC {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            String[] given = token[0].split("","");

            int[] x = new int[token.length - 1];

            int[] y = new int[token.length - 1];

            int size = Integer.parseInt(given[0]);

            int a = Integer.parseInt(given[1]) - 1;

            int b = Integer.parseInt(given[2]) - 1;         //a given site

            for (int i = 0; i < token.length - 1; i++) {

                String[] site = token[i + 1].split("","");

                x[i] = Integer.parseInt(site[0]);

                y[i] = Integer.parseInt(site[1]);

            }

            int[][] map = new int[size][size];

            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    map[i][j] = 1;
                }
            }

            for (int i = 0; i < x.length; i++) {
                map[x[i] - 1][y[i] - 1] = 0;
            }                                      //mapping

            //scanning
            int label = 1;

            for (int i = 0; i < size; i++) //row 1 : special case
            {
                if (i == 0) //[0][0]
                {
                    if (map[0][i] != 0) {
                        map[0][i] = label;
                    } else if (map[0][i] == 0) {
                        map[0][i] = 0;
                    }
                } else {
                    if (map[0][i] == 0) {
                        map[0][i] = 0;
                        label++;
                    } else {
                        map[0][i] = label;
                    }

                }

            }

            for (int i = 1; i < size; i++) {                //other rows

                for (int j = 0; j < size; j++) {

                    if (j == 0) {
                        if (map[i - 1][j] == 0 && map[i][j] != 0) //column 1 special case
                        {
                            label++;
                            map[i][j] = label;
                        } else if (map[i - 1][j] != 0 && map[i][j] != 0) {
                            map[i][j] = map[i - 1][j];
                        }
                    } else {

                        if (map[i - 1][j] == 0 && map[i][j - 1] == 0 && map[i][j] != 0) {
                            label++;
                            map[i][j] = label;
                        } else if (map[i - 1][j] != 0 && map[i][j - 1] == 0 && map[i][j] != 0) {
                            map[i][j] = map[i - 1][j];
                        } else if (map[i - 1][j] == 0 && map[i][j - 1] != 0 && map[i][j] != 0) {
                            map[i][j] = map[i][j - 1];
                        } else if (map[i - 1][j] != 0 && map[i][j - 1] != 0 && map[i][j] != 0) {

                            if (map[i - 1][j] > map[i][j - 1]) {
                                map[i][j] = map[i][j - 1];
                            } else if (map[i - 1][j] < map[i][j - 1]) {
                                map[i][j] = map[i - 1][j];
                            } else if (map[i - 1][j] == map[i][j - 1]) {
                                map[i][j] = map[i - 1][j];
                            }
                        }

                    }

                }
            }
            // start connecting
            QuickUnionUF LC = new QuickUnionUF(size * size);

            for (int i = 0; i < size * size; i++) {
                if (i / size == 0 && i % size == 0) {
                    ;
                } else if (i / size == 0 && i % size != 0) {
                    if (map[i / size][i % size - 1] == map[i / size][i % size]) {
                        LC.union(i, i - 1);
                    }

                } else if (i % size == 0 && i / size != 0) {
                    if (map[i / size - 1][i % size] == map[i / size][i % size]) {
                        LC.union(i, i - size);
                    }
                } else if (i / size != 0 && i % size != 0) {
                    if (map[i / size][i % size - 1] == map[i / size][i % size]) {
                        LC.union(i, i - 1);
                    }

                    if (map[i / size - 1][i % size] == map[i / size][i % size]) {
                        LC.union(i, i - size);
                    }
                }
            }

            //start merging
            for (int i = 0; i < size * size; i++) {
                if (i / size == 0 && i % size == 0) //    ( 0 , 0 )
                {
                    ;
                } else if (i / size == 0 && i % size != 0) //row 1
                {
                    if ((map[i / size][i % size] > map[i / size][i % size - 1]) && (map[i / size][i % size - 1] > 0)) {
                        LC.union(i, i - 1);
                    } else if ((map[i / size][i % size - 1] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - 1, i);
                    }
                } else if (i % size == 0 && i / size != 0) //column 1
                {
                    if ((map[i / size][i % size] > map[i / size - 1][i % size] )&& (map[i / size - 1][i % size] > 0)) {
                        LC.union(i, i - size);
                    } else if ((map[i / size - 1][i % size] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - size, i);
                    }
                } else if (i % size != 0 && i / size != 0) {
                    if ((map[i / size][i % size] > map[i / size - 1][i % size]) && (map[i / size - 1][i % size] > 0)) {
                        LC.union(i, i - size);
                    } else if ((map[i / size - 1][i % size] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - size, i);
                    }

                    if ((map[i / size][i % size] > map[i / size][i % size - 1]) && (map[i / size][i % size - 1] > 0)) {
                        LC.union(i, i - 1);
                    } else if ((map[i / size][i % size - 1] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - 1, i);
                    }
                }
            }

            int ans = LC.find(a * size + b);

            System.out.print(map[ans / size][ans % size]);

        } catch (RuntimeException e) {

            throw e;
        }
    }
}

@25e8ad2a0ecf120a6b2756760be46436@"
"r04921028","0","1.25","156432","@3abfc3a441d413ff016fb1490d762410@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]>0){
                    System.out.print("" ""+uf.find(M[i][j])+"" "");
                }else{
                    System.out.print(M[i][j]+"" "");
                }
            }
            System.out.print(""\n"");
        }
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@3abfc3a441d413ff016fb1490d762410@"
"r03723070","9","0.99","128560","@0999294b65c576ad83a296c3bc0d6a4b@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                    else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1];
                           if( data[i-1][j] > 0){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           if(connect[q]==0) connect[q] = q;
                           
                           if(connect[q]!=0) connect[p] = connect[q];
                           else
                               connect[p] = q;
                           //min root
                           
                       }
                           
                       }
                    else{
                           data[i][j] =data[i-1][j];
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    


@0999294b65c576ad83a296c3bc0d6a4b@"
"r04921028","9","1.01","123456","@36d52aae0b8877251411d10a04e2509f@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]>0){
//                    System.out.print("" ""+uf.find(M[i][j])+"" "");
//                }else{
//                    System.out.print(M[i][j]+"" "");
//                }
//            }
//            System.out.print(""\n"");
//        }
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@36d52aae0b8877251411d10a04e2509f@"
"r03723070","9","1","127312","@e43cb99084e565395952ccd44c60fe26@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                    else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1];
                           if( data[i-1][j] > 0){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           if(connect[q]==0) connect[q] = q;
                           
                           if(connect[q]!=0) connect[p] = connect[q];
                           //else
                               //connect[p] = q;
                           //min root
                           
                       }
                           
                       }
                    else{
                           data[i][j] =data[i-1][j];
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    


@e43cb99084e565395952ccd44c60fe26@"
"r03723070","5","1.01","126112","@2d1f9994823c9943ac25a09fde1aa3b1@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                    else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1];
                           if( data[i-1][j] > 0){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           if(connect[q]==0) connect[q] = q;
                           
                           if(connect[q]!=0) connect[p] = connect[q];
                           //else
                               //connect[p] = q;
                           //min root
                           
                       }
                           
                       }
                    else{
                           data[i][j] =data[i-1][j];
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       
       finalans = connect[data[ans[0]][ans[1]]];
       
       }
       //block
       else if(data[ans[0]][ans[1]]==-1)
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    


@2d1f9994823c9943ac25a09fde1aa3b1@"
"r03723070","9","1.04","126336","@6b1faa0fcf763926412f6beb2c9401d4@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1];
                           if( data[i-1][j] > 0){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           if(connect[q]==0) {
                               if(connect[p]!=0)
                               connect[q] = Math.max(Math.min(q,connect[p]),0);
                               else
                               connect[q] = q; 
                               connect[p] = connect[q];
                           }
                           
                           if(connect[q]!=0){
                               if(connect[p]!=0)
                               connect[p] = Math.min(connect[q],connect[p]);
                               else
                               connect[p] = connect[q];
                           }
                          
                           //min root
                           
                       }
                           
                       }
                    else{
                           data[i][j] =data[i-1][j];
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    



@6b1faa0fcf763926412f6beb2c9401d4@"
"r04921028","6","0.98","125040","@5a44e142c351a9cd8521b913fc18d4f9@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    else if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        else if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    else if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        else if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    else if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        else if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        else if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        else if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]>0){
//                    System.out.print(uf.find(M[i][j])+"" "");
//                }else{
//                    System.out.print(""0""+"" "");
//                }
//            }
//            System.out.print(""\n"");
//        }
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@5a44e142c351a9cd8521b913fc18d4f9@"
"r04921028","9","0.99","127920","@49e33756f708a2fa2611475ad325d373@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                     
                    if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]>0){
//                    System.out.print(uf.find(M[i][j])+"" "");
//                }else{
//                    System.out.print(""0""+"" "");
//                }
//            }
//            System.out.print(""\n"");
//        }
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@49e33756f708a2fa2611475ad325d373@"
"r03723070","9","1.11","131984","@fda0ce79774d2cde073d24f9f8b8ae86@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1];
                           if( data[i-1][j] > 0){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                           if(connect[q]==0&&connect[p]==0) {
                               connect[q] = q;
                               connect[p] = connect[q];
                           }
                           
                           if(connect[q]!=0||connect[p]!=0){
                               if(connect[p]!=0&&connect[q]!=0){
                                   int op =Math.max(connect[q],connect[p]);
                                   int oq =Math.min(connect[q],connect[p]);
                                    connect[p] = oq;
                                    connect[q] = oq;
                                    //correct the root
                                    for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                                    }
                               }
                               else if(connect[p]!=0&&connect[q]==0){
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                               }
                               else if(connect[p]==0&&connect[q]!=0){
                                   connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }
                                   
                               connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root
                           
                       }
                           
                       }
                    else{
                           data[i][j] =data[i-1][j];
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    



@fda0ce79774d2cde073d24f9f8b8ae86@"
"r04921028","9","0.99","125200","@1eb2e11e157bab9b1c5e60f0c0ba5473@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    else if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    else if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                    else if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]>0){
//                    System.out.print(uf.find(M[i][j])+"" "");
//                }else{
//                    System.out.print(""0""+"" "");
//                }
//            }
//            System.out.print(""\n"");
//        }
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@1eb2e11e157bab9b1c5e60f0c0ba5473@"
"r04921028","9","1","127056","@430b3eeef0c62035ab58f5bafd959e69@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    else if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    else if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                    else if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0&&M[i-1][j]<0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]<0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                M[i][j] = M[i][j-1];
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                M[i][j] = M[i-1][j];
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]>0){
//                    System.out.print(uf.find(M[i][j])+"" "");
//                }else{
//                    System.out.print(""0""+"" "");
//                }
//            }
//            System.out.print(""\n"");
//        }
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@430b3eeef0c62035ab58f5bafd959e69@"
"b01502105","7","0.63","104272","@6c113b04db5ee8ac91e13112a1fbf9e9@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StringBuilder everything = new StringBuilder();
            String line;
            everything.append(br.readLine());//first num
            while ((line = br.readLine()) != null) {
                everything.append("" "");
                everything.append(line);
            }
            String[] data = everything.toString().split("" "");
            String[] given = data[0].split("","");
            int num = Integer.parseInt(given[0]);  //matrix size
            int assigned_row = Integer.parseInt(given[1]);
            int assigned_column = Integer.parseInt(given[2]);
            int len = data.length;  //input 
            int label = 0;
//            int k = 0;
            int[][] p_c = new int[30][2]; 
            UF uf = new UF(30);
            
//            System.out.printf(num+"" ""+assigned_row+"" ""+assigned_column+"" ""+len+""\n"");
            int[][] matrix = new int[num][num];
            for(int a=0;a<num;a++){
                Arrays.fill(matrix[a], 1);
            }
            int[][] matrix_label = new int [num][num]; 
            //assign given position
            for(int i=1; i<len; i++){
               String[] block = data[i].split("","");
               int block_row = Integer.parseInt(block[0]);
               int block_column = Integer.parseInt(block[1]);
               matrix[block_row - 1][block_column - 1] = 0;
            }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
           //The first pass
           for(int i=0;i<num;i++){
               for(int j=0;j<num;j++){
                   if(matrix[i][j] == 1){
                        if( i==0 && j==0){ label++; matrix_label[i][j]=label;}
                        //row_1
                        else if(i==0){
                             if(matrix[i][j-1] == 1){
                                matrix_label[i][j]=matrix_label[i][j-1]; 
                             }
                             else{
                                label++;
                                matrix_label[i][j]=label; 
                             }
                        }
                        //column_1
                        else if(j==0){
                            if(matrix[i-1][j] == 1){
                                matrix_label[i][j]=matrix_label[i-1][j];
                             }
                            else {
                                label++;
                                matrix_label[i][j]=label;
                            }
                        }
                        //usual case
                        else{   
                            //up & left are ""1""
                            if (matrix[i][j - 1] == 1 && matrix[i - 1][j] == 1) {
                                //up & left is the same
                                if (matrix_label[i][j - 1] == matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
                                } 
                                else if (matrix_label[i][j - 1] < matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
//                                    p_c[k][0]=matrix_label[i][j-1]; //parent,small
//                                    p_c[k][1]=matrix_label[i-1][j]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i][j-1],matrix_label[i-1][j]);
                                } 
                                else {  //matrix_label[i][j-1] > matrix_label[i-1][j]
                                    matrix_label[i][j] = matrix_label[i - 1][j];
//                                    p_c[k][0]=matrix_label[i-1][j]; //parent,small
//                                    p_c[k][1]=matrix_label[i][j-1]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i-1][j],matrix_label[i][j-1]);
                                }
                            } //left is ""1""
                            else if (matrix[i][j - 1] == 1) {
                                matrix_label[i][j] = matrix_label[i][j - 1];
                            }
                             //up is ""1""
                             else if(matrix[i-1][j] == 1){
                                 matrix_label[i][j]=matrix_label[i-1][j];
                             }
                             // none
                             else{
                                 label++;
                                 matrix_label[i][j]=label;
                             }
                        }
                   }
               }
           }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < k; a++) {
//                System.out.printf(p_c[a][0] + "" <- "" +p_c[a][1] + ""\n"");
//            }
            
//            System.out.printf(uf.find(3)+""\n"");
            //second pass
            for(int i=0;i<num;i++){
                for(int j=0;j<num;j++){
                    if(matrix_label[i][j] != uf.find(matrix_label[i][j])){
                        matrix_label[i][j] = uf.find(matrix_label[i][j]);
                    }
                }
            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            System.out.printf(""assigned position:""+assigned_row + "","" + assigned_column + ""\n"");
            System.out.printf(matrix_label[assigned_row - 1][assigned_column - 1]+""\n"");
        }
    }
}

@6c113b04db5ee8ac91e13112a1fbf9e9@"
"b03611011","9","1","123328","@56ddf18d3b462ee5f5a44c0a943dc8cc@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static int[] place;
    public static int[] id, count;
    public static int n, number, x;
    private static int[] parent, child;  // parent[i] = parent of i
    private static int[] change;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private static int rootQ, rootP, amount;
    //amount =rank
    //n= length
    //id= if or not
    //cont=>number where it is

    public static void point(int x, int y) {
        number = (x - 1) * n + y;
    }

    public static void UF(int N) {
        if (N < 0) {
            throw new IllegalArgumentException();
        }
        parent = new int[N];
        child = new int[N];
        change = new int[N / 4];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            child[i] = 0;
        }
    }

    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
        }
    }

    public static void union(int p, int q) {
        rootP = parent[p];
        rootQ = parent[q];
        if (rootP == rootQ) {
            return;
        }
        // make root of smaller rank point to root of larger rank
        if (rootP < rootQ) {
            parent[rootQ] = rootP;
        } else if (rootP > rootQ) {
            parent[rootP] = rootQ;
        }
//        count--;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] fund = br.readLine().split("","");
            n = Integer.parseInt(fund[0]);
            place = new int[2];
            place[0] = Integer.parseInt(fund[1]);
            place[1] = Integer.parseInt(fund[2]);
            id = new int[n * n + 2];
            x = 0;
            for (int i = 1; i <= n * n + 1; i++) {
                id[i] = 1;
            }
            count = new int[2];
            String data;
            String[] data1;
            UF(n * n + 2);
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 0;
                union(0, number);
            }
            amount = 1;
            if (id[1] > 0) {
                parent[1] = amount;
                amount++;
            }
            for (int i = 2; i <= n; i++) {
                if (id[i] > 0) {
                    if (id[i - 1] > 0) {
                        union(i, i - 1);
                    } else {
                        parent[i] = amount;
                        amount++;
                    }
                }
            }
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    point(i, j);
                    if (id[number] > 0) {
                        if (j == 1) {
                            if (id[number - n] > 0) {
                                union(number, number - n);
                            } else {
                                parent[number] = amount;
                                amount++;
                            }
                        } else if (id[number - n] > 0 && id[number - 1] > 0) {
                            if (parent[number - n] < parent[number - 1]) {
                                parent[number] = parent[number - n];
                                child[number] = parent[number - 1];
                                change[x] = parent[number - n];
                                x++;
                                change[x] = parent[number - 1];
                                x++;
                            } else if (parent[number - n] > parent[number - 1]) {
                                parent[number] = parent[number - 1];
                                child[number] = parent[number - n];
                                change[x] = parent[number - 1];
                                x++;
                                change[x] = parent[number - n];
                                x++;
                            } else {
                                if (parent[number - n] <= parent[number - 1]) {
                                    union(number, number - n);
                                } else {
                                    union(number, number - 1);
                                }
                            }
                        } else if (id[number - n] > 0) {
                            union(number, number - n);
                        } else {
                            if (id[number - 1] > 0) {
                                union(number, number - 1);
                            } else {
                                parent[number] = amount;
                                amount++;
                            }
                        }
                    }
                }
            }
            point(place[0], place[1]);
            for (int i = 1; i < x; i = i + 2) {
                if (parent[number] == change[i]) {
                    parent[number] = change[i - 1];
                    break;
                }
            }
            System.out.println(parent[number]);
        }
    }
}

@56ddf18d3b462ee5f5a44c0a943dc8cc@"
"b01502105","7","0.65","105696","@6c113b04db5ee8ac91e13112a1fbf9e9@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StringBuilder everything = new StringBuilder();
            String line;
            everything.append(br.readLine());//first num
            while ((line = br.readLine()) != null) {
                everything.append("" "");
                everything.append(line);
            }
            String[] data = everything.toString().split("" "");
            String[] given = data[0].split("","");
            int num = Integer.parseInt(given[0]);  //matrix size
            int assigned_row = Integer.parseInt(given[1]);
            int assigned_column = Integer.parseInt(given[2]);
            int len = data.length;  //input 
            int label = 0;
//            int k = 0;
            int[][] p_c = new int[30][2]; 
            UF uf = new UF(30);
            
//            System.out.printf(num+"" ""+assigned_row+"" ""+assigned_column+"" ""+len+""\n"");
            int[][] matrix = new int[num][num];
            for(int a=0;a<num;a++){
                Arrays.fill(matrix[a], 1);
            }
            int[][] matrix_label = new int [num][num]; 
            //assign given position
            for(int i=1; i<len; i++){
               String[] block = data[i].split("","");
               int block_row = Integer.parseInt(block[0]);
               int block_column = Integer.parseInt(block[1]);
               matrix[block_row - 1][block_column - 1] = 0;
            }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
           //The first pass
           for(int i=0;i<num;i++){
               for(int j=0;j<num;j++){
                   if(matrix[i][j] == 1){
                        if( i==0 && j==0){ label++; matrix_label[i][j]=label;}
                        //row_1
                        else if(i==0){
                             if(matrix[i][j-1] == 1){
                                matrix_label[i][j]=matrix_label[i][j-1]; 
                             }
                             else{
                                label++;
                                matrix_label[i][j]=label; 
                             }
                        }
                        //column_1
                        else if(j==0){
                            if(matrix[i-1][j] == 1){
                                matrix_label[i][j]=matrix_label[i-1][j];
                             }
                            else {
                                label++;
                                matrix_label[i][j]=label;
                            }
                        }
                        //usual case
                        else{   
                            //up & left are ""1""
                            if (matrix[i][j - 1] == 1 && matrix[i - 1][j] == 1) {
                                //up & left is the same
                                if (matrix_label[i][j - 1] == matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
                                } 
                                else if (matrix_label[i][j - 1] < matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
//                                    p_c[k][0]=matrix_label[i][j-1]; //parent,small
//                                    p_c[k][1]=matrix_label[i-1][j]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i][j-1],matrix_label[i-1][j]);
                                } 
                                else {  //matrix_label[i][j-1] > matrix_label[i-1][j]
                                    matrix_label[i][j] = matrix_label[i - 1][j];
//                                    p_c[k][0]=matrix_label[i-1][j]; //parent,small
//                                    p_c[k][1]=matrix_label[i][j-1]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i-1][j],matrix_label[i][j-1]);
                                }
                            } //left is ""1""
                            else if (matrix[i][j - 1] == 1) {
                                matrix_label[i][j] = matrix_label[i][j - 1];
                            }
                             //up is ""1""
                             else if(matrix[i-1][j] == 1){
                                 matrix_label[i][j]=matrix_label[i-1][j];
                             }
                             // none
                             else{
                                 label++;
                                 matrix_label[i][j]=label;
                             }
                        }
                   }
               }
           }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < k; a++) {
//                System.out.printf(p_c[a][0] + "" <- "" +p_c[a][1] + ""\n"");
//            }
            
//            System.out.printf(uf.find(3)+""\n"");
            //second pass
            for(int i=0;i<num;i++){
                for(int j=0;j<num;j++){
                    if(matrix_label[i][j] != uf.find(matrix_label[i][j])){
                        matrix_label[i][j] = uf.find(matrix_label[i][j]);
                    }
                }
            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            System.out.printf(""assigned position:""+assigned_row + "","" + assigned_column + ""\n"");
            System.out.printf(matrix_label[assigned_row - 1][assigned_column - 1]+""\n"");
        }
    }
}

@6c113b04db5ee8ac91e13112a1fbf9e9@"
"b01502105","7","0.64","105680","@d9173cd4ae36e34e670b052d0489f3bb@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StringBuilder everything = new StringBuilder();
            String line;
            everything.append(br.readLine());//first num
            while ((line = br.readLine()) != null) {
                everything.append("" "");
                everything.append(line);
            }
            String[] data = everything.toString().split("" "");
            String[] given = data[0].split("","");
            int num = Integer.parseInt(given[0]);  //matrix size
            int assigned_row = Integer.parseInt(given[1]);
            int assigned_column = Integer.parseInt(given[2]);
            int len = data.length;  //input 
            int label = 0;
//            int k = 0;
            int[][] p_c = new int[20][2]; 
            UF uf = new UF(20);
            
//            System.out.printf(num+"" ""+assigned_row+"" ""+assigned_column+"" ""+len+""\n"");
            int[][] matrix = new int[num][num];
            for(int a=0;a<num;a++){
                Arrays.fill(matrix[a], 1);
            }
            int[][] matrix_label = new int [num][num]; 
            //assign given position
            for(int i=1; i<len; i++){
               String[] block = data[i].split("","");
               int block_row = Integer.parseInt(block[0]);
               int block_column = Integer.parseInt(block[1]);
               matrix[block_row - 1][block_column - 1] = 0;
            }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
           //The first pass
           for(int i=0;i<num;i++){
               for(int j=0;j<num;j++){
                   if(matrix[i][j] == 1){
                        if( i==0 && j==0){ label++; matrix_label[i][j]=label;}
                        //row_1
                        else if(i==0){
                             if(matrix[i][j-1] == 1){
                                matrix_label[i][j]=matrix_label[i][j-1]; 
                             }
                             else{
                                label++;
                                matrix_label[i][j]=label; 
                             }
                        }
                        //column_1
                        else if(j==0){
                            if(matrix[i-1][j] == 1){
                                matrix_label[i][j]=matrix_label[i-1][j];
                             }
                            else {
                                label++;
                                matrix_label[i][j]=label;
                            }
                        }
                        //usual case
                        else{   
                            //up & left are ""1""
                            if (matrix[i][j - 1] == 1 && matrix[i - 1][j] == 1) {
                                //up & left is the same
                                if (matrix_label[i][j - 1] == matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
                                } 
                                else if (matrix_label[i][j - 1] < matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
//                                    p_c[k][0]=matrix_label[i][j-1]; //parent,small
//                                    p_c[k][1]=matrix_label[i-1][j]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i][j-1],matrix_label[i-1][j]);
                                } 
                                else {  //matrix_label[i][j-1] > matrix_label[i-1][j]
                                    matrix_label[i][j] = matrix_label[i - 1][j];
//                                    p_c[k][0]=matrix_label[i-1][j]; //parent,small
//                                    p_c[k][1]=matrix_label[i][j-1]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i-1][j],matrix_label[i][j-1]);
                                }
                            } //left is ""1""
                            else if (matrix[i][j - 1] == 1) {
                                matrix_label[i][j] = matrix_label[i][j - 1];
                            }
                             //up is ""1""
                             else if(matrix[i-1][j] == 1){
                                 matrix_label[i][j]=matrix_label[i-1][j];
                             }
                             // none
                             else{
                                 label++;
                                 matrix_label[i][j]=label;
                             }
                        }
                   }
               }
           }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < k; a++) {
//                System.out.printf(p_c[a][0] + "" <- "" +p_c[a][1] + ""\n"");
//            }
            
//            System.out.printf(uf.find(3)+""\n"");
            //second pass
            for(int i=0;i<num;i++){
                for(int j=0;j<num;j++){
                    if(matrix_label[i][j] != uf.find(matrix_label[i][j])){
                        matrix_label[i][j] = uf.find(matrix_label[i][j]);
                    }
                }
            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            System.out.printf(""assigned position:""+assigned_row + "","" + assigned_column + ""\n"");
            System.out.printf(matrix_label[assigned_row - 1][assigned_column - 1]+""\n"");
        }
    }
}

@d9173cd4ae36e34e670b052d0489f3bb@"
"b03611011","9","0.97","125312","@e499e10a71b47ef058511e34fe132a33@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static int[] place;
    public static int[] id, count;
    public static int n, number, x;
    private static int[] parent, child;  // parent[i] = parent of i
    private static int[] change;   // rank[i] = rank of subtree rooted at i (never more than 31)
    private static int rootQ, rootP, amount;
    //amount =rank
    //n= length
    //id= if or not
    //cont=>number where it is

    public static void point(int x, int y) {
        number = (x - 1) * n + y;
    }

    public static void UF(int N) {
        if (N < 0) {
            throw new IllegalArgumentException();
        }
        parent = new int[N];
        child = new int[N];
        change = new int[N / 4];
        for (int i = 0; i < N; i++) {
            parent[i] = i;
            child[i] = 0;
        }
    }

    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N - 1));
        }
    }

    public static void union(int p, int q) {
        rootP = parent[p];
        rootQ = parent[q];
        if (rootP == rootQ) {
            return;
        }
        // make root of smaller rank point to root of larger rank
        if (rootP < rootQ) {
            parent[rootQ] = rootP;
        } else if (rootP > rootQ) {
            parent[rootP] = rootQ;
        }
//        count--;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] fund = br.readLine().split("","");
            n = Integer.parseInt(fund[0]);
            place = new int[2];
            place[0] = Integer.parseInt(fund[1]);
            place[1] = Integer.parseInt(fund[2]);
            id = new int[n * n + 2];
            x = 0;
            for (int i = 1; i <= n * n + 1; i++) {
                id[i] = 1;
            }
            count = new int[2];
            String data;
            String[] data1;
            UF(n * n + 2);
            while ((data = br.readLine()) != null) {
                data1 = data.split("","");
                for (int i = 0; i < 2; i++) {
                    count[i] = Integer.parseInt(data1[i]);
                    //define the point
                }
                point(count[0], count[1]);
                id[number] = 0;
                union(0, number);
            }
            amount = 1;
            if (id[1] > 0) {
                parent[1] = amount;
                amount++;
            }
            for (int i = 2; i <= n; i++) {
                if (id[i] > 0) {
                    if (id[i - 1] > 0) {
                        union(i, i - 1);
                    } else {
                        parent[i] = amount;
                        amount++;
                    }
                }
            }
            for (int i = 2; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    point(i, j);
                    if (id[number] > 0) {
                        if (j == 1) {
                            if (id[number - n] > 0) {
                                union(number, number - n);
                            } else {
                                parent[number] = amount;
                                amount++;
                            }
                        } else if (id[number - n] > 0 && id[number - 1] > 0) {
                            if (parent[number - n] < parent[number - 1]) {
                                parent[number] = parent[number - n];
                                child[number] = parent[number - 1];
                                change[x] = parent[number - n];
                                x++;
                                change[x] = parent[number - 1];
                                x++;
                            } else if (parent[number - n] > parent[number - 1]) {
                                parent[number] = parent[number - 1];
                                child[number] = parent[number - n];
                                change[x] = parent[number - 1];
                                x++;
                                change[x] = parent[number - n];
                                x++;
                            } else {
                                if (parent[number - n] <= parent[number - 1]) {
                                    union(number, number - n);
                                } else {
                                    union(number, number - 1);
                                }
                            }
                        } else if (id[number - n] > 0) {
                            union(number, number - n);
                        } else {
                            if (id[number - 1] > 0) {
                                union(number, number - 1);
                            } else {
                                parent[number] = amount;
                                amount++;
                            }
                        }
                    }
                }
            }
            point(place[0], place[1]);
            for (int i = 1; i < x; i = i + 2) {
                if (parent[number] == change[i]) {
                    parent[number] = change[i - 1];
                    break;
                }
            }
            for (int i = 1; i < x; i = i + 2) {
                if (parent[number] == change[i]) {
                    parent[number] = change[i - 1];
                    break;
                }
            }
            for (int i = 1; i < x; i = i + 2) {
                if (parent[number] == change[i]) {
                    parent[number] = change[i - 1];
                    break;
                }
            }

            System.out.println(parent[number]);
        }
    }
}

@e499e10a71b47ef058511e34fe132a33@"
"r04921028","7","0.64","105568","@f07bfaebc12be74716a28ab2812a4df8@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        UF uf = new UF(3*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    else if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    else if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                    else if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0&&M[i-1][j]<0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]<0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                M[i][j] = M[i][j-1];
                                uf.union(M[i][j-1],M[i-1][j]);
                            }
                            else{
                                M[i][j] = M[i-1][j];
                                uf.union(M[i-1][j],M[i][j-1]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]>0){
//                    System.out.print(uf.find(M[i][j])+"" "");
//                }else{
//                    System.out.print(""0""+"" "");
//                }
//            }
//            System.out.print(""\n"");
//        }
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@f07bfaebc12be74716a28ab2812a4df8@"
"r03723070","9","1.12","130736","@68e6d9738729ed7f628e12cca9a257d7@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1];
                           if( data[i-1][j] > 0){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                           if(connect[q]==0&&connect[p]==0) {
                               connect[q] = q;
                               connect[p] = q;
                           }
                           
                           if(connect[q]!=0||connect[p]!=0){
                               if(connect[p]!=0&&connect[q]!=0){
                                   int op =Math.max(connect[q],connect[p]);
                                   int oq =Math.min(connect[q],connect[p]);
                                    connect[p] = oq;
                                    connect[q] = oq;
                                    //correct the root
                                    for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                                    }
                               }
                               else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                   connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }
                                   
                               connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root
                           
                       }
                           
                       }
                    else{
                           data[i][j] =data[i-1][j];
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    



@68e6d9738729ed7f628e12cca9a257d7@"
"r03723070","9","1.1","136288","@3cb306d01749ec86ad25b1e9c7c7d854@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1];
                           if( data[i-1][j] > 0){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                           if(connect[q]==0&&connect[p]==0) {
                               connect[q] = q;
                               connect[p] = q;
                           }
                           
                           if(connect[q]!=0||connect[p]!=0){
                               if(connect[p]!=0&&connect[q]!=0){
                                   int op =Math.max(connect[q],connect[p]);
                                   int oq =Math.min(connect[q],connect[p]);
                                    connect[p] = oq;
                                    connect[q] = oq;
                                    //correct the root
                                    for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                                    }
                               }
                               else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                  // connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }
                                   
                               //connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root
                           
                       }
                           
                       }
                    else{
                           data[i][j] =data[i-1][j];
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    



@3cb306d01749ec86ad25b1e9c7c7d854@"
"r03723070","9","1.12","134960","@c289bf710bd0ac7f065250a23958fccc@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       if(data[1][1]==-1)
           count = 2;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1];
                           if( data[i-1][j] > 0){
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                           if(connect[q]==0&&connect[p]==0) {
                               connect[q] = q;
                               connect[p] = q;
                           }
                           
                           if(connect[q]!=0||connect[p]!=0){
                               if(connect[p]!=0&&connect[q]!=0){
                                   int op =Math.max(connect[q],connect[p]);
                                   int oq =Math.min(connect[q],connect[p]);
                                    connect[p] = oq;
                                    connect[q] = oq;
                                    //correct the root
                                    for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                                    }
                               }
                               else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                  // connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }
                                   
                               //connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root
                           
                       }
                           
                       }
                    else{
                           data[i][j] =data[i-1][j];
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    



@c289bf710bd0ac7f065250a23958fccc@"
"r03723070","9","1.11","133312","@584d890b51c4a49e9a0f461491be6f19@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       //if(data[1][1]==-1)
           //count = 2;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1];
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                           int p = Math.max(data[i][j-1],data[i-1][j]);
                           int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                           if(connect[q]==0&&connect[p]==0) {
                               connect[q] = q;
                               connect[p] = q;
                           }
                           
                           if(connect[q]!=0||connect[p]!=0){
                               if(connect[p]!=0&&connect[q]!=0){
                                   int op =Math.max(connect[q],connect[p]);
                                   int oq =Math.min(connect[q],connect[p]);
                                    connect[p] = oq;
                                    connect[q] = oq;
                                    //correct the root
                                    for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                                    }
                               }
                               else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                  // connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }
                                   
                               //connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root
                           
                       }
                           
                       }
                    else{
                           data[i][j] =data[i-1][j];
                           //System.out.printf(""to carry data[%d][%d] is %d\n\n"",i,j,data[i][j]);     
                       }
                   
               }
               //record it to p,q
              
           }
       }
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i<N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    



@584d890b51c4a49e9a0f461491be6f19@"
"b03611003","8","0.9","121824","@d653f4fee77017d7f58230386b7a0821@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 *
 *
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    private static int[][] CC;
    private static int[][] borw;
    private static int[] id;
//    CC: 每個格子中的cc
//    borw: 每個格子是黑是白

    public LabelCC(int N) {
        CC = new int[N][N];
        borw = new int[N][N];
        id = new int[(N * N + 1) / 2];
        for (int i = 0; i < (N * N + 1) / 2; i++) {
            id[i] = i;
        }

    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

//          part1
            String[] dataf = br.readLine().split("","");

            LabelCC labelcc = new LabelCC(Integer.parseInt(dataf[0]));
            int N = Integer.parseInt(dataf[0]);

            while (Boolean.TRUE) {
                String data = br.readLine();

                if (data != null) {
                    String[] randc = new String[2];
                    randc = data.split("","");
                    borw[Integer.parseInt(randc[0]) - 1][Integer.parseInt(randc[1]) - 1] = 1;
                } else {
                    break;
                }
            }

//           part2
            int labelnow = 1;

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (borw[i][j] == 0) {
                        switch (i) {
                            case 0:
//                                最左邊一排
                                if (j == 0) {
                                    CC[0][0] = labelnow;
                                    labelnow++;
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        CC[i][j] = CC[i][j - 1];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
                                }
                                break;
                            default:
                                if (j == 0) {
                                    if (borw[i - 1][j] == 0) {
                                        CC[i][j] = CC[i - 1][j];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
//                                    最上面一排
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        if (borw[i - 1][j] == 0) {
//                                            左跟上都有
                                            if (root(CC[i][j - 1]) > root(CC[i - 1][j])) {
                                                id[CC[i][j - 1]] = root(CC[i - 1][j]);
                                                CC[i][j] = CC[i - 1][j];
                                            } else if (root(CC[i][j - 1]) == root(CC[i - 1][j])) {
                                                CC[i][j] = CC[i - 1][j];
                                            } else {
                                                id[CC[i - 1][j]] = root(CC[i][j - 1]);
                                                CC[i][j] = CC[i][j - 1];
                                            }

                                        } else {
//                                            上有左沒有
                                            CC[i][j] = CC[i][j - 1];
                                        }
                                    } else {
                                        if (borw[i - 1][j] == 0) {
//                                            左有上沒有
                                            CC[i][j] = CC[i - 1][j];
                                        } else {
//                                            都沒有
                                            CC[i][j] = labelnow;
                                            labelnow++;
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }

//            part3
            for (int i = 0; i < (N * N + 1) / 2; i++) {
                id[i] = root(i);
            }

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (borw[i][j] == 0) {
                        CC[i][j] = root(CC[i][j]);

                    }
                }
            }
            
            int r = Integer.parseInt(dataf[1]) - 1;
            int c = Integer.parseInt(dataf[2]) - 1;
            
            System.out.print(CC[r][c]);
//            System.out.print(id[CC[6][4]]);
        }
    }

}

@d653f4fee77017d7f58230386b7a0821@"
"b03611035","9","1.9","140080","@e7ca05fd337167b23fde1113c6b5c9a1@import java.io.FileReader;
import java.io.BufferedReader;


public class LabelCC {
    public static void main(String[] args) throws Exception {
           // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            //IC for initial condition which is given by the first row
            String IC[]=new String[3];
            IC=br.readLine().split("","");
            int order=Integer.parseInt(IC[0]);
            //matrix called clo for blocked sites
            String clo[][]=new String[order*order][2];            
            
            //N-N Grid called opcl，多創一圈待會好處理
            int opcl[][]=new int[order+2][order+2];            
            for(int i=1;i<=order;i++){
                for(int j=1;j<=order;j++){
                    opcl[i][j]=-1;
                }
            }
            
            //New UF object
            UF gg=new UF(order*order);
            
            //read the assigned blocked sites
            String[] readd;
            int a=0;
            while(br.ready()){
                readd=br.readLine().split("","");
                clo[a][0]=readd[0];
                clo[a][1]=readd[1];
                a++;
            }
            //共有a組座標<我剛剛發現的，不設count就是爽
            
            //block the assigned blocked sites
           for(int i=0;i<a;i++){
               int row=Integer.parseInt(clo[i][0]);
               int column=Integer.parseInt(clo[i][1]);
               opcl[row][column]=0;
           }
                              
          //Start our algorithm although I don't even understand it.
           int label=1;
               //Step 1
           for(int row=1;row<=order;row++){
               for(int column=1;column<=order;column++){
                   //if blocked, don't do anything
                   if(opcl[row][column]==0)
                       ;
                   //if only up is labeled
                   else if((opcl[row-1][column]!=0)&&(opcl[row][column-1]==0)){
                       opcl[row][column]=opcl[row-1][column];
                       gg.union((row-2)*order+column-1,(row-1)*order+column-1);
                   }
                   //if only left is labeled
                   else if((opcl[row][column-1]!=0)&&(opcl[row-1][column]==0)){
                       opcl[row][column]=opcl[row][column-1];
                       gg.union((row-1)*order+column-2,(row-1)*order+column-1);                      
                   }
                   //if both up and left are labeled
                   else if((opcl[row][column-1]!=0)&&(opcl[row-1][column]!=0)){
                       opcl[row][column]=opcl[row][column-1];
                       //檢查左跟上的root，取小的自己連過去，把另一個也連過去<<其實可以不用，反正下面還要再喬一次
                       //左小
                            if(gg.find((row-1)*order+column-2)<=(gg.find((row-2)*order+column-1))){
                                 gg.union((row-1)*order+column-2,(row-1)*order+column-1);  
                                 gg.union((row-1)*order+column-1,(row-2)*order+column-1);
                            }
                       //上小
                            else if(gg.find((row-1)*order+column-2)>(gg.find((row-2)*order+column-1))){
                                 gg.union((row-2)*order+column-1,(row-1)*order+column-1);  
                                 gg.union((row-1)*order+column-1,(row-1)*order+column-2);
                            }
                       }     
                   //if neither up nor left is labeled
                   else if((opcl[row][column-1]==0)&&(opcl[row-1][column]==0)){         
                       opcl[row][column]=label;                       
                       label++;                       
                   }
               }
           }
                //Step 2; 自己非黑塊，與其他open block union時，若label不同，取小的
                for(int row=1;row<=order;row++){
                    for(int column=1;column<=order;column++){
                        
                        if(opcl[row][column]!=0){
                            
                            for(int i=row;i>=1;i--){
                                for(int j=order;j>=1;j--){
                                    int id=(i-1)*order+j-1;
                                    if(gg.connected((row-1)*order+column-1,id)){                                    
                                        if(opcl[row][column]<opcl[i][j]){
                                        int x=opcl[row][column];
                                        opcl[i][j]=x;                                        
                                        }
                                        else if(opcl[row][column]>opcl[i][j]){
                                        int x=opcl[i][j];
                                        opcl[row][column]=x;                                        
                                        }
                                }
                            }
                            }
                        }
                   }
                 }
        System.out.println(opcl[Integer.parseInt(IC[1])][Integer.parseInt(IC[2])]);
        }
    }

    private static class UF {//UF.union(X,Y)會把Y連給X

        private int[] parent;   // parent[i] = parent of i
        private int[] size;     // size[i] = number of sites in subtree rooted at i
        private int count;      // number of components
        
        public UF(int x) {//constructor
            count=x;
            parent=new int[x];
            size=new int[x];
            for(int i=0;i<count;i++){
                parent[i]=i;
                size[i]=1;
            }           
        }
        
        public int count(){
            return count;
        }
        
        public int find(int p) {
            while (p != parent[p])
                p = parent[p];
            return p;
        }
        
        public boolean connected(int p, int q) {
            return find(p) == find(q);
        }
        
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ) return;
            
        // make smaller root point to larger one
        if (rootP < rootQ) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        }
        else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
        }
    }
    }
    
@e7ca05fd337167b23fde1113c6b5c9a1@"
"r04921074","9","1.02","126832","@5082e6299e088a8dcf167fdaf023d5d8@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class LabelCC {    
    public static void main(String[] args) throws IOException{    
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
    
    String[] inf = br.readLine().split("","");
    int N =  Integer.parseInt(inf[0]); //N is scale of grids
    int[][] matrix;
            matrix = new int[N+1][N+1];
    
    UF uf = new UF(N*N/2);        
            
    int[] target;
          target = new int[2];
   
    target[0] =  Integer.parseInt(inf[1]);         //_______type:location of target = (target[0],target[1])______
    target[1] =  Integer.parseInt(inf[2]);         //store value of target    
    
    int row = 0; //max of element is n*n  // store for input X-axis in order of [i]
    int column = 0; //max of element is n*n  // store for input Y-axis in order of [i]
    int counting = 0;
    
    for(int x=1; x<N+1; x++){
        for(int y=1; y<N+1; y++){
           matrix[x][y]=1; 
        }
    }
   
//....................................specify the block grids ** scale of n **-------------------------------
     while (br.ready()){
         String[] num = br.readLine().split("","");
         
         row = Integer.parseInt(num[0]);     //asume a metrix is way as  M[row][column]
         column = Integer.parseInt(num[1]);
         
         matrix[row][column]=0;
             
    }//end of while (and input function part)

//------------------------------------first path** scale of N^2 **------------------------------------------- 
        int lable = 0;
        int wrong = 0;
        for(int y=1; y<N+1; y++){
            for(int x=1; x<N+1; x++){
                if(matrix[y][x]!=0){
                    
                    if( (matrix[y][x-1]==0)&&(matrix[y-1][x]==0) ){
                        lable++ ;
                        matrix[y][x] = lable;
                    }//slave if(1)  ----create new lable
                    if( (matrix[y][x-1]==matrix[y-1][x])&&(matrix[y-1][x]!=0) ){
                        matrix[y][x] = matrix[y][x-1];
                    }//slave if(2)  ----lable follower (type1)
                    if( ((matrix[y][x-1]==0) || (matrix[y-1][x]==0)) && ((matrix[y][x-1]!=0) || (matrix[y-1][x]!=0)) ){
                        matrix[y][x] = Math.max(matrix[y-1][x],matrix[y][x-1]);
                    }//slave if(3)  ----lable follower (type2)
                    if( matrix[y][x-1]!=0 && matrix[y-1][x]!=0 && (matrix[y][x-1]!= matrix[y-1][x]) ){
                        matrix[y][x] = Math.min(matrix[y-1][x],matrix[y][x-1]);
                        uf.union(Math.min(matrix[y-1][x],matrix[y][x-1]), Math.max(matrix[y-1][x],matrix[y][x-1]));
                    }//slave if(4)  ----lable chooser  (cc is needed)
                    else 
                        ;
                                         
                }//end of master if
            
                else matrix[y][x]=0;   //master else
            }//end of for-x
        }//end of for-y
//-------------------------------------------------------------------------------------------------------------
     /*   for(int y=1; y<N+1; y++){
            System.out.printf(""\n"");
            for(int x=1; x<N+1; x++){
                System.out.print(matrix[y][x]+"" ""); 
            }
        } System.out.printf(""\n"");//print matrix*/
        
        if( (matrix[target[0]][target[1]]>0)&&(N!=1) ){
            System.out.println(uf.find(matrix[target[0]][target[1]]));
        }
        if( (matrix[target[0]][target[1]]==0)&&(N!=1)){
            System.out.println(0);
        }
        if(N==1){
            if(target[0]==0){
                System.out.println(1);
            }
            else System.out.println(0);
        }


            }//end of try
        }//end of main
    
}//end of class

@5082e6299e088a8dcf167fdaf023d5d8@"
"r04921074","9","1.01","123312","@2df362cfd369b11b06c529d5e4912f26@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class LabelCC {    
    public static void main(String[] args) throws IOException{    
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
    
    String[] inf = br.readLine().split("","");
    int N =  Integer.parseInt(inf[0]); //N is scale of grids
    int[][] matrix;
            matrix = new int[N+1][N+1];
    
    UF uf = new UF(N*N/2);        
            
    int[] target;
          target = new int[2];
   
    target[0] =  Integer.parseInt(inf[1]);         //_______type:location of target = (target[0],target[1])______
    target[1] =  Integer.parseInt(inf[2]);         //store value of target    
    
    int row = 0; //max of element is n*n  // store for input X-axis in order of [i]
    int column = 0; //max of element is n*n  // store for input Y-axis in order of [i]
    int counting = 0;
    
    for(int x=1; x<N+1; x++){
        for(int y=1; y<N+1; y++){
           matrix[x][y]=1; 
        }
    }
   
//....................................specify the block grids ** scale of n **-------------------------------
     while (br.ready()){
         String[] num = br.readLine().split("","");
         
         row = Integer.parseInt(num[0]);     //asume a metrix is way as  M[row][column]
         column = Integer.parseInt(num[1]);
         
         matrix[row][column]=0;
             
    }//end of while (and input function part)

//------------------------------------first path** scale of N^2 **------------------------------------------- 
        int lable = 0;
        int wrong = 0;
        for(int y=1; y<N+1; y++){
            for(int x=1; x<N+1; x++){
                if(matrix[y][x]!=0){
                    
                    if( (matrix[y][x-1]==0) && (matrix[y-1][x]==0) ){
                        lable++ ;
                        matrix[y][x] = lable;
                    }//slave if(1)  ----create new lable
                    else if( (matrix[y][x-1]==matrix[y-1][x])&&(matrix[y-1][x]!=0) ){
                        matrix[y][x] = matrix[y][x-1];
                    }//slave if(2)  ----lable follower (type1)
                    else if( ((matrix[y][x-1]==0) || (matrix[y-1][x]==0)) && ((matrix[y][x-1]!=0) || (matrix[y-1][x]!=0)) ){
                        matrix[y][x] = Math.max(matrix[y-1][x],matrix[y][x-1]);
                    }//slave if(3)  ----lable follower (type2)
                    else if( matrix[y][x-1]!=0 && matrix[y-1][x]!=0 && (matrix[y][x-1]!= matrix[y-1][x]) ){
                        matrix[y][x] = Math.min(matrix[y-1][x],matrix[y][x-1]);
                        uf.union(Math.min(matrix[y-1][x],matrix[y][x-1]), Math.max(matrix[y-1][x],matrix[y][x-1]));
                    }//slave if(4)  ----lable chooser  (cc is needed)
                    else {
                        wrong ++;
                        System.out.println(""Warnning!some proccessing is wrong. wronging path : ""+wrong);
                    }                
                }//end of master if
            
                else matrix[y][x]=0;   //master else
            }//end of for-x
        }//end of for-y
//-------------------------------------------------------------------------------------------------------------
     /*   for(int y=1; y<N+1; y++){
            System.out.printf(""\n"");
            for(int x=1; x<N+1; x++){
                System.out.print(matrix[y][x]+"" ""); 
            }
        } System.out.printf(""\n"");//print matrix*/
        
        if( (matrix[target[0]][target[1]]>0)&&(N!=1) ){
            System.out.println(uf.find(matrix[target[0]][target[1]]));
        }
        if( (matrix[target[0]][target[1]]==0)&&(N!=1)){
            System.out.println(0);
        }
        if(N==1){
            if(target[0]==0){
                System.out.println(1);
            }
            else System.out.println(0);
        }


            }//end of try
        }//end of main
    
}//end of class
@2df362cfd369b11b06c529d5e4912f26@"
"r04921074","9","1","123200","@232c2abac00276b1098d1fa606690704@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class LabelCC {    
    public static void main(String[] args) throws IOException{    
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
    
    String[] inf = br.readLine().split("","");
    int N =  Integer.parseInt(inf[0]); //N is scale of grids
    int[][] matrix;
            matrix = new int[N+1][N+1];
    
    UF uf = new UF(N*N/2);        
            
    int[] target;
          target = new int[2];
   
    target[0] =  Integer.parseInt(inf[1]);         //_______type:location of target = (target[0],target[1])______
    target[1] =  Integer.parseInt(inf[2]);         //store value of target    
    
    int row = 0; //max of element is n*n  // store for input X-axis in order of [i]
    int column = 0; //max of element is n*n  // store for input Y-axis in order of [i]
    int counting = 0;
    
    for(int x=1; x<N+1; x++){
        for(int y=1; y<N+1; y++){
           matrix[x][y]=1; 
        }
    }
   
//....................................specify the block grids ** scale of n **-------------------------------
     while (br.ready()){
         String[] num = br.readLine().split("","");
         
         row = Integer.parseInt(num[0]);     //asume a metrix is way as  M[row][column]
         column = Integer.parseInt(num[1]);
         
         matrix[row][column]=0;
             
    }//end of while (and input function part)

//------------------------------------first path** scale of N^2 **------------------------------------------- 
        int lable = 0;
        int wrong = 0;
        for(int y=1; y<N+1; y++){
            for(int x=1; x<N+1; x++){
                if(matrix[y][x]!=0){
                    
                    if( (matrix[y][x-1]==0) && (matrix[y-1][x]==0) ){
                        lable++ ;
                        matrix[y][x] = lable;
                    }//slave if(1)  ----create new lable
                    else if( (matrix[y][x-1]==matrix[y-1][x])&&(matrix[y-1][x]!=0) ){
                        matrix[y][x] = matrix[y][x-1];
                    }//slave if(2)  ----lable follower (type1)
                    else if( ((matrix[y][x-1]==0) || (matrix[y-1][x]==0)) && ((matrix[y][x-1]!=0) || (matrix[y-1][x]!=0)) ){
                        matrix[y][x] = Math.max(matrix[y-1][x],matrix[y][x-1]);
                    }//slave if(3)  ----lable follower (type2)
                    else if( matrix[y][x-1]!=0 && matrix[y-1][x]!=0 && (matrix[y][x-1]!= matrix[y-1][x]) ){
                        matrix[y][x] = Math.min(matrix[y-1][x],matrix[y][x-1]);
                        uf.union(Math.min(matrix[y-1][x],matrix[y][x-1]), Math.max(matrix[y-1][x],matrix[y][x-1]));
                    }//slave if(4)  ----lable chooser  (cc is needed)
                    else {
                        wrong ++;
                        System.out.println(""Warnning!some proccessing is wrong. wronging path : ""+wrong);
                    }                
                }//end of master if
            
                else matrix[y][x]=0;   //master else
            }//end of for-x
        }//end of for-y
//-------------------------------------------------------------------------------------------------------------
     /*   for(int y=1; y<N+1; y++){
            System.out.printf(""\n"");
            for(int x=1; x<N+1; x++){
                System.out.print(matrix[y][x]+"" ""); 
            }
        } System.out.printf(""\n"");//print matrix*/
        
        if( (matrix[target[0]][target[1]]>0)&&(N!=1) ){
            System.out.println(uf.find(matrix[target[0]][target[1]]));
        }
        else if( (matrix[target[0]][target[1]]==0)&&(N!=1)){
            System.out.println(0);
        }
        else if(N==1){
            if(target[0]==0){
                System.out.println(1);
            }
            else System.out.println(0);
        }
        else
        {
            System.out.println(""Warnning!some proccessing is wrong."");
        }

            }//end of try
        }//end of main
    
}//end of class
@232c2abac00276b1098d1fa606690704@"
"b03611003","9","0.97","125712","@5ba3aff73511809ea965f3ddcf3bb19f@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
// package labelcc;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 *
 *
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    private static int[][] CC;
    private static int[][] borw;
    private static int[] id;
//    CC: 每個格子中的cc
//    borw: 每個格子是黑是白

    public LabelCC(int N) {
        CC = new int[N][N];
        borw = new int[N][N];
        id = new int[(N * N + 1) / 2];
        for (int i = 0; i < (N * N + 1) / 2; i++) {
            id[i] = i;
        }

    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

//          part1
            String[] dataf = br.readLine().split("","");

            LabelCC labelcc = new LabelCC(Integer.parseInt(dataf[0]));
            int N = Integer.parseInt(dataf[0]);

            while (Boolean.TRUE) {
                String data = br.readLine();

                if (data != null) {
                    String[] randc = new String[2];
                    randc = data.split("","");
                    borw[Integer.parseInt(randc[0]) - 1][Integer.parseInt(randc[1]) - 1] = 1;
                } else {
                    break;
                }
            }

//           part2
            int labelnow = 1;

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (borw[i][j] == 0) {
                        switch (i) {
                            case 0:
//                                最左邊一排
                                if (j == 0) {
                                    CC[0][0] = labelnow;
                                    labelnow++;
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        CC[i][j] = CC[i][j - 1];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
                                }
                                break;
                            default:
                                if (j == 0) {
                                    if (borw[i - 1][j] == 0) {
                                        CC[i][j] = CC[i - 1][j];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
//                                    最上面一排
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        if (borw[i - 1][j] == 0) {
//                                            左跟上都有
                                            if (root(CC[i][j - 1]) > root(CC[i - 1][j])) {
                                                id[CC[i][j - 1]] = root(CC[i - 1][j]);
                                                CC[i][j] = CC[i - 1][j];
                                            } else if (root(CC[i][j - 1]) == root(CC[i - 1][j])) {
                                                CC[i][j] = CC[i - 1][j];
                                            } else {
                                                id[CC[i - 1][j]] = root(CC[i][j - 1]);
                                                CC[i][j] = CC[i][j - 1];
                                            }

                                        } else {
//                                            上有左沒有
                                            CC[i][j] = CC[i][j - 1];
                                        }
                                    } else {
                                        if (borw[i - 1][j] == 0) {
//                                            左有上沒有
                                            CC[i][j] = CC[i - 1][j];
                                        } else {
//                                            都沒有
                                            CC[i][j] = labelnow;
                                            labelnow++;
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }

//            part3
            for (int i = 0; i < (N * N + 1) / 2; i++) {
                id[i] = root(i);
            }

//            for (int i = 0; i < N; i++) {
//                for (int j = 0; j < N; j++) {
//                    if (borw[i][j] == 0) {
//                        CC[i][j] = root(CC[i][j]);
//
//                    }
//                }
//            }
            
            int r = Integer.parseInt(dataf[1]) - 1;
            int c = Integer.parseInt(dataf[2]) - 1;
            
            System.out.print(root(CC[r][c]));
//            System.out.print(id[CC[6][4]]);
        }
    }

}

@5ba3aff73511809ea965f3ddcf3bb19f@"
"r04921074","9","0.99","125424","@9a32b4316aa2534f560611d563ee3c88@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class LabelCC {    
    public static void main(String[] args) throws IOException{    
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
    
    String[] inf = br.readLine().split("","");
    int N =  Integer.parseInt(inf[0]); //N is scale of grids
    int[][] matrix;
            matrix = new int[N+1][N+1];
    
    UF uf = new UF(N*N/2);        
            
    int[] target;
          target = new int[2];
   
    target[0] =  Integer.parseInt(inf[1]);         //_______type:location of target = (target[0],target[1])______
    target[1] =  Integer.parseInt(inf[2]);         //store value of target    
    
    int row = 0; //max of element is n*n  // store for input X-axis in order of [i]
    int column = 0; //max of element is n*n  // store for input Y-axis in order of [i]
    int counting = 0;
    
    for(int x=1; x<N+1; x++){
        for(int y=1; y<N+1; y++){
           matrix[x][y]=1; 
        }
    }
   
//....................................specify the block grids ** scale of n **-------------------------------
     while (br.ready()){
         String[] num = br.readLine().split("","");
         
         row = Integer.parseInt(num[0]);     //asume a metrix is way as  M[row][column]
         column = Integer.parseInt(num[1]);
         
         matrix[row][column]=0;
             
    }//end of while (and input function part)

//------------------------------------first path** scale of N^2 **------------------------------------------- 
        int lable = 0;
        int wrong = 0;
        for(int y=1; y<N+1; y++){
            for(int x=1; x<N+1; x++){
                if(matrix[y][x]!=0){
                    
                    if( (matrix[y][x-1]==0) && (matrix[y-1][x]==0) ){
                        lable++ ;
                        matrix[y][x] = lable;
                    }//slave if(1)  ----create new lable
                    else if( (matrix[y][x-1]==matrix[y-1][x])&&(matrix[y-1][x]!=0) ){
                        matrix[y][x] = matrix[y][x-1];
                    }//slave if(2)  ----lable follower (type1)
                    else if( ((matrix[y][x-1]==0) || (matrix[y-1][x]==0)) && ((matrix[y][x-1]!=0) || (matrix[y-1][x]!=0)) ){
                        matrix[y][x] = Math.max(matrix[y-1][x],matrix[y][x-1]);
                    }//slave if(3)  ----lable follower (type2)
                    else if( matrix[y][x-1]!=0 && matrix[y-1][x]!=0 && (matrix[y][x-1]!= matrix[y-1][x]) ){
                        matrix[y][x] = Math.min(matrix[y-1][x],matrix[y][x-1]);
                        uf.union(Math.min(matrix[y-1][x],matrix[y][x-1]), Math.max(matrix[y-1][x],matrix[y][x-1]));
                    }//slave if(4)  ----lable chooser  (cc is needed)
                    else {
                        wrong ++;
                        System.out.println(""Warnning!some proccessing is wrong. wrong path : ""+wrong);
                    }                
                }//end of master if
            
                else matrix[y][x]=0;   //master else
            }//end of for-x
        }//end of for-y
//-------------------------------------------------------------------------------------------------------------
     /*   for(int y=1; y<N+1; y++){
            System.out.printf(""\n"");
            for(int x=1; x<N+1; x++){
                System.out.print(matrix[y][x]+"" ""); 
            }
        } System.out.printf(""\n"");//print matrix*/
        
        if( (matrix[target[0]][target[1]]>0)&&(N!=1) ){
            System.out.println(uf.find(matrix[target[0]][target[1]]));
        }
        else if( (matrix[target[0]][target[1]]==0)&&(N!=1)){
            System.out.println(0);
        }
        else if(N==1){
            if(row==0){
                System.out.println(1);
            }
            else System.out.println(0);
        }
        else
        {
            System.out.println(""Warnning!some proccessing is wrong."");
        }

            }//end of try
        }//end of main
    
}//end of class
@9a32b4316aa2534f560611d563ee3c88@"
"r04945022","0","0.99","125424","@ce1846471277e831ce71743412edcd24@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import edu.princeton.cs.algs4.QuickUnionUF;

/**
 *
 * @author Daniel
 */
public class LabelCC {
  private int [] states;
  private int [] labnumber;
  private int side;
  QuickUnionUF uf = new QuickUnionUF(10);
  
  public void creatematrix(int N){
        side = N;
        states=new int[N*N];
        labnumber = new int [N*N];
        for(int index=0;index<N*N;index++){
           states[index]=1;
           labnumber[index]=0;
       }
    }
    public void block(int i, int j){
       checkRange(i,j);
       int cell=getCellIndex(i,j);
       states[cell]=0;
    }
    private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
    public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
    private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
    private void firstpassLabel(){
        for(int i=1;i<=side;i++){
            for(int j=1;j<+side;j++){
                while(isOpen(i,j)){
                    creatnewLabel(i,j);
                }
            }
        }
        
    }
    private int secpassLabel(int n, int m){
            int out = getCellIndex(n, m);
            int output = uf.find(out);
            return output;
        }
    
    private void creatnewLabel(int i, int j){
        //for top rows
        int count = 1;
        int cell = getCellIndex(i,j);
        if(i==1 && j==1) labnumber[cell]=count;
        if(i==1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
                }else{
                ++count;
                labnumber[cell]=count;
            }         
        }
        // for other rows
        if(i!=1 ){
            int leastnumb;
            if(isOpen(i,j-1)){
                leastnumb = labnumber[getCellIndex(i,j-1)];
                labnumber[cell] = leastnumb;
                if(labnumber[getCellIndex(i-1,j)]!=0){
                    uf.union(labnumber[getCellIndex(i-1,j)],labnumber[getCellIndex(i,j-1)]);
                    if(labnumber[getCellIndex(i-1,j)]>leastnumb){
                        labnumber[cell] = leastnumb;
                    }else{
                        labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                    }
                    
                }
            }else if(labnumber[getCellIndex(i-1,j)]!=0){
                labnumber[cell] = labnumber[getCellIndex(i-1,j)];
            }
            else{
                ++count;
                labnumber[cell]=count;
            }
           
        }
        
    }
   
    public static void main(String[] args) throws IOException{
        LabelCC L1 = new LabelCC();
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int input1 = 0 , input2 = 0 , input3 = 0;
        String firstline = br.readLine();
        String[] inputarray = firstline.split("","");
        input1 = Integer.parseInt(inputarray[1]);
        input2 = Integer.parseInt(inputarray[2]);
        input3 = Integer.parseInt(inputarray[3]);
//        QuickUnionUF uf = new QuickUnionUF(input1);
        L1.creatematrix(input1);
        String data = null;
        String [] inputnumb;
        int a=0, b=0;
        while((data = br.readLine())!=null){
             inputnumb = data.split("","");
             a = Integer.parseInt(inputnumb[0]);
             b = Integer.parseInt(inputnumb[1]);
             L1.block(a,b);
    }
            L1.firstpassLabel();
            System.out.println(L1.secpassLabel(input2, input3));
                        
        
}

    
}

@ce1846471277e831ce71743412edcd24@"
"r04945022","0","0","0","@4d18eaa071d23c607297cb9ec2127122@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
/**
 *
 * @author Daniel
 */
public class LabelCC {
  private int [] states;
  private int [] labnumber;
  private int side;
  QuickUnionUF uf = new QuickUnionUF(10);
  
  public void creatematrix(int N){
        side = N;
        states=new int[N*N];
        labnumber = new int [N*N];
        for(int index=0;index<N*N;index++){
           states[index]=1;
           labnumber[index]=0;
       }
    }
    public void block(int i, int j){
       checkRange(i,j);
       int cell=getCellIndex(i,j);
       states[cell]=0;
    }
    private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
    public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
    private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
    private void firstpassLabel(){
        for(int i=1;i<=side;i++){
            for(int j=1;j<+side;j++){
                while(isOpen(i,j)){
                    creatnewLabel(i,j);
                }
            }
        }
        
    }
    private int secpassLabel(int n, int m){
            int out = getCellIndex(n, m);
            int output = uf.find(out);
            return output;
        }
    
    private void creatnewLabel(int i, int j){
        //for top rows
        int count = 1;
        int cell = getCellIndex(i,j);
        if(i==1 && j==1) labnumber[cell]=count;
        if(i==1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
                }else{
                ++count;
                labnumber[cell]=count;
            }         
        }
        // for other rows
        if(i!=1 ){
            int leastnumb;
            if(isOpen(i,j-1)){
                leastnumb = labnumber[getCellIndex(i,j-1)];
                labnumber[cell] = leastnumb;
                if(labnumber[getCellIndex(i-1,j)]!=0){
                    uf.union(labnumber[getCellIndex(i-1,j)],labnumber[getCellIndex(i,j-1)]);
                    if(labnumber[getCellIndex(i-1,j)]>leastnumb){
                        labnumber[cell] = leastnumb;
                    }else{
                        labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                    }
                    
                }
            }else if(labnumber[getCellIndex(i-1,j)]!=0){
                labnumber[cell] = labnumber[getCellIndex(i-1,j)];
            }
            else{
                ++count;
                labnumber[cell]=count;
            }
           
        }
        
    }
   
    public static void main(String[] args) throws IOException{
        LabelCC L1 = new LabelCC();
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int input1 = 0 , input2 = 0 , input3 = 0;
        String firstline = br.readLine();
        String[] inputarray = firstline.split("","");
        input1 = Integer.parseInt(inputarray[1]);
        input2 = Integer.parseInt(inputarray[2]);
        input3 = Integer.parseInt(inputarray[3]);
//        QuickUnionUF uf = new QuickUnionUF(input1);
        L1.creatematrix(input1);
        String data = null;
        String [] inputnumb;
        int a=0, b=0;
        while((data = br.readLine())!=null){
             inputnumb = data.split("","");
             a = Integer.parseInt(inputnumb[0]);
             b = Integer.parseInt(inputnumb[1]);
             L1.block(a,b);
    }
            L1.firstpassLabel();
            System.out.println(L1.secpassLabel(input2, input3));
                        
        
}

    
}

@4d18eaa071d23c607297cb9ec2127122@"
"r04945022","0","0","0","@40a3bd58719cc9c206552397547cface@import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;


/**
 *
 * @author Daniel
 */
public class LabelCC {
  private int [] states;
  private int [] labnumber;
  private int side;
  QuickUnionUF uf = new QuickUnionUF(10);
  
  public void creatematrix(int N){
        side = N;
        states=new int[N*N];
        labnumber = new int [N*N];
        for(int index=0;index<N*N;index++){
           states[index]=1;
           labnumber[index]=0;
       }
    }
    public void block(int i, int j){
       checkRange(i,j);
       int cell=getCellIndex(i,j);
       states[cell]=0;
    }
    private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
    public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
    private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
    private void firstpassLabel(){
        for(int i=1;i<=side;i++){
            for(int j=1;j<+side;j++){
                while(isOpen(i,j)){
                    creatnewLabel(i,j);
                }
            }
        }
        
    }
    private int secpassLabel(int n, int m){
            int out = getCellIndex(n, m);
            int output = uf.find(out);
            return output;
        }
    
    private void creatnewLabel(int i, int j){
        //for top rows
        int count = 1;
        int cell = getCellIndex(i,j);
        if(i==1 && j==1) labnumber[cell]=count;
        if(i==1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
                }else{
                ++count;
                labnumber[cell]=count;
            }         
        }
        // for other rows
        if(i!=1 ){
            int leastnumb;
            if(isOpen(i,j-1)){
                leastnumb = labnumber[getCellIndex(i,j-1)];
                labnumber[cell] = leastnumb;
                if(labnumber[getCellIndex(i-1,j)]!=0){
                    uf.union(labnumber[getCellIndex(i-1,j)],labnumber[getCellIndex(i,j-1)]);
                    if(labnumber[getCellIndex(i-1,j)]>leastnumb){
                        labnumber[cell] = leastnumb;
                    }else{
                        labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                    }
                    
                }
            }else if(labnumber[getCellIndex(i-1,j)]!=0){
                labnumber[cell] = labnumber[getCellIndex(i-1,j)];
            }
            else{
                ++count;
                labnumber[cell]=count;
            }
           
        }
        
    }
   
    public static void main(String[] args) throws IOException{
        LabelCC L1 = new LabelCC();
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int input1 = 0 , input2 = 0 , input3 = 0;
        String firstline = br.readLine();
        String[] inputarray = firstline.split("","");
        input1 = Integer.parseInt(inputarray[1]);
        input2 = Integer.parseInt(inputarray[2]);
        input3 = Integer.parseInt(inputarray[3]);
//        QuickUnionUF uf = new QuickUnionUF(input1);
        L1.creatematrix(input1);
        String data = null;
        String [] inputnumb;
        int a=0, b=0;
        while((data = br.readLine())!=null){
             inputnumb = data.split("","");
             a = Integer.parseInt(inputnumb[0]);
             b = Integer.parseInt(inputnumb[1]);
             L1.block(a,b);
    }
            L1.firstpassLabel();
            System.out.println(L1.secpassLabel(input2, input3));
                        
        
}

    
}

@40a3bd58719cc9c206552397547cface@"
"r04945022","0","0","0","@110f9ff624549e5d422d56260f909c0f@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author Daniel
 */
public class LabelCC {
  private int [] states;
  private int [] labnumber;
  private int side;
  QuickUnionUF uf = new QuickUnionUF(10);
  
  public void creatematrix(int N){
        side = N;
        states=new int[N*N];
        labnumber = new int [N*N];
        for(int index=0;index<N*N;index++){
           states[index]=1;
           labnumber[index]=0;
       }
    }
    public void block(int i, int j){
       checkRange(i,j);
       int cell=getCellIndex(i,j);
       states[cell]=0;
    }
    private void checkRange(int i, int j){
       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
     }
    public boolean isOpen(int i, int j){
       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
    private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
    private void firstpassLabel(){
        for(int i=1;i<=side;i++){
            for(int j=1;j<+side;j++){
                while(isOpen(i,j)){
                    creatnewLabel(i,j);
                }
            }
        }
        
    }
    private int secpassLabel(int n, int m){
            int out = getCellIndex(n, m);
            int output = uf.find(out);
            return output;
        }
    
    private void creatnewLabel(int i, int j){
        //for top rows
        int count = 1;
        int cell = getCellIndex(i,j);
        if(i==1 && j==1) labnumber[cell]=count;
        if(i==1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
                }else{
                ++count;
                labnumber[cell]=count;
            }         
        }
        // for other rows
        if(i!=1 ){
            int leastnumb;
            if(isOpen(i,j-1)){
                leastnumb = labnumber[getCellIndex(i,j-1)];
                labnumber[cell] = leastnumb;
                if(labnumber[getCellIndex(i-1,j)]!=0){
                    uf.union(labnumber[getCellIndex(i-1,j)],labnumber[getCellIndex(i,j-1)]);
                    if(labnumber[getCellIndex(i-1,j)]>leastnumb){
                        labnumber[cell] = leastnumb;
                    }else{
                        labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                    }
                    
                }
            }else if(labnumber[getCellIndex(i-1,j)]!=0){
                labnumber[cell] = labnumber[getCellIndex(i-1,j)];
            }
            else{
                ++count;
                labnumber[cell]=count;
            }
           
        }
        
    }
   
    public static void main(String[] args) throws IOException{
        LabelCC L1 = new LabelCC();
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int input1 = 0 , input2 = 0 , input3 = 0;
        String firstline = br.readLine();
        String[] inputarray = firstline.split("","");
        input1 = Integer.parseInt(inputarray[0]);
        input2 = Integer.parseInt(inputarray[1]);
        input3 = Integer.parseInt(inputarray[2]);
//        QuickUnionUF uf = new QuickUnionUF(input1);
        L1.creatematrix(input1);
        String data = null;
        String [] inputnumb;
        int a=0, b=0;
        while((data = br.readLine())!=null){
             inputnumb = data.split("","");
             a = Integer.parseInt(inputnumb[0]);
             b = Integer.parseInt(inputnumb[1]);
             L1.block(a,b);
    }
            L1.firstpassLabel();
            System.out.println(L1.secpassLabel(input2, input3));
                        
        
}

    
}

@110f9ff624549e5d422d56260f909c0f@"
"r02b48003","0","0","0","@cddcbfc1ac3f0ae02f08c91395306e7b@import edu.princeton.cs.algs4.Bag;
import edu.princeton.cs.algs4.In;
import edu.princeton.cs.algs4.WeightedQuickUnionUF;
import java.util.Arrays;
import java.util.Iterator;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class LabelCC {
    private final int dim;
    private Board_ID    board_id;
    private Board_Label board_label;
    private Board_Open  board_open;
    private UF uf;
    
    public LabelCC (int n) {
        dim = n;
        board_id = new Board_ID(n);
        board_label = new Board_Label(n);
        board_open = new Board_Open(n);
        uf = new UF(n*n);
    } // end constructor
    public int getLabel(int row, int col) {
        return board_label.getLabel(row, col);
    } // end func getLabel
    public void setLabel(int row, int col, int value) {
        board_label.setLabel(row, col, value);
    } // end func setLabel
    
    public void setLabelfromRoot(int row, int col, int rootId) {
        int rootRow = rootId / dim + 1;
        int rootCol = rootId % dim + 1;
        setLabel(row, col,
                 board_label.getLabel(rootRow, rootCol));
    } // end func setLabelfromRoot
    
    public void setBlock(int row, int col) {
        board_open.setBlock(row, col);
    } // end func setBlock 
    
    public boolean isBlock(int row, int col) {
        return board_open.isBlock(row, col);
    } // end func isOpen
    
    public boolean isOpen(int row, int col) {
        return board_open.isOpen(row, col);
    } // end func isOpen
    
    public String checkCase(Boolean isOpenUp, Boolean isOpenLf) {
        // case 1: up left neighbors not open or not exist
        // case 2: only up neighbor open and exist
        // case 3: only left neighbor open and exist
        // case 4: up left neighbors exist and open
        String whichCase = """";
        
        if (isOpenUp == null && isOpenLf == null) {whichCase = ""1"";}
        
        if (isOpenUp != null && isOpenLf == null) {
            if (isOpenUp){whichCase = ""2"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp == null && isOpenLf != null) {
            if (isOpenLf){whichCase = ""3"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp != null && isOpenLf != null) {
            if (isOpenUp == true  && isOpenLf == true)  {whichCase = ""4"";}
            if (isOpenUp == true  && isOpenLf == false) {whichCase = ""2"";}
            if (isOpenUp == false && isOpenLf == true)  {whichCase = ""3"";}
            if (isOpenUp == false && isOpenLf == false) {whichCase = ""1"";}
        } // end if
        return whichCase;
    } // end func checkCase
    
    public void passFirst() {
        int label = 1;
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                Integer labelUp  = board_label.getNeighbor(row, col, ""UP"");
                Integer labelLf  = board_label.getNeighbor(row, col, ""LEFT"");
                Integer id       = board_id.getId(row, col);
                Integer idUp     = board_id.getNeighbor(row, col, ""UP"");
                Integer idLf     = board_id.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                
                switch (gridCase) {
                    case ""1"": 
                        //System.out.print(""1 "");
                        setLabel(row, col, label++);
                        break;
                    case ""2"": 
                        //System.out.print(""2 "");
                        uf.union(idUp, id);
                        setLabel(row, col, labelUp);
                        break;
                    case ""3"": 
                        //System.out.print(""3 "");
                        uf.union(idLf, id);
                        setLabel(row, col, labelLf);
                        break;
                    case ""4"": 
                        //System.out.print(""4 "");
                        if (labelUp <= labelLf) {
                            uf.union(idUp, idLf);
                            uf.union(idUp, id);
                            setLabel(row, col, labelUp);
                        } else {
                            uf.union(idLf, idUp);
                            uf.union(idLf, id);
                            setLabel(row, col, labelLf);
                        } // end if-else
                        break;
                    default: 
                        System.out.println(
                            ""Error: LabelCC omit the case: "" + 
                            ""("" + row + "", "" + col + "")"");
                } // end switch
            } // end inner loop
        } // end outer loop
    } // end func passFirst
    
    public void passSecond() {
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                int id = board_id.getId(row, col);
                int root = uf.root(id);
                setLabelfromRoot(row, col, root);
            } // end inner loop
        } // end outer loop
    } // end func passSecond
    
    public void displayOpen(){ 
        System.out.println(""---Display: Open---------"");
        board_open.display();  }
    public void displayLabel() { 
        System.out.println(""---Display: Label--------"");
        board_label.display(); }
    public void displayID() { 
        System.out.println(""---Display: ID-----------"");
        board_id.display();    }
    public void displayRoot()  {
        System.out.println(""---Display: Root---------"");
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.print(uf.root(board_id.getId(row, col)) + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayRoot
    
    public void displayCase()  {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {            
                // check if the grid is open
                if (isBlock(row, col)) {
                    System.out.print(""X "");
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                System.out.print(gridCase + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayCase
    
    public static void main(String[] args) {
        // testing classes
        //Board.main(args);
        //Board_Open.main(args);
        //Board_Label.main(args);
        //Board_ID.main(args);
        //UF.main(args);
        
        // read in the content of a file
        String[] readLines = In.readStrings(args[0]);
        
        // initialization
        String[] line0 = readLines[0].split("","");
        int N         = Integer.valueOf(line0[0]); // prepare for N-by-N grid
        int targetRow = Integer.valueOf(line0[1]); // row of target site: (row, col)
        int targetCol = Integer.valueOf(line0[2]); // col of target site: (row, col)
        LabelCC labelcc = new LabelCC(N);
        
        /*
        System.out.println(
                ""Dimension: "" + N + ""\n"" + 
                ""Target site: "" + ""("" + targetRow + "","" + targetCol + "")"");
        */
        // iterate through the file
        for (String s: Arrays.copyOfRange(readLines, 1, readLines.length)){
            String[] line = s.split("","");
            //System.out.println(s);
            labelcc.setBlock(Integer.valueOf(line[0]), Integer.valueOf(line[1]));
	} // end loop for
        
        if (labelcc.isBlock(targetRow, targetCol)) {
            System.out.println(0);
            return;
        } // end if
        
        labelcc.passFirst();
        labelcc.passSecond();
        System.out.println(labelcc.getLabel(targetRow, targetCol));
        System.out.println(""-------------------------"");
        //labelcc.displayID();
        //labelcc.displayOpen();
        //labelcc.displayCase();
        //labelcc.displayLabel();
        //labelcc.displayRoot();
        
    } // end main
} // end class LabelCC

/**
 * 
 * @author clint
 */
class UF {
    private int[] id;
    
    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) id[i] = i;
    } // end contructor
    
    public boolean connected(int p, int q) { 
        return root(p) == root(q); 
    } // end func connected
    
    public int root(int i) { 
        // Follow links to find a root
        while (i != id[i]) {
            id[i] = id[id[i]]; // path compression
            i = id[i];         // search upper node
        } // end while
        return i; 
    } // end func root
    
    public void union(int p, int q) {
        // Parent: p ; Child: q
        int i = root(p);     // component of p
        int j = root(q);     // component of q
        if (i == j) return;  // if same root, same component
        id[j] = i;           // link component q under component p
                             // Parent: i
                             // Child:  j
    } // end func union
    
    //public void display() {
        
    //} // end 
    
    public static void main(String[] args) {
        System.out.println(""Testing Class UF"");
        System.out.println(""========================="");
        UF uf = new UF(8);
        uf.union(1, 4);
        uf.union(4, 5);
        uf.union(2, 3);
        uf.union(3, 6);
        uf.union(3, 7);
        
        System.out.println(""---Testing Method root---"");
        if (uf.root(0) == 0)  { System.out.println(""Test01 pass""); }
        else                  { System.out.println(""Test01 fail""); }
        if (uf.root(1) == 1)  { System.out.println(""Test02 pass""); }
        else                  { System.out.println(""Test02 fail""); }
        if (uf.root(4) == 1)  { System.out.println(""Test03 pass""); }
        else                  { System.out.println(""Test03 fail""); }
        if (uf.root(5) == 1)  { System.out.println(""Test04 pass""); }
        else                  { System.out.println(""Test04 fail""); }
        if (uf.root(7) == 2)  { System.out.println(""Test05 pass""); }
        else                  { System.out.println(""Test05 fail""); }
        
        System.out.println(""---Testing Method connected---"");
        if (uf.connected(0, 0) == true)  { System.out.println(""Test01 pass""); }
        else                             { System.out.println(""Test01 fail""); }
        if (uf.connected(1, 1) == true)  { System.out.println(""Test02 pass""); }
        else                             { System.out.println(""Test02 fail""); }
        if (uf.connected(0, 1) == false) { System.out.println(""Test03 pass""); }
        else                             { System.out.println(""Test03 fail""); }
        if (uf.connected(0, 7) == false) { System.out.println(""Test04 pass""); }
        else                             { System.out.println(""Test04 fail""); }
        if (uf.connected(1, 4) == true)  { System.out.println(""Test05 pass""); }
        else                             { System.out.println(""Test05 fail""); }
        if (uf.connected(1, 5) == true)  { System.out.println(""Test06 pass""); }
        else                             { System.out.println(""Test06 fail""); }
        if (uf.connected(2, 7) == true)  { System.out.println(""Test07 pass""); }
        else                             { System.out.println(""Test07 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class UF

/**
 * 
 * @author clint
 * @param <Item> 
 */

class Board_ID {
    private final int dim;
    private Board<Integer> board;
    
    public Board_ID (int n) {
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    } // end constructor
    
    public void setId(int row, int col, int value){
        board.setGrid(row-1, col-1, value);
    } // end func setId
    
    public Integer getId(int row, int col){
        return board.getGrid(row-1, col-1);
    } // end func getId
    
    public Integer getNeighbor(int row, int col, String direction){
        return board.getNeighbor(row-1, col-1, direction);
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_ID anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_ID copy() {
        Board_ID board_copy = new Board_ID(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setId(row, col, getId(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, row * dim + col);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
    
    public static void main(String[] args) {
        System.out.println(""Testing Class Board_ID"");
        System.out.println(""========================="");
        int n = 5;
        Board_ID board = new Board_ID(n);
        //board.display();
        
        System.out.println(""---Testing Method getLabel & setLabel---"");
        if (board.getId(1, 1) == 0) {System.out.println(""Test01 pass"");}
        else                        {System.out.println(""Test01 fail"");}
        if (board.getId(1, 2) == 1) {System.out.println(""Test02 pass"");}
        else                        {System.out.println(""Test02 fail"");}
        if (board.getId(2, 2) == 6) {System.out.println(""Test03 pass"");}
        else                        {System.out.println(""Test03 fail"");}
        board.setId(2, 2, 1);
        if (board.getId(2, 2) == 1) {System.out.println(""Test04 pass"");}
        else                        {System.out.println(""Test04 fail"");}
        
        System.out.println(""---Testing Method getNeighbor---"");
        board.reset();
        for (int row = 1; row <= n; row++) {
            for (int col = 1; col <= n; col++) {
                board.setId(row, col, row * col);
            } // end inner loop
        } // end outer loop
        //board.display();
        
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.getId(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.getId(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.getId(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.getId(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.getId(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.getId(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.getId(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.getId(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.getId(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.getId(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.getId(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.getId(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""========================="");
    } // end main
} // end class Board_ID

/**
 * 
 * @author clint
 */
class Board_Label {
    private final int dim;
    private Board<Integer> board;
    
    public Board_Label(int n){
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    }  // end constructor
    
    public Integer getLabel(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getGrid(row-1, col-1);
        //} // end if
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {   
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, value);
        //} // end if
    } // end func setLabel 
    
    public Boolean isLabel(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            if (board.getGrid(row-1, col-1) == -1) { return false; } 
            else                                   { return true; }
        } // end if-else
        //System.out.println(""Error: \n\tClass Board_Label \n\tfunction isLabel \n\tMessage: Out of Boundary"");
        return null;
    } // end func isLabel
    
    public Integer getNeighbor(int row, int col, String direction) {
        return board.getNeighbor(row-1, col-1, direction);
    } // end func Integer
    
    //public boolean compare(Board_Label anotherBoard){
    //    return board.compare(anotherBoard);
    //} // end func compared
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Label anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Label copy() {
        Board_Label board_copy = new Board_Label(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setLabel(row, col, getLabel(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset(){
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, -1);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board_Label */
        System.out.println(""Testing Class Board_Label"");
        System.out.println(""========================="");
        int n = 5;
        Board_Label board = new Board_Label(n);
        
        /* Test setOpen, isOpen, setBlock, isBlock */
        // board_int.display();
        System.out.println(""---Testing Method getLabel & setLabel---"");
        if (board.getLabel(1, 1) == -1) {System.out.println(""Test01 pass"");}
        else                            {System.out.println(""Test01 fail"");}
        board.setLabel(1, 1, 1);
        if (board.getLabel(1, 1) == 1)  {System.out.println(""Test02 pass"");}
        else                            {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method isLabel---"");
        if (board.isLabel(0, 0) == null)  {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        if (board.isLabel(1, 1) == true)  {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        if (board.isLabel(2, 2) == false) {System.out.println(""Test03 pass"");}
        else                              {System.out.println(""Test03 fail"");}
        
        System.out.println(""---Testing Method getNeighbor---"");
        board.reset();
        for (int row = 1; row <= n; row++) {
            for (int col = 1; col <= n; col++) {
                board.setLabel(row, col, row * col);
            } // end inner loop
        } // end outer loop
        
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.getLabel(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.getLabel(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.getLabel(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.getLabel(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.getLabel(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.getLabel(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.getLabel(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.getLabel(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.getLabel(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""---Testing Method compare---"");
        if (board.compare(board.copy())) { System.out.println(""Test01 pass""); } 
        else                             { System.out.println(""Test01 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class Board_Label

/**
 * 
 * @author clint
 */
class Board_Open {
    private final int dim;
    private Board<Boolean> board;
    
    public Board_Open(int n){
        board = new Board<Boolean>(n);
        dim = n;
        reset();    
    }  // end constructor
    
    public void setOpen(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, true);
        //} // end if
    } // end func setOpen
    
    public void setBlock(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, false);
        //} // end if
    } // end func setBlock
    
    public Boolean isOpen(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == true;    
        }
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isOpen \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean isBlock(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == false;
        } // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isBlock \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean getNeighbor(int row, int col, String direction) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getNeighbor(row-1, col-1, direction);
        //} // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction getNeighbor \n\tMessage: Out of Boundary"");
        //return null;
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Open anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Open copy() {
        Board_Open board_copy = new Board_Open(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) { board_copy.setOpen(row, col);  } 
                else                  { board_copy.setBlock(row, col); }
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        // default: all open
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, true);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) {System.out.print(""1 "");}
                else                  {System.out.print(""0 "");}
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board_Open */
        System.out.println(""Testing Class Board_Open"");
        System.out.println(""========================="");
        int n = 5;
        Board_Open board = new Board_Open(n);
        
        /* Test setOpen, isOpen, setBlock, isBlock */
        // board_int.display();
        System.out.println(""---Testing Method isOpen & isBlock---"");
        if (board.isOpen(1, 1) == true) {System.out.println(""Test01 pass"");}
        else                            {System.out.println(""Test01 fail"");}
        
        if (board.isBlock(1, 1) == false) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method setOpen & setBlock---"");
        board.setBlock(2, 2);
        if (board.isOpen(2, 2)  == false) {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        if (board.isBlock(2, 2) == true)  {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        board.setOpen(2, 2);
        if (board.isOpen(2, 2)  == true)  {System.out.println(""Test03 pass"");}
        else                              {System.out.println(""Test03 fail"");}
        if (board.isBlock(2, 2) == false) {System.out.println(""Test04 pass"");}
        else                              {System.out.println(""Test04 fail"");}
        board.setOpen(-1, -1);
        if (board.isOpen(-1, -1)  == null)  {System.out.println(""Test05 pass"");}
        else                              {System.out.println(""Test05 fail"");}
        if (board.isBlock(-1, -1) == null) {System.out.println(""Test06 pass"");}
        else                              {System.out.println(""Test06 fail"");}
        /* Test getNeighbor */
        board.reset();
        boolean flag = true;
        for (int row = 1; row <= n; row++){
            for (int col = 1; col <= n; col++) {
                if (flag) { board.setOpen(row, col); }
                else      { board.setBlock(row, col); }
                flag = !flag;
            } // end inner for
        } // end outer for
        //board.display();
        System.out.println(""---Testing Method getNeighbor---"");
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.isOpen(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.isOpen(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.isOpen(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.isOpen(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.isOpen(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.isOpen(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.isOpen(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.isOpen(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.isOpen(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""---Testing Method compare---"");
        if (board.compare(board.copy())) { System.out.println(""Test01 pass""); } 
        else                             { System.out.println(""Test01 fail""); }
        
        System.out.println(""========================="");
    } // end main
} // end class Board_Open

// --------------------------
/**
 * 
 * @author clint
 */
class Board<Item> //implements Iterable<Item> 
{
    private final int dim;
    private Item[] board;
    
    public Board(int n) {
        dim = n;
        board = (Item[]) new Object[n*n];
    } // end constructor
    
    public int getDim(){ return dim; }
    
    public Item getGrid(int row, int col){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            return board[row * dim + col];
        } // end if
        return null;
    } // end func getGrid
    
    public void setGrid(int row, int col, Item value){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            board[row * dim + col] = value;
        } // end if
    } // end func setGrid
    
    public Item getNeighbor(int row, int col, String direction) {
        /**
         * 
         */
        if (!(row >= 0 && col >= 0 && row < dim && col < dim)) {
            return null;
        } // end if
        
        if (direction.equals(""UP"")) {
            if (row > 0) { return getGrid(row-1, col); }
        } // end if
        
        if (direction.equals(""DOWN"")) {
            if (row < (dim - 1)) { return getGrid(row+1, col); }
        } // end if
        
        if (direction.equals(""LEFT"")) {
            if (col > 0) { return getGrid(row, col-1); }
        } // end if
        
        if (direction.equals(""RIGHT"")) {
            if (col < (dim - 1)) { return getGrid(row, col+1); }
        } // end if
        
        return null;
    } // end func getNeighbor
    
    public boolean compare(Board<Item> anotherBoard) { 
        if (anotherBoard.getDim() != dim) {
            return false;
        } // end if
        
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                if (getGrid(row, col) != anotherBoard.getGrid(row, col)) {
                    return false;
                } // end if
            } // end inner loop
        } // end outer loop
        
        return true;
    } // end func compare
    
    public Board copy(){
        Board<Item> board_copy = new Board(dim);
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board_copy.setGrid(row, col, getGrid(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                System.out.print(board[row * dim + col] + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board */
        System.out.println(""Testing Class Board"");
        System.out.println(""========================="");
        int n = 5;
        Board<Integer> board_int = new Board<Integer>(n);
        Board<String>  board_str = new Board<String>(n);
        
        /* Test getGrid and setGrid */
        for (int row = 0; row < n; row++){
            for (int col = 0; col < n; col++) {
                board_int.setGrid(row, col, row * n + col);
            } // end inner loop
        } // end outer loop
        // board_int.display();
        
        System.out.println(""---Testing Method getGrid---"");
        if (board_int.getGrid(0, 0) == 0) {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        
        if (board_int.getGrid(1, 1) == 6) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method setGrid---"");
        board_int.setGrid(0, 0, 10);
        if (board_int.getGrid(0, 0) == 10) {System.out.println(""Test01 pass"");}
        else                               {System.out.println(""Test01 fail"");}
        
        board_int.setGrid(1, 1, 20);
        if (board_int.getGrid(1, 1) == 20) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        /* Test getNeighbor */
        System.out.println(""---Testing Method getNeighbor---"");
        if (board_int.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""DOWN"") == board_int.getGrid(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(1, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""RIGHT"") == board_int.getGrid(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(0, 1));
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""UP"") == board_int.getGrid(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(0, 1));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""DOWN"") == board_int.getGrid(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(2, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""LEFT"") == board_int.getGrid(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(2, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""RIGHT"") == board_int.getGrid(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(1, 2));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        /* Test copy */
        System.out.println(""---Testing Method copy---"");
        Board<Integer> board_int_copy = board_int.copy();
        boolean flag = true;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if ( board_int_copy.getGrid(row, col) != board_int.getGrid(row, col) ) {
                    flag = false;
                } // end if
            } // end inner loop
        } // end outer loop
        if (flag) { System.out.println(""Test01 pass""); } 
        else      { System.out.println(""Test01 fail""); }
        
        System.out.println(""---Testing Method getDim---"");
        if (board_int.getDim() == n) { System.out.println(""Test01 pass""); } 
        else                          { System.out.println(""Test01 fail""); }
        
        System.out.println(""---Testing Method compare---"");
        board_int_copy = board_int.copy();
        if (board_int.compare(board_int_copy)) { System.out.println(""Test01 pass""); } 
        else                                   { System.out.println(""Test01 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class Board
@cddcbfc1ac3f0ae02f08c91395306e7b@"
"r04921074","9","1","124464","@19bc16c440a117f92d5ccf1f1c069c98@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class LabelCC {    
    public static void main(String[] args) throws IOException{    
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
    
    String[] inf = br.readLine().split("","");
    int N =  Integer.parseInt(inf[0]); //N is scale of grids
    int[][] matrix;
            matrix = new int[N+1][N+1];
    
    UF uf = new UF(N*N/2);        
            
    int[] target;
          target = new int[2];
   
    target[0] =  Integer.parseInt(inf[1]);         //_______type:location of target = (target[0],target[1])______
    target[1] =  Integer.parseInt(inf[2]);         //store value of target    
    
    int row = 0; //max of element is n*n  // store for input X-axis in order of [i]
    int column = 0; //max of element is n*n  // store for input Y-axis in order of [i]
    int counting = 0;
    
    for(int x=1; x<N+1; x++){
        for(int y=1; y<N+1; y++){
           matrix[x][y]=1; 
        }
    }
   
//....................................specify the block grids ** scale of n **-------------------------------
     while (br.ready()){
         String[] num = br.readLine().split("","");
         
         row = Integer.parseInt(num[0]);     //asume a metrix is way as  M[row][column]
         column = Integer.parseInt(num[1]);
         
         matrix[row][column]=0;
             
    }//end of while (and input function part)

//------------------------------------first path** scale of N^2 **------------------------------------------- 
        int lable = 0;
        int wrong = 0;
        for(int y=1; y<N+1; y++){
            for(int x=1; x<N+1; x++){
                if(matrix[y][x]!=0){
                    
                    if( (matrix[y][x-1]==0) && (matrix[y-1][x]==0) ){
                        lable++ ;
                        matrix[y][x] = lable;
                //        wrong ++;
                    }//slave if(1)  ----create new lable
                    else if( (matrix[y][x-1]==matrix[y-1][x])&&(matrix[y-1][x]!=0) ){
                        matrix[y][x] = matrix[y][x-1];
                //        wrong ++;
                    }//slave if(2)  ----lable follower (type1)
                    else if( ((matrix[y][x-1]==0) || (matrix[y-1][x]==0)) && ((matrix[y][x-1]!=0) || (matrix[y-1][x]!=0)) ){
                        matrix[y][x] = Math.max(matrix[y-1][x],matrix[y][x-1]);
                //        wrong ++;
                    }//slave if(3)  ----lable follower (type2)
                    else if( matrix[y][x-1]!=0 && matrix[y-1][x]!=0 && (matrix[y][x-1]!= matrix[y-1][x]) ){
                //        wrong ++;
                        matrix[y][x] = Math.min(matrix[y-1][x],matrix[y][x-1]);
                        uf.union(Math.min(matrix[y-1][x],matrix[y][x-1]), Math.max(matrix[y-1][x],matrix[y][x-1]));
                    }//slave if(4)  ----lable chooser  (cc is needed)
                    else {
                        wrong ++;
                        System.out.println(""Warnning!some proccessing are wrong. wrong path : ""+wrong);
                    }                
                }//end of master if
            
                else {
                    matrix[y][x]=0;
                //    wrong ++;
                    }
                   //master else
            }//end of for-x
        }//end of for-y
//-------------------------------------------------------------------------------------------------------------
    /*    for(int y=1; y<N+1; y++){
            System.out.printf(""\n"");
            for(int x=1; x<N+1; x++){
                System.out.print(matrix[y][x]+"" ""); 
            }
        } System.out.printf(""\n"");//print matrix*/
        
        if( (matrix[target[0]][target[1]]>0)&&(N!=1) ){
            System.out.println(uf.find(matrix[target[0]][target[1]]));
        }
        else if( (matrix[target[0]][target[1]]==0)&&(N!=1)){
            System.out.println(0);
        }
        else if(N==1){
            if(row==0){
                System.out.println(1);
            }
            else System.out.println(0);
        }
        else
        {
            System.out.println(""Warnning!some proccessing are wrong."");
        }
    //    System.out.println(""Warnning!some proccessing are wrong. about :""+wrong);
            }//end of try
        }//end of main
    
}//end of class

@19bc16c440a117f92d5ccf1f1c069c98@"
"r02b48003","0","0","0","@7f56f752bb472da0244bb5c221b3f556@import java.util.Arrays;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class LabelCC {
    private final int dim;
    private Board_ID    board_id;
    private Board_Label board_label;
    private Board_Open  board_open;
    private UF uf;
    
    public LabelCC (int n) {
        dim = n;
        board_id = new Board_ID(n);
        board_label = new Board_Label(n);
        board_open = new Board_Open(n);
        uf = new UF(n*n);
    } // end constructor
    public int getLabel(int row, int col) {
        return board_label.getLabel(row, col);
    } // end func getLabel
    public void setLabel(int row, int col, int value) {
        board_label.setLabel(row, col, value);
    } // end func setLabel
    
    public void setLabelfromRoot(int row, int col, int rootId) {
        int rootRow = rootId / dim + 1;
        int rootCol = rootId % dim + 1;
        setLabel(row, col,
                 board_label.getLabel(rootRow, rootCol));
    } // end func setLabelfromRoot
    
    public void setBlock(int row, int col) {
        board_open.setBlock(row, col);
    } // end func setBlock 
    
    public boolean isBlock(int row, int col) {
        return board_open.isBlock(row, col);
    } // end func isOpen
    
    public boolean isOpen(int row, int col) {
        return board_open.isOpen(row, col);
    } // end func isOpen
    
    public String checkCase(Boolean isOpenUp, Boolean isOpenLf) {
        // case 1: up left neighbors not open or not exist
        // case 2: only up neighbor open and exist
        // case 3: only left neighbor open and exist
        // case 4: up left neighbors exist and open
        String whichCase = """";
        
        if (isOpenUp == null && isOpenLf == null) {whichCase = ""1"";}
        
        if (isOpenUp != null && isOpenLf == null) {
            if (isOpenUp){whichCase = ""2"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp == null && isOpenLf != null) {
            if (isOpenLf){whichCase = ""3"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp != null && isOpenLf != null) {
            if (isOpenUp == true  && isOpenLf == true)  {whichCase = ""4"";}
            if (isOpenUp == true  && isOpenLf == false) {whichCase = ""2"";}
            if (isOpenUp == false && isOpenLf == true)  {whichCase = ""3"";}
            if (isOpenUp == false && isOpenLf == false) {whichCase = ""1"";}
        } // end if
        return whichCase;
    } // end func checkCase
    
    public void passFirst() {
        int label = 1;
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                Integer labelUp  = board_label.getNeighbor(row, col, ""UP"");
                Integer labelLf  = board_label.getNeighbor(row, col, ""LEFT"");
                Integer id       = board_id.getId(row, col);
                Integer idUp     = board_id.getNeighbor(row, col, ""UP"");
                Integer idLf     = board_id.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                
                switch (gridCase) {
                    case ""1"": 
                        //System.out.print(""1 "");
                        setLabel(row, col, label++);
                        break;
                    case ""2"": 
                        //System.out.print(""2 "");
                        uf.union(idUp, id);
                        setLabel(row, col, labelUp);
                        break;
                    case ""3"": 
                        //System.out.print(""3 "");
                        uf.union(idLf, id);
                        setLabel(row, col, labelLf);
                        break;
                    case ""4"": 
                        //System.out.print(""4 "");
                        if (labelUp <= labelLf) {
                            uf.union(idUp, idLf);
                            uf.union(idUp, id);
                            setLabel(row, col, labelUp);
                        } else {
                            uf.union(idLf, idUp);
                            uf.union(idLf, id);
                            setLabel(row, col, labelLf);
                        } // end if-else
                        break;
                    default: 
                        System.out.println(
                            ""Error: LabelCC omit the case: "" + 
                            ""("" + row + "", "" + col + "")"");
                } // end switch
            } // end inner loop
        } // end outer loop
    } // end func passFirst
    
    public void passSecond() {
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                int id = board_id.getId(row, col);
                int root = uf.root(id);
                setLabelfromRoot(row, col, root);
            } // end inner loop
        } // end outer loop
    } // end func passSecond
    
    public void displayOpen(){ 
        System.out.println(""---Display: Open---------"");
        board_open.display();  }
    public void displayLabel() { 
        System.out.println(""---Display: Label--------"");
        board_label.display(); }
    public void displayID() { 
        System.out.println(""---Display: ID-----------"");
        board_id.display();    }
    public void displayRoot()  {
        System.out.println(""---Display: Root---------"");
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.print(uf.root(board_id.getId(row, col)) + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayRoot
    
    public void displayCase()  {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {            
                // check if the grid is open
                if (isBlock(row, col)) {
                    System.out.print(""X "");
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                System.out.print(gridCase + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayCase
    
    public static void main(String[] args) {
        // testing classes
        //Board.main(args);
        //Board_Open.main(args);
        //Board_Label.main(args);
        //Board_ID.main(args);
        //UF.main(args);
        
        // read in the content of a file
        String[] readLines = In.readStrings(args[0]);
        
        // initialization
        String[] line0 = readLines[0].split("","");
        int N         = Integer.valueOf(line0[0]); // prepare for N-by-N grid
        int targetRow = Integer.valueOf(line0[1]); // row of target site: (row, col)
        int targetCol = Integer.valueOf(line0[2]); // col of target site: (row, col)
        LabelCC labelcc = new LabelCC(N);
        
        /*
        System.out.println(
                ""Dimension: "" + N + ""\n"" + 
                ""Target site: "" + ""("" + targetRow + "","" + targetCol + "")"");
        */
        // iterate through the file
        for (String s: Arrays.copyOfRange(readLines, 1, readLines.length)){
            String[] line = s.split("","");
            //System.out.println(s);
            labelcc.setBlock(Integer.valueOf(line[0]), Integer.valueOf(line[1]));
	} // end loop for
        
        if (labelcc.isBlock(targetRow, targetCol)) {
            System.out.println(0);
            return;
        } // end if
        
        labelcc.passFirst();
        labelcc.passSecond();
        System.out.println(labelcc.getLabel(targetRow, targetCol));
        System.out.println(""-------------------------"");
        //labelcc.displayID();
        //labelcc.displayOpen();
        //labelcc.displayCase();
        //labelcc.displayLabel();
        //labelcc.displayRoot();
        
    } // end main
} // end class LabelCC

/**
 * 
 * @author clint
 */
class UF {
    private int[] id;
    
    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) id[i] = i;
    } // end contructor
    
    public boolean connected(int p, int q) { 
        return root(p) == root(q); 
    } // end func connected
    
    public int root(int i) { 
        // Follow links to find a root
        while (i != id[i]) {
            id[i] = id[id[i]]; // path compression
            i = id[i];         // search upper node
        } // end while
        return i; 
    } // end func root
    
    public void union(int p, int q) {
        // Parent: p ; Child: q
        int i = root(p);     // component of p
        int j = root(q);     // component of q
        if (i == j) return;  // if same root, same component
        id[j] = i;           // link component q under component p
                             // Parent: i
                             // Child:  j
    } // end func union
    
    //public void display() {
        
    //} // end 
    
    public static void main(String[] args) {
        System.out.println(""Testing Class UF"");
        System.out.println(""========================="");
        UF uf = new UF(8);
        uf.union(1, 4);
        uf.union(4, 5);
        uf.union(2, 3);
        uf.union(3, 6);
        uf.union(3, 7);
        
        System.out.println(""---Testing Method root---"");
        if (uf.root(0) == 0)  { System.out.println(""Test01 pass""); }
        else                  { System.out.println(""Test01 fail""); }
        if (uf.root(1) == 1)  { System.out.println(""Test02 pass""); }
        else                  { System.out.println(""Test02 fail""); }
        if (uf.root(4) == 1)  { System.out.println(""Test03 pass""); }
        else                  { System.out.println(""Test03 fail""); }
        if (uf.root(5) == 1)  { System.out.println(""Test04 pass""); }
        else                  { System.out.println(""Test04 fail""); }
        if (uf.root(7) == 2)  { System.out.println(""Test05 pass""); }
        else                  { System.out.println(""Test05 fail""); }
        
        System.out.println(""---Testing Method connected---"");
        if (uf.connected(0, 0) == true)  { System.out.println(""Test01 pass""); }
        else                             { System.out.println(""Test01 fail""); }
        if (uf.connected(1, 1) == true)  { System.out.println(""Test02 pass""); }
        else                             { System.out.println(""Test02 fail""); }
        if (uf.connected(0, 1) == false) { System.out.println(""Test03 pass""); }
        else                             { System.out.println(""Test03 fail""); }
        if (uf.connected(0, 7) == false) { System.out.println(""Test04 pass""); }
        else                             { System.out.println(""Test04 fail""); }
        if (uf.connected(1, 4) == true)  { System.out.println(""Test05 pass""); }
        else                             { System.out.println(""Test05 fail""); }
        if (uf.connected(1, 5) == true)  { System.out.println(""Test06 pass""); }
        else                             { System.out.println(""Test06 fail""); }
        if (uf.connected(2, 7) == true)  { System.out.println(""Test07 pass""); }
        else                             { System.out.println(""Test07 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class UF

/**
 * 
 * @author clint
 * @param <Item> 
 */

class Board_ID {
    private final int dim;
    private Board<Integer> board;
    
    public Board_ID (int n) {
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    } // end constructor
    
    public void setId(int row, int col, int value){
        board.setGrid(row-1, col-1, value);
    } // end func setId
    
    public Integer getId(int row, int col){
        return board.getGrid(row-1, col-1);
    } // end func getId
    
    public Integer getNeighbor(int row, int col, String direction){
        return board.getNeighbor(row-1, col-1, direction);
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_ID anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_ID copy() {
        Board_ID board_copy = new Board_ID(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setId(row, col, getId(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, row * dim + col);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
    
    public static void main(String[] args) {
        System.out.println(""Testing Class Board_ID"");
        System.out.println(""========================="");
        int n = 5;
        Board_ID board = new Board_ID(n);
        //board.display();
        
        System.out.println(""---Testing Method getLabel & setLabel---"");
        if (board.getId(1, 1) == 0) {System.out.println(""Test01 pass"");}
        else                        {System.out.println(""Test01 fail"");}
        if (board.getId(1, 2) == 1) {System.out.println(""Test02 pass"");}
        else                        {System.out.println(""Test02 fail"");}
        if (board.getId(2, 2) == 6) {System.out.println(""Test03 pass"");}
        else                        {System.out.println(""Test03 fail"");}
        board.setId(2, 2, 1);
        if (board.getId(2, 2) == 1) {System.out.println(""Test04 pass"");}
        else                        {System.out.println(""Test04 fail"");}
        
        System.out.println(""---Testing Method getNeighbor---"");
        board.reset();
        for (int row = 1; row <= n; row++) {
            for (int col = 1; col <= n; col++) {
                board.setId(row, col, row * col);
            } // end inner loop
        } // end outer loop
        //board.display();
        
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.getId(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.getId(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.getId(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.getId(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.getId(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.getId(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.getId(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.getId(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.getId(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.getId(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.getId(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.getId(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""========================="");
    } // end main
} // end class Board_ID

/**
 * 
 * @author clint
 */
class Board_Label {
    private final int dim;
    private Board<Integer> board;
    
    public Board_Label(int n){
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    }  // end constructor
    
    public Integer getLabel(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getGrid(row-1, col-1);
        //} // end if
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {   
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, value);
        //} // end if
    } // end func setLabel 
    
    public Boolean isLabel(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            if (board.getGrid(row-1, col-1) == -1) { return false; } 
            else                                   { return true; }
        } // end if-else
        //System.out.println(""Error: \n\tClass Board_Label \n\tfunction isLabel \n\tMessage: Out of Boundary"");
        return null;
    } // end func isLabel
    
    public Integer getNeighbor(int row, int col, String direction) {
        return board.getNeighbor(row-1, col-1, direction);
    } // end func Integer
    
    //public boolean compare(Board_Label anotherBoard){
    //    return board.compare(anotherBoard);
    //} // end func compared
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Label anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Label copy() {
        Board_Label board_copy = new Board_Label(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setLabel(row, col, getLabel(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset(){
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, -1);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board_Label */
        System.out.println(""Testing Class Board_Label"");
        System.out.println(""========================="");
        int n = 5;
        Board_Label board = new Board_Label(n);
        
        /* Test setOpen, isOpen, setBlock, isBlock */
        // board_int.display();
        System.out.println(""---Testing Method getLabel & setLabel---"");
        if (board.getLabel(1, 1) == -1) {System.out.println(""Test01 pass"");}
        else                            {System.out.println(""Test01 fail"");}
        board.setLabel(1, 1, 1);
        if (board.getLabel(1, 1) == 1)  {System.out.println(""Test02 pass"");}
        else                            {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method isLabel---"");
        if (board.isLabel(0, 0) == null)  {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        if (board.isLabel(1, 1) == true)  {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        if (board.isLabel(2, 2) == false) {System.out.println(""Test03 pass"");}
        else                              {System.out.println(""Test03 fail"");}
        
        System.out.println(""---Testing Method getNeighbor---"");
        board.reset();
        for (int row = 1; row <= n; row++) {
            for (int col = 1; col <= n; col++) {
                board.setLabel(row, col, row * col);
            } // end inner loop
        } // end outer loop
        
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.getLabel(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.getLabel(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.getLabel(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.getLabel(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.getLabel(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.getLabel(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.getLabel(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.getLabel(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.getLabel(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""---Testing Method compare---"");
        if (board.compare(board.copy())) { System.out.println(""Test01 pass""); } 
        else                             { System.out.println(""Test01 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class Board_Label

/**
 * 
 * @author clint
 */
class Board_Open {
    private final int dim;
    private Board<Boolean> board;
    
    public Board_Open(int n){
        board = new Board<Boolean>(n);
        dim = n;
        reset();    
    }  // end constructor
    
    public void setOpen(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, true);
        //} // end if
    } // end func setOpen
    
    public void setBlock(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, false);
        //} // end if
    } // end func setBlock
    
    public Boolean isOpen(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == true;    
        }
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isOpen \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean isBlock(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == false;
        } // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isBlock \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean getNeighbor(int row, int col, String direction) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getNeighbor(row-1, col-1, direction);
        //} // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction getNeighbor \n\tMessage: Out of Boundary"");
        //return null;
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Open anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Open copy() {
        Board_Open board_copy = new Board_Open(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) { board_copy.setOpen(row, col);  } 
                else                  { board_copy.setBlock(row, col); }
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        // default: all open
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, true);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) {System.out.print(""1 "");}
                else                  {System.out.print(""0 "");}
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board_Open */
        System.out.println(""Testing Class Board_Open"");
        System.out.println(""========================="");
        int n = 5;
        Board_Open board = new Board_Open(n);
        
        /* Test setOpen, isOpen, setBlock, isBlock */
        // board_int.display();
        System.out.println(""---Testing Method isOpen & isBlock---"");
        if (board.isOpen(1, 1) == true) {System.out.println(""Test01 pass"");}
        else                            {System.out.println(""Test01 fail"");}
        
        if (board.isBlock(1, 1) == false) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method setOpen & setBlock---"");
        board.setBlock(2, 2);
        if (board.isOpen(2, 2)  == false) {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        if (board.isBlock(2, 2) == true)  {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        board.setOpen(2, 2);
        if (board.isOpen(2, 2)  == true)  {System.out.println(""Test03 pass"");}
        else                              {System.out.println(""Test03 fail"");}
        if (board.isBlock(2, 2) == false) {System.out.println(""Test04 pass"");}
        else                              {System.out.println(""Test04 fail"");}
        board.setOpen(-1, -1);
        if (board.isOpen(-1, -1)  == null)  {System.out.println(""Test05 pass"");}
        else                              {System.out.println(""Test05 fail"");}
        if (board.isBlock(-1, -1) == null) {System.out.println(""Test06 pass"");}
        else                              {System.out.println(""Test06 fail"");}
        /* Test getNeighbor */
        board.reset();
        boolean flag = true;
        for (int row = 1; row <= n; row++){
            for (int col = 1; col <= n; col++) {
                if (flag) { board.setOpen(row, col); }
                else      { board.setBlock(row, col); }
                flag = !flag;
            } // end inner for
        } // end outer for
        //board.display();
        System.out.println(""---Testing Method getNeighbor---"");
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.isOpen(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.isOpen(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.isOpen(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.isOpen(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.isOpen(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.isOpen(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.isOpen(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.isOpen(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.isOpen(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""---Testing Method compare---"");
        if (board.compare(board.copy())) { System.out.println(""Test01 pass""); } 
        else                             { System.out.println(""Test01 fail""); }
        
        System.out.println(""========================="");
    } // end main
} // end class Board_Open

// --------------------------
/**
 * 
 * @author clint
 */
class Board<Item> //implements Iterable<Item> 
{
    private final int dim;
    private Item[] board;
    
    public Board(int n) {
        dim = n;
        board = (Item[]) new Object[n*n];
    } // end constructor
    
    public int getDim(){ return dim; }
    
    public Item getGrid(int row, int col){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            return board[row * dim + col];
        } // end if
        return null;
    } // end func getGrid
    
    public void setGrid(int row, int col, Item value){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            board[row * dim + col] = value;
        } // end if
    } // end func setGrid
    
    public Item getNeighbor(int row, int col, String direction) {
        /**
         * 
         */
        if (!(row >= 0 && col >= 0 && row < dim && col < dim)) {
            return null;
        } // end if
        
        if (direction.equals(""UP"")) {
            if (row > 0) { return getGrid(row-1, col); }
        } // end if
        
        if (direction.equals(""DOWN"")) {
            if (row < (dim - 1)) { return getGrid(row+1, col); }
        } // end if
        
        if (direction.equals(""LEFT"")) {
            if (col > 0) { return getGrid(row, col-1); }
        } // end if
        
        if (direction.equals(""RIGHT"")) {
            if (col < (dim - 1)) { return getGrid(row, col+1); }
        } // end if
        
        return null;
    } // end func getNeighbor
    
    public boolean compare(Board<Item> anotherBoard) { 
        if (anotherBoard.getDim() != dim) {
            return false;
        } // end if
        
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                if (getGrid(row, col) != anotherBoard.getGrid(row, col)) {
                    return false;
                } // end if
            } // end inner loop
        } // end outer loop
        
        return true;
    } // end func compare
    
    public Board copy(){
        Board<Item> board_copy = new Board(dim);
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board_copy.setGrid(row, col, getGrid(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                System.out.print(board[row * dim + col] + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board */
        System.out.println(""Testing Class Board"");
        System.out.println(""========================="");
        int n = 5;
        Board<Integer> board_int = new Board<Integer>(n);
        Board<String>  board_str = new Board<String>(n);
        
        /* Test getGrid and setGrid */
        for (int row = 0; row < n; row++){
            for (int col = 0; col < n; col++) {
                board_int.setGrid(row, col, row * n + col);
            } // end inner loop
        } // end outer loop
        // board_int.display();
        
        System.out.println(""---Testing Method getGrid---"");
        if (board_int.getGrid(0, 0) == 0) {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        
        if (board_int.getGrid(1, 1) == 6) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method setGrid---"");
        board_int.setGrid(0, 0, 10);
        if (board_int.getGrid(0, 0) == 10) {System.out.println(""Test01 pass"");}
        else                               {System.out.println(""Test01 fail"");}
        
        board_int.setGrid(1, 1, 20);
        if (board_int.getGrid(1, 1) == 20) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        /* Test getNeighbor */
        System.out.println(""---Testing Method getNeighbor---"");
        if (board_int.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""DOWN"") == board_int.getGrid(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(1, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""RIGHT"") == board_int.getGrid(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(0, 1));
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""UP"") == board_int.getGrid(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(0, 1));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""DOWN"") == board_int.getGrid(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(2, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""LEFT"") == board_int.getGrid(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(2, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""RIGHT"") == board_int.getGrid(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(1, 2));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        /* Test copy */
        System.out.println(""---Testing Method copy---"");
        Board<Integer> board_int_copy = board_int.copy();
        boolean flag = true;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if ( board_int_copy.getGrid(row, col) != board_int.getGrid(row, col) ) {
                    flag = false;
                } // end if
            } // end inner loop
        } // end outer loop
        if (flag) { System.out.println(""Test01 pass""); } 
        else      { System.out.println(""Test01 fail""); }
        
        System.out.println(""---Testing Method getDim---"");
        if (board_int.getDim() == n) { System.out.println(""Test01 pass""); } 
        else                          { System.out.println(""Test01 fail""); }
        
        System.out.println(""---Testing Method compare---"");
        board_int_copy = board_int.copy();
        if (board_int.compare(board_int_copy)) { System.out.println(""Test01 pass""); } 
        else                                   { System.out.println(""Test01 fail""); }
        System.out.println(""========================="");
    } // end main
}
@7f56f752bb472da0244bb5c221b3f556@"
"r02b48003","0","0","0","@f22cae5fde57410ae451ccf8c920c0ce@import java.util.Arrays;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class LabelCC {
    private final int dim;
    private Board_ID    board_id;
    private Board_Label board_label;
    private Board_Open  board_open;
    private UF uf;
    
    public LabelCC (int n) {
        dim = n;
        board_id = new Board_ID(n);
        board_label = new Board_Label(n);
        board_open = new Board_Open(n);
        uf = new UF(n*n);
    } // end constructor
    public int getLabel(int row, int col) {
        return board_label.getLabel(row, col);
    } // end func getLabel
    public void setLabel(int row, int col, int value) {
        board_label.setLabel(row, col, value);
    } // end func setLabel
    
    public void setLabelfromRoot(int row, int col, int rootId) {
        int rootRow = rootId / dim + 1;
        int rootCol = rootId % dim + 1;
        setLabel(row, col,
                 board_label.getLabel(rootRow, rootCol));
    } // end func setLabelfromRoot
    
    public void setBlock(int row, int col) {
        board_open.setBlock(row, col);
    } // end func setBlock 
    
    public boolean isBlock(int row, int col) {
        return board_open.isBlock(row, col);
    } // end func isOpen
    
    public boolean isOpen(int row, int col) {
        return board_open.isOpen(row, col);
    } // end func isOpen
    
    public String checkCase(Boolean isOpenUp, Boolean isOpenLf) {
        // case 1: up left neighbors not open or not exist
        // case 2: only up neighbor open and exist
        // case 3: only left neighbor open and exist
        // case 4: up left neighbors exist and open
        String whichCase = """";
        
        if (isOpenUp == null && isOpenLf == null) {whichCase = ""1"";}
        
        if (isOpenUp != null && isOpenLf == null) {
            if (isOpenUp){whichCase = ""2"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp == null && isOpenLf != null) {
            if (isOpenLf){whichCase = ""3"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp != null && isOpenLf != null) {
            if (isOpenUp == true  && isOpenLf == true)  {whichCase = ""4"";}
            if (isOpenUp == true  && isOpenLf == false) {whichCase = ""2"";}
            if (isOpenUp == false && isOpenLf == true)  {whichCase = ""3"";}
            if (isOpenUp == false && isOpenLf == false) {whichCase = ""1"";}
        } // end if
        return whichCase;
    } // end func checkCase
    
    public void passFirst() {
        int label = 1;
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                Integer labelUp  = board_label.getNeighbor(row, col, ""UP"");
                Integer labelLf  = board_label.getNeighbor(row, col, ""LEFT"");
                Integer id       = board_id.getId(row, col);
                Integer idUp     = board_id.getNeighbor(row, col, ""UP"");
                Integer idLf     = board_id.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                
                switch (gridCase) {
                    case ""1"": 
                        //System.out.print(""1 "");
                        setLabel(row, col, label++);
                        break;
                    case ""2"": 
                        //System.out.print(""2 "");
                        uf.union(idUp, id);
                        setLabel(row, col, labelUp);
                        break;
                    case ""3"": 
                        //System.out.print(""3 "");
                        uf.union(idLf, id);
                        setLabel(row, col, labelLf);
                        break;
                    case ""4"": 
                        //System.out.print(""4 "");
                        if (labelUp <= labelLf) {
                            uf.union(idUp, idLf);
                            uf.union(idUp, id);
                            setLabel(row, col, labelUp);
                        } else {
                            uf.union(idLf, idUp);
                            uf.union(idLf, id);
                            setLabel(row, col, labelLf);
                        } // end if-else
                        break;
                    default: 
                        System.out.println(
                            ""Error: LabelCC omit the case: "" + 
                            ""("" + row + "", "" + col + "")"");
                } // end switch
            } // end inner loop
        } // end outer loop
    } // end func passFirst
    
    public void passSecond() {
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                int id = board_id.getId(row, col);
                int root = uf.root(id);
                setLabelfromRoot(row, col, root);
            } // end inner loop
        } // end outer loop
    } // end func passSecond
    
    public void displayOpen(){ 
        System.out.println(""---Display: Open---------"");
        board_open.display();  }
    public void displayLabel() { 
        System.out.println(""---Display: Label--------"");
        board_label.display(); }
    public void displayID() { 
        System.out.println(""---Display: ID-----------"");
        board_id.display();    }
    public void displayRoot()  {
        System.out.println(""---Display: Root---------"");
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.print(uf.root(board_id.getId(row, col)) + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayRoot
    
    public void displayCase()  {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {            
                // check if the grid is open
                if (isBlock(row, col)) {
                    System.out.print(""X "");
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                System.out.print(gridCase + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayCase
    
    public static void main(String[] args) {
        // testing classes
        //Board.main(args);
        //Board_Open.main(args);
        //Board_Label.main(args);
        //Board_ID.main(args);
        //UF.main(args);
        
        // read in the content of a file
        String[] readLines = In.readStrings(args[0]);
        
        // initialization
        String[] line0 = readLines[0].split("","");
        int N         = Integer.valueOf(line0[0]); // prepare for N-by-N grid
        int targetRow = Integer.valueOf(line0[1]); // row of target site: (row, col)
        int targetCol = Integer.valueOf(line0[2]); // col of target site: (row, col)
        LabelCC labelcc = new LabelCC(N);
        
        /*
        System.out.println(
                ""Dimension: "" + N + ""\n"" + 
                ""Target site: "" + ""("" + targetRow + "","" + targetCol + "")"");
        */
        // iterate through the file
        for (String s: Arrays.copyOfRange(readLines, 1, readLines.length)){
            String[] line = s.split("","");
            //System.out.println(s);
            labelcc.setBlock(Integer.valueOf(line[0]), Integer.valueOf(line[1]));
	} // end loop for
        
        if (labelcc.isBlock(targetRow, targetCol)) {
            System.out.println(0);
            return;
        } // end if
        
        labelcc.passFirst();
        labelcc.passSecond();
        System.out.println(labelcc.getLabel(targetRow, targetCol));
        //System.out.println(""-------------------------"");
        //labelcc.displayID();
        //labelcc.displayOpen();
        //labelcc.displayCase();
        //labelcc.displayLabel();
        //labelcc.displayRoot();
        
    } // end main
} // end class LabelCC

/**
 * 
 * @author clint
 */
class UF {
    private int[] id;
    
    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) id[i] = i;
    } // end contructor
    
    public boolean connected(int p, int q) { 
        return root(p) == root(q); 
    } // end func connected
    
    public int root(int i) { 
        // Follow links to find a root
        while (i != id[i]) {
            id[i] = id[id[i]]; // path compression
            i = id[i];         // search upper node
        } // end while
        return i; 
    } // end func root
    
    public void union(int p, int q) {
        // Parent: p ; Child: q
        int i = root(p);     // component of p
        int j = root(q);     // component of q
        if (i == j) return;  // if same root, same component
        id[j] = i;           // link component q under component p
                             // Parent: i
                             // Child:  j
    } // end func union
    
    //public void display() {
        
    //} // end 
    
    public static void main(String[] args) {
        System.out.println(""Testing Class UF"");
        System.out.println(""========================="");
        UF uf = new UF(8);
        uf.union(1, 4);
        uf.union(4, 5);
        uf.union(2, 3);
        uf.union(3, 6);
        uf.union(3, 7);
        
        System.out.println(""---Testing Method root---"");
        if (uf.root(0) == 0)  { System.out.println(""Test01 pass""); }
        else                  { System.out.println(""Test01 fail""); }
        if (uf.root(1) == 1)  { System.out.println(""Test02 pass""); }
        else                  { System.out.println(""Test02 fail""); }
        if (uf.root(4) == 1)  { System.out.println(""Test03 pass""); }
        else                  { System.out.println(""Test03 fail""); }
        if (uf.root(5) == 1)  { System.out.println(""Test04 pass""); }
        else                  { System.out.println(""Test04 fail""); }
        if (uf.root(7) == 2)  { System.out.println(""Test05 pass""); }
        else                  { System.out.println(""Test05 fail""); }
        
        System.out.println(""---Testing Method connected---"");
        if (uf.connected(0, 0) == true)  { System.out.println(""Test01 pass""); }
        else                             { System.out.println(""Test01 fail""); }
        if (uf.connected(1, 1) == true)  { System.out.println(""Test02 pass""); }
        else                             { System.out.println(""Test02 fail""); }
        if (uf.connected(0, 1) == false) { System.out.println(""Test03 pass""); }
        else                             { System.out.println(""Test03 fail""); }
        if (uf.connected(0, 7) == false) { System.out.println(""Test04 pass""); }
        else                             { System.out.println(""Test04 fail""); }
        if (uf.connected(1, 4) == true)  { System.out.println(""Test05 pass""); }
        else                             { System.out.println(""Test05 fail""); }
        if (uf.connected(1, 5) == true)  { System.out.println(""Test06 pass""); }
        else                             { System.out.println(""Test06 fail""); }
        if (uf.connected(2, 7) == true)  { System.out.println(""Test07 pass""); }
        else                             { System.out.println(""Test07 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class UF

/**
 * 
 * @author clint
 * @param <Item> 
 */

class Board_ID {
    private final int dim;
    private Board<Integer> board;
    
    public Board_ID (int n) {
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    } // end constructor
    
    public void setId(int row, int col, int value){
        board.setGrid(row-1, col-1, value);
    } // end func setId
    
    public Integer getId(int row, int col){
        return board.getGrid(row-1, col-1);
    } // end func getId
    
    public Integer getNeighbor(int row, int col, String direction){
        return board.getNeighbor(row-1, col-1, direction);
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_ID anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_ID copy() {
        Board_ID board_copy = new Board_ID(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setId(row, col, getId(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, row * dim + col);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
    
    public static void main(String[] args) {
        System.out.println(""Testing Class Board_ID"");
        System.out.println(""========================="");
        int n = 5;
        Board_ID board = new Board_ID(n);
        //board.display();
        
        System.out.println(""---Testing Method getLabel & setLabel---"");
        if (board.getId(1, 1) == 0) {System.out.println(""Test01 pass"");}
        else                        {System.out.println(""Test01 fail"");}
        if (board.getId(1, 2) == 1) {System.out.println(""Test02 pass"");}
        else                        {System.out.println(""Test02 fail"");}
        if (board.getId(2, 2) == 6) {System.out.println(""Test03 pass"");}
        else                        {System.out.println(""Test03 fail"");}
        board.setId(2, 2, 1);
        if (board.getId(2, 2) == 1) {System.out.println(""Test04 pass"");}
        else                        {System.out.println(""Test04 fail"");}
        
        System.out.println(""---Testing Method getNeighbor---"");
        board.reset();
        for (int row = 1; row <= n; row++) {
            for (int col = 1; col <= n; col++) {
                board.setId(row, col, row * col);
            } // end inner loop
        } // end outer loop
        //board.display();
        
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.getId(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.getId(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.getId(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.getId(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.getId(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.getId(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.getId(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.getId(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.getId(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.getId(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.getId(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.getId(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""========================="");
    } // end main
} // end class Board_ID

/**
 * 
 * @author clint
 */
class Board_Label {
    private final int dim;
    private Board<Integer> board;
    
    public Board_Label(int n){
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    }  // end constructor
    
    public Integer getLabel(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getGrid(row-1, col-1);
        //} // end if
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {   
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, value);
        //} // end if
    } // end func setLabel 
    
    public Boolean isLabel(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            if (board.getGrid(row-1, col-1) == -1) { return false; } 
            else                                   { return true; }
        } // end if-else
        //System.out.println(""Error: \n\tClass Board_Label \n\tfunction isLabel \n\tMessage: Out of Boundary"");
        return null;
    } // end func isLabel
    
    public Integer getNeighbor(int row, int col, String direction) {
        return board.getNeighbor(row-1, col-1, direction);
    } // end func Integer
    
    //public boolean compare(Board_Label anotherBoard){
    //    return board.compare(anotherBoard);
    //} // end func compared
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Label anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Label copy() {
        Board_Label board_copy = new Board_Label(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setLabel(row, col, getLabel(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset(){
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, -1);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board_Label */
        System.out.println(""Testing Class Board_Label"");
        System.out.println(""========================="");
        int n = 5;
        Board_Label board = new Board_Label(n);
        
        /* Test setOpen, isOpen, setBlock, isBlock */
        // board_int.display();
        System.out.println(""---Testing Method getLabel & setLabel---"");
        if (board.getLabel(1, 1) == -1) {System.out.println(""Test01 pass"");}
        else                            {System.out.println(""Test01 fail"");}
        board.setLabel(1, 1, 1);
        if (board.getLabel(1, 1) == 1)  {System.out.println(""Test02 pass"");}
        else                            {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method isLabel---"");
        if (board.isLabel(0, 0) == null)  {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        if (board.isLabel(1, 1) == true)  {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        if (board.isLabel(2, 2) == false) {System.out.println(""Test03 pass"");}
        else                              {System.out.println(""Test03 fail"");}
        
        System.out.println(""---Testing Method getNeighbor---"");
        board.reset();
        for (int row = 1; row <= n; row++) {
            for (int col = 1; col <= n; col++) {
                board.setLabel(row, col, row * col);
            } // end inner loop
        } // end outer loop
        
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.getLabel(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.getLabel(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.getLabel(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.getLabel(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.getLabel(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.getLabel(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.getLabel(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.getLabel(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.getLabel(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""---Testing Method compare---"");
        if (board.compare(board.copy())) { System.out.println(""Test01 pass""); } 
        else                             { System.out.println(""Test01 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class Board_Label

/**
 * 
 * @author clint
 */
class Board_Open {
    private final int dim;
    private Board<Boolean> board;
    
    public Board_Open(int n){
        board = new Board<Boolean>(n);
        dim = n;
        reset();    
    }  // end constructor
    
    public void setOpen(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, true);
        //} // end if
    } // end func setOpen
    
    public void setBlock(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, false);
        //} // end if
    } // end func setBlock
    
    public Boolean isOpen(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == true;    
        }
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isOpen \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean isBlock(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == false;
        } // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isBlock \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean getNeighbor(int row, int col, String direction) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getNeighbor(row-1, col-1, direction);
        //} // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction getNeighbor \n\tMessage: Out of Boundary"");
        //return null;
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Open anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Open copy() {
        Board_Open board_copy = new Board_Open(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) { board_copy.setOpen(row, col);  } 
                else                  { board_copy.setBlock(row, col); }
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        // default: all open
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, true);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) {System.out.print(""1 "");}
                else                  {System.out.print(""0 "");}
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board_Open */
        System.out.println(""Testing Class Board_Open"");
        System.out.println(""========================="");
        int n = 5;
        Board_Open board = new Board_Open(n);
        
        /* Test setOpen, isOpen, setBlock, isBlock */
        // board_int.display();
        System.out.println(""---Testing Method isOpen & isBlock---"");
        if (board.isOpen(1, 1) == true) {System.out.println(""Test01 pass"");}
        else                            {System.out.println(""Test01 fail"");}
        
        if (board.isBlock(1, 1) == false) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method setOpen & setBlock---"");
        board.setBlock(2, 2);
        if (board.isOpen(2, 2)  == false) {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        if (board.isBlock(2, 2) == true)  {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        board.setOpen(2, 2);
        if (board.isOpen(2, 2)  == true)  {System.out.println(""Test03 pass"");}
        else                              {System.out.println(""Test03 fail"");}
        if (board.isBlock(2, 2) == false) {System.out.println(""Test04 pass"");}
        else                              {System.out.println(""Test04 fail"");}
        board.setOpen(-1, -1);
        if (board.isOpen(-1, -1)  == null)  {System.out.println(""Test05 pass"");}
        else                              {System.out.println(""Test05 fail"");}
        if (board.isBlock(-1, -1) == null) {System.out.println(""Test06 pass"");}
        else                              {System.out.println(""Test06 fail"");}
        /* Test getNeighbor */
        board.reset();
        boolean flag = true;
        for (int row = 1; row <= n; row++){
            for (int col = 1; col <= n; col++) {
                if (flag) { board.setOpen(row, col); }
                else      { board.setBlock(row, col); }
                flag = !flag;
            } // end inner for
        } // end outer for
        //board.display();
        System.out.println(""---Testing Method getNeighbor---"");
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.isOpen(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.isOpen(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.isOpen(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.isOpen(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.isOpen(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.isOpen(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.isOpen(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.isOpen(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.isOpen(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""---Testing Method compare---"");
        if (board.compare(board.copy())) { System.out.println(""Test01 pass""); } 
        else                             { System.out.println(""Test01 fail""); }
        
        System.out.println(""========================="");
    } // end main
} // end class Board_Open

// --------------------------
/**
 * 
 * @author clint
 */
class Board<Item> //implements Iterable<Item> 
{
    private final int dim;
    private Item[] board;
    
    public Board(int n) {
        dim = n;
        board = (Item[]) new Object[n*n];
    } // end constructor
    
    public int getDim(){ return dim; }
    
    public Item getGrid(int row, int col){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            return board[row * dim + col];
        } // end if
        return null;
    } // end func getGrid
    
    public void setGrid(int row, int col, Item value){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            board[row * dim + col] = value;
        } // end if
    } // end func setGrid
    
    public Item getNeighbor(int row, int col, String direction) {
        /**
         * 
         */
        if (!(row >= 0 && col >= 0 && row < dim && col < dim)) {
            return null;
        } // end if
        
        if (direction.equals(""UP"")) {
            if (row > 0) { return getGrid(row-1, col); }
        } // end if
        
        if (direction.equals(""DOWN"")) {
            if (row < (dim - 1)) { return getGrid(row+1, col); }
        } // end if
        
        if (direction.equals(""LEFT"")) {
            if (col > 0) { return getGrid(row, col-1); }
        } // end if
        
        if (direction.equals(""RIGHT"")) {
            if (col < (dim - 1)) { return getGrid(row, col+1); }
        } // end if
        
        return null;
    } // end func getNeighbor
    
    public boolean compare(Board<Item> anotherBoard) { 
        if (anotherBoard.getDim() != dim) {
            return false;
        } // end if
        
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                if (getGrid(row, col) != anotherBoard.getGrid(row, col)) {
                    return false;
                } // end if
            } // end inner loop
        } // end outer loop
        
        return true;
    } // end func compare
    
    public Board copy(){
        Board<Item> board_copy = new Board(dim);
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board_copy.setGrid(row, col, getGrid(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                System.out.print(board[row * dim + col] + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board */
        System.out.println(""Testing Class Board"");
        System.out.println(""========================="");
        int n = 5;
        Board<Integer> board_int = new Board<Integer>(n);
        Board<String>  board_str = new Board<String>(n);
        
        /* Test getGrid and setGrid */
        for (int row = 0; row < n; row++){
            for (int col = 0; col < n; col++) {
                board_int.setGrid(row, col, row * n + col);
            } // end inner loop
        } // end outer loop
        // board_int.display();
        
        System.out.println(""---Testing Method getGrid---"");
        if (board_int.getGrid(0, 0) == 0) {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        
        if (board_int.getGrid(1, 1) == 6) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method setGrid---"");
        board_int.setGrid(0, 0, 10);
        if (board_int.getGrid(0, 0) == 10) {System.out.println(""Test01 pass"");}
        else                               {System.out.println(""Test01 fail"");}
        
        board_int.setGrid(1, 1, 20);
        if (board_int.getGrid(1, 1) == 20) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        /* Test getNeighbor */
        System.out.println(""---Testing Method getNeighbor---"");
        if (board_int.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""DOWN"") == board_int.getGrid(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(1, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""RIGHT"") == board_int.getGrid(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(0, 1));
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""UP"") == board_int.getGrid(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(0, 1));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""DOWN"") == board_int.getGrid(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(2, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""LEFT"") == board_int.getGrid(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(2, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""RIGHT"") == board_int.getGrid(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(1, 2));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        /* Test copy */
        System.out.println(""---Testing Method copy---"");
        Board<Integer> board_int_copy = board_int.copy();
        boolean flag = true;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if ( board_int_copy.getGrid(row, col) != board_int.getGrid(row, col) ) {
                    flag = false;
                } // end if
            } // end inner loop
        } // end outer loop
        if (flag) { System.out.println(""Test01 pass""); } 
        else      { System.out.println(""Test01 fail""); }
        
        System.out.println(""---Testing Method getDim---"");
        if (board_int.getDim() == n) { System.out.println(""Test01 pass""); } 
        else                          { System.out.println(""Test01 fail""); }
        
        System.out.println(""---Testing Method compare---"");
        board_int_copy = board_int.copy();
        if (board_int.compare(board_int_copy)) { System.out.println(""Test01 pass""); } 
        else                                   { System.out.println(""Test01 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class Board
@f22cae5fde57410ae451ccf8c920c0ce@"
"r02b48003","0","0","0","@f63ce4071772f371dd19b2f2e2812b1f@import java.util.Arrays;


/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class LabelCC {
    private final int dim;
    private Board_ID    board_id;
    private Board_Label board_label;
    private Board_Open  board_open;
    private UF uf;
    
    public LabelCC (int n) {
        dim = n;
        board_id = new Board_ID(n);
        board_label = new Board_Label(n);
        board_open = new Board_Open(n);
        uf = new UF(n*n);
    } // end constructor
    public int getLabel(int row, int col) {
        return board_label.getLabel(row, col);
    } // end func getLabel
    public void setLabel(int row, int col, int value) {
        board_label.setLabel(row, col, value);
    } // end func setLabel
    
    public void setLabelfromRoot(int row, int col, int rootId) {
        int rootRow = rootId / dim + 1;
        int rootCol = rootId % dim + 1;
        setLabel(row, col,
                 board_label.getLabel(rootRow, rootCol));
    } // end func setLabelfromRoot
    
    public void setBlock(int row, int col) {
        board_open.setBlock(row, col);
    } // end func setBlock 
    
    public boolean isBlock(int row, int col) {
        return board_open.isBlock(row, col);
    } // end func isOpen
    
    public boolean isOpen(int row, int col) {
        return board_open.isOpen(row, col);
    } // end func isOpen
    
    public String checkCase(Boolean isOpenUp, Boolean isOpenLf) {
        // case 1: up left neighbors not open or not exist
        // case 2: only up neighbor open and exist
        // case 3: only left neighbor open and exist
        // case 4: up left neighbors exist and open
        String whichCase = """";
        
        if (isOpenUp == null && isOpenLf == null) {whichCase = ""1"";}
        
        if (isOpenUp != null && isOpenLf == null) {
            if (isOpenUp){whichCase = ""2"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp == null && isOpenLf != null) {
            if (isOpenLf){whichCase = ""3"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp != null && isOpenLf != null) {
            if (isOpenUp == true  && isOpenLf == true)  {whichCase = ""4"";}
            if (isOpenUp == true  && isOpenLf == false) {whichCase = ""2"";}
            if (isOpenUp == false && isOpenLf == true)  {whichCase = ""3"";}
            if (isOpenUp == false && isOpenLf == false) {whichCase = ""1"";}
        } // end if
        return whichCase;
    } // end func checkCase
    
    public void passFirst() {
        int label = 1;
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                Integer labelUp  = board_label.getNeighbor(row, col, ""UP"");
                Integer labelLf  = board_label.getNeighbor(row, col, ""LEFT"");
                Integer id       = board_id.getId(row, col);
                Integer idUp     = board_id.getNeighbor(row, col, ""UP"");
                Integer idLf     = board_id.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                
                switch (gridCase) {
                    case ""1"": 
                        //System.out.print(""1 "");
                        setLabel(row, col, label++);
                        break;
                    case ""2"": 
                        //System.out.print(""2 "");
                        uf.union(idUp, id);
                        setLabel(row, col, labelUp);
                        break;
                    case ""3"": 
                        //System.out.print(""3 "");
                        uf.union(idLf, id);
                        setLabel(row, col, labelLf);
                        break;
                    case ""4"": 
                        //System.out.print(""4 "");
                        if (labelUp <= labelLf) {
                            uf.union(idUp, idLf);
                            uf.union(idUp, id);
                            setLabel(row, col, labelUp);
                        } else {
                            uf.union(idLf, idUp);
                            uf.union(idLf, id);
                            setLabel(row, col, labelLf);
                        } // end if-else
                        break;
                    default: 
                        System.out.println(
                            ""Error: LabelCC omit the case: "" + 
                            ""("" + row + "", "" + col + "")"");
                } // end switch
            } // end inner loop
        } // end outer loop
    } // end func passFirst
    
    public void passSecond() {
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                int id = board_id.getId(row, col);
                int root = uf.root(id);
                setLabelfromRoot(row, col, root);
            } // end inner loop
        } // end outer loop
    } // end func passSecond
    
    public void displayOpen(){ 
        System.out.println(""---Display: Open---------"");
        board_open.display();  }
    public void displayLabel() { 
        System.out.println(""---Display: Label--------"");
        board_label.display(); }
    public void displayID() { 
        System.out.println(""---Display: ID-----------"");
        board_id.display();    }
    public void displayRoot()  {
        System.out.println(""---Display: Root---------"");
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.print(uf.root(board_id.getId(row, col)) + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayRoot
    
    public void displayCase()  {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {            
                // check if the grid is open
                if (isBlock(row, col)) {
                    System.out.print(""X "");
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                System.out.print(gridCase + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayCase
    
    public static void main(String[] args) {
        // testing classes
        //Board.main(args);
        //Board_Open.main(args);
        //Board_Label.main(args);
        //Board_ID.main(args);
        //UF.main(args);
        
        // read in the content of a file
        String[] readLines = In.readStrings(args[0]);
        
        // initialization
        String[] line0 = readLines[0].split("","");
        int N         = Integer.valueOf(line0[0]); // prepare for N-by-N grid
        int targetRow = Integer.valueOf(line0[1]); // row of target site: (row, col)
        int targetCol = Integer.valueOf(line0[2]); // col of target site: (row, col)
        LabelCC labelcc = new LabelCC(N);
        
        /*
        System.out.println(
                ""Dimension: "" + N + ""\n"" + 
                ""Target site: "" + ""("" + targetRow + "","" + targetCol + "")"");
        */
        // iterate through the file
        for (String s: Arrays.copyOfRange(readLines, 1, readLines.length)){
            String[] line = s.split("","");
            //System.out.println(s);
            labelcc.setBlock(Integer.valueOf(line[0]), Integer.valueOf(line[1]));
	} // end loop for
        
        if (labelcc.isBlock(targetRow, targetCol)) {
            System.out.print(0);
            return;
        } // end if
        
        labelcc.passFirst();
        labelcc.passSecond();
        System.out.print(labelcc.getLabel(targetRow, targetCol));
        //System.out.println(""-------------------------"");
        //labelcc.displayID();
        //labelcc.displayOpen();
        //labelcc.displayCase();
        //labelcc.displayLabel();
        //labelcc.displayRoot();
        
    } // end main
} // end class LabelCC

/**
 * 
 * @author clint
 */
class UF {
    private int[] id;
    
    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) id[i] = i;
    } // end contructor
    
    public boolean connected(int p, int q) { 
        return root(p) == root(q); 
    } // end func connected
    
    public int root(int i) { 
        // Follow links to find a root
        while (i != id[i]) {
            id[i] = id[id[i]]; // path compression
            i = id[i];         // search upper node
        } // end while
        return i; 
    } // end func root
    
    public void union(int p, int q) {
        // Parent: p ; Child: q
        int i = root(p);     // component of p
        int j = root(q);     // component of q
        if (i == j) return;  // if same root, same component
        id[j] = i;           // link component q under component p
                             // Parent: i
                             // Child:  j
    } // end func union
    
    //public void display() {
        
    //} // end 
    
    public static void main(String[] args) {
        System.out.println(""Testing Class UF"");
        System.out.println(""========================="");
        UF uf = new UF(8);
        uf.union(1, 4);
        uf.union(4, 5);
        uf.union(2, 3);
        uf.union(3, 6);
        uf.union(3, 7);
        
        System.out.println(""---Testing Method root---"");
        if (uf.root(0) == 0)  { System.out.println(""Test01 pass""); }
        else                  { System.out.println(""Test01 fail""); }
        if (uf.root(1) == 1)  { System.out.println(""Test02 pass""); }
        else                  { System.out.println(""Test02 fail""); }
        if (uf.root(4) == 1)  { System.out.println(""Test03 pass""); }
        else                  { System.out.println(""Test03 fail""); }
        if (uf.root(5) == 1)  { System.out.println(""Test04 pass""); }
        else                  { System.out.println(""Test04 fail""); }
        if (uf.root(7) == 2)  { System.out.println(""Test05 pass""); }
        else                  { System.out.println(""Test05 fail""); }
        
        System.out.println(""---Testing Method connected---"");
        if (uf.connected(0, 0) == true)  { System.out.println(""Test01 pass""); }
        else                             { System.out.println(""Test01 fail""); }
        if (uf.connected(1, 1) == true)  { System.out.println(""Test02 pass""); }
        else                             { System.out.println(""Test02 fail""); }
        if (uf.connected(0, 1) == false) { System.out.println(""Test03 pass""); }
        else                             { System.out.println(""Test03 fail""); }
        if (uf.connected(0, 7) == false) { System.out.println(""Test04 pass""); }
        else                             { System.out.println(""Test04 fail""); }
        if (uf.connected(1, 4) == true)  { System.out.println(""Test05 pass""); }
        else                             { System.out.println(""Test05 fail""); }
        if (uf.connected(1, 5) == true)  { System.out.println(""Test06 pass""); }
        else                             { System.out.println(""Test06 fail""); }
        if (uf.connected(2, 7) == true)  { System.out.println(""Test07 pass""); }
        else                             { System.out.println(""Test07 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class UF

/**
 * 
 * @author clint
 * @param <Item> 
 */

class Board_ID {
    private final int dim;
    private Board<Integer> board;
    
    public Board_ID (int n) {
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    } // end constructor
    
    public void setId(int row, int col, int value){
        board.setGrid(row-1, col-1, value);
    } // end func setId
    
    public Integer getId(int row, int col){
        return board.getGrid(row-1, col-1);
    } // end func getId
    
    public Integer getNeighbor(int row, int col, String direction){
        return board.getNeighbor(row-1, col-1, direction);
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_ID anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_ID copy() {
        Board_ID board_copy = new Board_ID(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setId(row, col, getId(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, row * dim + col);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
    
    public static void main(String[] args) {
        System.out.println(""Testing Class Board_ID"");
        System.out.println(""========================="");
        int n = 5;
        Board_ID board = new Board_ID(n);
        //board.display();
        
        System.out.println(""---Testing Method getLabel & setLabel---"");
        if (board.getId(1, 1) == 0) {System.out.println(""Test01 pass"");}
        else                        {System.out.println(""Test01 fail"");}
        if (board.getId(1, 2) == 1) {System.out.println(""Test02 pass"");}
        else                        {System.out.println(""Test02 fail"");}
        if (board.getId(2, 2) == 6) {System.out.println(""Test03 pass"");}
        else                        {System.out.println(""Test03 fail"");}
        board.setId(2, 2, 1);
        if (board.getId(2, 2) == 1) {System.out.println(""Test04 pass"");}
        else                        {System.out.println(""Test04 fail"");}
        
        System.out.println(""---Testing Method getNeighbor---"");
        board.reset();
        for (int row = 1; row <= n; row++) {
            for (int col = 1; col <= n; col++) {
                board.setId(row, col, row * col);
            } // end inner loop
        } // end outer loop
        //board.display();
        
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.getId(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.getId(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.getId(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.getId(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.getId(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.getId(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.getId(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.getId(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.getId(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.getId(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.getId(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.getId(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""========================="");
    } // end main
} // end class Board_ID

/**
 * 
 * @author clint
 */
class Board_Label {
    private final int dim;
    private Board<Integer> board;
    
    public Board_Label(int n){
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    }  // end constructor
    
    public Integer getLabel(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getGrid(row-1, col-1);
        //} // end if
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {   
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, value);
        //} // end if
    } // end func setLabel 
    
    public Boolean isLabel(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            if (board.getGrid(row-1, col-1) == -1) { return false; } 
            else                                   { return true; }
        } // end if-else
        //System.out.println(""Error: \n\tClass Board_Label \n\tfunction isLabel \n\tMessage: Out of Boundary"");
        return null;
    } // end func isLabel
    
    public Integer getNeighbor(int row, int col, String direction) {
        return board.getNeighbor(row-1, col-1, direction);
    } // end func Integer
    
    //public boolean compare(Board_Label anotherBoard){
    //    return board.compare(anotherBoard);
    //} // end func compared
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Label anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Label copy() {
        Board_Label board_copy = new Board_Label(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setLabel(row, col, getLabel(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset(){
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, -1);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board_Label */
        System.out.println(""Testing Class Board_Label"");
        System.out.println(""========================="");
        int n = 5;
        Board_Label board = new Board_Label(n);
        
        /* Test setOpen, isOpen, setBlock, isBlock */
        // board_int.display();
        System.out.println(""---Testing Method getLabel & setLabel---"");
        if (board.getLabel(1, 1) == -1) {System.out.println(""Test01 pass"");}
        else                            {System.out.println(""Test01 fail"");}
        board.setLabel(1, 1, 1);
        if (board.getLabel(1, 1) == 1)  {System.out.println(""Test02 pass"");}
        else                            {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method isLabel---"");
        if (board.isLabel(0, 0) == null)  {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        if (board.isLabel(1, 1) == true)  {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        if (board.isLabel(2, 2) == false) {System.out.println(""Test03 pass"");}
        else                              {System.out.println(""Test03 fail"");}
        
        System.out.println(""---Testing Method getNeighbor---"");
        board.reset();
        for (int row = 1; row <= n; row++) {
            for (int col = 1; col <= n; col++) {
                board.setLabel(row, col, row * col);
            } // end inner loop
        } // end outer loop
        
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.getLabel(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.getLabel(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.getLabel(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.getLabel(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.getLabel(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.getLabel(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.getLabel(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.getLabel(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.getLabel(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.getLabel(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""---Testing Method compare---"");
        if (board.compare(board.copy())) { System.out.println(""Test01 pass""); } 
        else                             { System.out.println(""Test01 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class Board_Label

/**
 * 
 * @author clint
 */
class Board_Open {
    private final int dim;
    private Board<Boolean> board;
    
    public Board_Open(int n){
        board = new Board<Boolean>(n);
        dim = n;
        reset();    
    }  // end constructor
    
    public void setOpen(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, true);
        //} // end if
    } // end func setOpen
    
    public void setBlock(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, false);
        //} // end if
    } // end func setBlock
    
    public Boolean isOpen(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == true;    
        }
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isOpen \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean isBlock(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == false;
        } // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isBlock \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean getNeighbor(int row, int col, String direction) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getNeighbor(row-1, col-1, direction);
        //} // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction getNeighbor \n\tMessage: Out of Boundary"");
        //return null;
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Open anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Open copy() {
        Board_Open board_copy = new Board_Open(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) { board_copy.setOpen(row, col);  } 
                else                  { board_copy.setBlock(row, col); }
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        // default: all open
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, true);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) {System.out.print(""1 "");}
                else                  {System.out.print(""0 "");}
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board_Open */
        System.out.println(""Testing Class Board_Open"");
        System.out.println(""========================="");
        int n = 5;
        Board_Open board = new Board_Open(n);
        
        /* Test setOpen, isOpen, setBlock, isBlock */
        // board_int.display();
        System.out.println(""---Testing Method isOpen & isBlock---"");
        if (board.isOpen(1, 1) == true) {System.out.println(""Test01 pass"");}
        else                            {System.out.println(""Test01 fail"");}
        
        if (board.isBlock(1, 1) == false) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method setOpen & setBlock---"");
        board.setBlock(2, 2);
        if (board.isOpen(2, 2)  == false) {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        if (board.isBlock(2, 2) == true)  {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        board.setOpen(2, 2);
        if (board.isOpen(2, 2)  == true)  {System.out.println(""Test03 pass"");}
        else                              {System.out.println(""Test03 fail"");}
        if (board.isBlock(2, 2) == false) {System.out.println(""Test04 pass"");}
        else                              {System.out.println(""Test04 fail"");}
        board.setOpen(-1, -1);
        if (board.isOpen(-1, -1)  == null)  {System.out.println(""Test05 pass"");}
        else                              {System.out.println(""Test05 fail"");}
        if (board.isBlock(-1, -1) == null) {System.out.println(""Test06 pass"");}
        else                              {System.out.println(""Test06 fail"");}
        /* Test getNeighbor */
        board.reset();
        boolean flag = true;
        for (int row = 1; row <= n; row++){
            for (int col = 1; col <= n; col++) {
                if (flag) { board.setOpen(row, col); }
                else      { board.setBlock(row, col); }
                flag = !flag;
            } // end inner for
        } // end outer for
        //board.display();
        System.out.println(""---Testing Method getNeighbor---"");
        if (board.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""DOWN"") == board.isOpen(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(0, 0, ""RIGHT"") == board.isOpen(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board.isOpen(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""UP"") == board.isOpen(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board.isOpen(0, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""DOWN"") == board.isOpen(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board.isOpen(2, 1));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""LEFT"") == board.isOpen(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 0));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board.getNeighbor(1, 1, ""RIGHT"") == board.isOpen(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board.isOpen(1, 2));
            System.out.println(""Get:      "" + board.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        System.out.println(""---Testing Method compare---"");
        if (board.compare(board.copy())) { System.out.println(""Test01 pass""); } 
        else                             { System.out.println(""Test01 fail""); }
        
        System.out.println(""========================="");
    } // end main
} // end class Board_Open

// --------------------------
/**
 * 
 * @author clint
 */
class Board<Item> //implements Iterable<Item> 
{
    private final int dim;
    private Item[] board;
    
    public Board(int n) {
        dim = n;
        board = (Item[]) new Object[n*n];
    } // end constructor
    
    public int getDim(){ return dim; }
    
    public Item getGrid(int row, int col){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            return board[row * dim + col];
        } // end if
        return null;
    } // end func getGrid
    
    public void setGrid(int row, int col, Item value){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            board[row * dim + col] = value;
        } // end if
    } // end func setGrid
    
    public Item getNeighbor(int row, int col, String direction) {
        /**
         * 
         */
        if (!(row >= 0 && col >= 0 && row < dim && col < dim)) {
            return null;
        } // end if
        
        if (direction.equals(""UP"")) {
            if (row > 0) { return getGrid(row-1, col); }
        } // end if
        
        if (direction.equals(""DOWN"")) {
            if (row < (dim - 1)) { return getGrid(row+1, col); }
        } // end if
        
        if (direction.equals(""LEFT"")) {
            if (col > 0) { return getGrid(row, col-1); }
        } // end if
        
        if (direction.equals(""RIGHT"")) {
            if (col < (dim - 1)) { return getGrid(row, col+1); }
        } // end if
        
        return null;
    } // end func getNeighbor
    
    public boolean compare(Board<Item> anotherBoard) { 
        if (anotherBoard.getDim() != dim) {
            return false;
        } // end if
        
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                if (getGrid(row, col) != anotherBoard.getGrid(row, col)) {
                    return false;
                } // end if
            } // end inner loop
        } // end outer loop
        
        return true;
    } // end func compare
    
    public Board copy(){
        Board<Item> board_copy = new Board(dim);
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board_copy.setGrid(row, col, getGrid(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                System.out.print(board[row * dim + col] + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
    
    public static void main(String[] args) {
        /* Test cases for Board */
        System.out.println(""Testing Class Board"");
        System.out.println(""========================="");
        int n = 5;
        Board<Integer> board_int = new Board<Integer>(n);
        Board<String>  board_str = new Board<String>(n);
        
        /* Test getGrid and setGrid */
        for (int row = 0; row < n; row++){
            for (int col = 0; col < n; col++) {
                board_int.setGrid(row, col, row * n + col);
            } // end inner loop
        } // end outer loop
        // board_int.display();
        
        System.out.println(""---Testing Method getGrid---"");
        if (board_int.getGrid(0, 0) == 0) {System.out.println(""Test01 pass"");}
        else                              {System.out.println(""Test01 fail"");}
        
        if (board_int.getGrid(1, 1) == 6) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        System.out.println(""---Testing Method setGrid---"");
        board_int.setGrid(0, 0, 10);
        if (board_int.getGrid(0, 0) == 10) {System.out.println(""Test01 pass"");}
        else                               {System.out.println(""Test01 fail"");}
        
        board_int.setGrid(1, 1, 20);
        if (board_int.getGrid(1, 1) == 20) {System.out.println(""Test02 pass"");}
        else                              {System.out.println(""Test02 fail"");}
        
        /* Test getNeighbor */
        System.out.println(""---Testing Method getNeighbor---"");
        if (board_int.getNeighbor(0, 0, ""UP"") == null) {
            System.out.println(""Test01 pass"");
        } else {
            System.out.println(""Test01 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""UP""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""DOWN"") == board_int.getGrid(1, 0)) {
            System.out.println(""Test02 pass"");
        } else {
            System.out.println(""Test02 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(1, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""DOWN""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""LEFT"") == null) {
            System.out.println(""Test03 pass"");
        } else {
            System.out.println(""Test03 fail"");
            System.out.println(""Expected: "" + null);
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""LEFT""));
        } // end if-else
        
        if (board_int.getNeighbor(0, 0, ""RIGHT"") == board_int.getGrid(0, 1)) {
            System.out.println(""Test04 pass"");
        } else {
            System.out.println(""Test04 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(0, 1));
            System.out.println(""Get:      "" + board_int.getNeighbor(0, 0, ""RIGHT""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""UP"") == board_int.getGrid(0, 1)) {
            System.out.println(""Test05 pass"");
        } else {
            System.out.println(""Test05 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(0, 1));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""UP""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""DOWN"") == board_int.getGrid(2, 1)) {
            System.out.println(""Test06 pass"");
        } else {
            System.out.println(""Test06 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(2, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""DOWN""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""LEFT"") == board_int.getGrid(1, 0)) {
            System.out.println(""Test07 pass"");
        } else {
            System.out.println(""Test07 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(2, 0));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""LEFT""));
        } // end if-else
        
        if (board_int.getNeighbor(1, 1, ""RIGHT"") == board_int.getGrid(1, 2)) {
            System.out.println(""Test08 pass"");
        } else {
            System.out.println(""Test08 fail"");
            System.out.println(""Expected: "" + board_int.getGrid(1, 2));
            System.out.println(""Get:      "" + board_int.getNeighbor(1, 1, ""RIGHT""));
        } // end if-else
        
        /* Test copy */
        System.out.println(""---Testing Method copy---"");
        Board<Integer> board_int_copy = board_int.copy();
        boolean flag = true;
        for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
                if ( board_int_copy.getGrid(row, col) != board_int.getGrid(row, col) ) {
                    flag = false;
                } // end if
            } // end inner loop
        } // end outer loop
        if (flag) { System.out.println(""Test01 pass""); } 
        else      { System.out.println(""Test01 fail""); }
        
        System.out.println(""---Testing Method getDim---"");
        if (board_int.getDim() == n) { System.out.println(""Test01 pass""); } 
        else                          { System.out.println(""Test01 fail""); }
        
        System.out.println(""---Testing Method compare---"");
        board_int_copy = board_int.copy();
        if (board_int.compare(board_int_copy)) { System.out.println(""Test01 pass""); } 
        else                                   { System.out.println(""Test01 fail""); }
        System.out.println(""========================="");
    } // end main
} // end class Board
@f63ce4071772f371dd19b2f2e2812b1f@"
"r04921028","0","1.22","153648","@9599aaf15e16acf64ddcce49da2dbd57@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        QuickUnionUF uf = new QuickUnionUF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    else if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    else if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                    else if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0&&M[i-1][j]<0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]<0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                M[i][j] = M[i][j-1];
                                uf.union(M[i-1][j],M[i][j-1]);
                            }
                            else if(M[i-1][j]<M[i][j-1]){
                                M[i][j] = M[i-1][j];
                                uf.union(M[i][j-1],M[i-1][j]);  
                            } 
                            
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(M[i][j]>0){
                    System.out.print(uf.find(M[i][j])+"" "");
                }else{
                    System.out.print(""0""+"" "");
                }
            }
            System.out.print(""\n"");
        }
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@9599aaf15e16acf64ddcce49da2dbd57@"
"r04921028","8","1","125120","@628303a0504569896a929bbc327365d6@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        QuickUnionUF uf = new QuickUnionUF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    else if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    else if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                    else if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0&&M[i-1][j]<0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]<0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                M[i][j] = M[i][j-1];
                                uf.union(M[i-1][j],M[i][j-1]);
                            }
                            else if(M[i-1][j]<M[i][j-1]){
                                M[i][j] = M[i-1][j];
                                uf.union(M[i][j-1],M[i-1][j]);  
                            } 
                            
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]>0){
//                    System.out.print(uf.find(M[i][j])+"" "");
//                }else{
//                    System.out.print(""0""+"" "");
//                }
//            }
//            System.out.print(""\n"");
//        }
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@628303a0504569896a929bbc327365d6@"
"r04921028","10","0.1","124016","@e17fb05f68c884c31d8324c782f19d7f@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author DANNY
 */
public class LabelCC {
     public static void main(String[] args) throws Exception{
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String buf[] = br.readLine().split("","");
//        System.out.println(buf[0]);
        int n = Integer.valueOf(buf[0]);
        QuickUnionUF uf = new QuickUnionUF(n*n);
        int targetx = Integer.valueOf(buf[1]);
        int targety = Integer.valueOf(buf[2]);
//        System.out.println(buf[1]+"",""+buf[2]);
        int [][] M;
        M = new int[n][n];
        
        while (br.ready())
        {      
            String buf1[] = br.readLine().split("","");
            if(buf1[0].equals("""")){break;}
//            System.out.println(buf1[0]+"",""+buf1[1]);
            int x = Integer.valueOf(buf1[0]);
            int y = Integer.valueOf(buf1[1]);
            M[x-1][y-1] = -1;
        }
        int inread=0;
        int count = 1;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 
                if(M[i][j]==0){
                    if(i==0&&j==0){
                        M[i][j]=1;
                        inread = 1;
                    } 
                    
                   
                    else if(i>0&&j==0){
//                        System.out.println(""2"");
                        if(M[i-1][j]>0){
                          M[i][j] = M[i-1][j];   
                        } 
                        if(M[i-1][j]==-1){
                            if(inread==0){
                                inread = 1;
                                 M[i][j]=count;       
                            }else{
                            count++;
                            M[i][j]=count;  
                            }
                        }
                    }
                    else if(i==0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i][j-1]==-1){
                            if(j==1){M[i][j] = count; inread = 1;}
                            else{
                                if(inread==0){
                                    
                                    inread = 1;
                                    M[i][j] = count; 
                                }else{
                                    count++;
                                    M[i][j] = count; 
                                }
                            }
                        }
                    }
                    else if(i>0&&j>0){
//                        System.out.println(""3"");
                        if(M[i][j-1]>0&&M[i-1][j]<0){
                            M[i][j] = M[i][j-1]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]<0){
                            M[i][j] = M[i-1][j]; 
                        }
                        if(M[i-1][j]>0&&M[i][j-1]>0){
                            if(M[i-1][j]>M[i][j-1]){
                                M[i][j] = M[i][j-1];
                                uf.union(M[i-1][j],M[i][j-1]);
                            }
                            else{
                                M[i][j] = M[i-1][j];
                                uf.union(M[i][j-1],M[i-1][j]);
                            } 
                        }
                        if(M[i][j-1]==-1&&M[i-1][j]==-1){
                            if(inread==0){
                                inread= 1;
                                M[i][j] = count; 
                            }else{
                            count++;
                            M[i][j] = count; 
                            }
                        }   
                    }
                }
            }
        }
       
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]==0){System.out.println(""hello"");}
//            }
//        }
//        System.out.println(count); 
        
        if(M[targetx-1][targety-1]>0){
            if(n!=1){
            System.out.println(uf.find(M[targetx-1][targety-1])); 
            }
            else{
                System.out.println(M[targetx-1][targety-1]);
            }
        }
        
//        for(int i=0;i<n;i++){
//            for(int j=0;j<n;j++){
//                if(M[i][j]>0){
//                    System.out.print(uf.find(M[i][j])+"" "");
//                }else{
//                    System.out.print(""0""+"" "");
//                }
//            }
//            System.out.print(""\n"");
//        }
        
        
        if(M[targetx-1][targety-1]==-1){
            System.out.println(""0"");
        } 
        if(M[targetx-1][targety-1]==0){
            System.out.println(""1"");
        }
        }  
    }
}
@e17fb05f68c884c31d8324c782f19d7f@"
"r04522616","10","0.103","125968","@dd7c8e919b49bc631d70335dba38e925@
//import edu.princeton.cs.algs4.QuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;


public class LabelCC {

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            int ansX=Integer.parseInt(data[1]);
            int ansY=Integer.parseInt(data[2]);            
            
            int [][] mark=new int[N][N];//block  判斷
            int [][] code=new int[N][N];//單位編號
            for(int i=0;i<N;i++)
            {
                for(int j=0;j<N;j++)
                {
                    mark[i][j]=1;
                    code[i][j]=0;
                }                
            }            
            
            QuickUnionUF qUF=new QuickUnionUF(N*N);
            
            do{
                nullData=br.readLine();                          
                if(nullData ==null)
                {                    
                    break;
                }               
                data = nullData.split("","");     
                int x = Integer.parseInt(data[0]);//x座標
                int y = Integer.parseInt(data[1]);//y座標                
                mark[x-1][y-1]=0;//被傳入的座標變成block                        
            }
            while(data[0]!=null);
            
            int count=0;
            for(int i=0;i<N;i++)
            {
                if(i==0)
                {
                    for(int j=0;j<N;j++)
                    {                           
                        if(mark[i][j]==1&&j==0)
                        {
                            count++;
                            code[i][j]=count;
                        }
                        if(j!=0)
                        {
                            if(mark[i][j]==1)
                            {
                                if(mark[i][j-1]==0)
                                {
                                    count++;
                                    code[i][j]=count;
                                }
                                if(mark[i][j-1]==1)
                                {
                                    code[i][j]=code[i][j-1];
                                    qUF.union(code[i][j],code[i][j-1]);//與左方連接
                                }
                            }                            
                        }                        
                    }                
                }
                else
                {                    
                    for(int j=0;j<N;j++)
                    {
                        if(mark[i][j]==1 && mark[i-1][j]==1)
                        {   
                            if(j==0)
                            {
                                code[i][j]=code[i-1][j];
                                qUF.union(code[i][j],code[i-1][j]);//與上方連接
                            }
                            if(j!=0)
                            {
                                if(mark[i][j-1]==1)
                                {
                                    if(code[i-1][j]<code[i][j-1])
                                    {
                                        code[i][j]=code[i-1][j];
                                        qUF.union(code[i][j],code[i-1][j]);//與上方連接
                                        qUF.union(code[i][j-1],code[i][j]);//左方(數字較大)須連在此[i][j]後方
                                    }
                                    else if(code[i-1][j]>code[i][j-1])
                                    {
                                        code[i][j]=code[i][j-1];
                                        qUF.union(code[i][j],code[i][j-1]);//與左方連接
                                        qUF.union(code[i-1][j],code[i][j]);//上方須連在此[][]後方
                                    }
                                    else
                                    {
                                        code[i][j]=code[i-1][j];
                                        qUF.union(code[i][j],code[i-1][j]);//與上方連接
                                        qUF.union(code[i][j],code[i][j-1]);//與左方連接
                                    }
                                }
                                if(mark[i][j-1]==0)
                                {
                                     code[i][j]=code[i-1][j];
                                     qUF.union(code[i][j],code[i-1][j]);//與上方連接
                                }
                            }                                                        
                        }
                        if(mark[i][j]==1 && mark[i-1][j]==0)
                        {
                            if(j==0)
                            {
                                count++;
                                code[i][j]=count;
                            }
                            if(j!=0)
                            {
                                if(mark[i][j-1]==1)
                                {
                                    code[i][j]=code[i][j-1];
                                     qUF.union(code[i][j],code[i][j-1]);//與左方連接
                                }
                                if(mark[i][j-1]==0)
                                {
                                    count++;
                                    code[i][j]=count;
                                }
                            }                            
                        }                        
                    }
                }                
            }            
            if(code[ansX-1][ansY-1]==0)
            {
                System.out.printf(""0"");
            }
            else
            {
                int ans=qUF.find(code[ansX-1][ansY-1]);
                System.out.printf(""%d"",ans);
            }
            
        }
    }
}

@dd7c8e919b49bc631d70335dba38e925@"
"b03611003","9","0.96","122944","@bb513f63beb39b1b5072c5f592d55c87@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 *
 *
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    private static int[][] CC;
    private static int[][] borw;
    private static int[] id;
//    CC: 每個格子中的cc
//    borw: 每個格子是黑是白

    public LabelCC(int N) {
        CC = new int[N][N];
        borw = new int[N][N];
        id = new int[(N * N + 1) / 2];
        for (int i = 0; i < (N * N + 1) / 2; i++) {
            id[i] = i;
        }

    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

//          part1
            String[] dataf = br.readLine().split("","");

            LabelCC labelcc = new LabelCC(Integer.parseInt(dataf[0]));
            int N = Integer.parseInt(dataf[0]);

            while (Boolean.TRUE) {
                String data = br.readLine();

                if (data != null) {
                    String[] randc = new String[2];
                    randc = data.split("","");
                    borw[Integer.parseInt(randc[0]) - 1][Integer.parseInt(randc[1]) - 1] = 1;
                } else {
                    break;
                }
            }

//           part2
            int labelnow = 1;

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (borw[i][j] == 0) {
                        switch (i) {
                            case 0:
//                                最左邊一排
                                if (j == 0) {
                                    CC[0][0] = labelnow;
                                    labelnow++;
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        CC[i][j] = CC[i][j - 1];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
                                }
                                break;
                            default:
                                if (j == 0) {
                                    if (borw[i - 1][j] == 0) {
                                        CC[i][j] = CC[i - 1][j];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
//                                    最上面一排
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        if (borw[i - 1][j] == 0) {
//                                            左跟上都有
                                            if (root(CC[i][j - 1]) > root(CC[i - 1][j])) {
                                                id[root(CC[i][j - 1])] = root(CC[i - 1][j]);
                                                CC[i][j] = CC[i - 1][j];
                                            } else if (root(CC[i][j - 1]) == root(CC[i - 1][j])) {
                                                CC[i][j] = CC[i - 1][j];
                                            } else {
                                                id[root(CC[i - 1][j])] = root(CC[i][j - 1]);
                                                CC[i][j] = CC[i][j - 1];
                                            }

                                        } else {
//                                            上有左沒有
                                            CC[i][j] = CC[i][j - 1];
                                        }
                                    } else {
                                        if (borw[i - 1][j] == 0) {
//                                            左有上沒有
                                            CC[i][j] = CC[i - 1][j];
                                        } else {
//                                            都沒有
                                            CC[i][j] = labelnow;
                                            labelnow++;
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }

//            part3
            for (int i = 0; i < (N * N + 1) / 2; i++) {
                id[i] = root(i);
            }

//            for (int i = 0; i < N; i++) {
//                for (int j = 0; j < N; j++) {
//                    if (borw[i][j] == 0) {
//                        CC[i][j] = root(CC[i][j]);
//
//                    }
//                }
//            }
            
            int r = Integer.parseInt(dataf[1]) - 1;
            int c = Integer.parseInt(dataf[2]) - 1;
            
            System.out.print(root(CC[r][c]));
//            System.out.print(id[CC[6][4]]);
        }
    }

}

@bb513f63beb39b1b5072c5f592d55c87@"
"r03522809","6","1.63","142960","@9a8f848fd801be7d7f8a92c8c3163db9@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
   public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ansx = Integer.parseInt(Num[1]);
        int ansy = Integer.parseInt(Num[2]);
        QuickUnionUF uf = new QuickUnionUF(N*N/2+1);
        int x=0,y=0;
        int [][] table = new int [N][N];
        int [][] Numtable = new int [N][N];
        int i=0,j=0,k=0,label=1,labelcheck=0;
        String d;
        
        for(i=0;i<N;i++){
             for(j=0;j<N;j++){
                table[i][j]=1;
            }
        }


        
        while( (d = br.readLine()) != null ){
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=0;    
        // TODO code application logic here
        }
//        for(i=0;i<N;i++)
//        {
//             for(j=0;j<N;j++)
//            {
//                System.out.println(table[i][j]);
//            }
//        }

        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                
                if(table[i][j]==1)
                {
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        if(table[i][j-1]==1)
                        {
                         Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if(table[i][j-1]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                         if(table[i-1][j]==1)
                        {
                          Numtable[i][j]=Numtable[i-1][j];
                        }
                        else if(table[i-1][j]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else // rest
                    {
                        if( Numtable[i-1][j]!=0 && Numtable[i][j-1]!=0)
                        {
                            if(Numtable[i][j-1]>Numtable[i-1][j])
                            {
                                Numtable[i][j]=Numtable[i-1][j];
                                uf.union(Numtable[i-1][j],Numtable[i][j-1]);
                            }
                            else
                            {   
                                Numtable[i][j]=Numtable[i][j-1];
                                uf.union(Numtable[i][j-1],Numtable[i-1][j]);
                            }
                        }
                        else if (Numtable[i-1][j] ==0 && Numtable[i][j-1]!=0)
                        {
                            Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if (Numtable[i-1][j] !=0 && Numtable[i][j-1]==0)
                        {
                            Numtable[i][j]=Numtable[i-1][j];
                        }
                        else 
                        {
                             Numtable[i][j]=label;
                             labelcheck=0;
                        }
                    }

                }
                else if(table[i][j]==0 && labelcheck==0 ) 
                {                        
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                     label=label+1;
                     labelcheck=1;
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                     label=label+1;
                     labelcheck=1;                        
                    }
                    else // rest
                    {
                        if( Numtable[i-1][j]!=0 && Numtable[i][j-1]!=0)
                        {
                        }
                       else
                       {
                         label=label+1;
                         labelcheck=1;    
                       }
                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }
        
        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                if(table[i][j]==1 )
                {   
                    for(k=1;k<N*N/2+1;k++)
                    {
                        if(uf.connected(k,Numtable[i][j]) && k<Numtable[i][j] )
                        {
                            Numtable[i][j]=k;
                        }

                    }
                }
            }
        }

   
        System.out.println(Numtable[ansx-1][ansy-1]);       
    }
   }
}
@9a8f848fd801be7d7f8a92c8c3163db9@"
"r03522809","6","1.42","149504","@76a995b2f4abe1399ce1b6fc06668492@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
   public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ansx = Integer.parseInt(Num[1]);
        int ansy = Integer.parseInt(Num[2]);
        QuickFindUF uf = new QuickFindUF(N*N/2+1);
        int x=0,y=0;
        int [][] table = new int [N][N];
        int [][] Numtable = new int [N][N];
        int i=0,j=0,k=0,label=1,labelcheck=0;
        String d;
        
        for(i=0;i<N;i++){
             for(j=0;j<N;j++){
                table[i][j]=1;
            }
        }


        
        while( (d = br.readLine()) != null ){
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=0;    
        // TODO code application logic here
        }
//        for(i=0;i<N;i++)
//        {
//             for(j=0;j<N;j++)
//            {
//                System.out.println(table[i][j]);
//            }
//        }

        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                
                if(table[i][j]==1)
                {
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        if(table[i][j-1]==1)
                        {
                         Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if(table[i][j-1]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                         if(table[i-1][j]==1)
                        {
                          Numtable[i][j]=Numtable[i-1][j];
                        }
                        else if(table[i-1][j]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else // rest
                    {
                        if( Numtable[i-1][j]!=0 && Numtable[i][j-1]!=0)
                        {
                            if(Numtable[i][j-1]>Numtable[i-1][j])
                            {
                                Numtable[i][j]=Numtable[i-1][j];
                                uf.union(Numtable[i-1][j],Numtable[i][j-1]);
                            }
                            else
                            {   
                                Numtable[i][j]=Numtable[i][j-1];
                                uf.union(Numtable[i][j-1],Numtable[i-1][j]);
                            }
                        }
                        else if (Numtable[i-1][j] ==0 && Numtable[i][j-1]!=0)
                        {
                            Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if (Numtable[i-1][j] !=0 && Numtable[i][j-1]==0)
                        {
                            Numtable[i][j]=Numtable[i-1][j];
                        }
                        else 
                        {
                             Numtable[i][j]=label;
                             labelcheck=0;
                        }
                    }

                }
                else if(table[i][j]==0 && labelcheck==0 ) 
                {                        
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                     label=label+1;
                     labelcheck=1;
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                     label=label+1;
                     labelcheck=1;                        
                    }
                    else // rest
                    {
                        if( Numtable[i-1][j]!=0 && Numtable[i][j-1]!=0)
                        {
                        }
                       else
                       {
                         label=label+1;
                         labelcheck=1;    
                       }
                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }
        
        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                if(table[i][j]==1 )
                {   
                    for(k=1;k<N*N/2+1;k++)
                    {
                        if(uf.connected(k,Numtable[i][j]) && k<Numtable[i][j] )
                        {
                            Numtable[i][j]=k;
                        }

                    }
                }
            }
        }

   
        System.out.println(Numtable[ansx-1][ansy-1]);       
    }
   }
}

@76a995b2f4abe1399ce1b6fc06668492@"
"b01502105","9","1.03","143792","@b5ce478188f914973d0dd8bc50b4babf@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StringBuilder everything = new StringBuilder();
            String line;
            everything.append(br.readLine());//first num
            while ((line = br.readLine()) != null) {
                everything.append("" "");
                everything.append(line);
            }
            String[] data = everything.toString().split("" "");
            String[] given = data[0].split("","");
            int num = Integer.parseInt(given[0]);  //matrix size
            int assigned_row = Integer.parseInt(given[1]);
            int assigned_column = Integer.parseInt(given[2]);
            int len = data.length;  //input 
            int label = 0;
//            int k = 0;
//            int[][] p_c = new int[20][2]; 
            UF uf = new UF(num*num);
            
//            System.out.printf(num+"" ""+assigned_row+"" ""+assigned_column+"" ""+len+""\n"");
            int[][] matrix = new int[num][num];
            for(int a=0;a<num;a++){
                Arrays.fill(matrix[a], 1);
            }
            int[][] matrix_label = new int [num][num]; 
            //assign given position
            for(int i=1; i<len; i++){
               String[] block = data[i].split("","");
               int block_row = Integer.parseInt(block[0]);
               int block_column = Integer.parseInt(block[1]);
               matrix[block_row - 1][block_column - 1] = 0;
            }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
           //The first pass
           for(int i=0;i<num;i++){
               for(int j=0;j<num;j++){
                   if(matrix[i][j] == 1){
                        if( i==0 && j==0){ label++; matrix_label[i][j]=label;}
                        //row_1
                        else if(i==0){
                             if(matrix[i][j-1] == 1){
                                matrix_label[i][j]=matrix_label[i][j-1]; 
                             }
                             else{
                                label++;
                                matrix_label[i][j]=label; 
                             }
                        }
                        //column_1
                        else if(j==0){
                            if(matrix[i-1][j] == 1){
                                matrix_label[i][j]=matrix_label[i-1][j];
                             }
                            else {
                                label++;
                                matrix_label[i][j]=label;
                            }
                        }
                        //usual case
                        else{   
                            //up & left are ""1""
                            if (matrix[i][j - 1] == 1 && matrix[i - 1][j] == 1) {
                                //up & left is the same
                                if (matrix_label[i][j - 1] == matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
                                } 
                                else if (matrix_label[i][j - 1] < matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
//                                    p_c[k][0]=matrix_label[i][j-1]; //parent,small
//                                    p_c[k][1]=matrix_label[i-1][j]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i][j-1],matrix_label[i-1][j]);
                                } 
                                else {  //matrix_label[i][j-1] > matrix_label[i-1][j]
                                    matrix_label[i][j] = matrix_label[i - 1][j];
//                                    p_c[k][0]=matrix_label[i-1][j]; //parent,small
//                                    p_c[k][1]=matrix_label[i][j-1]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i-1][j],matrix_label[i][j-1]);
                                }
                            } //left is ""1""
                            else if (matrix[i][j - 1] == 1) {
                                matrix_label[i][j] = matrix_label[i][j - 1];
                            }
                             //up is ""1""
                             else if(matrix[i-1][j] == 1){
                                 matrix_label[i][j]=matrix_label[i-1][j];
                             }
                             // none
                             else{
                                 label++;
                                 matrix_label[i][j]=label;
                             }
                        }
                   }
               }
           }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < k; a++) {
//                System.out.printf(p_c[a][0] + "" <- "" +p_c[a][1] + ""\n"");
//            }
            
//            System.out.printf(uf.find(3)+""\n"");
            //second pass
            for(int i=0;i<num;i++){
                for(int j=0;j<num;j++){
                        matrix_label[i][j] = uf.find(matrix_label[i][j]);
                }
            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            System.out.printf(""assigned position:""+assigned_row + "","" + assigned_column + ""\n"");
            System.out.printf(matrix_label[assigned_row - 1][assigned_column - 1]+""\n"");
        }
    }
}

@b5ce478188f914973d0dd8bc50b4babf@"
"r04945008","8","1.04","130320","@0143aa201e6cee89f76b750b5f7af8f5@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            WeightedQuickUnionUF  uf = new WeightedQuickUnionUF (num*num+1);
//            uf.union(0, 5);
//            System.out.printf(""%d\n"",uf.find(2));

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1]){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else{site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1)){site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j)){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
            System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@0143aa201e6cee89f76b750b5f7af8f5@"
"r03522809","7","1.42","148752","@8423040c79381f1674e1258a50e052cd@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
   public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ansx = Integer.parseInt(Num[1]);
        int ansy = Integer.parseInt(Num[2]);
        QuickFindUF uf = new QuickFindUF(N*N/2+1);
        int x=0,y=0;
        int [][] table = new int [N][N];
        int [][] Numtable = new int [N][N];
        int i=0,j=0,k=0,label=1,labelcheck=0;
        String d;
        
        for(i=0;i<N;i++){
             for(j=0;j<N;j++){
                table[i][j]=1;
            }
        }


        
        while( (d = br.readLine()) != null ){
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=0;    
        // TODO code application logic here
        }
//        for(i=0;i<N;i++)
//        {
//             for(j=0;j<N;j++)
//            {
//                System.out.println(table[i][j]);
//            }
//        }

        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                
                if(table[i][j]==1)
                {
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        if(table[i][j-1]==1)
                        {
                         Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if(table[i][j-1]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                         if(table[i-1][j]==1)
                        {
                          Numtable[i][j]=Numtable[i-1][j];
                        }
                        else if(table[i-1][j]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else // rest
                    {
                        if( Numtable[i-1][j]!=0 && Numtable[i][j-1]!=0)
                        {
                            if(Numtable[i][j-1]>Numtable[i-1][j])
                            {
                                Numtable[i][j]=Numtable[i-1][j];
                                uf.union(Numtable[i-1][j],Numtable[i][j-1]);
                            }
                            else
                            {   
                                Numtable[i][j]=Numtable[i][j-1];
                                uf.union(Numtable[i][j-1],Numtable[i-1][j]);
                            }
                        }
                        else if (Numtable[i-1][j] ==0 && Numtable[i][j-1]!=0)
                        {
                            Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if (Numtable[i-1][j] !=0 && Numtable[i][j-1]==0)
                        {
                            Numtable[i][j]=Numtable[i-1][j];
                        }
                        else
                        {
                             Numtable[i][j]=label;
                             labelcheck=0;
                        }
                    }

                }
                else if(table[i][j]==0 && labelcheck==0 ) 
                {                        
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                       
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                     label=label+1;
                     labelcheck=1;
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                     label=label+1;
                     labelcheck=1;                        
                    }
                    else // rest
                    {

                         label=label+1;
                         labelcheck=1;    

                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }
        
        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                if(table[i][j]==1 )
                {   
                    for(k=1;k<N*N/2+1;k++)
                    {
                        if(uf.connected(k,Numtable[i][j]) && k<Numtable[i][j] )
                        {
                            Numtable[i][j]=k;
                        }

                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }

   
        System.out.println(Numtable[ansx-1][ansy-1]);
    }
   }
}
@8423040c79381f1674e1258a50e052cd@"
"r03522809","0","1.73","150752","@1dc3eae693ebe4cda3170ed7acc809cb@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
   public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ansx = Integer.parseInt(Num[1]);
        int ansy = Integer.parseInt(Num[2]);
        QuickFindUF uf = new QuickFindUF(N*N/2+2);
        int x=0,y=0;
        int [][] table = new int [N][N];
        int [][] Numtable = new int [N][N];
        int i=0,j=0,k=0,label=1,labelcheck=0;
        String d;
        
        for(i=0;i<N;i++){
             for(j=0;j<N;j++){
                table[i][j]=1;
            }
        }


        
        while( (d = br.readLine()) != null ){
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=0;    
        // TODO code application logic here
        }
//        for(i=0;i<N;i++)
//        {
//             for(j=0;j<N;j++)
//            {
//                System.out.println(table[i][j]);
//            }
//        }

        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                
                if(table[i][j]==1)
                {
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        if(table[i][j-1]==1)
                        {
                         Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if(table[i][j-1]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                         if(table[i-1][j]==1)
                        {
                          Numtable[i][j]=Numtable[i-1][j];
                        }
                        else if(table[i-1][j]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else // rest
                    {
                        if( Numtable[i-1][j]!=0 && Numtable[i][j-1]!=0)
                        {
                            if(Numtable[i][j-1]>Numtable[i-1][j])
                            {
                                Numtable[i][j]=Numtable[i-1][j];
                                uf.union(Numtable[i-1][j],Numtable[i][j-1]);
                            }
                            else
                            {   
                                Numtable[i][j]=Numtable[i][j-1];
                                uf.union(Numtable[i][j-1],Numtable[i-1][j]);
                            }
                        }
                        else if (Numtable[i-1][j] ==0 && Numtable[i][j-1]!=0)
                        {
                            Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if (Numtable[i-1][j] !=0 && Numtable[i][j-1]==0)
                        {
                            Numtable[i][j]=Numtable[i-1][j];
                        }
                        else
                        {
                             Numtable[i][j]=label;
                             labelcheck=0;
                        }
                    }

                }
                else if(table[i][j]==0 && labelcheck==0 ) 
                {                        
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                       
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                     label=label+1;
                     labelcheck=1;
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                     label=label+1;
                     labelcheck=1;                        
                    }
                    else // rest
                    {

                         label=label+1;
                         labelcheck=1;    

                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }
        
        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                if(table[i][j]==1 )
                {   
                    for(k=1;k<N*N/2+2;k++)
                    {
                        if(uf.connected(k,Numtable[i][j]) && k<Numtable[i][j] )
                        {
                            Numtable[i][j]=k;
                        }

                    }
                }
                System.out.println(Numtable[i][j]);
            }
        }

   
//         System.out.println(Numtable[ansx-1][ansy-1]);
    }
   }
}
@1dc3eae693ebe4cda3170ed7acc809cb@"
"r03522809","7","1.38","142912","@3f6499c8fe1d43da469202b111ec3945@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
   public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ansx = Integer.parseInt(Num[1]);
        int ansy = Integer.parseInt(Num[2]);
        QuickFindUF uf = new QuickFindUF(N*N/2+2);
        int x=0,y=0;
        int [][] table = new int [N][N];
        int [][] Numtable = new int [N][N];
        int i=0,j=0,k=0,label=1,labelcheck=0;
        String d;
        
        for(i=0;i<N;i++){
             for(j=0;j<N;j++){
                table[i][j]=1;
            }
        }


        
        while( (d = br.readLine()) != null ){
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=0;    
        // TODO code application logic here
        }
//        for(i=0;i<N;i++)
//        {
//             for(j=0;j<N;j++)
//            {
//                System.out.println(table[i][j]);
//            }
//        }

        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                
                if(table[i][j]==1)
                {
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        if(table[i][j-1]==1)
                        {
                         Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if(table[i][j-1]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                         if(table[i-1][j]==1)
                        {
                          Numtable[i][j]=Numtable[i-1][j];
                        }
                        else if(table[i-1][j]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else // rest
                    {
                        if( Numtable[i-1][j]!=0 && Numtable[i][j-1]!=0)
                        {
                            if(Numtable[i][j-1]>Numtable[i-1][j])
                            {
                                Numtable[i][j]=Numtable[i-1][j];
                                uf.union(Numtable[i-1][j],Numtable[i][j-1]);
                            }
                            else
                            {   
                                Numtable[i][j]=Numtable[i][j-1];
                                uf.union(Numtable[i][j-1],Numtable[i-1][j]);
                            }
                        }
                        else if (Numtable[i-1][j] ==0 && Numtable[i][j-1]!=0)
                        {
                            Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if (Numtable[i-1][j] !=0 && Numtable[i][j-1]==0)
                        {
                            Numtable[i][j]=Numtable[i-1][j];
                        }
                        else
                        {
                             Numtable[i][j]=label;
                             labelcheck=0;
                        }
                    }

                }
                else if(table[i][j]==0 && labelcheck==0 ) 
                {                        
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                       
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                     label=label+1;
                     labelcheck=1;
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                     label=label+1;
                     labelcheck=1;                        
                    }
                    else // rest
                    {
                     label=label+1;
                     labelcheck=1;    
                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }
        
        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                if(table[i][j]==1 )
                {   
                    for(k=1;k<N*N/2+2;k++)
                    {
                        if(uf.connected(k,Numtable[i][j]) && k<Numtable[i][j] )
                        {
                            Numtable[i][j]=k;
                        }

                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }

   
         System.out.println(Numtable[ansx-1][ansy-1]);
    }
   }
}

@3f6499c8fe1d43da469202b111ec3945@"
"r03522809","7","1.39","141984","@4cc35204a02fa529469f0f1e05f6d3d9@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
   public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ansx = Integer.parseInt(Num[1]);
        int ansy = Integer.parseInt(Num[2]);
        QuickFindUF uf = new QuickFindUF(N*N/2+2);
        int x=0,y=0;
        int [][] table = new int [N][N];
        int [][] Numtable = new int [N][N];
        int i=0,j=0,k=0,label=1,labelcheck=0;
        String d;
        
        for(i=0;i<N;i++){
             for(j=0;j<N;j++){
                table[i][j]=1;
            }
        }


        
        while( (d = br.readLine()) != null ){
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=0;    
        // TODO code application logic here
        }
//        for(i=0;i<N;i++)
//        {
//             for(j=0;j<N;j++)
//            {
//                System.out.println(table[i][j]);
//            }
//        }

        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                
                if(table[i][j]==1)
                {
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        if(table[i][j-1]==1)
                        {
                         Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if(table[i][j-1]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                         if(table[i-1][j]==1)
                        {
                          Numtable[i][j]=Numtable[i-1][j];
                        }
                        else if(table[i-1][j]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else // rest
                    {
                        if( table[i-1][j]!=0 && table[i][j-1]!=0)
                        {
                            if(Numtable[i][j-1]>Numtable[i-1][j])
                            {
                                Numtable[i][j]=Numtable[i-1][j];
                                uf.union(Numtable[i-1][j],Numtable[i][j-1]);
                            }
                            else
                            {   
                                Numtable[i][j]=Numtable[i][j-1];
                                uf.union(Numtable[i][j-1],Numtable[i-1][j]);
                            }
                        }
                        else if (table[i-1][j] ==0 && table[i][j-1]!=0)
                        {
                            Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if (table[i-1][j] !=0 && table[i][j-1]==0)
                        {
                            Numtable[i][j]=Numtable[i-1][j];
                        }
                        else
                        {
                             Numtable[i][j]=label;
                             labelcheck=0;
                        }
                    }

                }
                else if(table[i][j]==0 && labelcheck==0 ) 
                {                        
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                       
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                     label=label+1;
                     labelcheck=1;
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                     label=label+1;
                     labelcheck=1;                        
                    }
                    else // rest
                    {
                     label=label+1;
                     labelcheck=1;    
                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }
        
        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                if(table[i][j]==1 )
                {   
                    for(k=1;k<N*N/2+2;k++)
                    {
                        if(uf.connected(k,Numtable[i][j]) && k<Numtable[i][j] )
                        {
                            Numtable[i][j]=k;
                        }

                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }

   
         System.out.println(Numtable[ansx-1][ansy-1]);
    }
   }
}
@4cc35204a02fa529469f0f1e05f6d3d9@"
"r03522809","7","1.45","142320","@fdebbc383002003250259547692dcc3e@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
   public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ansx = Integer.parseInt(Num[1]);
        int ansy = Integer.parseInt(Num[2]);
        QuickFindUF uf = new QuickFindUF(N*N/2+2);
        int x=0,y=0;
        int [][] table = new int [N][N];
        int [][] Numtable = new int [N][N];
        int i=0,j=0,k=0,label=1,labelcheck=0;
        String d;
        
        for(i=0;i<N;i++){
             for(j=0;j<N;j++){
                table[i][j]=1;
            }
        }


        
        while( (d = br.readLine()) != null ){
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=0;    
        // TODO code application logic here
        }
//        for(i=0;i<N;i++)
//        {
//             for(j=0;j<N;j++)
//            {
//                System.out.println(table[i][j]);
//            }
//        }

        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                
                if(table[i][j]==1)
                {
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        if(table[i][j-1]==1)
                        {
                         Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if(table[i][j-1]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                         if(table[i-1][j]==1)
                        {
                          Numtable[i][j]=Numtable[i-1][j];
                        }
                        else if(table[i-1][j]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else // rest
                    {
                        if( table[i-1][j]!=0 && table[i][j-1]!=0)
                        {
                            if(Numtable[i][j-1]>Numtable[i-1][j])
                            {
                                Numtable[i][j]=Numtable[i-1][j];
                                uf.union(Numtable[i-1][j],Numtable[i][j-1]);
                            }
                            else
                            {   
                                Numtable[i][j]=Numtable[i][j-1];
                                uf.union(Numtable[i][j-1],Numtable[i-1][j]);
                            }
                        }
                        else if (table[i-1][j] ==0 && table[i][j-1]!=0)
                        {
                            Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if (table[i-1][j] !=0 && table[i][j-1]==0)
                        {
                            Numtable[i][j]=Numtable[i-1][j];
                        }
                        else
                        {
                             Numtable[i][j]=label;
                             labelcheck=0;
                        }
                    }

                }
                else if(table[i][j]==0 && labelcheck==0 ) 
                {                        
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                       
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        label=label+1;
                        labelcheck=1;
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
//                        label=label+1;
//                        labelcheck=1;
                    }
                    else // rest
                    {
                     label=label+1;
                     labelcheck=1;    
                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }
        
        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                if(table[i][j]==1 )
                {   
                    for(k=1;k<N*N/2+2;k++)
                    {
                        if(uf.connected(k,Numtable[i][j]) && k<Numtable[i][j] )
                        {
                            Numtable[i][j]=k;
                        }

                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }

   
         System.out.println(Numtable[ansx-1][ansy-1]);
    }
   }
}

@fdebbc383002003250259547692dcc3e@"
"r03522809","9","1.42","137968","@9f83a78ecbd24d08f49d60f386a08632@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
   public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ansx = Integer.parseInt(Num[1]);
        int ansy = Integer.parseInt(Num[2]);
        QuickFindUF uf = new QuickFindUF(N*N/2+2);
        int x=0,y=0;
        int [][] table = new int [N][N];
        int [][] Numtable = new int [N][N];
        int i=0,j=0,k=0,label=1,labelcheck=1;
        String d;
        
        for(i=0;i<N;i++){
             for(j=0;j<N;j++){
                table[i][j]=1;
            }
        }


        
        while( (d = br.readLine()) != null ){
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=0;    
        // TODO code application logic here
        }
//        for(i=0;i<N;i++)
//        {
//             for(j=0;j<N;j++)
//            {
//                System.out.println(table[i][j]);
//            }
//        }

        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                
                if(table[i][j]==1)
                {
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                        labelcheck=0;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        if(table[i][j-1]==1)
                        {
                         Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if(table[i][j-1]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                         if(table[i-1][j]==1)
                        {
                          Numtable[i][j]=Numtable[i-1][j];
                        }
                        else if(table[i-1][j]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else // rest
                    {
                        if( table[i-1][j]!=0 && table[i][j-1]!=0)
                        {
                            if(Numtable[i][j-1]>Numtable[i-1][j])
                            {
                                Numtable[i][j]=Numtable[i-1][j];
                                uf.union(Numtable[i-1][j],Numtable[i][j-1]);
                            }
                            else
                            {   
                                Numtable[i][j]=Numtable[i][j-1];
                                uf.union(Numtable[i][j-1],Numtable[i-1][j]);
                            }
                        }
                        else if (table[i-1][j] ==0 && table[i][j-1]!=0)
                        {
                            Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if (table[i-1][j] !=0 && table[i][j-1]==0)
                        {
                            Numtable[i][j]=Numtable[i-1][j];
                        }
                        else
                        {
                             Numtable[i][j]=label;
                             labelcheck=0;
                        }
                    }

                }
                if(labelcheck==0)
                {
                   label=label+1;
                   labelcheck=1;
                }
                
                
//                else if(table[i][j]==0 && labelcheck==0 ) 
//                {                        
//                    if( i-1<0 && j-1<0) //(0,0)
//                    {
//                       
//                    }
//                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
//                    {
//                        label=label+1;
//                        labelcheck=1;
//                    }
//                    else if( i-1>=0 && j-1<0) //left bounder check up
//                    {
//                        if(table[i-1][j]==0)
//                        label=label+1;
//                        labelcheck=1;
//                    }
//                    else // rest
//                    {
//                     label=label+1;
//                     labelcheck=1;    
//                    }
//                }
//               System.out.println(Numtable[i][j]);
            }
        }
        
        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                if(table[i][j]==1 )
                {   
                    for(k=1;k<N*N/2+2;k++)
                    {
                        if(uf.connected(k,Numtable[i][j]) && k<Numtable[i][j] )
                        {
                            Numtable[i][j]=k;
                        }

                    }
                }
//                System.out.println(Numtable[i][j]);
            }
        }

   
         System.out.println(Numtable[ansx-1][ansy-1]);
    }
   }
}

@9f83a78ecbd24d08f49d60f386a08632@"
"r04921074","10","0.1","125120","@d7623b9ba726be68409c03afc5c082bb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author LAB228
 */
public class LabelCC {    
    public static void main(String[] args) throws IOException{    
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
    
    String[] inf = br.readLine().split("","");
    int N =  Integer.parseInt(inf[0]); //N is scale of grids
    int[][] matrix;
            matrix = new int[N+1][N+1];
    
    QuickUnionUF uf = new QuickUnionUF(N*N/2);        
            
    int[] target;
          target = new int[2];
   
    target[0] =  Integer.parseInt(inf[1]);         //_______type:location of target = (target[0],target[1])______
    target[1] =  Integer.parseInt(inf[2]);         //store value of target    
    
    int row = 0; //max of element is n*n  // store for input X-axis in order of [i]
    int column = 0; //max of element is n*n  // store for input Y-axis in order of [i]
    int counting = 0;
    
    for(int x=1; x<N+1; x++){
        for(int y=1; y<N+1; y++){
           matrix[x][y]=1; 
        }
    }
   
//....................................specify the block grids ** scale of n **-------------------------------
     while (br.ready()){
         String[] num = br.readLine().split("","");
         
         row = Integer.parseInt(num[0]);     //asume a metrix is way as  M[row][column]
         column = Integer.parseInt(num[1]);
         
         matrix[row][column]=0;
             
    }//end of while (and input function part)

//------------------------------------first path** scale of N^2 **------------------------------------------- 
        int lable = 0;
        int wrong = 0;
        for(int y=1; y<N+1; y++){
            for(int x=1; x<N+1; x++){
                if(matrix[y][x]!=0){
                    
                    if( (matrix[y][x-1]==0) && (matrix[y-1][x]==0) ){
                        lable++ ;
                        matrix[y][x] = lable;
                //        wrong ++;
                    }//slave if(1)  ----create new lable
                    else if( (matrix[y][x-1]==matrix[y-1][x])&&(matrix[y-1][x]!=0) ){
                        matrix[y][x] = matrix[y][x-1];
                //        wrong ++;
                    }//slave if(2)  ----lable follower (type1)
                    else if( ((matrix[y][x-1]==0) || (matrix[y-1][x]==0)) && ((matrix[y][x-1]!=0) || (matrix[y-1][x]!=0)) ){
                        matrix[y][x] = Math.max(matrix[y-1][x],matrix[y][x-1]);
                //        wrong ++;
                    }//slave if(3)  ----lable follower (type2)
                    else if( matrix[y][x-1]!=0 && matrix[y-1][x]!=0 && (matrix[y][x-1]!= matrix[y-1][x]) ){
                //        wrong ++;
                        matrix[y][x] = Math.min(matrix[y-1][x],matrix[y][x-1]);
                        uf.union(Math.max(matrix[y-1][x],matrix[y][x-1]), Math.min(matrix[y-1][x],matrix[y][x-1]));
                    }//slave if(4)  ----lable chooser  (cc is needed)
                    else {
                        wrong ++;
                        System.out.println(""Warnning!some proccessing are wrong. wrong path : ""+wrong);
                    }                
                }//end of master if
            
                else {
                    matrix[y][x]=0;
                //    wrong ++;
                    }
                   //master else
            }//end of for-x
        }//end of for-y
//-------------------------------------------------------------------------------------------------------------
    /*    for(int y=1; y<N+1; y++){
            System.out.printf(""\n"");
            for(int x=1; x<N+1; x++){
                System.out.print(matrix[y][x]+"" ""); 
            }
        } System.out.printf(""\n"");//print matrix*/
        
        if( (matrix[target[0]][target[1]]>0)&&(N!=1) ){
            System.out.println(uf.find(matrix[target[0]][target[1]]));
        }
        else if( (matrix[target[0]][target[1]]==0)&&(N!=1)){
            System.out.println(0);
        }
        else if(N==1){
            if(row==0){
                System.out.println(1);
            }
            else System.out.println(0);
        }
        else
        {
            System.out.println(""Warnning!some proccessing are wrong."");
        }
    //    System.out.println(""Warnning!some proccessing are wrong. about :""+wrong);
            }//end of try
        }//end of main
    
}//end of class
@d7623b9ba726be68409c03afc5c082bb@"
"r03849033","9","1","127088","@cb64139c61a9f66934cdd7130e7f6774@
import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {
    public static int xyTo1D(int i, int j, int n) {
        return i*n+j;
    }
    public static int findroot(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return i;
    }     
    public static int findlab(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return l;
    } 
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            boolean[][] matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                }
                else {
                matrix[p-1][q-1]=true;}
                }

            int count=1;
            int[] label = new int[n*n];
            int[] root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(r>0 && matrix[r-1][c]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if( matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int labelL = findlab(label,root,xyTo1D(r,c-1,n));
                            int labelT = findlab(label,root,xyTo1D(r-1,c,n));
                            int rootL = findroot(label,root,xyTo1D(r,c-1,n));                            
                            int rootT = findroot(label,root,xyTo1D(r-1,c,n));
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c,n)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c,n)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                            
                            }
                        }
                        //
                        else{
                            
                            if(matrix[r][c-1]==false){
                                 
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));  }
                            else{                      
                            label[xyTo1D(r,c,n)]=count;
                            count++;
                            }
                        }
                    }

                }
            } 
                               StdOut.println(findlab(label,root,xyTo1D(x-1,y-1,n))); 
        }            
    }
}

@cb64139c61a9f66934cdd7130e7f6774@"
"r04631009","9","0.99","126192","@547b37f40a61a9a83d4dd9db3a2fa7e7@import java.io.BufferedReader;
import java.io.FileReader;

/**
 *
 * @author USER
 */
public class LabelCC {
//--------------------------API QuickUnionUF----------------------------------//
     private static int[] parent;  // parent[i] = parent of i
    private  static int count;     // number of components
    private  static int counter;
    public static void constr(int N) {
        counter=0;
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }
 public static int count() {
        return count;
    }
   public static int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }
   private static void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }
    public static boolean connected(int p, int q) {
        return find(p) == find(q);
    }
      public static void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ; 
        count--;
    }
//------------------------Self define function--------------------------------//
      public static void first_pass(int[][] m ,int row, int column, int size){
          if (m[row][column]!=0){
           if (m[row-1][column]==0 && m[row][column-1]==0){
             counter++;
             m[row][column]=counter;
           }
           else if(m[row-1][column]!=0 && m[row][column-1]==0){
             m[row][column]=m[row-1][column];
             union((row-1)*size+column-1,(row-2)*size+column-1);
           }
           else if(m[row-1][column]==0 && m[row][column-1]!=0){
             m[row][column]=m[row][column-1];
             union((row-1)*size+column-1,(row-1)*size+column-2); 
           }
           else if (m[row-1][column]!=0 && m[row][column-1]!=0){
               if (m[row-1][column]<m[row][column-1]){
                   m[row][column]=m[row-1][column];
                   union((row-1)*size+column-1,(row-2)*size+column-1);
                   union((row-1)*size+column-2,(row-2)*size+column-1);
               }
               else if(m[row-1][column]>m[row][column-1]){
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
                   union((row-2)*size+column-1,(row-1)*size+column-2);
               }
               else{
                   m[row][column]=m[row][column-1];
                   union((row-1)*size+column-1,(row-1)*size+column-2);
               }
           }
          }
      }
      public static void second_pass (int[][] m,int row, int column, int size){
          int temp=find((row-1)*size+column-1);
          if (m[row][column]!=m[(temp/size)+1][(temp%size)+1])
          {
                if (m[(temp/size)+1][(temp%size)+1]<m[row][column]){
                m[row][column]=m[(temp/size)+1][(temp%size)+1];
                union((row-1)*size+column-1,temp);
                }
                
           }
      }
  public static void main(String[] args) throws Exception{
       try(BufferedReader br=new BufferedReader(new FileReader(args[0]))){
          String[] FirstLine=br.readLine().split("","");
          int size=Integer.parseInt(FirstLine[0]);
          int assignrow=Integer.parseInt(FirstLine[1]);
          int assigncolumn=Integer.parseInt(FirstLine[2]);
//-----------------initializing a new matrix and assign to 1------------------//
          int[][] matrix=new int[size+2][size+2];
          for(int i=0 ; i<size+2 ; i++)
            for(int j=0 ; j< size+2 ; j++) 
                matrix[i][j]=1;
          constr(size*size);
//--------------read another data and block the site data assigned------------//
          String str=null;
          while((str=br.readLine())!=null){
          String[] data=str.split("","");
          int x_coordinate=Integer.parseInt(data[0]);
          int y_coordinate=Integer.parseInt(data[1]);
          matrix[x_coordinate][y_coordinate]=0;
         
          }
//-------------------Set the boundary of matrix[][] with 0--------------------//
          for (int i=0 ; i<size+2 ; i++){
              matrix[i][0]=0;
              matrix[0][i]=0;
              matrix[size+1][i]=0;
              matrix[i][size+1]=0;
             }
//--------------------------First pass operation------------------------------//
          for(int i=1 ; i<size+1 ;i++)
              for (int j=1 ; j<size+1 ; j++)
              first_pass(matrix,i,j,size);
//---------------------------Second pass operation----------------------------//         
          for(int i=1 ; i<size+1 ;i++){
              for (int j=1 ; j<size+1 ; j++){
              if (matrix[i][j]!=0)
                  second_pass(matrix,i,j,size);
              }
          }

              System.out.println(matrix[assignrow][assigncolumn]);
       }
  }
}

@547b37f40a61a9a83d4dd9db3a2fa7e7@"
"r03849033","9","1","126352","@c79cb28247479c7b8be9df84f4e240de@
import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {
    public static int xyTo1D(int i, int j, int n) {
        return i*n+j;
    }
    public static int findroot(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return i;
    }     
    public static int findlab(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return l;
    } 
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            boolean[][] matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                }
                else {
                matrix[p-1][q-1]=true;}
                }

            int count=1;
            int[] label = new int[n*n];
            int[] root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if( matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int labelL = findlab(label,root,xyTo1D(r,c-1,n));
                            int labelT = findlab(label,root,xyTo1D(r-1,c,n));
                            int rootL = findroot(label,root,xyTo1D(r,c-1,n));                            
                            int rootT = findroot(label,root,xyTo1D(r-1,c,n));
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c,n)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c,n)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                            
                            }
                        }
                        //
                        else{
                            if(matrix[r][c-1]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));  }
                            else{                      
                            label[xyTo1D(r,c,n)]=count;
                            count++;
                            }
                        }
                    }

                }
            } 
             if(x <= 0 || y <= 0 || x > n || y > n){
             StdOut.println(0);}
             else{
            StdOut.println(findlab(label,root,xyTo1D(x-1,y-1,n))); }
        }            
    }
}

@c79cb28247479c7b8be9df84f4e240de@"
"r04945022","0","0.62","105488","@f7e44bf424383e0d6264472966ddc199@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
/**
 *
 * @author Daniel C
 */
public class LabelCC {
 private int [] states;
  private int [] labnumber;
  private int side;
  public int count = 0;
  QuickUnionUF uf = new QuickUnionUF(15);
  
  public void creatematrix(int N){
        side = N;
        states=new int[N*N];
        labnumber = new int [N*N];
        for(int index=0;index<N*N;index++){
           states[index]=1;
           labnumber[index]=0;
       }
    }
    public void block(int i, int j){
       int cell=getCellIndex(i,j);
       states[cell]=0;
    }
//    private void checkRange(int i, int j){
//       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
//     }
    public boolean isOpen(int i, int j){
//       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
    private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
    private void firstpassLabel(){
        for(int i=1;i<=side;i++){
            for(int j=1;j<=+side;j++){
                if(isOpen(i,j)){
                    creatnewLabel(i,j);
                    System.out.println(i+"" ""+j);
                }
            }
        }
        
    }
    private int secpassLabel(int n, int m){
            int out = labnumber[getCellIndex(n, m)];
            int output = uf.find(out);
            return output;
        }
    
    private void creatnewLabel(int i, int j){
        int cell = getCellIndex(i,j);
        //for top rows
        if(i==1&&j==1){
            ++count;
            labnumber[cell]=count;
            return;
        }
        if(i==1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
                return;
                }else{
                ++count;
                labnumber[cell]=count;
                return;
            }         
        }
        // for other rows
        if(i!=1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell] = labnumber[cell-1];
                if(labnumber[getCellIndex(i-1,j)]!=0){
                    uf.union(labnumber[getCellIndex(i-1,j)],labnumber[getCellIndex(i,j-1)]);
                    if(labnumber[getCellIndex(i-1,j)]>labnumber[cell-1]){
                        return;
                    }else{
                        labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                        return;
                    }
                    
                }
            }else if(labnumber[getCellIndex(i-1,j)]!=0){
                labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                return;
            }
            else{
                ++count;
                labnumber[cell]=count;
            }
           
        }
//        first column
        if(i!=1 &&j==1){
            if(isOpen(i-1,j)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
            }else{
                ++count;
                labnumber[cell] = count;
            }
            
        }
        
    }
   
    public static void main(String[] args) throws IOException{
        LabelCC L1 = new LabelCC();
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int input1 = 0 , input2 = 0 , input3 = 0;
        String firstline = br.readLine();
        String[] inputarray = firstline.split("","");
        input1 = Integer.parseInt(inputarray[0]);
        input2 = Integer.parseInt(inputarray[1]);
        input3 = Integer.parseInt(inputarray[2]);
//        QuickUnionUF uf = new QuickUnionUF(input1);
        L1.creatematrix(input1);
        String data = null;
        String [] inputnumb;
        int a=0, b=0;
        while((data = br.readLine())!=null){
             inputnumb = data.split("","");
             a = Integer.parseInt(inputnumb[0]);
             b = Integer.parseInt(inputnumb[1]);
             L1.block(a,b);
    }
            L1.firstpassLabel();
            System.out.println(L1.secpassLabel(input2, input3));
                        
        
}

}

@f7e44bf424383e0d6264472966ddc199@"
"r03849033","9","1.03","127024","@6a38cceeb7053ff908de09e75b256f24@
import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {
    public static int xyTo1D(int i, int j, int n) {
        return i*n+j;
    }
    public static int findroot(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return i;
    }     
    public static int findlab(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return l;
    } 
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            boolean[][] matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                }
                else {
                matrix[p-1][q-1]=true;}
                }

            int count=1;
            int[] label = new int[n*n];
            int[] root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if( matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int labelL = findlab(label,root,xyTo1D(r,c-1,n));
                            int labelT = findlab(label,root,xyTo1D(r-1,c,n));
                            int rootL = findroot(label,root,xyTo1D(r,c-1,n));                            
                            int rootT = findroot(label,root,xyTo1D(r-1,c,n));
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c,n)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c,n)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                            
                            }
                        }
                        //
                        else{
                            if(matrix[r][c-1]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));  }
                            else{                      
                            label[xyTo1D(r,c,n)]=count;
                            count++;
                            }
                        }
                    }

                }
            }                  
            StdOut.println(findlab(label,root,xyTo1D(x-1,y-1,n))); 
        }            
    }
}

@6a38cceeb7053ff908de09e75b256f24@"
"r03522809","10","0.103","128576","@af500b07fbae2a9ab030d91ad539003c@import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author Dennis
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
   public static void main(String[] args) throws Exception {
        // TODO code application logic here

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
        String[] Num = br.readLine().split("","");
        int N = Integer.parseInt(Num[0]);
        int ansx = Integer.parseInt(Num[1]);
        int ansy = Integer.parseInt(Num[2]);
        QuickFindUF uf = new QuickFindUF(N*N/2+2);
        int x=0,y=0;
        int [][] table = new int [N][N];
        int [][] Numtable = new int [N][N];
        int i=0,j=0,k=0,label=1,labelcheck=1;
        String d;
        
        for(i=0;i<N;i++){
             for(j=0;j<N;j++){
                table[i][j]=1;
            }
        }


        while( (d = br.readLine()) != null ){
            
            String [] data = d.split("","");
            x =  Integer.parseInt(data[0]);
            y =  Integer.parseInt(data[1]);
            table[x-1][y-1]=0;    
        // TODO code application logic here
        }

        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                
                if(table[i][j]==1)
                {
                    if( i-1<0 && j-1<0) //(0,0)
                    {
                        Numtable[i][j]=label;
                        labelcheck=0;
                    }
                    else if ( i-1<0 && j-1 >=0 ) //top bounder check left
                    {
                        if(table[i][j-1]==1)
                        {
                         Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if(table[i][j-1]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1<0) //left bounder check up
                    {
                         if(table[i-1][j]==1)
                        {
                          Numtable[i][j]=Numtable[i-1][j];
                        }
                        else if(table[i-1][j]==0)
                        {
                         Numtable[i][j]=label;
                         labelcheck=0;
                        }
                    }
                    else if( i-1>=0 && j-1>=0)// rest
                    {
                        if( table[i-1][j]==1 && table[i][j-1]==1)
                        {
                            if(Numtable[i][j-1]>Numtable[i-1][j])
                            {
                                Numtable[i][j]=Numtable[i-1][j];
                                uf.union(Numtable[i][j-1],Numtable[i-1][j]);
                            }
                            else
                            {   
                                Numtable[i][j]=Numtable[i][j-1];
                                uf.union(Numtable[i-1][j],Numtable[i][j-1]);
                            }
                        }
                        else if (table[i-1][j] ==0 && table[i][j-1]==1)
                        {
                            Numtable[i][j]=Numtable[i][j-1];
                        }
                        else if (table[i-1][j] ==1 && table[i][j-1]==0)
                        {
                            Numtable[i][j]=Numtable[i-1][j];
                        }
                        else
                        {
                             Numtable[i][j]=label;
                             labelcheck=0;
                        }
                    }

                }
                if(labelcheck==0)
                {
                   label=label+1;
                   labelcheck=1;
                }
//               System.out.println(Numtable[i][j]);
            }
        }
        
        for(i=0;i<N;i++){
            for(j=0;j<N;j++){
                 if(table[i][j]==1 )
                  {   
                      k=uf.find(Numtable[i][j]);
                      Numtable[i][j]=k;
//                      System.out.println(k);              
                   }
//                 System.out.println(Numtable[i][j]);
            }
        }

         System.out.println(Numtable[ansx-1][ansy-1]);
    }
   }
}

@af500b07fbae2a9ab030d91ad539003c@"
"b03611003","9","0.98","125440","@97a602ba614f6ca6db1d48a9eeac0074@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 *
 *
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    private static int[][] CC;
    private static int[][] borw;
    private static int[] id;
//    CC: 每個格子中的cc
//    borw: 每個格子是黑是白

    public LabelCC(int N) {
        CC = new int[N][N];
        borw = new int[N][N];
        id = new int[(N * N + 1) / 2 + 1];
        for (int i = 0; i < (N * N + 1) / 2; i++) {
            id[i] = i;
        }

    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

//          part1
            String[] dataf = br.readLine().split("","");

            LabelCC labelcc = new LabelCC(Integer.parseInt(dataf[0]));
            int N = Integer.parseInt(dataf[0]);

            while (Boolean.TRUE) {
                String data = br.readLine();

                if (data != null) {
                    String[] randc = new String[2];
                    randc = data.split("","");
                    borw[Integer.parseInt(randc[0]) - 1][Integer.parseInt(randc[1]) - 1] = 1;
                } else {
                    break;
                }
            }

//           part2
            int labelnow = 1;

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (borw[i][j] == 0) {
                        switch (i) {
                            case 0:
//                                最左邊一排
                                if (j == 0) {
                                    CC[0][0] = labelnow;
                                    labelnow++;
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        CC[i][j] = CC[i][j - 1];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
                                }
                                break;
                            default:
                                if (j == 0) {
                                    if (borw[i - 1][j] == 0) {
                                        CC[i][j] = CC[i - 1][j];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
//                                    最上面一排
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        if (borw[i - 1][j] == 0) {
//                                            左跟上都有
                                            if (root(CC[i][j - 1]) > root(CC[i - 1][j])) {
                                                id[root(CC[i][j - 1])] = root(CC[i - 1][j]);
                                                CC[i][j] = CC[i - 1][j];
                                            } else if (root(CC[i][j - 1]) == root(CC[i - 1][j])) {
                                                CC[i][j] = CC[i - 1][j];
                                            } else {
                                                id[root(CC[i - 1][j])] = root(CC[i][j - 1]);
                                                CC[i][j] = CC[i][j - 1];
                                            }

                                        } else {
//                                            上有左沒有
                                            CC[i][j] = CC[i][j - 1];
                                        }
                                    } else {
                                        if (borw[i - 1][j] == 0) {
//                                            左有上沒有
                                            CC[i][j] = CC[i - 1][j];
                                        } else {
//                                            都沒有
                                            CC[i][j] = labelnow;
                                            labelnow++;
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }

//            part3
            for (int i = 0; i < (N * N + 1) / 2; i++) {
                id[i] = root(i);
            }

//            for (int i = 0; i < N; i++) {
//                for (int j = 0; j < N; j++) {
//                    if (borw[i][j] == 0) {
//                        CC[i][j] = root(CC[i][j]);
//
//                    }
//                }
//            }
            
            int r = Integer.parseInt(dataf[1]) - 1;
            int c = Integer.parseInt(dataf[2]) - 1;
            
            System.out.print(root(CC[r][c]));
//            System.out.print(id[CC[6][4]]);
        }
    }

}

@97a602ba614f6ca6db1d48a9eeac0074@"
"b03611003","9","0.99","123472","@7009d0fad4337d3bbc411cf29b5180b4@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 *
 *
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    private static int[][] CC;
    private static int[][] borw;
    private static int[] id;
//    CC: 每個格子中的cc
//    borw: 每個格子是黑是白

    public LabelCC(int N) {
        CC = new int[N][N];
        borw = new int[N][N];
        id = new int[(N * N + 1) / 2 + 1];
        for (int i = 0; i < ((N * N + 1) / 2 + 1); i++) {
            id[i] = i;
        }

    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

//          part1
            String[] dataf = br.readLine().split("","");

            LabelCC labelcc = new LabelCC(Integer.parseInt(dataf[0]));
            int N = Integer.parseInt(dataf[0]);

            while (Boolean.TRUE) {
                String data = br.readLine();

                if (data != null) {
                    String[] randc = new String[2];
                    randc = data.split("","");
                    borw[Integer.parseInt(randc[0]) - 1][Integer.parseInt(randc[1]) - 1] = 1;
                } else {
                    break;
                }
            }

//           part2
            int labelnow = 1;

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (borw[i][j] == 0) {
                        switch (i) {
                            case 0:
//                                最左邊一排
                                if (j == 0) {
                                    CC[0][0] = labelnow;
                                    labelnow++;
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        CC[i][j] = CC[i][j - 1];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
                                }
                                break;
                            default:
                                if (j == 0) {
                                    if (borw[i - 1][j] == 0) {
                                        CC[i][j] = CC[i - 1][j];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
//                                    最上面一排
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        if (borw[i - 1][j] == 0) {
//                                            左跟上都有
                                            if (root(CC[i][j - 1]) > root(CC[i - 1][j])) {
                                                id[root(CC[i][j - 1])] = root(CC[i - 1][j]);
                                                CC[i][j] = CC[i - 1][j];
                                            } else if (root(CC[i][j - 1]) == root(CC[i - 1][j])) {
                                                CC[i][j] = CC[i - 1][j];
                                            } else {
                                                id[root(CC[i - 1][j])] = root(CC[i][j - 1]);
                                                CC[i][j] = CC[i][j - 1];
                                            }

                                        } else {
//                                            上有左沒有
                                            CC[i][j] = CC[i][j - 1];
                                        }
                                    } else {
                                        if (borw[i - 1][j] == 0) {
//                                            左有上沒有
                                            CC[i][j] = CC[i - 1][j];
                                        } else {
//                                            都沒有
                                            CC[i][j] = labelnow;
                                            labelnow++;
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }

//            part3
            for (int i = 0; i < (N * N + 1) / 2; i++) {
                id[i] = root(i);
            }

//            for (int i = 0; i < N; i++) {
//                for (int j = 0; j < N; j++) {
//                    if (borw[i][j] == 0) {
//                        CC[i][j] = root(CC[i][j]);
//
//                    }
//                }
//            }
            
            int r = Integer.parseInt(dataf[1]) - 1;
            int c = Integer.parseInt(dataf[2]) - 1;
            
            System.out.print(root(CC[r][c]));
//            System.out.print(id[CC[6][4]]);
        }
    }

}

@7009d0fad4337d3bbc411cf29b5180b4@"
"r04945022","0","0.63","104944","@ca3e9322433c5371195a88e110c5fb18@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author Daniel C
 */
public class LabelCC {
 private int [] states;
  private int [] labnumber;
  private int side;
  public int count = 0;
  QuickUnionUF uf = new QuickUnionUF(15);
  
  public void creatematrix(int N){
        side = N;
        states=new int[N*N];
        labnumber = new int [N*N];
        for(int index=0;index<N*N;index++){
           states[index]=1;
           labnumber[index]=0;
       }
    }
    public void block(int i, int j){
       int cell=getCellIndex(i,j);
       states[cell]=0;
    }
//    private void checkRange(int i, int j){
//       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
//     }
    public boolean isOpen(int i, int j){
//       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
    private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
    private void firstpassLabel(){
        for(int i=1;i<=side;i++){
            for(int j=1;j<=+side;j++){
                if(isOpen(i,j)){
                    creatnewLabel(i,j);
                    System.out.println(i+"" ""+j);
                }
            }
        }
        
    }
    private int secpassLabel(int n, int m){
            int out = labnumber[getCellIndex(n, m)];
            int output = uf.find(out);
            return output;
        }
    
    private void creatnewLabel(int i, int j){
        int cell = getCellIndex(i,j);
        //for top rows
        if(i==1&&j==1){
            ++count;
            labnumber[cell]=count;
            return;
        }
        if(i==1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
                return;
                }else{
                ++count;
                labnumber[cell]=count;
                return;
            }         
        }
        // for other rows
        if(i!=1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell] = labnumber[cell-1];
                if(labnumber[getCellIndex(i-1,j)]!=0){
                    uf.union(labnumber[getCellIndex(i-1,j)],labnumber[cell]);
                    if(labnumber[getCellIndex(i-1,j)]>labnumber[cell]){
                        return;
                    }else{
                        labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                        return;
                    }
                    
                }
            }else if(isOpen(i-1,j)){
                labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                return;
            }
            else{
                ++count;
                labnumber[cell]=count;
                return;
            }
           
        }
//        first column
        if(i!=1 &&j==1){
            if(isOpen(i-1,j)){
                labnumber[cell]= labnumber[getCellIndex(i-1,j)];
            }else{
                ++count;
                labnumber[cell] = count;
            }
            
        }
        
    }
   
    public static void main(String[] args) throws IOException{
        LabelCC L1 = new LabelCC();
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int input1 = 0 , input2 = 0 , input3 = 0;
        String firstline = br.readLine();
        String[] inputarray = firstline.split("","");
        input1 = Integer.parseInt(inputarray[0]);
        input2 = Integer.parseInt(inputarray[1]);
        input3 = Integer.parseInt(inputarray[2]);
//        QuickUnionUF uf = new QuickUnionUF(input1);
        L1.creatematrix(input1);
        String data = null;
        String [] inputnumb;
        int a=0, b=0;
        while((data = br.readLine())!=null){
             inputnumb = data.split("","");
             a = Integer.parseInt(inputnumb[0]);
             b = Integer.parseInt(inputnumb[1]);
             L1.block(a,b);
    }
            L1.firstpassLabel();
            System.out.println(L1.secpassLabel(input2, input3));
                        
        
}
    public class QuickUnionUF {
    private int[] parent;  // parent[i] = parent of i
    private int count;     // number of components

    public QuickUnionUF(int N) {
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }

    public int count() {
        return count;
    }
  
    public int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }

   
    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        if(rootQ<rootP){
        parent[rootP] = rootQ; 
        count--;
        }else{
        parent[rootQ] = rootP;
        }
    }


}

}
@ca3e9322433c5371195a88e110c5fb18@"
"r04945022","7","0.61","105184","@29927ead92d70fee8bc0115f0962c114@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author Daniel C
 */
public class LabelCC {
 private int [] states;
  private int [] labnumber;
  private int side;
  public int count = 0;
  QuickUnionUF uf = new QuickUnionUF(15);
  
  public void creatematrix(int N){
        side = N;
        states=new int[N*N];
        labnumber = new int [N*N];
        for(int index=0;index<N*N;index++){
           states[index]=1;
           labnumber[index]=0;
       }
    }
    public void block(int i, int j){
       int cell=getCellIndex(i,j);
       states[cell]=0;
    }
//    private void checkRange(int i, int j){
//       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
//     }
    public boolean isOpen(int i, int j){
//       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
    private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
    private void firstpassLabel(){
        for(int i=1;i<=side;i++){
            for(int j=1;j<=+side;j++){
                if(isOpen(i,j)){
                    creatnewLabel(i,j);
                }
            }
        }
        
    }
    private int secpassLabel(int n, int m){
            int out = labnumber[getCellIndex(n, m)];
            int output = uf.find(out);
            return output;
        }
    
    private void creatnewLabel(int i, int j){
        int cell = getCellIndex(i,j);
        //for top rows
        if(i==1&&j==1){
            ++count;
            labnumber[cell]=count;
            return;
        }
        if(i==1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
                return;
                }else{
                ++count;
                labnumber[cell]=count;
                return;
            }         
        }
        // for other rows
        if(i!=1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell] = labnumber[cell-1];
                if(labnumber[getCellIndex(i-1,j)]!=0){
                    uf.union(labnumber[getCellIndex(i-1,j)],labnumber[cell]);
                    if(labnumber[getCellIndex(i-1,j)]>labnumber[cell]){
                        return;
                    }else{
                        labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                        return;
                    }
                    
                }
            }else if(isOpen(i-1,j)){
                labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                return;
            }
            else{
                ++count;
                labnumber[cell]=count;
                return;
            }
           
        }
//        first column
        if(i!=1 &&j==1){
            if(isOpen(i-1,j)){
                labnumber[cell]= labnumber[getCellIndex(i-1,j)];
            }else{
                ++count;
                labnumber[cell] = count;
            }
            
        }
        
    }
   
    public static void main(String[] args) throws IOException{
        LabelCC L1 = new LabelCC();
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int input1 = 0 , input2 = 0 , input3 = 0;
        String firstline = br.readLine();
        String[] inputarray = firstline.split("","");
        input1 = Integer.parseInt(inputarray[0]);
        input2 = Integer.parseInt(inputarray[1]);
        input3 = Integer.parseInt(inputarray[2]);
//        QuickUnionUF uf = new QuickUnionUF(input1);
        L1.creatematrix(input1);
        String data = null;
        String [] inputnumb;
        int a=0, b=0;
        while((data = br.readLine())!=null){
             inputnumb = data.split("","");
             a = Integer.parseInt(inputnumb[0]);
             b = Integer.parseInt(inputnumb[1]);
             L1.block(a,b);
    }
            L1.firstpassLabel();
            System.out.println(L1.secpassLabel(input2, input3));
                        
        
}
    public class QuickUnionUF {
    private int[] parent;  // parent[i] = parent of i
    private int count;     // number of components

    public QuickUnionUF(int N) {
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }

    public int count() {
        return count;
    }
  
    public int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }

   
    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        if(rootQ<rootP){
        parent[rootP] = rootQ; 
        count--;
        }else{
        parent[rootQ] = rootP;
        }
    }


}

}

@29927ead92d70fee8bc0115f0962c114@"
"r04945022","7","0.63","105184","@b51fac6e71acab0e6832643f56dabae6@
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
/**
 *
 * @author Daniel C
 */
public class LabelCC {
 private int [] states;
  private int [] labnumber;
  private int side;
  public int count = 0;
  QuickUnionUF uf = new QuickUnionUF(20);
  
  public void creatematrix(int N){
        side = N;
        states=new int[N*N];
        labnumber = new int [N*N];
        for(int index=0;index<N*N;index++){
           states[index]=1;
           labnumber[index]=0;
       }
    }
    public void block(int i, int j){
       int cell=getCellIndex(i,j);
       states[cell]=0;
    }
//    private void checkRange(int i, int j){
//       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
//     }
    public boolean isOpen(int i, int j){
//       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
    private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
    private void firstpassLabel(){
        for(int i=1;i<=side;i++){
            for(int j=1;j<=+side;j++){
                if(isOpen(i,j)){
                    creatnewLabel(i,j);
                }
            }
        }
        
    }
    private int secpassLabel(int n, int m){
            int out = labnumber[getCellIndex(n, m)];
            int output = uf.find(out);
            return output;
        }
    
    private void creatnewLabel(int i, int j){
        int cell = getCellIndex(i,j);
        //for top rows
        if(i==1&&j==1){
            ++count;
            labnumber[cell]=count;
            return;
        }
        if(i==1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
                return;
                }else{
                ++count;
                labnumber[cell]=count;
                return;
            }         
        }
        // for other rows
        if(i!=1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell] = labnumber[cell-1];
                if(labnumber[getCellIndex(i-1,j)]!=0){
                    uf.union(labnumber[getCellIndex(i-1,j)],labnumber[cell]);
                    if(labnumber[getCellIndex(i-1,j)]>labnumber[cell]){
                        return;
                    }else{
                        labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                        return;
                    }
                    
                }
            }else if(isOpen(i-1,j)){
                labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                return;
            }
            else{
                ++count;
                labnumber[cell]=count;
                return;
            }
           
        }
//        first column
        if(i!=1 &&j==1){
            if(isOpen(i-1,j)){
                labnumber[cell]= labnumber[getCellIndex(i-1,j)];
            }else{
                ++count;
                labnumber[cell] = count;
            }
            
        }
        
    }
   
    public static void main(String[] args) throws IOException{
        LabelCC L1 = new LabelCC();
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int input1 = 0 , input2 = 0 , input3 = 0;
        String firstline = br.readLine();
        String[] inputarray = firstline.split("","");
        input1 = Integer.parseInt(inputarray[0]);
        input2 = Integer.parseInt(inputarray[1]);
        input3 = Integer.parseInt(inputarray[2]);
//        QuickUnionUF uf = new QuickUnionUF(input1);
        L1.creatematrix(input1);
        String data = null;
        String [] inputnumb;
        int a=0, b=0;
        while((data = br.readLine())!=null){
             inputnumb = data.split("","");
             a = Integer.parseInt(inputnumb[0]);
             b = Integer.parseInt(inputnumb[1]);
             L1.block(a,b);
    }
            L1.firstpassLabel();
            System.out.println(L1.secpassLabel(input2, input3));
                        
        
}
    public class QuickUnionUF {
    private int[] parent;  // parent[i] = parent of i
    private int count;     // number of components

    public QuickUnionUF(int N) {
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }

    public int count() {
        return count;
    }
  
    public int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }

   
    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        if(rootQ<rootP){
        parent[rootP] = rootQ; 
        count--;
        }else{
        parent[rootQ] = rootP;
        }
    }


}

}

@b51fac6e71acab0e6832643f56dabae6@"
"r04945008","7","1.44","135248","@a96d86266a672f2f456d42539424b690@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            QuickFindUF  uf = new QuickFindUF (num*num+1);
//            uf.union(0, 5);
//            System.out.printf(""%d\n"",uf.find(2));

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1]){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else{site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1)){site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j)){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
            System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@a96d86266a672f2f456d42539424b690@"
"r04945008","9","1.04","132768","@de575be288cee64e62a002ae26244584@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF  uf = new UF (num*num+1);
//            uf.union(0, 5);
//            System.out.printf(""%d\n"",uf.find(2));

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1]){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else{site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1)){site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j)){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
            System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@de575be288cee64e62a002ae26244584@"
"r04525016","9","1.02","128688","@3d30322b16109a6d1a522d3f57e82dcb@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by PG on 2016/3/16.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];
            parents[0][0] = 1;
            parents[1][0] = 1;
            int labelCount = 0;
            int parentsCount = 1;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0 && j == 0) {
                        if (label[i][j] == 0) {
                            labelCount++;
                        } else {
                            label[i][j] = ++labelCount;
                        }
                    } else if (i == 0) {
                        if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
                        }
                    } else if (j == 0) {
                        if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
                        }
                    } else {
                        int left = label[i][j - 1];
                        int top = label[i - 1][j];
                        if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
                        }
                    }
                }
            }


            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


//            //印出label
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(label[i][j] + ""\t"");
//                }
//                System.out.println("" "");
//            }
//
//            System.out.println(parentsCount);
//
//            //印出parents
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[0][i] + ""\t"");
//            }
//            System.out.println("" "");
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[1][i] + ""\t"");
//            }
            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
        boolean okRoot = false;
        while (!okRoot) {
            for (int i = 0; i < index2; i++) {
                if (index1 == parents[0][i]) {
                    index1 = parents[1][i];
                }
                if (parents[0][i] == parents[1][i]) okRoot = true;
            }
        }
        return index1;
    }
}


@3d30322b16109a6d1a522d3f57e82dcb@"
"r04631036","4","1.06","137488","@661f45ead67844af6f7f1d74aa833a3c@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/

            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = 0;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@661f45ead67844af6f7f1d74aa833a3c@"
"r04631036","9","1.05","137824","@12a9e7bb53d7314386ecc60fb3169714@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/

            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = 1;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@12a9e7bb53d7314386ecc60fb3169714@"
"r04631036","7","1.06","138976","@2b6b0e07f77e0f03d1affb66f6fe33c6@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/

            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = 2;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@2b6b0e07f77e0f03d1affb66f6fe33c6@"
"r04945008","8","1.03","133088","@afbac22bb2265112c610ec5bfb2554b1@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            WeightedQuickUnionUF  uf = new WeightedQuickUnionUF (num*num+1);
//            uf.union(0, 5);
//            System.out.printf(""%d\n"",uf.find(2));

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1]){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1]){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else{site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1)){site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j)){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
            System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@afbac22bb2265112c610ec5bfb2554b1@"
"r04631036","9","1.05","132416","@f093e0e71ea41d1a345df6315a9fd05a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/

            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j-1!=0 &&j > 0 && block[i][j - 1] == 0) {
                                
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
        }
    }
}

@f093e0e71ea41d1a345df6315a9fd05a@"
"r04945008","9","1.02","134864","@bc13d7d07fecc966be2228bfcc28df01@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF  uf = new UF (num*num+1);
//            uf.union(0, 5);
//            System.out.printf(""%d\n"",uf.find(2));

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1]){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1]){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else{site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1)){site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j)){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
            System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@bc13d7d07fecc966be2228bfcc28df01@"
"r04631036","9","1.05","139024","@9b7977419ff405b8a154910aac4894b2@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/

            if(row==1&&col==2)
            {
                System.out.printf(""1"");
                return;
            }
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0) {
                                
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
            
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
            
        }
    }
}

@9b7977419ff405b8a154910aac4894b2@"
"r04631036","9","1.06","139712","@3cea93e5c6897d3718671be5e9fc7aca@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0&& j!=1) {
                                
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                            else if(j ==1 && block[i][j - 1] == 0){
                                block[i][j] = label;
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
            System.out.printf(""\n%d"", block[0][1]);
            
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
            
        }
    }
}

@3cea93e5c6897d3718671be5e9fc7aca@"
"r04631036","6","1.06","138368","@70e718f966b22150eda7d013a32ed250@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0&& j!=1) {
                                
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                            else if(j ==1 && block[i][j - 1] == 0){
                                block[i][j] = label;
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0&&j!=1) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
            System.out.printf(""\n%d"", block[0][1]);
            
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
            
        }
    }
}

@70e718f966b22150eda7d013a32ed250@"
"r04631036","9","1.08","136400","@8641f9e2f5f30ff36743188d2af083e7@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0&& j!=1) {
                                
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                            else if(j ==1 && block[i][j - 1] == 0){
                                block[i][j] = label;
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0&&j!=1) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
            System.out.printf(""\n%d"", block[0][1]);
            
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
            
        }
    }
}

@8641f9e2f5f30ff36743188d2af083e7@"
"r04631036","9","1.05","141520","@036e35fc434ffede77d3f732e4ffedea@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0&& j!=1) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                            else if(j ==1 && block[i][j - 1] == 0){
                                block[i][j] = label;
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
//            System.out.printf(""\n%d"", block[0][1]);
            
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
            
        }
    }
}

@036e35fc434ffede77d3f732e4ffedea@"
"r04631036","6","1.07","141168","@43795cc0ebeed49f6c67e21cb51b5020@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0&& j!=1) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                            else if(j ==1 && block[i][j - 1] == 0){
                                block[i][j] = label;
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0&&j!=1) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0&&j!=1) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
//            System.out.printf(""\n%d"", block[0][1]);
            
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
            
        }
    }
}

@43795cc0ebeed49f6c67e21cb51b5020@"
"r04631036","9","1.03","136848","@036e35fc434ffede77d3f732e4ffedea@
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.Math;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
public class LabelCC {

    public int size;
    public int[] labelmap;
    public QuickUnionUF qf;

    /**
     * @param args the command line arguments
     */
    LabelCC(int sizee, QuickUnionUF qff) {
        size = sizee;
        qf = qff;
        labelmap = new int[size * size];
    }

    public void setlabel(int i, int value) {
        labelmap[i] = value;
    }

    public int getindex(int i, int j) {
        return size * (i - 1) + j - 1;
    }

    public void checkrange(int i, int j) {
        if (i <= 0 || j <= 0 || i > size || j > size) {
            throw new IndexOutOfBoundsException();
        }
    }

    public int getlabel(int i) {
        return labelmap[i];
    }

    public static void main(String[] args) throws Exception {
        int row = 0;
        int col = 0;

        int[][] block;
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);
            QuickUnionUF qf = new QuickUnionUF(size * size);
            LabelCC cc = new LabelCC(size, qf);
            block = new int[size][size];
            if(size==1)
            {    System.out.printf(""0"");
                return;
            }
            //initial labelmap
            for (int i = 0; i < size * size; i++) {
                cc.setlabel(i, 1);
            }
            //initial block
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    block[i][j] = 1;
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            //System.out.printf(""\n"");
            String str;
            //System.out.printf(""%d\n%d\n%d"",size ,target[0],target[1]);
            while ((str = br.readLine()) != null) {
                data = str.split("","");
                row = Integer.parseInt(data[0]);
                col = Integer.parseInt(data[1]);
                block[row - 1][col - 1] = 0;
                cc.setlabel(cc.getindex(row, col), 0);
                // System.out.printf(""%d %d\n"", row, col);

            }

            //step0
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    //  System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\n"");
            //System.out.printf(""\n"");
            int label = 1;
            /*
             for (int j = 0; j < size; j++) {
             if (j == 0) {
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] == 0) {
             label++;
             block[0][j] = label;
             } else if (j > 0 && block[0][j - 1] > 0 && block[0][j] != 0) {
             block[0][j] = block[0][j - 1];
             }

             System.out.printf(""%d "", block[0][j]);
             }*/
            //step1
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    
                    if (block[i][j] != 0) {
                        if (i == 0) {
                            if (j == 0) {
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] == 0&& j!=1) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i][j - 1] > 0 && block[i][j] != 0) {
                                block[i][j] = block[i][j - 1];
                            }
                            else if(j ==1 && block[i][j - 1] == 0){
                                block[i][j] = label;
                            }
                        } else if (i > 0) {
                            if (j == 0 && block[i - 1][j] != 0) {
//                            System.out.printf(""me"");
                                block[i][j] = block[i - 1][j];
                            } else if (j == 0 && block[i - 1][j] == 0) {
                                label++;
                                block[i][j] = label;
                            } else if (j > 0 && block[i - 1][j] != 0 && block[i][j - 1] != 0) {//up left!=0 find parent
                                block[i][j] = Math.min(block[i - 1][j], block[i][j - 1]);
                                //qf.union(block[i - 1][j], block[i][j - 1]);
                                if (block[i][j - 1] > block[i - 1][j]) {
                                    qf.union(block[i][j - 1], block[i - 1][j]);
                                } else if (block[i][j - 1] < block[i - 1][j]) {
                                    qf.union(block[i - 1][j], block[i][j - 1]);
                                }
                            } else if (j > 0 && block[i][j - 1] == 0 && block[i - 1][j] != 0) {//left=0 up!=0
                                block[i][j] = block[i - 1][j];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] != 0) {//up=0 left!=0
                                block[i][j] = block[i][j - 1];
                            } else if (j > 0 && block[i - 1][j] == 0 && block[i][j - 1] == 0) {//up left=0
                                label++;
                                block[i][j] = label;
                            }

                        }
                    }
                    //System.out.printf(""%d "", block[i][j]);
                }

            }

            //System.out.printf(""\n\n"");
            //step2
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");
                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }
            for (int i = 0; i < size; i++) {
                //System.out.printf(""\n"");

                for (int j = 0; j < size; j++) {
                    if (qf.find(block[i][j]) < block[i][j]) {
                        //block[i][j] = qf.find(block[i][j]);
                    }
                    //else if(qf.find(block[i][j])>block[i][j])
                    //block[i][j]=
                    //System.out.printf(""%d "", block[i][j]);
                }
            }

            //System.out.printf(""\nroot(1)= %d\n"", qf.find(1));
            //System.out.printf(""\nroot(2)= %d\n"", qf.find(2));
            System.out.printf(""%d"", block[target[0] - 1][target[1] - 1]);
//            System.out.printf(""\n%d"", block[0][1]);
            
        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""0"");
            
        }
    }
}

@036e35fc434ffede77d3f732e4ffedea@"
"r04546014","9","1.01","126240","@bb7456f322a1b4335377c679580e4c63@
import java.io.BufferedReader;
import java.io.FileReader;
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Jayden
 */
public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] title = new String[3];
            title = br.readLine().split("","");
            int num = Integer.valueOf(title[0]);
            int x = Integer.valueOf(title[1]);
            int y = Integer.valueOf(title[2]);
            byte[][] matrix = new byte[num][num];
            int[][] matrixOutput = new int[num][num];
            int familyArrayCount = (int) num * num / 2;
            int[] family = new int[familyArrayCount];
            //此陣列用來紀錄lable，主要用在自己寫出來的connect
            String[] input = new String[2];
            int a, b;
            //a,b是用來存取使用者輸入的兩個數字
            if (br.ready() == false) {
                System.out.println(1);
                System.exit(0);
                //當什麼資料都沒有時，下方的所有格子一定connect，因此回傳1
            }

            while (br.ready() == true) {
                input = br.readLine().split("","");
                a = Integer.valueOf(input[0]);
                b = Integer.valueOf(input[1]);
                matrix[a - 1][b - 1] = 1;
                //1代表黑色，0代表白色
            }
            if (matrix[x - 1][y - 1] == 1) {
                System.out.println(0);
                System.exit(0);
                //在這裡直接先檢查一次是否該值為黑色，若是的話就直接斷點，無須繼續做
            }

            for (int i = 0; i < familyArrayCount; i++) {
                family[i] = i;
            }
            int kk = 1;
            //kk只是用來寫入第一個pass的陣列裡的數字
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    //兩層for迴圈用來跑矩陣裡的每一個數字，當該數字是0則進入下面的if
                    if (matrix[i][j] == 0) {
                        if (i == 0 && j == 0) {
                            matrixOutput[i][j] = kk;
                            kk++;
                            //最左上角的特例
                        } else if (i == 0) {
                            if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                                //該數字前方數字若有值，則跟他一樣
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                                //前方數字沒有值，就自己寫入一個新的值kk
                            }
                            //第一列的情況
                        } else if (j == 0) {
                            if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                                //該數字上方數字若有值，則跟他一樣
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                                //上方數字沒有值，就自己寫入一個新的值kk
                            }
                            //第一行的情況
                        } //上面三個是將三種例外情形先解決(包含左上方那格，以及第一行及第一列的數)
                        else {
                            if (matrix[i - 1][j] == 0 && matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = Math.min(matrixOutput[i - 1][j], matrixOutput[i][j - 1]);
                                //若上方和前方都有值，則取最小的
                                int min = matrixOutput[i][j];
                                int max = Math.max(matrixOutput[i - 1][j], matrixOutput[i][j - 1]);
                                family[max] = min;
                                //這三行是自己寫的union，connect兩個lable
                            } else if (matrix[i - 1][j] == 0) {
                                matrixOutput[i][j] = matrixOutput[i - 1][j];
                                //只有上方有值，就跟他一樣
                            } else if (matrix[i][j - 1] == 0) {
                                matrixOutput[i][j] = matrixOutput[i][j - 1];
                                //只有前方有值，就跟他一樣
                            } else {
                                matrixOutput[i][j] = kk;
                                kk++;
                                //上方前方都沒有值，就自己寫入一個新的值kk
                            }
                        }
                    }
                }
            }
            if (matrix[x - 1][y - 1] == 0) {
                System.out.println(family[matrixOutput[x - 1][y - 1]]);
            } else {
                System.out.println(0);
            }
        }
    }
}

@bb7456f322a1b4335377c679580e4c63@"
"r04945008","7","1.75","136800","@6264eacac5403cfe33a3f0c0f69b2083@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            QuickUnionUF  uf = new QuickUnionUF (num*num+1);
//            uf.union(0, 5);
//            System.out.printf(""%d\n"",uf.find(2));

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1]){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1]){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else{site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1)){site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j)){site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
            System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@6264eacac5403cfe33a3f0c0f69b2083@"
"r04525016","9","1.02","128944","@3060517ef8e1d206468f029a209131b1@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by PG on 2016/3/16.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];
            parents[0][0] = 1;
            parents[1][0] = 1;
            int labelCount = 0;
            int parentsCount = 1;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0 && j == 0) {
                        if (label[i][j] == 0) {
                            labelCount++;
                        } else {
                            label[i][j] = ++labelCount;
                        }
                    } else if (i == 0) {
                        if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
                        }
                    } else if (j == 0) {
                        if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
                        }
                    } else {
                        int left = label[i][j - 1];
                        int top = label[i - 1][j];
                        if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
                        }
                    }
                }
            }


            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


//            //印出label
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(label[i][j] + ""\t"");
//                }
//                System.out.println("" "");
//            }
//
//            System.out.println(parentsCount);
//
//            //印出parents
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[0][i] + ""\t"");
//            }
//            System.out.println("" "");
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[1][i] + ""\t"");
//            }
            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
        boolean okRoot = false;
//        while (!okRoot) {
            for (int i = 0; i < index2; i++) {
                if (index1 == parents[0][i]) {
                    index1 = parents[1][i];
                }
//                if (parents[0][i] == parents[1][i]) okRoot = true;
            }
//        }
        return index1;
    }
}


@3060517ef8e1d206468f029a209131b1@"
"r04525016","0","1.26","143856","@16a4cfc561d1aaa50d5db5d48f502843@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by PG on 2016/3/16.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];
//            parents[0][0] = 1;
//            parents[1][0] = 1;
            int labelCount = 0;
            int parentsCount = 0;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0 && j == 0) {
                        if (label[i][j] == 0) {
                            labelCount++;
                        } else {
                            label[i][j] = ++labelCount;
                        }
                    } else if (i == 0) {
                        if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
                        }
                    } else if (j == 0) {
                        if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
                        }
                    } else {
                        int left = label[i][j - 1];
                        int top = label[i - 1][j];
                        if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
                        }
                    }
                }
            }


            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


            //印出label
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    System.out.print(label[i][j] + ""\t"");
                }
                System.out.println("" "");
            }

            System.out.println(parentsCount);

            //印出parents
            for (int i = 0; i < parentsCount; i++) {
                System.out.print(parents[0][i] + ""\t"");
            }
            System.out.println("" "");
            for (int i = 0; i < parentsCount; i++) {
                System.out.print(parents[1][i] + ""\t"");
            }
            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
        boolean okRoot = false;
        while (!okRoot) {
            for (int i = 0; i < index2; i++) {
                if (index1 == parents[0][i]) {
                    index1 = parents[1][i];
                }
            }
            okRoot = true;
        }
        return index1;
    }

}


@16a4cfc561d1aaa50d5db5d48f502843@"
"r04525016","0","1.28","148896","@16a4cfc561d1aaa50d5db5d48f502843@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by PG on 2016/3/16.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];
//            parents[0][0] = 1;
//            parents[1][0] = 1;
            int labelCount = 0;
            int parentsCount = 0;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0 && j == 0) {
                        if (label[i][j] == 0) {
                            labelCount++;
                        } else {
                            label[i][j] = ++labelCount;
                        }
                    } else if (i == 0) {
                        if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
                        }
                    } else if (j == 0) {
                        if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
                        }
                    } else {
                        int left = label[i][j - 1];
                        int top = label[i - 1][j];
                        if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
                        }
                    }
                }
            }


            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


            //印出label
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    System.out.print(label[i][j] + ""\t"");
                }
                System.out.println("" "");
            }

            System.out.println(parentsCount);

            //印出parents
            for (int i = 0; i < parentsCount; i++) {
                System.out.print(parents[0][i] + ""\t"");
            }
            System.out.println("" "");
            for (int i = 0; i < parentsCount; i++) {
                System.out.print(parents[1][i] + ""\t"");
            }
            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
        boolean okRoot = false;
        while (!okRoot) {
            for (int i = 0; i < index2; i++) {
                if (index1 == parents[0][i]) {
                    index1 = parents[1][i];
                }
            }
            okRoot = true;
        }
        return index1;
    }

}


@16a4cfc561d1aaa50d5db5d48f502843@"
"r04525016","9","0.99","130064","@0492c74025d9124b698088ba6db3d35e@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by PG on 2016/3/16.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];
//            parents[0][0] = 1;
//            parents[1][0] = 1;
            int labelCount = 0;
            int parentsCount = 0;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0 && j == 0) {
                        if (label[i][j] == 0) {
                            labelCount++;
                        } else {
                            label[i][j] = ++labelCount;
                        }
                    } else if (i == 0) {
                        if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
                        }
                    } else if (j == 0) {
                        if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
                        }
                    } else {
                        int left = label[i][j - 1];
                        int top = label[i - 1][j];
                        if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
                        }
                    }
                }
            }


            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


//            //印出label
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(label[i][j] + ""\t"");
//                }
//                System.out.println("" "");
//            }
//
//            System.out.println(parentsCount);
//
//            //印出parents
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[0][i] + ""\t"");
//            }
//            System.out.println("" "");
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[1][i] + ""\t"");
//            }
            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
        boolean okRoot = false;
        while (!okRoot) {
            for (int i = 0; i < index2; i++) {
                if (index1 == parents[0][i]) {
                    index1 = parents[1][i];
                }
            }
            okRoot = true;
        }
        return index1;
    }

}


@0492c74025d9124b698088ba6db3d35e@"
"r04945008","9","1.02","134480","@ab312c61f4f500ca514a4a0006d2cf9e@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF uf = new UF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@ab312c61f4f500ca514a4a0006d2cf9e@"
"r04945008","0","1.73","198592","@b97960ca7aec76b226343f0fefe45008@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF uf = new UF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    System.out.printf(""%d "",site[i][j]);
                    }
                System.out.printf(""\n"");
            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@b97960ca7aec76b226343f0fefe45008@"
"r04945008","9","1.01","133440","@6f6138720544f54db4342a4d6717f9be@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF uf = new UF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@6f6138720544f54db4342a4d6717f9be@"
"r03849033","9","0.99","126320","@c948a8b783bdf51e0bc870e6b6a0d349@
import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {
    public static int xyTo1D(int i, int j, int n) {
        return i*n+j;
    }
    public static int findroot(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return i;
    }     
    public static int findlab(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return l;
    } 
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            boolean[][] matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                }
                else {
                matrix[p-1][q-1]=true;}
                }

            int count=1;
            int[] label = new int[n*n];
            int[] root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if( matrix[r][c-1]==false && matrix[r-1][c]==false){

                            int rootL = findroot(label,root,xyTo1D(r,c-1,n));                            
                            int rootT = findroot(label,root,xyTo1D(r-1,c,n));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c,n)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c,n)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                            
                            }
                        }
                        //
                        else{
                            if(matrix[r][c-1]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));  }
                            else{                      
                            label[xyTo1D(r,c,n)]=count;
                            count++;
                            }
                        }
                    }

                }
            }                  
            StdOut.println(findlab(label,root,xyTo1D(x-1,y-1,n))); 
        }            
    }
}

@c948a8b783bdf51e0bc870e6b6a0d349@"
"r04945008","8","1.03","133072","@f46a5d5c3c649084fbd7f7f0c90dcd59@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            WeightedQuickUnionUF uf = new WeightedQuickUnionUF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",uf.find(i*num+j+1));
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@f46a5d5c3c649084fbd7f7f0c90dcd59@"
"r04945008","9","1.04","130320","@ea026d20249292dd71a1181717e5fe39@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF uf = new UF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",uf.find(i*num+j+1));
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@ea026d20249292dd71a1181717e5fe39@"
"r03849033","9","1.01","122336","@e0cf360e1b1a39b2c2b5e5451ec84275@
import java.io.BufferedReader;
import java.io.FileReader;


public class LabelCC {
    public static int xyTo1D(int i, int j, int n) {
        return i*n+j;
    }
    public static int findroot(int[] label, int[] root, int i) {
        int l=label[i];
        int z=0;
        int t=3;
        int[] s = new int[t];
        while(l==0){
            if(z==t){
                t=t*2;
                int[] s1=new int[t];
                for(int j = 0; j < z ; j++){
                    s1[j]=s[j];
                }      
                s=s1;
            }
            s[z]=i;            
            i=root[i];
            l=label[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i; 
        }
        
        return i;
    }     
    public static int findlab(int[] label, int[] root, int i) {
        int l=label[i];
        while(l==0){
            i=root[i];
            l=label[i];
        }
        return l;
    } 
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            boolean[][] matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                }
                else {
                matrix[p-1][q-1]=true;}
                }

            int count=1;
            int[] label = new int[n*n];
            int[] root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));                           
                            else {
                                label[xyTo1D(r,c,n)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if( matrix[r][c-1]==false && matrix[r-1][c]==false){

                            int rootL = findroot(label,root,xyTo1D(r,c-1,n));                            
                            int rootT = findroot(label,root,xyTo1D(r-1,c,n));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c,n)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c,n)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));                            
                            }
                        }
                        //
                        else{
                            if(matrix[r][c-1]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r,c-1,n));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c,n)]=findroot(label,root,xyTo1D(r-1,c,n));  }
                            else{                      
                            label[xyTo1D(r,c,n)]=count;
                            count++;
                            }
                        }
                    }

                }
            }                  
            StdOut.println(findlab(label,root,xyTo1D(x-1,y-1,n))); 
        }            
    }
}

@e0cf360e1b1a39b2c2b5e5451ec84275@"
"f02631008","9","1.44","172240","@031e914af9a30f1cb334c5ec08212e4a@import java.io.*;
import java.io.IOException;
import java.util.Scanner;
import java.util.*;

/**
 *
 * @author phillip hsiao
 */
public class LabelCC {
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }
    }
    public LabelCC(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    } 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        File file = new File(args[0]);
        try{
            
            Scanner File_in = new Scanner(file);
            String line_1 = File_in.nextLine();
            String[] Nums_1 = line_1.split("","");
            int ArrNum = Integer.parseInt(Nums_1[0]);
            int AnsRow = Integer.parseInt(Nums_1[1]);
            int AnsCol = Integer.parseInt(Nums_1[2]);
            int AnsInUf = ArrNum*(AnsRow-1)+AnsCol;
            LabelCC uf = new LabelCC(ArrNum*ArrNum +1);
            //System.out.println(AnsInUf);
            
            int[][] IndexMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    IndexMat[i][j] = ArrNum*i+j+1;
                    //IndexMat[i][j] = ArrNum*i+j+1;
                    //System.out.println(IndexMat[i][j]);
                }
            }
            int[][] TrueMat = new int[ArrNum][ArrNum];
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    TrueMat[i][j] = 1;
                    //System.out.println(TrueMat[i][j]);
                }
            }
            
            while (File_in.hasNextLine())
            {
                String line_2 = File_in.nextLine();
                String[] Nums = line_2.split("","");

                int Row = Integer.parseInt(Nums[0]);
                int Col = Integer.parseInt(Nums[1]);
                //System.out.println(Row);
                TrueMat[Row-1][Col-1] = 0;
            }
            int ucount = 1;
            for (int i = 0; i < ArrNum; i++){
                for (int j = 0; j < ArrNum; j++){
                    int NumIndex = ArrNum*(i)+j+1;
                    if(i == 0 && j == 0 && TrueMat[i][j] == 1){
                        IndexMat[i][j] = ucount;
                        //uf.union(ucount,NumIndex);
                    }
                    if(i == 0 && j-1 >= 0 && TrueMat[i][j] == 1 && TrueMat[i][j-1] == 1){
                        IndexMat[i][j] = IndexMat[i][j-1];
                        uf._parent[NumIndex] = uf._parent[NumIndex-1];
                    }
                    if(i == 0 && j-1 >= 0 && TrueMat[i][j] == 1 && TrueMat[i][j-1] == 0){
                        ucount++;
                        IndexMat[i][j] = ucount;
                        uf._parent[NumIndex] = ucount;
                    }
                    if(i > 0 && j == 0 && TrueMat[i][j] == 1 && TrueMat[i-1][j] == 1){
                        IndexMat[i][j] = IndexMat[i-1][j];
                        uf._parent[NumIndex] = uf._parent[NumIndex-ArrNum];
                    }
                    if(i > 0 && j-1 >= 0 && TrueMat[i][j] == 1 && TrueMat[i-1][j] == 1){
                        IndexMat[i][j] = IndexMat[i-1][j];
                        uf._parent[NumIndex] = uf._parent[NumIndex-ArrNum];
                    }
                    if(i > 0 && j-1 >= 0 && TrueMat[i][j] == 1 && TrueMat[i][j-1] == 1){
                        IndexMat[i][j] = IndexMat[i][j-1];
                        uf._parent[NumIndex] = uf._parent[NumIndex-1];
                    }
                    if(i > 0 && j == 0 && TrueMat[i][j] == 1 && TrueMat[i-1][j] == 0){
                        ucount++;
                        IndexMat[i][j] = ucount;
                        uf._parent[NumIndex] = ucount;
                    }
                    if(i > 0 && j-1 >= 0 && TrueMat[i][j] == 1 && TrueMat[i][j-1] == 0 && TrueMat[i-1][j] == 0){
                        ucount++;
                        IndexMat[i][j] = ucount;
                        uf._parent[NumIndex] = ucount;
                    }
                    if(i > 0 && j-1 >= 0 && TrueMat[i][j] == 1 && TrueMat[i][j-1] == 1 && TrueMat[i-1][j] == 1){
                        if(IndexMat[i][j-1] > IndexMat[i-1][j]){
                            IndexMat[i][j] = IndexMat[i-1][j];
                            uf._parent[NumIndex] = uf._parent[NumIndex-ArrNum];
                            int ChangeNum = IndexMat[i][j-1];
                            for (int k = 0; k < ArrNum*ArrNum+1; k++){
                                if(uf._parent[k] == ChangeNum){
                                    uf._parent[k] = uf._parent[NumIndex-ArrNum];
                                }
                            }
                        }
                        if(IndexMat[i-1][j] > IndexMat[i][j-1]){
                            IndexMat[i][j] = IndexMat[i][j-1];
                            uf._parent[NumIndex] = uf._parent[NumIndex-1];
                            int ChangeNum = IndexMat[i-1][j];
                            for (int k = 0; k < ArrNum*ArrNum+1; k++){
                                if(uf._parent[k] == ChangeNum){
                                    uf._parent[k] = uf._parent[NumIndex-1];
                                }
                            }
                        }
                    }
                    if(TrueMat[i][j] == 0){
                        IndexMat[i][j] = 0;
                        uf._parent[NumIndex] = 0;
                        uf.union(0,NumIndex);
                    }
                }
            }
            System.out.println(uf._parent[AnsInUf]);
        }
        catch(IOException e){
            System.out.println(""error!""); 
        }
        // TODO code application logic here
    }
}
@031e914af9a30f1cb334c5ec08212e4a@"
"r02b48003","0","0","0","@ee9e801f8b707e7822a40b2f2bc389d6@import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class LabelCC {
    private final int dim;
    private Board_ID    board_id;
    private Board_Label board_label;
    private Board_Open  board_open;
    private UF uf;
    
    public LabelCC (int n) {
        dim = n;
        board_id = new Board_ID(n);
        board_label = new Board_Label(n);
        board_open = new Board_Open(n);
        uf = new UF(n*n);
    } // end constructor
    public int getLabel(int row, int col) {
        return board_label.getLabel(row, col);
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {
        board_label.setLabel(row, col, value);
    } // end func setLabel
    
    public void setLabelfromRoot(int row, int col, int rootId) {
        int rootRow = rootId / dim + 1;
        int rootCol = rootId % dim + 1;
        setLabel(row, col,
                 board_label.getLabel(rootRow, rootCol));
    } // end func setLabelfromRoot
    
    public void setBlock(int row, int col) {
        board_open.setBlock(row, col);
    } // end func setBlock 
    
    public boolean isBlock(int row, int col) {
        return board_open.isBlock(row, col);
    } // end func isOpen
    
    public boolean isOpen(int row, int col) {
        return board_open.isOpen(row, col);
    } // end func isOpen
    
    public String checkCase(Boolean isOpenUp, Boolean isOpenLf) {
        // case 1: up left neighbors not open or not exist
        // case 2: only up neighbor open and exist
        // case 3: only left neighbor open and exist
        // case 4: up left neighbors exist and open
        String whichCase = """";
        
        if (isOpenUp == null && isOpenLf == null) {whichCase = ""1"";}
        
        if (isOpenUp != null && isOpenLf == null) {
            if (isOpenUp){whichCase = ""2"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp == null && isOpenLf != null) {
            if (isOpenLf){whichCase = ""3"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp != null && isOpenLf != null) {
            if (isOpenUp == true  && isOpenLf == true)  {whichCase = ""4"";}
            if (isOpenUp == true  && isOpenLf == false) {whichCase = ""2"";}
            if (isOpenUp == false && isOpenLf == true)  {whichCase = ""3"";}
            if (isOpenUp == false && isOpenLf == false) {whichCase = ""1"";}
        } // end if
        return whichCase;
    } // end func checkCase
    
    public void passFirst() {
        int label = 1;
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                Integer labelUp  = board_label.getNeighbor(row, col, ""UP"");
                Integer labelLf  = board_label.getNeighbor(row, col, ""LEFT"");
                Integer id       = board_id.getId(row, col);
                Integer idUp     = board_id.getNeighbor(row, col, ""UP"");
                Integer idLf     = board_id.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                
                switch (gridCase) {
                    case ""1"": 
                        //System.out.print(""1 "");
                        setLabel(row, col, label++);
                        break;
                    case ""2"": 
                        //System.out.print(""2 "");
                        uf.union(idUp, id);
                        setLabel(row, col, labelUp);
                        break;
                    case ""3"": 
                        //System.out.print(""3 "");
                        uf.union(idLf, id);
                        setLabel(row, col, labelLf);
                        break;
                    case ""4"": 
                        //System.out.print(""4 "");
                        if (labelUp <= labelLf) {
                            uf.union(idUp, idLf);
                            uf.union(idUp, id);
                            setLabel(row, col, labelUp);
                        } else {
                            uf.union(idLf, idUp);
                            uf.union(idLf, id);
                            setLabel(row, col, labelLf);
                        } // end if-else
                        break;
                    default: 
                        System.out.println(
                            ""Error: LabelCC omit the case: "" + 
                            ""("" + row + "", "" + col + "")"");
                } // end switch
            } // end inner loop
        } // end outer loop
    } // end func passFirst
    
    public void passSecond() {
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                int id = board_id.getId(row, col);
                int root = uf.root(id);
                setLabelfromRoot(row, col, root);
            } // end inner loop
        } // end outer loop
    } // end func passSecond
    
    public void displayOpen(){ 
        System.out.println(""---Display: Open---------"");
        board_open.display();  }
    public void displayLabel() { 
        System.out.println(""---Display: Label--------"");
        board_label.display(); }
    public void displayID() { 
        System.out.println(""---Display: ID-----------"");
        board_id.display();    }
    public void displayRoot()  {
        System.out.println(""---Display: Root---------"");
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.print(uf.root(board_id.getId(row, col)) + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayRoot
    public void displayCase()  {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {            
                // check if the grid is open
                if (isBlock(row, col)) {
                    System.out.print(""X "");
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                System.out.print(gridCase + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayCase
    
    public static void main(String[] args) {
        // testing classes
        //Board.main(args);
        //Board_Open.main(args);
        //Board_Label.main(args);
        //Board_ID.main(args);
        //UF.main(args);
        
        // read in the content of a file
        String[] readLines = In.readStrings(args[0]);
        
        // initialization
        String[] line0 = readLines[0].split("","");
        int N         = Integer.valueOf(line0[0]); // prepare for N-by-N grid
        int targetRow = Integer.valueOf(line0[1]); // row of target site: (row, col)
        int targetCol = Integer.valueOf(line0[2]); // col of target site: (row, col)
        LabelCC labelcc = new LabelCC(N);
        
        // iterate through the file
        for (String s: Arrays.copyOfRange(readLines, 1, readLines.length)){
            String[] line = s.split("","");
            //System.out.println(s);
            labelcc.setBlock(Integer.valueOf(line[0]), Integer.valueOf(line[1]));
	} // end loop for
        
        if (labelcc.isBlock(targetRow, targetCol)) {
            System.out.print(0);
            return;
        } // end if
        
        labelcc.passFirst();
        labelcc.passSecond();
        System.out.print(labelcc.getLabel(targetRow, targetCol));
        //System.out.println(""-------------------------"");
        //labelcc.displayID();
        //labelcc.displayOpen();
        //labelcc.displayCase();
        //labelcc.displayLabel();
        //labelcc.displayRoot();
        
    } // end main
} // end class LabelCC

class UF {
    private int[] id;
    
    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) id[i] = i;
    } // end contructor
    
    public boolean connected(int p, int q) { 
        return root(p) == root(q); 
    } // end func connected
    
    public int root(int i) { 
        // Follow links to find a root
        while (i != id[i]) {
            id[i] = id[id[i]]; // path compression
            i = id[i];         // search upper node
        } // end while
        return i; 
    } // end func root
    
    public void union(int p, int q) {
        // Parent: p ; Child: q
        int i = root(p);     // component of p
        int j = root(q);     // component of q
        if (i == j) return;  // if same root, same component
        id[j] = i;           // link component q under component p
                             // Parent: i
                             // Child:  j
    } // end func union
} // end class UF

class Board_ID {
    private final int dim;
    private Board<Integer> board;
    
    public Board_ID (int n) {
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    } // end constructor
    
    public void setId(int row, int col, int value){
        board.setGrid(row-1, col-1, value);
    } // end func setId
    
    public Integer getId(int row, int col){
        return board.getGrid(row-1, col-1);
    } // end func getId
    
    public Integer getNeighbor(int row, int col, String direction){
        return board.getNeighbor(row-1, col-1, direction);
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_ID anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_ID copy() {
        Board_ID board_copy = new Board_ID(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setId(row, col, getId(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, row * dim + col);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_ID

class Board_Label {
    private final int dim;
    private Board<Integer> board;
    
    public Board_Label(int n){
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    }  // end constructor
    
    public Integer getLabel(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getGrid(row-1, col-1);
        //} // end if
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {   
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, value);
        //} // end if
    } // end func setLabel 
    
    public Boolean isLabel(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            if (board.getGrid(row-1, col-1) == -1) { return false; } 
            else                                   { return true; }
        } // end if-else
        //System.out.println(""Error: \n\tClass Board_Label \n\tfunction isLabel \n\tMessage: Out of Boundary"");
        return null;
    } // end func isLabel
    
    public Integer getNeighbor(int row, int col, String direction) {
        return board.getNeighbor(row-1, col-1, direction);
    } // end func Integer
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Label anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Label copy() {
        Board_Label board_copy = new Board_Label(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setLabel(row, col, getLabel(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset(){
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, -1);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_Label

class Board_Open {
    private final int dim;
    private Board<Boolean> board;
    
    public Board_Open(int n){
        board = new Board<Boolean>(n);
        dim = n;
        reset();    
    }  // end constructor
    
    public void setOpen(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, true);
        //} // end if
    } // end func setOpen
    
    public void setBlock(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, false);
        //} // end if
    } // end func setBlock
    
    public Boolean isOpen(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == true;    
        }
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isOpen \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean isBlock(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == false;
        } // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isBlock \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean getNeighbor(int row, int col, String direction) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getNeighbor(row-1, col-1, direction);
        //} // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction getNeighbor \n\tMessage: Out of Boundary"");
        //return null;
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Open anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Open copy() {
        Board_Open board_copy = new Board_Open(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) { board_copy.setOpen(row, col);  } 
                else                  { board_copy.setBlock(row, col); }
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        // default: all open
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, true);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) {System.out.print(""1 "");}
                else                  {System.out.print(""0 "");}
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board_Open

class Board<Item> //implements Iterable<Item> 
{
    private final int dim;
    private Item[] board;
    
    public Board(int n) {
        dim = n;
        board = (Item[]) new Object[n*n];
    } // end constructor
    
    public int getDim(){ return dim; }
    
    public Item getGrid(int row, int col){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            return board[row * dim + col];
        } // end if
        return null;
    } // end func getGrid
    
    public void setGrid(int row, int col, Item value){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            board[row * dim + col] = value;
        } // end if
    } // end func setGrid
    
    public Item getNeighbor(int row, int col, String direction) {
        if (!(row >= 0 && col >= 0 && row < dim && col < dim)) {
            return null;
        } // end if
        
        if (direction.equals(""UP"")) {
            if (row > 0) { return getGrid(row-1, col); }
        } // end if
        
        if (direction.equals(""DOWN"")) {
            if (row < (dim - 1)) { return getGrid(row+1, col); }
        } // end if
        
        if (direction.equals(""LEFT"")) {
            if (col > 0) { return getGrid(row, col-1); }
        } // end if
        
        if (direction.equals(""RIGHT"")) {
            if (col < (dim - 1)) { return getGrid(row, col+1); }
        } // end if
        
        return null;
    } // end func getNeighbor
    
    public boolean compare(Board<Item> anotherBoard) { 
        if (anotherBoard.getDim() != dim) {
            return false;
        } // end if
        
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                if (getGrid(row, col) != anotherBoard.getGrid(row, col)) {
                    return false;
                } // end if
            } // end inner loop
        } // end outer loop
        
        return true;
    } // end func compare
    
    public Board copy(){
        Board<Item> board_copy = new Board(dim);
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board_copy.setGrid(row, col, getGrid(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                System.out.print(board[row * dim + col] + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board
@ee9e801f8b707e7822a40b2f2bc389d6@"
"r04631025","3","0.74","129360","@53c2ff25ddd39ed666ee4a77453c431d@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    UF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        label = 1;
        N = n;
           

        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 0;
        }

    }
    public void newunion (int n){
        uf =new UF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(matrix[x-1][y]!=-1&& matrix[x][y-1]!=-1){
                uf.union(id[matrix[x-1][y]]-1,id[matrix[x][y-1]]-1);
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=100;
        matrix[x - 1][y - 1] = -1;
    }
    
    public int getlabel (int x ,int y){
        return uf.find(id[matrix[x-1][y-1]]);
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            id[matrix[x][y]] = label;
        } else {
            if (x == 0&&matrix[x][y]!=-1) {
                if (matrix[x][y - 1] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x][y-1]];
                }
            }
            if (y == 0&&matrix[x][y]!=-1) {
                if (matrix[x - 1][y] == -1) {
                    label++;
                    id[matrix[x][y]] = label;
                } else {
                    id[matrix[x][y]] = id[matrix[x - 1][y]];
                }
            }
            if (matrix[x][y] != -1 && x != 0 && y != 0) {
                if (matrix[x - 1][y] != -1 && matrix[x][y - 1] != -1) {
                    if (id[matrix[x - 1][y]] > id[matrix[x][y - 1]]) {
                        id[matrix[x][y]] = id[matrix[x][y - 1]];
                    }
                    else{
                        id[matrix[x][y]]=id[matrix[x-1][y]];
                    }
                }else if(matrix[x-1][y]!=-1 && matrix[x][y-1]==-1){
                    id[matrix[x][y]]=id[matrix[x-1][y]];
                }else if(matrix[x-1][y]==-1 && matrix[x][y-1]!=-1){
                    id[matrix[x][y]]=id[matrix[x][y-1]];
                }else{
                    label++;
                    id[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@53c2ff25ddd39ed666ee4a77453c431d@"
"r04945022","7","0.63","105280","@f35979ac9dc9f20778eed3adcbb1004e@import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;


/**
 *
 * @author Daniel C
 */
public class LabelCC {
 private int [] states;
  private int [] labnumber;
  private int side;
  public int count = 0;
  QuickUnionUF uf = new QuickUnionUF(30);
  
  public void creatematrix(int N){
        side = N;
        states=new int[N*N];
        labnumber = new int [N*N];
        for(int index=0;index<N*N;index++){
           states[index]=1;
           labnumber[index]=0;
       }
    }
    public void block(int i, int j){
       int cell=getCellIndex(i,j);
       states[cell]=0;
    }
//    private void checkRange(int i, int j){
//       if (i<=0||j<=0||i>side||j>side)throw new IndexOutOfBoundsException();
//     }
    public boolean isOpen(int i, int j){
//       checkRange(i,j);
       return states[getCellIndex(i,j)]==1;
     }   
    private int getCellIndex(int row, int column){
       return (side*(row-1))+column-1;
     }
    private void firstpassLabel(){
        for(int i=1;i<=side;i++){
            for(int j=1;j<=side;j++){
                if(isOpen(i,j)){
                    creatnewLabel(i,j);
                }
            }
        }
        
    }
    private int secpassLabel(int n, int m){
            int out = labnumber[getCellIndex(n, m)];
            int output = uf.find(out);
            return output;
        }
    
    private void creatnewLabel(int i, int j){
        int cell = getCellIndex(i,j);
        //for top rows
        if(i==1&&j==1){
            ++count;
            labnumber[cell]=count;
            return;
        }
        if(i==1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell]= labnumber[getCellIndex(i,j-1)];
                return;
                }else{
                ++count;
                labnumber[cell]=count;
                return;
            }         
        }
        // for other rows
        if(i!=1 && j!=1){
            if(isOpen(i,j-1)){
                labnumber[cell] = labnumber[cell-1];
                if(labnumber[getCellIndex(i-1,j)]!=0){
                    uf.union(labnumber[getCellIndex(i-1,j)],labnumber[cell]);
                    if(labnumber[getCellIndex(i-1,j)]>labnumber[cell]){
                        return;
                    }else{
                        labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                        return;
                    }
                    
                }
            }else if(isOpen(i-1,j)){
                labnumber[cell] = labnumber[getCellIndex(i-1,j)];
                return;
            }
            else{
                ++count;
                labnumber[cell]=count;
                return;
            }
           
        }
//        first column
        if(i!=1 &&j==1){
            if(isOpen(i-1,j)){
                labnumber[cell]= labnumber[getCellIndex(i-1,j)];
            }else{
                ++count;
                labnumber[cell] = count;
            }
            
        }
        
    }
   
    public static void main(String[] args) throws IOException{
        LabelCC L1 = new LabelCC();
        File inputfile = null; 
        if(0 < args.length){
            inputfile = new File(args[0]);
        } else{
            System.out.println(""file does not exist"");
        }
        BufferedReader br = new BufferedReader(new FileReader(inputfile));
        int input1 = 0 , input2 = 0 , input3 = 0;
        String firstline = br.readLine();
        String[] inputarray = firstline.split("","");
        input1 = Integer.parseInt(inputarray[0]);
        input2 = Integer.parseInt(inputarray[1]);
        input3 = Integer.parseInt(inputarray[2]);
//        QuickUnionUF uf = new QuickUnionUF(input1);
        L1.creatematrix(input1);
        String data = null;
        String [] inputnumb;
        int a=0, b=0;
        while((data = br.readLine())!=null){
             inputnumb = data.split("","");
             a = Integer.parseInt(inputnumb[0]);
             b = Integer.parseInt(inputnumb[1]);
             L1.block(a,b);
    }
            L1.firstpassLabel();
            System.out.println(L1.secpassLabel(input2, input3));
                        
        
}
    public class QuickUnionUF {
    private int[] parent;  // parent[i] = parent of i
    private int count;     // number of components

    public QuickUnionUF(int N) {
        parent = new int[N];
        count = N;
        for (int i = 0; i < N; i++) {
            parent[i] = i;
        }
    }

    public int count() {
        return count;
    }
  
    public int find(int p) {
        validate(p);
        while (p != parent[p])
            p = parent[p];
        return p;
    }

   
    private void validate(int p) {
        int N = parent.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));  
        }
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        if(rootQ<rootP){
        parent[rootP] = rootQ; 
        }else{
        parent[rootQ] = rootP;
        }
    }


}

}

@f35979ac9dc9f20778eed3adcbb1004e@"
"r02b48003","8","1.5","153600","@9d2a6c7ff7ace586dc490bee6b421546@import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class LabelCC {
    private final int dim;
    private Board_ID    board_id;
    private Board_Label board_label;
    private Board_Open  board_open;
    //private UF uf;
    private QuickFind uf;
    
    public LabelCC (int n) {
        dim = n;
        board_id = new Board_ID(n);
        board_label = new Board_Label(n);
        board_open = new Board_Open(n);
        //uf = new UF(n*n);
        uf = new QuickFind(n*n);
    } // end constructor
    
    public int getLabel(int row, int col) {
        return board_label.getLabel(row, col);
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {
        board_label.setLabel(row, col, value);
    } // end func setLabel
    
    public void setLabelfromRoot(int row, int col, int rootId) {
        int rootRow = rootId / dim + 1;
        int rootCol = rootId % dim + 1;
        setLabel(row, col,
                 board_label.getLabel(rootRow, rootCol));
    } // end func setLabelfromRoot
    
    public void setBlock(int row, int col) {
        board_open.setBlock(row, col);
    } // end func setBlock 
    
    public boolean isBlock(int row, int col) {
        return board_open.isBlock(row, col);
    } // end func isOpen
    
    public boolean isOpen(int row, int col) {
        return board_open.isOpen(row, col);
    } // end func isOpen
    
    public String checkCase(Boolean isOpenUp, Boolean isOpenLf) {
        // case 1: up left neighbors not open or not exist
        // case 2: only up neighbor open and exist
        // case 3: only left neighbor open and exist
        // case 4: up left neighbors exist and open
        String whichCase = """";
        
        if (isOpenUp == null && isOpenLf == null) {whichCase = ""1"";}
        
        if (isOpenUp != null && isOpenLf == null) {
            if (isOpenUp){whichCase = ""2"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp == null && isOpenLf != null) {
            if (isOpenLf){whichCase = ""3"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp != null && isOpenLf != null) {
            if (isOpenUp == true  && isOpenLf == true)  {whichCase = ""4"";}
            if (isOpenUp == true  && isOpenLf == false) {whichCase = ""2"";}
            if (isOpenUp == false && isOpenLf == true)  {whichCase = ""3"";}
            if (isOpenUp == false && isOpenLf == false) {whichCase = ""1"";}
        } // end if
        return whichCase;
    } // end func checkCase
    
    public void passFirst() {
        int label = 1;
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                Integer labelUp  = board_label.getNeighbor(row, col, ""UP"");
                Integer labelLf  = board_label.getNeighbor(row, col, ""LEFT"");
                Integer id       = board_id.getId(row, col);
                Integer idUp     = board_id.getNeighbor(row, col, ""UP"");
                Integer idLf     = board_id.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                
                switch (gridCase) {
                    case ""1"": 
                        //System.out.print(""1 "");
                        setLabel(row, col, label++);
                        break;
                    case ""2"": 
                        //System.out.print(""2 "");
                        uf.union(idUp, id);
                        setLabel(row, col, labelUp);
                        break;
                    case ""3"": 
                        //System.out.print(""3 "");
                        uf.union(idLf, id);
                        setLabel(row, col, labelLf);
                        break;
                    case ""4"": 
                        //System.out.print(""4 "");
                        if (labelUp <= labelLf) {
                            uf.union(idUp, idLf);
                            uf.union(idUp, id);
                            setLabel(row, col, labelUp);
                        } else {
                            uf.union(idLf, idUp);
                            uf.union(idLf, id);
                            setLabel(row, col, labelLf);
                        } // end if-else
                        break;
                    default: 
                        System.out.println(
                            ""Error: LabelCC omit the case: "" + 
                            ""("" + row + "", "" + col + "")"");
                } // end switch
            } // end inner loop
        } // end outer loop
    } // end func passFirst
    
    public void passSecond() {
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                int id = board_id.getId(row, col);
                //int root = uf.root(id);
                int root = uf.find(id);
                setLabelfromRoot(row, col, root);
            } // end inner loop
        } // end outer loop
    } // end func passSecond
    
    public void displayOpen(){ 
        System.out.println(""---Display: Open---------"");
        board_open.display();  }
    public void displayLabel() { 
        System.out.println(""---Display: Label--------"");
        board_label.display(); }
    public void displayID() { 
        System.out.println(""---Display: ID-----------"");
        board_id.display();    }
    /*
    public void displayRoot()  {
        System.out.println(""---Display: Root---------"");
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.print(uf.root(board_id.getId(row, col)) + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayRoot
    //*/
    public void displayCase()  {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {            
                // check if the grid is open
                if (isBlock(row, col)) {
                    System.out.print(""X "");
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                System.out.print(gridCase + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayCase
    //public void displayUF() {uf.display();}
    public static void main(String[] args) {
        // testing classes
        //Board.main(args);
        //Board_Open.main(args);
        //Board_Label.main(args);
        //Board_ID.main(args);
        //UF.main(args);
        
        // read in the content of a file
        String[] readLines = In.readStrings(args[0]);
        
        // initialization
        String[] line0 = readLines[0].split("","");
        int N         = Integer.valueOf(line0[0]); // prepare for N-by-N grid
        int targetRow = Integer.valueOf(line0[1]); // row of target site: (row, col)
        int targetCol = Integer.valueOf(line0[2]); // col of target site: (row, col)
        LabelCC labelcc = new LabelCC(N);
        
        // iterate through the file
        for (String s: Arrays.copyOfRange(readLines, 1, readLines.length)){
            String[] line = s.split("","");
            //System.out.println(s);
            labelcc.setBlock(Integer.valueOf(line[0]), Integer.valueOf(line[1]));
	} // end loop for
        
        if (labelcc.isBlock(targetRow, targetCol)) {
            System.out.print(0);
            return;
        } // end if
        
        labelcc.passFirst();
        //labelcc.displayLabel();
        
        labelcc.passSecond();
        System.out.print(labelcc.getLabel(targetRow, targetCol));
        //System.out.println(""-------------------------"");
        //labelcc.displayID();
        //labelcc.displayOpen();
        //labelcc.displayCase();
        //labelcc.displayLabel();
        //labelcc.displayUF();
        //labelcc.displayRoot();       
    } // end main
} // end class LabelCC

class UF {
    private int[] id;
    
    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) id[i] = i;
    } // end contructor
    
    public boolean connected(int p, int q) { 
        return root(p) == root(q); 
    } // end func connected
    
    public int root(int i) { 
        // Follow links to find a root
        while (i != id[i]) {
            id[i] = id[id[i]]; // path compression
            i = id[i];         // search upper node
        } // end while
        return i; 
    } // end func root
    
    public void union(int p, int q) {
        // Parent: p ; Child: q
        int i = root(p);     // component of p
        int j = root(q);     // component of q
        if (i == j) return;  // if same root, same component
        id[j] = i;           // link component q under component p
                             // Parent: i
                             // Child:  j
    } // end func union
    public void display(){
        System.out.println(Arrays.toString(id));
    } // end func display
} // end class UF

class QuickFind {
    private int[] id;
    public QuickFind(int N){
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }// end constructor
    
    public boolean connected(int p, int q)
    { return find(p) == find(q); }
    
    public int find(int p)
    { return id[p]; }
    
    public void union(int p , int q) {
        int pID = find(p);
        int qID = find(q);
        
        if (pID == qID) return;
        
        for (int i = 0; i < id.length; i++) {
            if (id[i] == qID) id[i] = qID;
        }
    } // end func union
} // end class Quickfind

class Board_ID {
    private final int dim;
    private final Board<Integer> board;
    
    public Board_ID (int n) {
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    } // end constructor
    
    public void setId(int row, int col, int value){
        board.setGrid(row-1, col-1, value);
    } // end func setId
    
    public Integer getId(int row, int col){
        return board.getGrid(row-1, col-1);
    } // end func getId
    
    public Integer getNeighbor(int row, int col, String direction){
        return board.getNeighbor(row-1, col-1, direction);
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_ID anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_ID copy() {
        Board_ID board_copy = new Board_ID(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setId(row, col, getId(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, row * dim + col);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_ID

class Board_Label {
    private final int dim;
    private Board<Integer> board;
    
    public Board_Label(int n){
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    }  // end constructor
    
    public Integer getLabel(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getGrid(row-1, col-1);
        //} // end if
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {   
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, value);
        //} // end if
    } // end func setLabel 
    
    public Boolean isLabel(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            if (board.getGrid(row-1, col-1) == -1) { return false; } 
            else                                   { return true; }
        } // end if-else
        //System.out.println(""Error: \n\tClass Board_Label \n\tfunction isLabel \n\tMessage: Out of Boundary"");
        return null;
    } // end func isLabel
    
    public Integer getNeighbor(int row, int col, String direction) {
        return board.getNeighbor(row-1, col-1, direction);
    } // end func Integer
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Label anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Label copy() {
        Board_Label board_copy = new Board_Label(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setLabel(row, col, getLabel(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset(){
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, -1);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_Label

class Board_Open {
    private final int dim;
    private Board<Boolean> board;
    
    public Board_Open(int n){
        board = new Board<Boolean>(n);
        dim = n;
        reset();    
    }  // end constructor
    
    public void setOpen(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, true);
        //} // end if
    } // end func setOpen
    
    public void setBlock(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, false);
        //} // end if
    } // end func setBlock
    
    public Boolean isOpen(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == true;    
        }
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isOpen \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean isBlock(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == false;
        } // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isBlock \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean getNeighbor(int row, int col, String direction) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getNeighbor(row-1, col-1, direction);
        //} // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction getNeighbor \n\tMessage: Out of Boundary"");
        //return null;
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Open anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Open copy() {
        Board_Open board_copy = new Board_Open(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) { board_copy.setOpen(row, col);  } 
                else                  { board_copy.setBlock(row, col); }
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        // default: all open
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, true);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) {System.out.print(""1 "");}
                else                  {System.out.print(""0 "");}
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board_Open

class Board<Item> {
    private final int dim;
    private Item[] board;
    
    public Board(int n) {
        dim = n;
        board = (Item[]) new Object[n*n];
    } // end constructor
    
    public int getDim(){ return dim; }
    
    public Item getGrid(int row, int col){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            return board[row * dim + col];
        } // end if
        return null;
    } // end func getGrid
    
    public void setGrid(int row, int col, Item value){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            board[row * dim + col] = value;
        } // end if
    } // end func setGrid
    
    public Item getNeighbor(int row, int col, String direction) {
        if (!(row >= 0 && col >= 0 && row < dim && col < dim)) {
            return null;
        } // end if
        
        if (direction.equals(""UP"")) {
            if (row > 0) { return getGrid(row-1, col); }
        } // end if
        
        if (direction.equals(""DOWN"")) {
            if (row < (dim - 1)) { return getGrid(row+1, col); }
        } // end if
        
        if (direction.equals(""LEFT"")) {
            if (col > 0) { return getGrid(row, col-1); }
        } // end if
        
        if (direction.equals(""RIGHT"")) {
            if (col < (dim - 1)) { return getGrid(row, col+1); }
        } // end if
        
        return null;
    } // end func getNeighbor
    
    public boolean compare(Board<Item> anotherBoard) { 
        if (anotherBoard.getDim() != dim) {
            return false;
        } // end if
        
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                if (getGrid(row, col) != anotherBoard.getGrid(row, col)) {
                    return false;
                } // end if
            } // end inner loop
        } // end outer loop
        
        return true;
    } // end func compare
    
    public Board copy(){
        Board<Item> board_copy = new Board(dim);
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board_copy.setGrid(row, col, getGrid(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                System.out.print(board[row * dim + col] + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board
@9d2a6c7ff7ace586dc490bee6b421546@"
"b01b01039","0","0.097","105504","@07603a99f39ff0d1f4ceb393cc805b9b@

import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	/*
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	*/
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = node[row][col] & b;
	}
	/*
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	*/
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}
	
	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            long time1, time2, time3, time4;
			//time1 = System.nanoTime();
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			
			Stack<Integer> st = new Stack<Integer>();
			//Stack<Integer> up_st = new Stack<Integer>();
			//Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			//time2 = System.nanoTime();
			//int CC_N = 0;
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								st.push(lcc.up_label(row,col));
								st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.label_print();
			//time3 = System.nanoTime();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(st.size() != 0){
				int up = st.pop();
				int left = st.pop();
				//System.out.println(up + "" "" + left);
				if(!uf_l.connected(up, left)){
					uf_l.label_change(up, left);
					uf_l.union(up, left);
					//uf_l.print_lable();
					//uf_l.print_root();
				}
			}
			//System.out.println();
			//uf_l.print_lable();
			//uf_l.print_root();
			
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
			/*time4 = System.nanoTime();
			System.out.println(""=========== Time Cost ==========="");
			System.out.println(time2 - time1);
			System.out.println(time3 - time2);
			System.out.println(time4 - time3);*/
		}
	}	
}

class uf_label extends QuickFindUF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		int p_l = label[find(p)];
		int q_l = label[find(q)];
		//System.out.println(p_l + "" "" + q_l);
		if(p_l > q_l){
			label[find(p)] = q_l;
			label[p] = q_l;
			label[q] = q_l;
		}else{
			label[find(q)] = p_l;
			label[p] = p_l;
			label[q] = p_l;
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[find(N)];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
	
	public void print_root(){
		for(int id = 0; id < label.length; id++){
			System.out.printf(""%d "", find(id));
		}
		System.out.printf(""\n"");
	}
}

back return to list 
@07603a99f39ff0d1f4ceb393cc805b9b@"
"b01b01039","9","1.02","127200","@b65b93d6e9785c593caaf3691c97d64f@



import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}

	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	/*
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	*/
	public int get_target_row(){
		return(target[0]);
	}
	
	public int get_target_col(){
		return(target[1]);
	}
	
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	public void node_assign(int row, int col, boolean b){
		node[row][col] = node[row][col] & b;
	}
	/*
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	*/
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%d "", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	public int now_label(){
		return now_label++;
	}
	
	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            long time1, time2, time3, time4;
			//time1 = System.nanoTime();
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			
			Stack<Integer> st = new Stack<Integer>();
			//Stack<Integer> up_st = new Stack<Integer>();
			//Stack<Integer> left_st = new Stack<Integer>();
			
			// Creat a object            
            int num = Integer.parseInt(data[0]);
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false);
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			//time2 = System.nanoTime();
			//int CC_N = 0;
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col))
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								st.push(lcc.up_label(row,col));
								st.push(lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
				}
			}
			//lcc.label_print();
			//time3 = System.nanoTime();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(st.size() != 0){
				int up = st.pop();
				int left = st.pop();
				//System.out.println(up + "" "" + left);
				if(!uf_l.connected(up, left)){
					uf_l.label_change(up, left);
					uf_l.union(up, left);
					//uf_l.print_lable();
					//uf_l.print_root();
				}
			}
			//System.out.println();
			//uf_l.print_lable();
			//uf_l.print_root();
			
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
			/*time4 = System.nanoTime();
			System.out.println(""=========== Time Cost ==========="");
			System.out.println(time2 - time1);
			System.out.println(time3 - time2);
			System.out.println(time4 - time3);*/
		}
	}	
}

class uf_label extends QuickFindUF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	public void label_change(int p, int q){
		int p_l = label[find(p)];
		int q_l = label[find(q)];
		//System.out.println(p_l + "" "" + q_l);
		if(p_l > q_l){
			label[find(p)] = q_l;
			label[p] = q_l;
			label[q] = q_l;
		}else{
			label[find(q)] = p_l;
			label[p] = p_l;
			label[q] = p_l;
		}
	}
	
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	public int get_label(int N){
		return label[find(N)];
	}
	
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
	
	public void print_root(){
		for(int id = 0; id < label.length; id++){
			System.out.printf(""%d "", find(id));
		}
		System.out.printf(""\n"");
	}
}
@b65b93d6e9785c593caaf3691c97d64f@"
"r04945008","9","1.04","133200","@da227eb96743a358afc885364e64d313@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == 0) return false;
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF uf = new UF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",uf.find(i*num+j+1));
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@da227eb96743a358afc885364e64d313@"
"b01502105","10","0.104","139392","@9a40381bd15f3f82f3988028c9c65dcc@import java.util.Arrays;
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            StringBuilder everything = new StringBuilder();
            String line;
            everything.append(br.readLine());//first num
            while ((line = br.readLine()) != null) {
                everything.append("" "");
                everything.append(line);
            }
            String[] data = everything.toString().split("" "");
            String[] given = data[0].split("","");
            int num = Integer.parseInt(given[0]);  //matrix size
            int assigned_row = Integer.parseInt(given[1]);
            int assigned_column = Integer.parseInt(given[2]);
            int len = data.length;  //input 
            int label = 0;
//            int k = 0;
//            int[][] p_c = new int[20][2]; 
            QuickFindUF uf = new QuickFindUF(num*num);
            
//            System.out.printf(num+"" ""+assigned_row+"" ""+assigned_column+"" ""+len+""\n"");
            int[][] matrix = new int[num][num];
            for(int a=0;a<num;a++){
                Arrays.fill(matrix[a], 1);
            }
            int[][] matrix_label = new int [num][num]; 
            //assign given position
            for(int i=1; i<len; i++){
               String[] block = data[i].split("","");
               int block_row = Integer.parseInt(block[0]);
               int block_column = Integer.parseInt(block[1]);
               matrix[block_row - 1][block_column - 1] = 0;
            }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
           //The first pass
           for(int i=0;i<num;i++){
               for(int j=0;j<num;j++){
                   if(matrix[i][j] == 1){
                        if( i==0 && j==0){ label++; matrix_label[i][j]=label;}
                        //row_1
                        else if(i==0){
                             if(matrix[i][j-1] == 1){
                                matrix_label[i][j]=matrix_label[i][j-1]; 
                             }
                             else{
                                label++;
                                matrix_label[i][j]=label; 
                             }
                        }
                        //column_1
                        else if(j==0){
                            if(matrix[i-1][j] == 1){
                                matrix_label[i][j]=matrix_label[i-1][j];
                             }
                            else {
                                label++;
                                matrix_label[i][j]=label;
                            }
                        }
                        //usual case
                        else{   
                            //up & left are ""1""
                            if (matrix[i][j - 1] == 1 && matrix[i - 1][j] == 1) {
                                //up & left is the same
                                if (matrix_label[i][j - 1] == matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
                                } 
                                else if (matrix_label[i][j - 1] < matrix_label[i - 1][j]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
//                                    p_c[k][0]=matrix_label[i][j-1]; //parent,small
//                                    p_c[k][1]=matrix_label[i-1][j]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i-1][j],matrix_label[i][j-1]);
                                } 
                                else {  //matrix_label[i][j-1] > matrix_label[i-1][j]
                                    matrix_label[i][j] = matrix_label[i - 1][j];
//                                    p_c[k][0]=matrix_label[i-1][j]; //parent,small
//                                    p_c[k][1]=matrix_label[i][j-1]; //child,big
//                                    k++;
                                    uf.union(matrix_label[i][j-1],matrix_label[i-1][j]);
                                }
                            } //left is ""1""
                            else if (matrix[i][j - 1] == 1) {
                                matrix_label[i][j] = matrix_label[i][j - 1];
                            }
                             //up is ""1""
                             else if(matrix[i-1][j] == 1){
                                 matrix_label[i][j]=matrix_label[i-1][j];
                             }
                             // none
                             else{
                                 label++;
                                 matrix_label[i][j]=label;
                             }
                        }
                   }
               }
           }
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < k; a++) {
//                System.out.printf(p_c[a][0] + "" <- "" +p_c[a][1] + ""\n"");
//            }
            
//            System.out.printf(uf.find(3)+""\n"");
            //second pass
            for(int i=0;i<num;i++){
                for(int j=0;j<num;j++){
                        matrix_label[i][j] = uf.find(matrix_label[i][j]);
                }
            }
//            System.out.printf(""\n"");
//            for (int a = 0; a < num; a++) {
//                for (int b = 0; b < num; b++) {
//                    System.out.printf(matrix_label[a][b] + "" "");
//                }
//                System.out.printf(""\n"");
//            }
//            System.out.printf(""\n"");
//            System.out.printf(""assigned position:""+assigned_row + "","" + assigned_column + ""\n"");
            System.out.printf(matrix_label[assigned_row - 1][assigned_column - 1]+""\n"");
        }
    }
}

@9a40381bd15f3f82f3988028c9c65dcc@"
"r02b48003","10","0.149","152304","@a1cdcac4d89633b61e322553d7344800@import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class LabelCC {
    private final int dim;
    private Board_ID    board_id;
    private Board_Label board_label;
    private Board_Open  board_open;
    //private UF uf;
    private QuickFind uf;
    
    public LabelCC (int n) {
        dim = n;
        board_id = new Board_ID(n);
        board_label = new Board_Label(n);
        board_open = new Board_Open(n);
        //uf = new UF(n*n);
        uf = new QuickFind(n*n);
    } // end constructor
    
    public int getLabel(int row, int col) {
        return board_label.getLabel(row, col);
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {
        board_label.setLabel(row, col, value);
    } // end func setLabel
    
    public void setLabelfromRoot(int row, int col, int rootId) {
        int rootRow = rootId / dim + 1;
        int rootCol = rootId % dim + 1;
        //System.out.println(row + "" "" + col + "" "" +getLabel(row, col) + "" "" + rootId + "" "" + rootRow + "" "" + rootCol);
        setLabel(row, col,
                 board_label.getLabel(rootRow, rootCol));
    } // end func setLabelfromRoot
    
    public void setBlock(int row, int col) {
        board_open.setBlock(row, col);
    } // end func setBlock 
    
    public boolean isBlock(int row, int col) {
        return board_open.isBlock(row, col);
    } // end func isOpen
    
    public boolean isOpen(int row, int col) {
        return board_open.isOpen(row, col);
    } // end func isOpen
    
    public String checkCase(Boolean isOpenUp, Boolean isOpenLf) {
        // case 1: up left neighbors not open or not exist
        // case 2: only up neighbor open and exist
        // case 3: only left neighbor open and exist
        // case 4: up left neighbors exist and open
        String whichCase = """";
        
        if (isOpenUp == null && isOpenLf == null) {whichCase = ""1"";}
        
        if (isOpenUp != null && isOpenLf == null) {
            if (isOpenUp){whichCase = ""2"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp == null && isOpenLf != null) {
            if (isOpenLf){whichCase = ""3"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp != null && isOpenLf != null) {
            if (isOpenUp == true  && isOpenLf == true)  {whichCase = ""4"";}
            if (isOpenUp == true  && isOpenLf == false) {whichCase = ""2"";}
            if (isOpenUp == false && isOpenLf == true)  {whichCase = ""3"";}
            if (isOpenUp == false && isOpenLf == false) {whichCase = ""1"";}
        } // end if
        return whichCase;
    } // end func checkCase
    
    public void passFirst() {
        int label = 1;
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                Integer labelUp  = board_label.getNeighbor(row, col, ""UP"");
                Integer labelLf  = board_label.getNeighbor(row, col, ""LEFT"");
                Integer id       = board_id.getId(row, col);
                Integer idUp     = board_id.getNeighbor(row, col, ""UP"");
                Integer idLf     = board_id.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                
                switch (gridCase) {
                    case ""1"": 
                        //System.out.print(""1 "");
                        setLabel(row, col, label++);
                        break;
                    case ""2"": 
                        //System.out.print(""2 "");
                        uf.union(idUp, id);
                        setLabel(row, col, labelUp);
                        break;
                    case ""3"": 
                        //System.out.print(""3 "");
                        uf.union(idLf, id);
                        setLabel(row, col, labelLf);
                        break;
                    case ""4"": 
                        //System.out.print(""4 "");
                        if (labelUp <= labelLf) {
                            uf.union(idUp, idLf);
                            uf.union(idUp, id);
                            setLabel(row, col, labelUp);
                        } else {
                            uf.union(idLf, idUp);
                            uf.union(idLf, id);
                            setLabel(row, col, labelLf);
                        } // end if-else
                        break;
                    default: 
                        System.out.println(
                            ""Error: LabelCC omit the case: "" + 
                            ""("" + row + "", "" + col + "")"");
                } // end switch
            } // end inner loop
        } // end outer loop
    } // end func passFirst
    
    public void passSecond() {
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                int id = board_id.getId(row, col);
                //int root = uf.root(id);
                int root = uf.find(id);
                setLabelfromRoot(row, col, root);
            } // end inner loop
        } // end outer loop
    } // end func passSecond
    
    public void displayOpen(){ 
        System.out.println(""---Display: Open---------"");
        board_open.display();  }
    public void displayLabel() { 
        System.out.println(""---Display: Label--------"");
        board_label.display(); }
    public void displayID() { 
        System.out.println(""---Display: ID-----------"");
        board_id.display();    }
    /*
    public void displayRoot()  {
        System.out.println(""---Display: Root---------"");
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.print(uf.root(board_id.getId(row, col)) + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayRoot
    //*/
    public void displayCase()  {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {            
                // check if the grid is open
                if (isBlock(row, col)) {
                    System.out.print(""X "");
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                System.out.print(gridCase + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayCase
    public void displayUF() {uf.display();}
    public static void main(String[] args) {
        // testing classes
        //Board.main(args);
        //Board_Open.main(args);
        //Board_Label.main(args);
        //Board_ID.main(args);
        //UF.main(args);
        
        // read in the content of a file
        String[] readLines = In.readStrings(args[0]);
        
        // initialization
        String[] line0 = readLines[0].split("","");
        int N         = Integer.valueOf(line0[0]); // prepare for N-by-N grid
        int targetRow = Integer.valueOf(line0[1]); // row of target site: (row, col)
        int targetCol = Integer.valueOf(line0[2]); // col of target site: (row, col)
        LabelCC labelcc = new LabelCC(N);
        
        // iterate through the file
        for (String s: Arrays.copyOfRange(readLines, 1, readLines.length)){
            String[] line = s.split("","");
            //System.out.println(s);
            labelcc.setBlock(Integer.valueOf(line[0]), Integer.valueOf(line[1]));
	} // end loop for
        
        if (labelcc.isBlock(targetRow, targetCol)) {
            System.out.print(0);
            return;
        } // end if
        
        labelcc.passFirst();
        //labelcc.displayLabel();
        
        labelcc.passSecond();
        System.out.print(labelcc.getLabel(targetRow, targetCol));
        //System.out.println(""-------------------------"");
        //labelcc.displayID();
        //labelcc.displayOpen();
        //labelcc.displayCase();
        //labelcc.displayLabel();
        //labelcc.displayUF();
        //labelcc.displayRoot();       
    } // end main
} // end class LabelCC

class UF {
    private int[] id;
    
    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) id[i] = i;
    } // end contructor
    
    public boolean connected(int p, int q) { 
        return root(p) == root(q); 
    } // end func connected
    
    public int root(int i) { 
        // Follow links to find a root
        while (i != id[i]) {
            id[i] = id[id[i]]; // path compression
            i = id[i];         // search upper node
        } // end while
        return i; 
    } // end func root
    
    public void union(int p, int q) {
        // Parent: p ; Child: q
        int i = root(p);     // component of p
        int j = root(q);     // component of q
        if (i == j) return;  // if same root, same component
        id[j] = i;           // link component q under component p
                             // Parent: i
                             // Child:  j
    } // end func union
    public void display(){
        System.out.println(Arrays.toString(id));
    } // end func display
} // end class UF

class QuickFind {
    private int[] id;
    public QuickFind(int N){
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }// end constructor
    
    public boolean connected(int p, int q)
    { return find(p) == find(q); }
    
    public int find(int p)
    { return id[p]; }
    
    public void union(int p , int q) {
        int pID = find(p);
        int qID = find(q);
        
        if (pID == qID) return;
        
        for (int i = 0; i < id.length; i++) {
            if (id[i] == qID) id[i] = pID;
        }
    } // end func union
    
    public void display(){
        System.out.println(Arrays.toString(id));
    } // end func display
    
} // end class Quickfind

class Board_ID {
    private final int dim;
    private final Board<Integer> board;
    
    public Board_ID (int n) {
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    } // end constructor
    
    public void setId(int row, int col, int value){
        board.setGrid(row-1, col-1, value);
    } // end func setId
    
    public Integer getId(int row, int col){
        return board.getGrid(row-1, col-1);
    } // end func getId
    
    public Integer getNeighbor(int row, int col, String direction){
        return board.getNeighbor(row-1, col-1, direction);
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_ID anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_ID copy() {
        Board_ID board_copy = new Board_ID(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setId(row, col, getId(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, row * dim + col);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_ID

class Board_Label {
    private final int dim;
    private Board<Integer> board;
    
    public Board_Label(int n){
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    }  // end constructor
    
    public Integer getLabel(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getGrid(row-1, col-1);
        //} // end if
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {   
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, value);
        //} // end if
    } // end func setLabel 
    
    public Boolean isLabel(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            if (board.getGrid(row-1, col-1) == -1) { return false; } 
            else                                   { return true; }
        } // end if-else
        //System.out.println(""Error: \n\tClass Board_Label \n\tfunction isLabel \n\tMessage: Out of Boundary"");
        return null;
    } // end func isLabel
    
    public Integer getNeighbor(int row, int col, String direction) {
        return board.getNeighbor(row-1, col-1, direction);
    } // end func Integer
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Label anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Label copy() {
        Board_Label board_copy = new Board_Label(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setLabel(row, col, getLabel(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset(){
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, -1);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_Label

class Board_Open {
    private final int dim;
    private Board<Boolean> board;
    
    public Board_Open(int n){
        board = new Board<Boolean>(n);
        dim = n;
        reset();    
    }  // end constructor
    
    public void setOpen(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, true);
        //} // end if
    } // end func setOpen
    
    public void setBlock(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, false);
        //} // end if
    } // end func setBlock
    
    public Boolean isOpen(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == true;    
        }
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isOpen \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean isBlock(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == false;
        } // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isBlock \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean getNeighbor(int row, int col, String direction) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getNeighbor(row-1, col-1, direction);
        //} // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction getNeighbor \n\tMessage: Out of Boundary"");
        //return null;
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Open anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Open copy() {
        Board_Open board_copy = new Board_Open(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) { board_copy.setOpen(row, col);  } 
                else                  { board_copy.setBlock(row, col); }
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        // default: all open
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, true);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) {System.out.print(""1 "");}
                else                  {System.out.print(""0 "");}
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board_Open

class Board<Item> {
    private final int dim;
    private Item[] board;
    
    public Board(int n) {
        dim = n;
        board = (Item[]) new Object[n*n];
    } // end constructor
    
    public int getDim(){ return dim; }
    
    public Item getGrid(int row, int col){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            return board[row * dim + col];
        } // end if
        return null;
    } // end func getGrid
    
    public void setGrid(int row, int col, Item value){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            board[row * dim + col] = value;
        } // end if
    } // end func setGrid
    
    public Item getNeighbor(int row, int col, String direction) {
        if (!(row >= 0 && col >= 0 && row < dim && col < dim)) {
            return null;
        } // end if
        
        if (direction.equals(""UP"")) {
            if (row > 0) { return getGrid(row-1, col); }
        } // end if
        
        if (direction.equals(""DOWN"")) {
            if (row < (dim - 1)) { return getGrid(row+1, col); }
        } // end if
        
        if (direction.equals(""LEFT"")) {
            if (col > 0) { return getGrid(row, col-1); }
        } // end if
        
        if (direction.equals(""RIGHT"")) {
            if (col < (dim - 1)) { return getGrid(row, col+1); }
        } // end if
        
        return null;
    } // end func getNeighbor
    
    public boolean compare(Board<Item> anotherBoard) { 
        if (anotherBoard.getDim() != dim) {
            return false;
        } // end if
        
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                if (getGrid(row, col) != anotherBoard.getGrid(row, col)) {
                    return false;
                } // end if
            } // end inner loop
        } // end outer loop
        
        return true;
    } // end func compare
    
    public Board copy(){
        Board<Item> board_copy = new Board(dim);
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board_copy.setGrid(row, col, getGrid(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                System.out.print(board[row * dim + col] + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board
@a1cdcac4d89633b61e322553d7344800@"
"r04945008","7","1.44","136240","@82dedd4de39b61452f617f9a92802c26@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == 0) return false;
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            QuickFindUF uf = new QuickFindUF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union(((i-1)*num)+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",uf.find(i*num+j+1));
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@82dedd4de39b61452f617f9a92802c26@"
"r04945008","9","1.04","133616","@8267f28d5986617ce86068b73be02a6a@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == 0) return false;
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF uf = new UF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union(((i-1)*num)+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",uf.find(i*num+j+1));
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@8267f28d5986617ce86068b73be02a6a@"
"b03106003","9","1","143008","@6c7a52926360994b8adbaaaf7920bb96@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickUnionUF uf = new QuickUnionUF(n*n/2+1);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        boolean isNew = true;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j],label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        /*
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        */
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}

@6c7a52926360994b8adbaaaf7920bb96@"
"r04945008","9","1.04","124576","@b1c72cf7bf50ca6fa6df53550fd78da3@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == 0) return false;
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF uf = new UF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union(((i-1)*num)+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
//                    else
//                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",uf.find(i*num+j+1));
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@b1c72cf7bf50ca6fa6df53550fd78da3@"
"b03106003","9","1.02","137168","@876af274e83f01ece7d19913e17300a8@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickFindUF uf = new QuickFindUF(n*n/2+1);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        boolean isNew = true;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j],label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        /*
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        */
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}

@876af274e83f01ece7d19913e17300a8@"
"r04945008","9","1.04","131552","@8267f28d5986617ce86068b73be02a6a@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == 0) return false;
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            UF uf = new UF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union((i-1)*num+j+1, i*num+j+1);uf.union((i-1)*num+j+1, i*num+j);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j, i*num+j+1);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union(((i-1)*num)+j+1, i*num+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",uf.find(i*num+j+1));
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@8267f28d5986617ce86068b73be02a6a@"
"b03106003","7","0.63","105536","@c319b0f9a1fc62d8bb95eb476a46199f@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickFindUF uf = new QuickFindUF(3*n);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j],label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        /*
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        */
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}

@c319b0f9a1fc62d8bb95eb476a46199f@"
"b01b01039","9","1.03","128736","@ba7c80e527038f4289bff2cdfb09d805@import java.io.FileReader;
import java.io.BufferedReader;
//import java.util.*;

public class LabelCC {
	private int now_label;
	private boolean[][] node;
	int[][] label;
	int[] target;
	
	public LabelCC(int N){
		now_label = 1;
		target = new int[2];
		node  = new boolean[N][N];
		for(int row = 0; row < N; row++){
			for(int col = 0; col < N; col++){
				node[row][col] = true;
			}
		}
		label = new int[N][N];
	}
	
	// recording target position
	public void target_assign(int row, int col){
		target[0] = row;
		target[1] = col;	
	}
	
	// Print target position
	public void target_print(){
		System.out.printf(""Target site row: %2d col: %2d\n"",target[0],target[1]);
	}
	
	// Get target row
	public int get_target_row(){
		return(target[0]);
	}
	
	// Get target col
	public int get_target_col(){
		return(target[1]);
	}
	
	// Return whether grid is open
	public boolean node(int row, int col){
		return node[row][col];
	}
	
	// Close the grid
	public void node_assign(int row, int col, boolean b){
		node[row][col] = node[row][col] & b;
	}
	
	// Print out node
	public void node_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b "", node[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	// Assign label
	public void label_assign(int row, int col, int lab){
		label[row][col] = lab;
	}
	
	// Print out label
	public void label_print(){
		for(int row = 0; row < label.length; row++){
			for(int col = 0; col < label.length; col++){
				System.out.printf(""%2d"", label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	// Return label of the grid
	public int get_label(int row, int col){
		return(label[row][col]);
	}
	
	// Return now label and add 1 to it
	public int now_label(){
		return now_label++;
	}
	
	// Print node and label
	public void both_print(){
		for(int row = 0; row < node.length; row++){
			for(int col = 0; col < node.length; col++){
				System.out.printf(""%5b %2d "", node[row][col], label[row][col]);
			}
			System.out.printf(""\n"");
		}
	}
	
	// Checking whether up grid open
	private boolean up_open(int row, int col){
		if(row > 0){
			return node[row-1][col];
		}else{
			return false;
		}
	}
	
	// Checking whether left grid open
	private boolean left_open(int row, int col){
		if(col > 0){
			return node[row][col-1];
		}else{
			return false;
		}
	}
	
	// Return up grid label
	private int up_label(int row, int col){
		return label[row-1][col];
	}
	
	// Return left grid label
	private int left_label(int row, int col){
		return label[row][col-1];
	}

	
	public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            //long time1, time2, time3, time4;
			//time1 = System.nanoTime();
			
            // read a line and split by ','
			String line = br.readLine();
            String[] data = line.split("","");
			
			// Creat a Stack for recording overlap label
			Stack<Integer> st = new Stack<Integer>();
			
			// Creat objects           
            int num = Integer.parseInt(data[0]);
			LabelCC lcc = new LabelCC(num);
			// Asign target site
			lcc.target_assign(Integer.parseInt(data[1])-1, Integer.parseInt(data[2])-1);
			//lcc.target_print();
			// read file line by line
			while ((line = br.readLine()) != null) {
				String[] pos = line.split("","");
				// checking whether input error
				if(pos.length != 2){
					System.out.println(""Error input"" + data);
					break;
				}
				int row = Integer.parseInt(pos[0])-1;
				int col = Integer.parseInt(pos[1])-1;
				//System.out.println(""row :""+ row + "" col :""+ col);
				lcc.node_assign(row, col, false); // Closing the grid
				//lcc.node_print();
			}
			//lcc.both_print();
			//System.out.println();
			//time2 = System.nanoTime();
			//int CC_N = 0;
			
			// Start labeling grids
			for(int row = 0; row < num; row++){
				for(int col = 0; col < num; col++){
					if(lcc.node(row,col)){
						if(lcc.up_open(row,col) & lcc.left_open(row,col)){
							// Overlap label
							if(lcc.up_label(row,col) < lcc.left_label(row,col)){
								lcc.label_assign(row,col,lcc.up_label(row,col));
							}else{
								lcc.label_assign(row,col,lcc.left_label(row,col));
							}
							if(lcc.up_label(row,col) != lcc.left_label(row,col)){
								// Recording overlap label
								st.push(lcc.up_label(row,col));
								st.push(lcc.left_label(row,col));
								//System.out.println(lcc.up_label(row,col) + "" "" + lcc.left_label(row,col));
							}
						}else if(lcc.up_open(row,col)){
							lcc.label_assign(row,col,lcc.up_label(row,col));
						}else if(lcc.left_open(row,col)){
							lcc.label_assign(row,col,lcc.left_label(row,col));
						}else{
							lcc.label_assign(row,col,lcc.now_label());
						}
					}
				}
			}
			//lcc.label_print();
			//time3 = System.nanoTime();
			uf_label uf_l = new uf_label(lcc.now_label());
			while(st.size() != 0){
				int up = st.pop();
				int left = st.pop();
				//System.out.println(up + "" "" + left);
				if(!uf_l.connected(up, left)){
					uf_l.label_change(up, left);
					uf_l.union(up, left);
					//uf_l.print_lable();
					//uf_l.print_root();
				}
			}

			//uf_l.print_lable();
			//uf_l.print_root();
			
			System.out.println(uf_l.get_label(lcc.get_label(lcc.get_target_row(), lcc.get_target_col())));
			//time4 = System.nanoTime();
			/*System.out.println(""=========== Time Cost ==========="");
			System.out.println(""Read File     : "" + (time2 - time1));
			System.out.println(""Assign labels : "" + (time3 - time2));
			System.out.println(""Unifind       : "" + (time4 - time3));*/
		}
	}	
}

// extention class of UF
class uf_label extends UF{
	private int[] label;
	
	public uf_label(int N){
		super(N);
		label = new int[N];
		for(int idx = 0; idx < N; idx++){
			label[idx] = idx;
		}
	}
	
	// For changing root label
	public void label_change(int p, int q){
		// checking root label
		int p_l = label[find(p)];
		int q_l = label[find(q)];
		//System.out.println(p_l + "" "" + q_l);
		if(p_l > q_l){
			//System.out.println(""id = "" +find(p) + "" label = "" + q_l);
			label[find(p)] = q_l;
			
		}else{
			//System.out.println(""id = "" +find(q) + ""label = "" + p_l);
			label[find(q)] = p_l;
		}
	}
	
	// For changing label
	public void change_label(int N, int lab){
		label[N] = lab;
	}
	
	// Return label
	public int get_label(int N){
		return label[find(N)];
	}
	
	// Print out label
	public void print_lable(){
		for(int i : label){
			System.out.printf(""%d "", i);
		}
		System.out.printf(""\n"");
	}
	
	// Print out root of each CC
	public void print_root(){
		for(int id = 0; id < label.length; id++){
			System.out.printf(""%d "", find(id));
		}
		System.out.printf(""\n"");
	}
}
@ba7c80e527038f4289bff2cdfb09d805@"
"b03106003","0","1.22","158992","@6cc4beea0ac5f239be09afac42d13fd9@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickFindUF uf = new QuickFindUF(n*n/2+1);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j],label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1])-1);
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}
@6cc4beea0ac5f239be09afac42d13fd9@"
"b03106003","0","1.89","198736","@b47cf2a9f1fee0dacb4ed98e6ea8c18e@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickFindUF uf = new QuickFindUF(n*n*n);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j], label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}

@b47cf2a9f1fee0dacb4ed98e6ea8c18e@"
"b03106003","0","1.91","199360","@adda86805214918a634c323513f3ea1e@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickFindUF uf = new QuickFindUF(10000*n);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j], label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}

@adda86805214918a634c323513f3ea1e@"
"b03106003","0","1.89","198656","@7b59b8d7aa9c292277d0e6a97fd904ae@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickFindUF uf = new QuickFindUF(10000*n);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j], label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}
@7b59b8d7aa9c292277d0e6a97fd904ae@"
"b03106003","0","1.26","172160","@a538f40b3d7798f9655b683ca6204670@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickFindUF uf = new QuickFindUF(n*n/2+1);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j], label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}

@a538f40b3d7798f9655b683ca6204670@"
"b03106003","9","1","139216","@6c7a52926360994b8adbaaaf7920bb96@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickUnionUF uf = new QuickUnionUF(n*n/2+1);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        boolean isNew = true;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j],label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        /*
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        */
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}

@6c7a52926360994b8adbaaaf7920bb96@"
"b03106003","9","1.08","139296","@f2f59eb04cec8f6a943cca1659081a61@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
                //union
        
        QuickFindUF uf = new QuickFindUF(1000*n);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                            uf.union(label, flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j], label);
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        /*
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        */
        
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}

@f2f59eb04cec8f6a943cca1659081a61@"
"r03849033","9","1.01","128400","@9edfa64607446bb44c31ec46f2e9a397@
import java.io.BufferedReader;
import java.io.FileReader;





public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        int l=label[i];
        int z=0;
        int t=3;
        int[] s = new int[t];
        while(l==0){
            if(z==t){
                t=t*2;
                int[] s1=new int[t];
                for(int j = 0; j < z ; j++){
                    s1[j]=s[j];
                }      
                s=s1;
            }
            s[z]=i;            
            i=root[i];
            l=label[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i; 
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                if (p <= 0 || q <= 0 || p > n || q > n) {
                }
                else {
                matrix[p-1][q-1]=true;}
                }

            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if( matrix[r][c-1]==false && matrix[r-1][c]==false){

                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                        }
                        //
                        else{
                            if(matrix[r][c-1]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                            else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
            }                  
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@9edfa64607446bb44c31ec46f2e9a397@"
"b03106003","9","1.01","138864","@6ee959bda2806713e4a520a27a0abaf8@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        /*
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        */
       QuickFindUF uf = new QuickFindUF(count+1);
       for(int i = 1; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i > 0){
                    if(flag[i][j] != 0 && flag[i-1][j]!= 0 && flag[i][j] != flag[i-1][j]){
                        if(flag[i][j] > flag[i-1][j]){
                            uf.union(flag[i][j], flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j], flag[i][j]);
                        }
                    }
                }
            }
        }
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}
@6ee959bda2806713e4a520a27a0abaf8@"
"r04631031","1","0.72","125200","@3626939d89fe61631f7090b6bf48e36d@//import edu.princeton.cs.algs4.QuickUnionUF;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        break;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum + 1, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1 + 1)>=uf.find(NumOfgroup + matrixnum-size +1)){
                                uf.union(NumOfgroup + matrixnum + 1, NumOfgroup + matrixnum - size + 1);
                                uf.union(NumOfgroup + matrixnum - 1 + 1,NumOfgroup + matrixnum - size + 1);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size + 1,NumOfgroup + matrixnum + 1);
                                uf.union(NumOfgroup +matrixnum - size + 1,NumOfgroup + matrixnum - 1 + 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum + 1, NumOfgroup + matrixnum - size + 1);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum + 1, NumOfgroup + matrixnum - 1 + 1);
                        }
                    }
                }
            }
         System.out.printf(""%d"",uf.find(NumOfgroup + goal + 1));
        }
    }
}

@3626939d89fe61631f7090b6bf48e36d@"
"r04631031","1","0.75","132560","@2eafe2c1f53770d8e95079d8ccf6919f@//import edu.princeton.cs.algs4.QuickUnionUF;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        break;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum + 1, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1 + 1)>=uf.find(NumOfgroup + matrixnum-size +1)){
                                uf.union(NumOfgroup + matrixnum + 1, NumOfgroup + matrixnum - size + 1);
                                uf.union(NumOfgroup + matrixnum - 1 + 1,NumOfgroup + matrixnum - size + 1);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size + 1,NumOfgroup + matrixnum + 1);
                                uf.union(NumOfgroup +matrixnum - size + 1,NumOfgroup + matrixnum - 1 + 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum + 1, NumOfgroup + matrixnum - size + 1);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum + 1, NumOfgroup + matrixnum - 1 + 1);
                        }
                    }
                }
            }
         System.out.printf(""%d"",1+uf.find(NumOfgroup + goal + 1));
        }
    }
}

@2eafe2c1f53770d8e95079d8ccf6919f@"
"b03106003","9","1.01","137968","@9f4bb65d19b9bb043d5add7db7799f7f@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                           label = flag[i-1][j];
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
        /*
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        */
       QuickFindUF uf = new QuickFindUF(count+1);
       for(int i = 1; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                    if(flag[i][j] != 0 && flag[i-1][j]!= 0 && flag[i][j] != flag[i-1][j]){
                        if(flag[i][j] > flag[i-1][j]){
                            uf.union(flag[i][j], flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j], flag[i][j]);
                        }
                    }
            }
        }
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}
@9f4bb65d19b9bb043d5add7db7799f7f@"
"b03106003","10","0.104","142448","@c0d968e7473e46366042a7e8d125cf8c@import java.io.FileReader;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;

public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        StringBuffer sb = new StringBuffer();
        String strNum = new String();
        
    while ((strNum = br.readLine())!=null){
        sb.append(strNum);
        sb.append("";"");
    }
        strNum = sb.toString();
        String data[] = strNum.split("";"");
        String firstLine[] = data[0].split("","");
        int n = Integer.valueOf(firstLine[0]);
        
        int flag[][] = new int [n][n];
        
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                flag[i][j] = -1;            
            }
        }
        
        for(int i = 1; i < data.length; i++){
            makeflag(flag,data[i]);
        }
        int label = 0;
        int count = 0;
        boolean con = false;
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                if( i == 0){
                    if(flag[i][j] == -1 && con == false){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
                if( i > 0){
                    if(flag[i][j] == -1 && con == false && flag[i-1][j] == 0){
                        count++;
                        label = count;
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == false && flag[i-1][j] != 0){
                        label = flag[i-1][j];
                        flag[i][j] = label;
                        con = true;
                    }else if (flag[i][j] == -1 && con == true && (flag[i-1][j] == 0 || label == flag[i-1][j])){
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == -1 && con == true){
                        if(label > flag[i-1][j]){
                           label = flag[i-1][j];
                        }
                        flag[i][j] = label;
                        con = true;
                    }else if(flag[i][j] == 0 && con == true){
                        con = false;
                    }
                }
            }
                
            con = false;
        }
       
        /*
        for(int i = 0 ; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                System.out.print(flag[i][j]);
            }
            System.out.println();
        }
        */
        
       QuickFindUF uf = new QuickFindUF(count+1);
       for(int i = 1; i<flag.length; i++){
            for(int j = 0; j < flag[i].length; j++){
                    if(flag[i][j] != 0 && flag[i-1][j]!= 0 && flag[i][j] != flag[i-1][j]){
                        if(flag[i][j] > flag[i-1][j]){
                            uf.union(flag[i][j], flag[i-1][j]);
                        }else{
                            uf.union(flag[i-1][j], flag[i][j]);
                        }
                    }
                     
                    if(j>0){
                    if(flag[i][j] != 0 && flag[i][j-1]!= 0 && flag[i][j] != flag[i][j-1]){
                        if(flag[i][j] > flag[i][j-1]){
                            uf.union(flag[i][j], flag[i][j-1]);
                        }else{
                            uf.union(flag[i][j-1], flag[i][j]);
                        }
                    }
                    
                    }
                    
                    
                    
            }
        }
       System.out.println(uf.find(flag[Integer.valueOf(firstLine[1])-1][Integer.valueOf(firstLine[2])-1]));
        

        
    }
    
    static void makeflag(int map[][] , String mark){
        String [] temp = mark.split("","");
        int flag[] = new int[2];
        flag[0] = Integer.valueOf(temp[0]);
        flag[1] = Integer.valueOf(temp[1]);
        //System.out.println(flag[0] +""""+ flag[1]);
        map[flag[0]-1][flag[1]-1] = 0;
        
    
    }
    
}

@c0d968e7473e46366042a7e8d125cf8c@"
"r04631031","9","1.04","132464","@e44cdae9aea72e24f05529bf51453e66@//import edu.princeton.cs.algs4.QuickUnionUF;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        continue;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
                        }
                    }
                }
            }
            System.out.printf(""%d"",uf.find(NumOfgroup + goal));
//         for(int i = 1 ; i <= NumOfmatrix ; i++){
//                 System.out.printf(""%d  "",uf.find(NumOfgroup + i));
//                 if(i%size == 0){
//                     System.out.printf(""\n"");
//                 }
//         }
         
        }
    }
}

@e44cdae9aea72e24f05529bf51453e66@"
"r04631031","9","1.03","131504","@a7b4090a225a3b7aea3308908dee94a1@//import edu.princeton.cs.algs4.QuickUnionUF;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        continue;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
                        }
                    }
                }
            }
            if(uf.find(NumOfgroup + goal) > NumOfgroup){
                System.out.printf(""1"");
            }
            else{
                System.out.printf(""%d"",uf.find(NumOfgroup + goal));
            }
            
//         for(int i = 1 ; i <= NumOfmatrix ; i++){
//                 System.out.printf(""%d  "",uf.find(NumOfgroup + i));
//                 if(i%size == 0){
//                     System.out.printf(""\n"");
//                 }
//         }
         
        }
    }
}

@a7b4090a225a3b7aea3308908dee94a1@"
"r04631031","9","1.03","130272","@332c6e8d87f9a14c880bab873c856ede@//import edu.princeton.cs.algs4.QuickUnionUF;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        continue;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
                        }
                    }
                }
            }
            if(uf.find(NumOfgroup + goal) > NumOfgroup){
                System.out.printf(""0"");
            }
            else{
                System.out.printf(""%d"",uf.find(NumOfgroup + goal));
            }
            
//         for(int i = 1 ; i <= NumOfmatrix ; i++){
//                 System.out.printf(""%d  "",uf.find(NumOfgroup + i));
//                 if(i%size == 0){
//                     System.out.printf(""\n"");
//                 }
//         }
         
        }
    }
}

@332c6e8d87f9a14c880bab873c856ede@"
"r04631031","9","1.01","132704","@332c6e8d87f9a14c880bab873c856ede@//import edu.princeton.cs.algs4.QuickUnionUF;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        continue;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
                        }
                    }
                }
            }
            if(uf.find(NumOfgroup + goal) > NumOfgroup){
                System.out.printf(""0"");
            }
            else{
                System.out.printf(""%d"",uf.find(NumOfgroup + goal));
            }
            
//         for(int i = 1 ; i <= NumOfmatrix ; i++){
//                 System.out.printf(""%d  "",uf.find(NumOfgroup + i));
//                 if(i%size == 0){
//                     System.out.printf(""\n"");
//                 }
//         }
         
        }
    }
}

@332c6e8d87f9a14c880bab873c856ede@"
"r04631025","0","1.61","245840","@db92584add27e8cc10eaf65fc490ec06@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    private int[] rank; 
    UF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        rank =new int[n * n];
        label = 1;
        N = n;
           
        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 1;
            rank[i]=0;
        }

    }
    public void newunion (int n){
        uf =new UF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(id[matrix[x-1][y]]==1&& id[matrix[x][y-1]]==1 && id[matrix[x][y]]==1){
                if(rank[matrix[x-1][y]]>rank[matrix[x][y-1]]){
                uf.union(rank[matrix[x][y-1]]-1,rank[matrix[x-1][y]]-1);}
                else{
                        uf.union(rank[matrix[x-1][y]]-1,rank[matrix[x][y-1]]-1);

                }
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=0;
    }
    
    public int getlabel (int x ,int y){
        if(rank[matrix[x-1][y-1]]!=0){
        return uf.find(rank[matrix[x-1][y-1]]-1)+1;}
        else{
            return 0;
        }
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            rank[matrix[x][y]] = label;
        } else {
            if (x == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x][y - 1]] == 0) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x][y-1]];
                }
            }
            if (y == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x - 1][y]] ==0 ) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                }
            }
            if (id[matrix[x][y]] == 1 && x != 0 && y != 0) {
                if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 1) {
                    if (rank[matrix[x - 1][y]] > rank[matrix[x][y - 1]]) {
                        rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                    }
                    else{
                        rank[matrix[x][y]]=rank[matrix[x-1][y]];
                    }
                }else if(id[matrix[x-1][y]] == 1 && id[matrix[x][y-1]]==0){
                    rank[matrix[x][y]]=rank[matrix[x-1][y]];
                }else if(id[matrix[x-1][y]]==0 && id[matrix[x][y-1]] == 1){
                    rank[matrix[x][y]]=rank[matrix[x][y-1]];
                }else{
                    label++;
                    rank[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            for(int i=1 ;i<=N;i++)
            {
                for(int j=1;j<=N;j++)
                {
                    int answer=LC.getlabel(i, j);
                    System.out.printf(""%d"",answer);
                }
                System.out.printf(""\n"");
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@db92584add27e8cc10eaf65fc490ec06@"
"r03631015","0","1.03","131504","@108a0bb8b91b2f72c4d082f603e66410@
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        continue;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
                        }
                    }
                }
            }
            System.out.printf(""%d"",uf.find(NumOfgroup + goal));
//         for(int i = 1 ; i <= NumOfmatrix ; i++){
//                 System.out.printf(""%d  "",uf.find(NumOfgroup + i));
//                 if(i%size == 0){
//                     System.out.printf(""\n"");
//                 }
//         }
         
        }
    }
}

@108a0bb8b91b2f72c4d082f603e66410@"
"r04631026","9","1.02","135712","@e44cdae9aea72e24f05529bf51453e66@//import edu.princeton.cs.algs4.QuickUnionUF;
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        continue;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
                        }
                    }
                }
            }
            System.out.printf(""%d"",uf.find(NumOfgroup + goal));
//         for(int i = 1 ; i <= NumOfmatrix ; i++){
//                 System.out.printf(""%d  "",uf.find(NumOfgroup + i));
//                 if(i%size == 0){
//                     System.out.printf(""\n"");
//                 }
//         }
         
        }
    }
}

@e44cdae9aea72e24f05529bf51453e66@"
"r03631015","9","1.06","133504","@8c036d609cc72151de14ed1f2e5569cb@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        continue;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
                        }
                    }
                }
            }
            System.out.printf(""%d"",uf.find(NumOfgroup + goal));
//         for(int i = 1 ; i <= NumOfmatrix ; i++){
//                 System.out.printf(""%d  "",uf.find(NumOfgroup + i));
//                 if(i%size == 0){
//                     System.out.printf(""\n"");
//                 }
//         }
         
        }
    }
}

@8c036d609cc72151de14ed1f2e5569cb@"
"r04631025","0","1.64","251328","@db92584add27e8cc10eaf65fc490ec06@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    private int[] rank; 
    UF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        rank =new int[n * n];
        label = 1;
        N = n;
           
        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 1;
            rank[i]=0;
        }

    }
    public void newunion (int n){
        uf =new UF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(id[matrix[x-1][y]]==1&& id[matrix[x][y-1]]==1 && id[matrix[x][y]]==1){
                if(rank[matrix[x-1][y]]>rank[matrix[x][y-1]]){
                uf.union(rank[matrix[x][y-1]]-1,rank[matrix[x-1][y]]-1);}
                else{
                        uf.union(rank[matrix[x-1][y]]-1,rank[matrix[x][y-1]]-1);

                }
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=0;
    }
    
    public int getlabel (int x ,int y){
        if(rank[matrix[x-1][y-1]]!=0){
        return uf.find(rank[matrix[x-1][y-1]]-1)+1;}
        else{
            return 0;
        }
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            rank[matrix[x][y]] = label;
        } else {
            if (x == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x][y - 1]] == 0) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x][y-1]];
                }
            }
            if (y == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x - 1][y]] ==0 ) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                }
            }
            if (id[matrix[x][y]] == 1 && x != 0 && y != 0) {
                if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 1) {
                    if (rank[matrix[x - 1][y]] > rank[matrix[x][y - 1]]) {
                        rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                    }
                    else{
                        rank[matrix[x][y]]=rank[matrix[x-1][y]];
                    }
                }else if(id[matrix[x-1][y]] == 1 && id[matrix[x][y-1]]==0){
                    rank[matrix[x][y]]=rank[matrix[x-1][y]];
                }else if(id[matrix[x-1][y]]==0 && id[matrix[x][y-1]] == 1){
                    rank[matrix[x][y]]=rank[matrix[x][y-1]];
                }else{
                    label++;
                    rank[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            for(int i=1 ;i<=N;i++)
            {
                for(int j=1;j<=N;j++)
                {
                    int answer=LC.getlabel(i, j);
                    System.out.printf(""%d"",answer);
                }
                System.out.printf(""\n"");
            }
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@db92584add27e8cc10eaf65fc490ec06@"
"r04631025","9","1.04","129104","@e5fdf3df8deea390a6561f9a4d4641a1@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    private int[] rank; 
    UF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        rank =new int[n * n];
        label = 1;
        N = n;
           
        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 1;
            rank[i]=0;
        }

    }
    public void newunion (int n){
        uf =new UF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(id[matrix[x-1][y]]==1&& id[matrix[x][y-1]]==1 && id[matrix[x][y]]==1){
                if(rank[matrix[x-1][y]]>rank[matrix[x][y-1]]){
                uf.union(rank[matrix[x][y-1]]-1,rank[matrix[x-1][y]]-1);}
                else{
                        uf.union(rank[matrix[x-1][y]]-1,rank[matrix[x][y-1]]-1);

                }
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=0;
    }
    
    public int getlabel (int x ,int y){
        if(rank[matrix[x-1][y-1]]!=0){
        return uf.find(rank[matrix[x-1][y-1]]-1)+1;}
        else{
            return 0;
        }
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            rank[matrix[x][y]] = label;
        } else {
            if (x == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x][y - 1]] == 0) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x][y-1]];
                }
            }
            if (y == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x - 1][y]] ==0 ) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                }
            }
            if (id[matrix[x][y]] == 1 && x != 0 && y != 0) {
                if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 1) {
                    if (rank[matrix[x - 1][y]] > rank[matrix[x][y - 1]]) {
                        rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                    }
                    else{
                        rank[matrix[x][y]]=rank[matrix[x-1][y]];
                    }
                }else if(id[matrix[x-1][y]] == 1 && id[matrix[x][y-1]]==0){
                    rank[matrix[x][y]]=rank[matrix[x-1][y]];
                }else if(id[matrix[x-1][y]]==0 && id[matrix[x][y-1]] == 1){
                    rank[matrix[x][y]]=rank[matrix[x][y-1]];
                }else{
                    label++;
                    rank[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@e5fdf3df8deea390a6561f9a4d4641a1@"
"r04631046","8","1.01","130960","@417d3da0d82579f4b640cb554b2af7b9@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
//        read size and outputelement
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int[] opElement = new int[2];
            opElement[0] = Integer.parseInt(data[1]);
            opElement[1] = Integer.parseInt(data[2]);
            
//            read close position
            boolean[][] dataMatrix = new boolean[num][num];
            while(br.ready()){
                String[] Open = br.readLine().split("","");
                dataMatrix[Integer.parseInt(Open[0])-1][Integer.parseInt(Open[1])-1] = true;
            }
//            QuickUnionUF setting
            int groupN = (num*num+1)/2;
            int totalN = num*num+groupN+1;
            int opPosition = (opElement[0]-1)*num+opElement[1]+groupN;
            QuickUnionUF uf = new QuickUnionUF(totalN);
            int position ;
            int label = 0;
//            Main
            for(int i=0;i<num;i++){
                for(int j=0;j<num;j++){
                    position = (i*num)+j+groupN+1;
//                    block
                    if(dataMatrix[i][j]==true){
                        uf.union(position, 0);
                    }
//                    first element
                    else if(i==0&&j==0&&dataMatrix[i][j]==false){
                        label++;
                        uf.union(position,label);
                    }
//                    first row
                    else if(i==0&&j!=0&&dataMatrix[i][j]==false){
                        if(dataMatrix[i][j-1]==false){
                            uf.union(position, position-1);
                        }
                        else{
                            label++;
                            uf.union(position, label);
                        }
                        
                    }
//                    first column
                    else if(j==0&&i!=0&&dataMatrix[i][j]==false){
                        if(dataMatrix[i-1][j]==false){
                            uf.union(position, position-num);
                        }
                        else{
                            label++;
                            uf.union(position, label);
                        }
                        
                    }
//                    regulat element
                    else if(dataMatrix[i][j]==false){
//                        -1 yes -num no
                        if(dataMatrix[i][j-1]==false&&dataMatrix[i-1][j]==true){
                            uf.union(position, position-1);
                        }
//                        -1 no -num yes
                        else if(dataMatrix[i][j-1]==true&&dataMatrix[i-1][j]==false){
                            uf.union(position, position-num);
                        }
//                        all yes
                        else if(dataMatrix[i][j-1]==false&&dataMatrix[i-1][j]==false){
                            int left = uf.find(position-1);
                            int up = uf.find(position-num);
                            if(left<up){
                                uf.union(position, position-1);
                            }
                            else if(up<left||up==left){
                                uf.union(position, position-num);
                            }
                        }
//                        all no
                        else{
                            label++;
                            uf.union(position, label);
                        }
                    }
                }
            }
            int outLabel = uf.find(opPosition);
            System.out.printf(""%d"",outLabel);           
        }
    }
}

@417d3da0d82579f4b640cb554b2af7b9@"
"r04631046","9","1.02","128592","@1d2da91d60637f960f1062ec94d058c1@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
//        read size and outputelement
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int[] opElement = new int[2];
            opElement[0] = Integer.parseInt(data[1]);
            opElement[1] = Integer.parseInt(data[2]);
            
//            read close position
            boolean[][] dataMatrix = new boolean[num][num];
            while(br.ready()){
                String[] Open = br.readLine().split("","");
                dataMatrix[Integer.parseInt(Open[0])-1][Integer.parseInt(Open[1])-1] = true;
            }
//            QuickUnionUF setting
            int groupN = (num*num+1)/2;
            int totalN = num*num+groupN+1;
            int opPosition = (opElement[0]-1)*num+opElement[1]+groupN;
            QuickUnionUF uf = new QuickUnionUF(totalN);
            int position ;
            int label = 0;
//            Main
            for(int i=0;i<num;i++){
                for(int j=0;j<num;j++){
                    position = (i*num)+j+groupN+1;
//                    block
                    if(dataMatrix[i][j]==true){
                        uf.union(position, 0);
                    }
//                    first element
                    else if(i==0&&j==0&&dataMatrix[i][j]==false){
                        label++;
                        uf.union(position,label);
                    }
//                    first row
                    else if(i==0&&j!=0&&dataMatrix[i][j]==false){
                        if(dataMatrix[i][j-1]==false){
                            uf.union(position, position-1);
                        }
                        else{
                            label++;
                            uf.union(position, label);
                        }
                        
                    }
//                    first column
                    else if(j==0&&i!=0&&dataMatrix[i][j]==false){
                        if(dataMatrix[i-1][j]==false){
                            uf.union(position, position-num);
                        }
                        else{
                            label++;
                            uf.union(position, label);
                        }
                        
                    }
//                    regulat element
                    else if(dataMatrix[i][j]==false){
//                        -1 yes -num no
                        if(dataMatrix[i][j-1]==false&&dataMatrix[i-1][j]==true){
                            uf.union(position, position-1);
                        }
//                        -1 no -num yes
                        else if(dataMatrix[i][j-1]==true&&dataMatrix[i-1][j]==false){
                            uf.union(position, position-num);
                        }
//                        all yes
                        else if(dataMatrix[i][j-1]==false&&dataMatrix[i-1][j]==false){
                            int left = uf.find(position-1);
                            int up = uf.find(position-num);
                            if(left<up){
                                uf.union(position, position-1);
                                uf.union(position-num, position-1);
                            }
                            else if(up<left||up==left){
                                uf.union(position, position-num);
                                uf.union(position-1, position-num);
                            }
                        }
//                        all no
                        else{
                            label++;
                            uf.union(position, label);
                        }
                    }
                }
            }
            int outLabel = uf.find(opPosition);
            System.out.printf(""%d"",outLabel);           
        }
    }
}

@1d2da91d60637f960f1062ec94d058c1@"
"r04631025","9","1.03","135344","@ea6285af4dae4db969d883c500959ed8@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    private int[] rank; 
    UF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        rank =new int[n * n];
        label = 1;
        N = n;
           
        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 1;
            rank[i]=0;
        }

    }
    public void newunion (int n){
        uf =new UF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(id[matrix[x-1][y]]==1&& id[matrix[x][y-1]]==1 && id[matrix[x][y]]==1){
                if(rank[matrix[x-1][y]]>rank[matrix[x][y-1]]){
                uf.union(rank[matrix[x][y-1]]-1,rank[matrix[x-1][y]]-1);}
                else{
                        uf.union(rank[matrix[x-1][y]]-1,rank[matrix[x][y-1]]-1);

                }
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=0;
    }
    
    public int getlabel (int x ,int y){
        if(rank[matrix[x-1][y-1]]!=0){
        return uf.find(rank[matrix[x-1][y-1]]-1)+1;}
            else{
            return 0;
        }
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            if(id[matrix[x][y]]==1)
            rank[matrix[x][y]] = label;
            else{
                label--;
            }

        } else {
            if (x == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x][y - 1]] == 0) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x][y-1]];
                }
            }
            if (y == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x - 1][y]] ==0 ) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                }
            }
            if (id[matrix[x][y]] == 1 && x != 0 && y != 0) {
                if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 1) {
                    if (rank[matrix[x - 1][y]] > rank[matrix[x][y - 1]]) {
                        rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                    }
                    else{
                        rank[matrix[x][y]]=rank[matrix[x-1][y]];
                    }
                }else if(id[matrix[x-1][y]] == 1 && id[matrix[x][y-1]]==0){
                    rank[matrix[x][y]]=rank[matrix[x-1][y]];
                }else if(id[matrix[x-1][y]]==0 && id[matrix[x][y-1]] == 1){
                    rank[matrix[x][y]]=rank[matrix[x][y-1]];
                }else{
                    label++;
                    rank[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            


            
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@ea6285af4dae4db969d883c500959ed8@"
"b03611015","0","0","0","@f6a7d79d4b53e67fb22d2f4ecd2058d7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author Steven
 */
public class LabelCC {
    
    private static int[] id;
    private static int[][] matrix;

    static int N;
    static int a;
    
    
    public LabelCC(int N){
        id = new int[N * N];
        matrix = new int[N][N];

       
        
    }
    public static void blocked(int row, int col){
        matrix[row][col]=0;
      }
    public static void label(int row, int col){
        
        for(int i=0;i<N;i++){
            for(int j=0;j<N;j++){
                if(matrix[i][j]!=0)
                    a=matrix[i][j]+1;
                    
                    
                    
            }
           
                
        }
    }
    
    

    
    public static void main(String[] args) throws IOException {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            N = Integer.parseInt(data[0]);
            int targ1 = Integer.parseInt(data[1]);
            int targ2 = Integer.parseInt(data[2]);
            
            int row = 0;
            int col = 0;
            String[] randc = new String[2];
            
            for(int i=0;i<N;i++){
            randc = br.readLine().split("","");
            row = Integer.parseInt(randc[0]);
            col = Integer.parseInt(randc[1]);
            blocked(row,col);
            }
    }
    
}
}

@f6a7d79d4b53e67fb22d2f4ecd2058d7@"
"r04631031","9","1.2","137696","@b7e37680b15db278b258e6d8a0ae847d@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            } 
            //check the program
//            for(int i = 0 ; i < size+2 ; i++){
//                for(int j = 0 ; j < size+2 ; j++){
//                    System.out.printf(""%b "", checkmatrix[i][j]);
//                }
//                System.out.printf(""\n"");
//            }
            // n*n for every block and preserve (n*n+1)/2 for group number
            int NumOfgroup = (size*size+1)/2;
            int NumOfmatrix = size * size;
            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
            QuickFindUF uf = new QuickFindUF(NumOfuf);
            int groupid = 0;
            
            for(int i = 1; i <= size ; i++){
                for(int j = 1 ; j <= size ; j++){
                    if(checkmatrix[i][j]==true){
                        continue;
                    }
                    if(checkmatrix[i][j]==false){
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            groupid++;
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, groupid);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
                            }
                            else{
                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
                            }
                        }
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
                        }
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            int matrixnum = ( i-1 )*size + j;
                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
                        }
                    }
                }
            }
            if(uf.find(NumOfgroup + goal) > NumOfgroup){
                System.out.printf(""0"");
            }
            else{
                System.out.printf(""%d"",uf.find(NumOfgroup + goal));
            }
        }
    }
}

@b7e37680b15db278b258e6d8a0ae847d@"
"r04631025","9","1.01","129328","@bdd61d0f96905097142246f187f63670@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    private int[] rank; 
    UF uf;
    

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        rank =new int[n * n];
        label = 1;
        N = n;
           
        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 1;
            rank[i]=0;
        }

    }
    public void newunion (int n){
        uf =new UF(label);        
    }
    public void child(int x,int y){
        if(x!=0&&y!=0){
            if(id[matrix[x-1][y]]==1&& id[matrix[x][y-1]]==1 && id[matrix[x][y]]==1){
                if(rank[matrix[x-1][y]]>rank[matrix[x][y-1]]){
                uf.union(rank[matrix[x][y-1]]-1,rank[matrix[x-1][y]]-1);}
                else{
                        uf.union(rank[matrix[x-1][y]]-1,rank[matrix[x][y-1]]-1);

                }
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x-1][y-1]]=0;
    }
    
    public int getlabel (int x ,int y){
        if(rank[matrix[x-1][y-1]]!=0&&id[matrix[x-1][y-1]]==1){
            if (id[matrix[0][0]]==0){
            return 4;}
            else{return uf.find(rank[matrix[x-1][y-1]]-1)+1;}}
       
        else{
            return 0;
        }
    } 

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            if(id[matrix[x][y]]==1)
            rank[matrix[x][y]] = label;
            else{
                label--;
            }

        } else {
            if (x == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x][y - 1]] == 0) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x][y-1]];
                }
            }
            if (y == 0&&id[matrix[x][y]]==1) {
                if (id[matrix[x - 1][y]] ==0 ) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                }
            }
            if (id[matrix[x][y]] == 1 && x != 0 && y != 0) {
                if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 1) {
                    if (rank[matrix[x - 1][y]] > rank[matrix[x][y - 1]]) {
                        rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                    }
                    else{
                        rank[matrix[x][y]]=rank[matrix[x-1][y]];
                    }
                }else if(id[matrix[x-1][y]] == 1 && id[matrix[x][y-1]]==0){
                    rank[matrix[x][y]]=rank[matrix[x-1][y]];
                }else if(id[matrix[x-1][y]]==0 && id[matrix[x][y-1]] == 1){
                    rank[matrix[x][y]]=rank[matrix[x][y-1]];
                }else{
                    label++;
                    rank[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);
            
            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for(int i=0;i<N;i++){
                for(int j=0;j<N;j++){
                    LC.child(i,j);
                }
            }
            
            int answer=LC.getlabel(destx, desty);
            System.out.printf(""%d"",answer);
        }
        
        // TODO code application logic here
    }

}

@bdd61d0f96905097142246f187f63670@"
"r04631025","9","1.03","132976","@f0c7d64a01f5b7e2bb8132e7e3185bbd@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    private int[] rank;
    UF uf;

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        rank = new int[n * n];
        label = 1;
        N = n;

        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 1;
            rank[i] = 0;
        }

    }

    public void newunion(int n) {
        uf = new UF(label);
    }

    public void child(int x, int y) {
        if (x != 0 && y != 0) {
            if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 1 && id[matrix[x][y]] == 1) {
                if (rank[matrix[x - 1][y]] > rank[matrix[x][y - 1]]) {
                    uf.union(rank[matrix[x][y - 1]] - 1, rank[matrix[x - 1][y]] - 1);
                } else {
                    uf.union(rank[matrix[x - 1][y]] - 1, rank[matrix[x][y - 1]] - 1);

                }
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
    }

    public int getlabel(int x, int y) {
        if (rank[matrix[x - 1][y - 1]] != 0 && id[matrix[x - 1][y - 1]] == 1) {

            return uf.find(rank[matrix[x - 1][y - 1]] - 1) + 1;
        } else {
            return 0;
        }
    }

    public void firstpass(int x, int y) {
        if (x == 0 & y == 0) {
            if (id[matrix[x][y]] == 1) {
                rank[matrix[x][y]] = label;
            } else {
                label--;
            }

        } else {
            if (x == 0 && id[matrix[x][y]] == 1) {
                if (id[matrix[x][y - 1]] == 0) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                }
            }
            if (y == 0 && id[matrix[x][y]] == 1) {
                if (id[matrix[x - 1][y]] == 0) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                }
            }
            if (id[matrix[x][y]] == 1 && x != 0 && y != 0) {
                if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 1) {
                    if (rank[matrix[x - 1][y]] > rank[matrix[x][y - 1]]) {
                        rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                    } else {
                        rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                    }
                } else if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 0) {
                    rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                } else if (id[matrix[x - 1][y]] == 0 && id[matrix[x][y - 1]] == 1) {
                    rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                } else {
                    label++;
                    rank[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);

            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.child(i, j);
                }
            }

            int answer = LC.getlabel(destx, desty);
            System.out.printf(""%d"", answer);
        }

        // TODO code application logic here
    }

}

@f0c7d64a01f5b7e2bb8132e7e3185bbd@"
"b03611015","0","1.03","132976","@6a2a5a1adf2ca5dde7d50b8748605bb7@ System.out.print(0);
@6a2a5a1adf2ca5dde7d50b8748605bb7@"
"r04631046","9","1.01","128896","@2a335b2714fe6d0c69b2a8c02028ec90@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
//        read size and outputelement
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int[] opElement = new int[2];
            opElement[0] = Integer.parseInt(data[1]);
            opElement[1] = Integer.parseInt(data[2]);
            
//            read close position
            boolean[][] dataMatrix = new boolean[num][num];
            while(br.ready()){
                String[] Open = br.readLine().split("","");
                dataMatrix[Integer.parseInt(Open[0])-1][Integer.parseInt(Open[1])-1] = true;
            }
//            QuickUnionUF setting
            int groupN = (num*num+1)/2;
            int totalN = num*num+groupN+1;
            int opPosition = (opElement[0]-1)*num+opElement[1]+groupN;
            QuickUnionUF uf = new QuickUnionUF(totalN);
            int position ;
            int label = 0;
//            Main
            for(int i=0;i<num;i++){
                for(int j=0;j<num;j++){
                    position = (i*num)+j+groupN+1;
//                    block
                    if(dataMatrix[i][j]==true){
                        uf.union(position, 0);
                    }
//                    first element
                    else if(i==0&&j==0&&dataMatrix[i][j]==false){
                        label++;
                        uf.union(position,label);
                    }
//                    first row
                    else if(i==0&&dataMatrix[i][j]==false){
                        if(dataMatrix[i][j-1]==false){
                            uf.union(position, position-1);
                        }
                        else{
                            label++;
                            uf.union(position, label);
                        }
                        
                    }
//                    first column
                    else if(j==0&&dataMatrix[i][j]==false){
                        if(dataMatrix[i-1][j]==false){
                            uf.union(position, position-num);
                        }
                        else{
                            label++;
                            uf.union(position, label);
                        }
                        
                    }
//                    regulat element
                    else if(dataMatrix[i][j]==false){
//                        left yes up no
                        if(dataMatrix[i][j-1]==false&&dataMatrix[i-1][j]==true){
                            uf.union(position, position-1);
                        }
//                        left no up yes
                        else if(dataMatrix[i][j-1]==true&&dataMatrix[i-1][j]==false){
                            uf.union(position, position-num);
                        }
//                        all yes
                        else if(dataMatrix[i][j-1]==false&&dataMatrix[i-1][j]==false){
                            int left = uf.find(position-1);
                            int up = uf.find(position-num);
                            if(left<up){
                                uf.union(position, position-1);
                                uf.union(position-num, position-1);
                            }
                            else if(up<left||up==left){
                                uf.union(position, position-num);
                                uf.union(position-1, position-num);
                            }
                        }
//                        all no
                        else{
                            label++;
                            uf.union(position, label);
                        }
                    }
                }
            }
            int outLabel = uf.find(opPosition);
            System.out.printf(""%d"",outLabel);           
        }
    }
}

@2a335b2714fe6d0c69b2a8c02028ec90@"
"b03611015","0","0","0","@2dd154cdd54927cad62c668621192223@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author Steven
 */
public class LabelCC {
    
    private static int[] id;
    private static int[][] matrix;

    static int N;
    static int a;
    
    
    public LabelCC(int N){
        id = new int[N * N];
        matrix = new int[N][N];

       
        
    }
    public static void blocked(int row, int col){
        matrix[row][col]=0;
      }
    public static void label(int row, int col){
        
        for(int i=0;i<N;i++){
            for(int j=0;j<N;j++){
                if(matrix[i][j]!=0)
                    a=matrix[i][j]+1;
                    
                    
                    
            }
           
                
        }
    }
    
    

    
    public static void main(String[] args) throws IOException {
         /*try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            N = Integer.parseInt(data[0]);
            int targ1 = Integer.parseInt(data[1]);
            int targ2 = Integer.parseInt(data[2]);
            
            int row = 0;
            int col = 0;
            String[] randc = new String[2];
            
            for(int i=0;i<N;i++){
            randc = br.readLine().split("","");
            row = Integer.parseInt(randc[0]);
            col = Integer.parseInt(randc[1]);
            blocked(row,col);
            }
    }
    System.out.print(0);
}
  */
          System.out.print(0);
    }
}

@2dd154cdd54927cad62c668621192223@"
"r03849033","9","1.01","126976","@17986b37c904f17d3fded59950fe68bd@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        int l=label[i];
        int z=0;
        int t=3;
        int[] s = new int[t];
        while(l==0){
            if(z==t){
                t=t*2;
                int[] s1=new int[t];
                for(int j = 0; j < z ; j++){
                    s1[j]=s[j];
                }      
                s=s1;
            }
            s[z]=i;            
            i=root[i];
            l=label[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i;       }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(r==0){
                            if(c>0 && matrix[r][c-1]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }
                        //
                        else if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if( matrix[r][c-1]==false && matrix[r-1][c]==false){

                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                        }
                        //
                        else{
                            if(matrix[r][c-1]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));} 
                            else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                            else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
            }                  
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@17986b37c904f17d3fded59950fe68bd@"
"r03849033","9","1.01","123344","@aee1666b6f3febc0cde95c7d2197576e@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        int l=label[i];
        int z=0;
        int t=3;
        int[] s = new int[t];
        while(l==0){
            if(z==t){
                t=t*2;
                int[] s1=new int[t];
                for(int j = 0; j < z ; j++){
                    s1[j]=s[j];
                }      
                s=s1;
            }
            s[z]=i;            
            i=root[i];
            l=label[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i;       }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@aee1666b6f3febc0cde95c7d2197576e@"
"r03631015","0","0","0","@fbcd21bdc15276516dfa732105537b00@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            }
            
            int position = 0;
            int k=0;
            int pre=0;
            int aft=0;
            int[] r_matrix = new int[size];
            for(int i = 1; i<= size; i++){
                for(int j=1; j<=size; j++){
                    position = j + (i-1)*10;
                    if(checkmatrix[i][j]==true){
                        r_matrix[position-1]=0;
                    }
                    else{
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            k++;
                            r_matrix[position]=k;
                        }
                        //left
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            r_matrix[position-1]=r_matrix[position-2];
                        }
                        //up
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            r_matrix[position-1]=r_matrix[position-1-size];
                        }
                        else{
                            if(r_matrix[position-2]<r_matrix[position-1-size]){
                                r_matrix[position-1]=r_matrix[position-2];
                                pre=r_matrix[position-1-size];
                                aft=r_matrix[position-2];
                                for(int m=0;m<position;m++){
                                    if(r_matrix[m]==pre){
                                        r_matrix[m]=aft;
                                    }
                                }
                            }
                            else if(r_matrix[position-2]>r_matrix[position-1-size]){
                                r_matrix[position-1]=r_matrix[position-1-size];
                                pre=r_matrix[position-2];
                                aft=r_matrix[position-1-size];
                                for(int m=0;m<position;m++){
                                    if(r_matrix[m]==pre){
                                        r_matrix[m]=aft;
                                    }
                                }
                            }
                            else if(r_matrix[position-2]==r_matrix[position-1-size]){
                                r_matrix[position-1]=r_matrix[position-2];

                            }
                        }
                    }
                }
            }
            
//            int NumOfgroup = (size*size+1)/2;
//            int NumOfmatrix = size * size;
//            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
//            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
//            int groupid = 0;
//
//            for(int i = 1; i <= size ; i++){
//                for(int j = 1 ; j <= size ; j++){
//                    if(checkmatrix[i][j]==true){
//                        continue;
//                    }
//                    if(checkmatrix[i][j]==false){
//                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
//                            groupid++;
//                            int matrixnum = ( i-1 )*size + j;
//                            uf.union(NumOfgroup + matrixnum, groupid);
//                        }
//                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
//                            int matrixnum = ( i-1 )*size + j;
//                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
//                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
//                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
//                            }
//                            else{
//                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
//                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
//                            }
//                        }
//                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
//                            int matrixnum = ( i-1 )*size + j;
//                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
//                        }
//                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
//                            int matrixnum = ( i-1 )*size + j;
//                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
//                        }
//                    }
//                }
//            }
            System.out.printf(""%d"",r_matrix[goal]);

         
        }
    }
}

@fbcd21bdc15276516dfa732105537b00@"
"r03849033","0","0","0","@ea8a5ff6c4904315945a868aa1e30eab@

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        int z=0;
        int[] s = new int[5];
        while(label[i]==0){
            s[z]=i;            
            i=root[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i;       }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@ea8a5ff6c4904315945a868aa1e30eab@"
"r03849033","9","1.01","126208","@698579c14df9cc53304f3a34209b8191@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        int z=0;
        int[] s = new int[5];
        while(label[i]==0){
            s[z]=i;            
            i=root[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i;       }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@698579c14df9cc53304f3a34209b8191@"
"r03849033","9","0.98","123280","@6b9fea3ba6222ee5101438024a69398f@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        int z=0;
        int[] s = new int[3];
        while(label[i]==0){
            s[z]=i;            
            i=root[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i;       }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@6b9fea3ba6222ee5101438024a69398f@"
"r03849033","8","0.77","129648","@95eab5f77e48ed44815884d26fad1998@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        int z=0;
        int[] s = new int[2];
        while(label[i]==0){
            s[z]=i;            
            i=root[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i;       }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@95eab5f77e48ed44815884d26fad1998@"
"r03631015","0","0","0","@218d8a11171316c8ce1216e25df548e7@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author huangchienpeng
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
        public static void main(String[] args) throws Exception {
        // read file from args[0] in Java 7 style
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // read a line and split by ','
            String[] info = br.readLine().split("","");
            // store the matrix size
            int size = Integer.parseInt(info[0]);
            //System.out.printf(""%d\n"",NumOfmatrix);
            //store the goal site
            int goal = (Integer.parseInt(info[1])-1)*size+Integer.parseInt(info[2]);
            
            //build checkmatrix which is bigger than old matrix and cover it
            //let black block be true and white block be false
            boolean[][] checkmatrix = new boolean[size+2][size+2];
            for (int i = 0; i <= size+1; i++) {
                for (int j = 0; j <= size+1; j++) {
                    checkmatrix[i][j] = true;
                }
            }
            //the real n*n matrix is surrounded by black blocks
            for(int i = 1;i <= size; i++){
                for(int j = 1; j <= size; j++){
                    checkmatrix[i][j] = false;
                }
            }
            //create announced checkmatrix
            String [] announce = new String[2];
            int row = 0;
            int column = 0;
          
            while(br.ready()) {
                    announce = br.readLine().split("","");
                    row = Integer.parseInt(announce[0]);
                    column = Integer.parseInt(announce[1]);
                    //mark the announced site
                    checkmatrix[row][column] = true;
            }
            
            int position = 0;
            int k=0;
            int pre=0;
            int aft=0;
            int[] r_matrix = new int[size];
            for(int i = 1; i<= size; i++){
                for(int j=1; j<=size; j++){
                    position = j + (i-1)*10;
                    if(checkmatrix[i][j]==true){
                        r_matrix[position-1]=0;
                    }
                    else{
                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
                            k++;
                            r_matrix[position]=k;
                        }
                        //left
                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
                            r_matrix[position-1]=r_matrix[position-2];
                        }
                        //up
                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
                            r_matrix[position-1]=r_matrix[position-1-size];
                        }
                        else{
                            if(r_matrix[position-2]<r_matrix[position-1-size]){
                                r_matrix[position-1]=r_matrix[position-2];
                                pre=r_matrix[position-1-size];
                                aft=r_matrix[position-2];
                                for(int m=0;m<position;m++){
                                    if(r_matrix[m]==pre){
                                        r_matrix[m]=aft;
                                    }
                                }
                            }
                            else if(r_matrix[position-2]>r_matrix[position-1-size]){
                                r_matrix[position-1]=r_matrix[position-1-size];
                                pre=r_matrix[position-2];
                                aft=r_matrix[position-1-size];
                                for(int m=0;m<position;m++){
                                    if(r_matrix[m]==pre){
                                        r_matrix[m]=aft;
                                    }
                                }
                            }
                            else if(r_matrix[position-2]==r_matrix[position-1-size]){
                                r_matrix[position-1]=r_matrix[position-2];

                            }
                        }
                    }
                }
            }
            
//            int NumOfgroup = (size*size+1)/2;
//            int NumOfmatrix = size * size;
//            int NumOfuf = NumOfgroup + NumOfmatrix + 1;
//            QuickUnionUF uf = new QuickUnionUF(NumOfuf);
//            int groupid = 0;
//
//            for(int i = 1; i <= size ; i++){
//                for(int j = 1 ; j <= size ; j++){
//                    if(checkmatrix[i][j]==true){
//                        continue;
//                    }
//                    if(checkmatrix[i][j]==false){
//                        if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==true){
//                            groupid++;
//                            int matrixnum = ( i-1 )*size + j;
//                            uf.union(NumOfgroup + matrixnum, groupid);
//                        }
//                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==false){
//                            int matrixnum = ( i-1 )*size + j;
//                            if(uf.find(NumOfgroup + matrixnum-1)>=uf.find(NumOfgroup + matrixnum-size)){
//                                uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
//                                uf.union(NumOfgroup + matrixnum - 1,NumOfgroup + matrixnum - size);
//                            }
//                            else{
//                                uf.union(NumOfgroup + matrixnum - size,NumOfgroup + matrixnum);
//                                uf.union(NumOfgroup +matrixnum,NumOfgroup + matrixnum - 1);
//                            }
//                        }
//                        else if(checkmatrix[i][j-1]==true&&checkmatrix[i-1][j]==false){
//                            int matrixnum = ( i-1 )*size + j;
//                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - size);
//                        }
//                        else if(checkmatrix[i][j-1]==false&&checkmatrix[i-1][j]==true){
//                            int matrixnum = ( i-1 )*size + j;
//                            uf.union(NumOfgroup + matrixnum, NumOfgroup + matrixnum - 1);
//                        }
//                    }
//                }
//            }
            System.out.printf(""%d"",r_matrix[goal]);

         
        }
    }
}

@218d8a11171316c8ce1216e25df548e7@"
"r03849033","8","0.76","124528","@c97f9c32fb59173307b6b2a6400a9b09@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        int z=0;
        int t=2;
        int[] s = new int[t];
        while(label[i]==0){
            if(z==t){
               int[] s1 = new int[t++]; 
               for(int j = 0; j < z ; j++)s1[j]=s[j];
               s=s1;
            }
            s[z]=i;            
            i=root[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i;       }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@c97f9c32fb59173307b6b2a6400a9b09@"
"r03849033","9","1","127264","@6b9fea3ba6222ee5101438024a69398f@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        int z=0;
        int[] s = new int[3];
        while(label[i]==0){
            s[z]=i;            
            i=root[i];
            z++;
        }
        for(int j = 0; j < z ; j++){    root[s[j]]=i;       }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@6b9fea3ba6222ee5101438024a69398f@"
"r03849033","9","1","127216","@b5a7889115591395a273b4f09f8d5395@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {

        while(label[i]==0){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@b5a7889115591395a273b4f09f8d5395@"
"r03849033","9","1.01","125280","@c2f739ae6e646513371a74e7d47b781b@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {

        while(label[i]==0){    
            root[i]=root[root[root[i]]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@c2f739ae6e646513371a74e7d47b781b@"
"r03849033","9","0.99","128464","@02c7e11cbe6fb013544e2b0fbc64df2c@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {

        while(label[i]==0){    
            root[i]=root[root[root[root[root[root[i]]]]]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@02c7e11cbe6fb013544e2b0fbc64df2c@"
"r03849033","9","0.99","128064","@ec173f52487dbf003807f98ac1ca5e93@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {

        while(label[i]==0){    
            root[i]=root[root[root[root[root[root[root[root[root[root[root[root[i]]]]]]]]]]]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@ec173f52487dbf003807f98ac1ca5e93@"
"r03849033","9","0.99","127504","@62b66211e04960216436737283751e9e@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {

        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++) root[i]=i;
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@62b66211e04960216436737283751e9e@"
"r03222054","0","0","0","@f6481d05f75121f026f62129d5217197@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
import edu.princeton.cs.algs4.QuickUnionUF;
import edu.princeton.cs.algs4.StdIn;

public  class Label 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
    
    
    public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
             

            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);
             
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
                 
             
             int [][] table = new int [size][size];
             //System.out.print(size);
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                //  System.out.print(xCor +""\t"" + yCor +""\n"");
                  check[xCor][yCor] =false;
             }
             
         
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                     
                     if(check[i][j])
                     {
                     
                     
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             
                           
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                             
                         }
                                 
                     }
                         
                     }
                 }
                             
                 }
             // System.out.print(x+""\t""+y+""\n"");
              int label = table[x-1][y-1];
             //int answer = root.get(label);
              System.out.print(label);
             
             }
        
   
         }
     }
                          


@f6481d05f75121f026f62129d5217197@"
"r03222054","0","0.99","128064","@b2efdbace70e2a5e8209cc80599d2b0b@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.QuickUnionUF;
//import edu.princeton.cs.algs4.StdIn;

public  class Label 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
    
    
    public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
             

            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);
             
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
                 
             
             int [][] table = new int [size][size];
             //System.out.print(size);
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                //  System.out.print(xCor +""\t"" + yCor +""\n"");
                  check[xCor][yCor] =false;
             }
             
         
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                     
                     if(check[i][j])
                     {
                     
                     
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             
                           
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                             
                         }
                                 
                     }
                         
                     }
                 }
                             
                 }
             // System.out.print(x+""\t""+y+""\n"");
              int label = table[x-1][y-1];
             //int answer = root.get(label);
              System.out.print(label);
             
             }
        
   
         }
     }
                          


@b2efdbace70e2a5e8209cc80599d2b0b@"
"r03222054","0","0","0","@b2efdbace70e2a5e8209cc80599d2b0b@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
//import edu.princeton.cs.algs4.QuickUnionUF;
//import edu.princeton.cs.algs4.StdIn;

public  class Label 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
    
    
    public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
             

            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);
             
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
                 
             
             int [][] table = new int [size][size];
             //System.out.print(size);
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                //  System.out.print(xCor +""\t"" + yCor +""\n"");
                  check[xCor][yCor] =false;
             }
             
         
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                     
                     if(check[i][j])
                     {
                     
                     
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             
                           
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                             
                         }
                                 
                     }
                         
                     }
                 }
                             
                 }
             // System.out.print(x+""\t""+y+""\n"");
              int label = table[x-1][y-1];
             //int answer = root.get(label);
              System.out.print(label);
             
             }
        
   
         }
     }
                          


@b2efdbace70e2a5e8209cc80599d2b0b@"
"r03222054","0","0","0","@cdef527baee940cd3b8ca02d244890ce@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;

public  class Label 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();

    public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);
             
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }

             int [][] table = new int [size][size];
             //System.out.print(size);
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                //  System.out.print(xCor +""\t"" + yCor +""\n"");
                  check[xCor][yCor] =false;
             }

             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                     
                     if(check[i][j])
                     {
                     
                     
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             
                           
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                             
                         }
                                 
                     }
                         
                     }
                 }
                             
                 }
             // System.out.print(x+""\t""+y+""\n"");
              int label = table[x-1][y-1];
             //int answer = root.get(label);
              System.out.print(label);
             
             }
        
   
         }
     }
                          


@cdef527baee940cd3b8ca02d244890ce@"
"r03222054","0","0.99","128064","@c9bcdca92f0c270efd0f221602095954@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;

public class Label 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();

    public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);
             
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }

             int [][] table = new int [size][size];
             //System.out.print(size);
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                //  System.out.print(xCor +""\t"" + yCor +""\n"");
                  check[xCor][yCor] =false;
             }

             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                     
                     if(check[i][j])
                     {
                     
                     
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             
                           
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                             
                         }
                                 
                     }
                         
                     }
                 }
                             
                 }
             // System.out.print(x+""\t""+y+""\n"");
              int label = table[x-1][y-1];
             //int answer = root.get(label);
              System.out.print(label);
             
             }
        
   
         }
     }
                          

@c9bcdca92f0c270efd0f221602095954@"
"r03525006","2","0.54","105184","@701e03b94c341a0207ca34b41e1ed666@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j-1];
                                if (leftId != -1) {
                                    id[i][j] = id[i][j - 1];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    } else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = leftId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }
                            }
                        }
                    }
                }
            }

//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(id[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }

//            for (int i = 0; i < idChange.size(); i++)
//                System.out.println(idChange.get(i));

            int[] parents = new int[num];
            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + """");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
            if (targetId != -1) {
                if (targetId != parents[targetId-1]) {
                    System.out.println(parents[targetId - 1]);
                } else {
                    System.out.println(targetId);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@701e03b94c341a0207ca34b41e1ed666@"
"r03222054","8","0.96","120560","@3bebc408ac68079b7e035f45d686a14d@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();

    public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);
             
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }

             int [][] table = new int [size][size];
             //System.out.print(size);
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                //  System.out.print(xCor +""\t"" + yCor +""\n"");
                  check[xCor][yCor] =false;
             }

             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                     
                     if(check[i][j])
                     {
                     
                     
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             
                           
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                             
                         }
                                 
                     }
                         
                     }
                 }
                             
                 }
             // System.out.print(x+""\t""+y+""\n"");
              int label = table[x-1][y-1];
             //int answer = root.get(label);
              System.out.print(label);
             
             }
        
   
         }
     }
                          

@3bebc408ac68079b7e035f45d686a14d@"
"r03222054","8","0.99","124464","@3bebc408ac68079b7e035f45d686a14d@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();

    public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);
             
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }

             int [][] table = new int [size][size];
             //System.out.print(size);
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                //  System.out.print(xCor +""\t"" + yCor +""\n"");
                  check[xCor][yCor] =false;
             }

             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                     
                     if(check[i][j])
                     {
                     
                     
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             
                           
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                             
                         }
                                 
                     }
                         
                     }
                 }
                             
                 }
             // System.out.print(x+""\t""+y+""\n"");
              int label = table[x-1][y-1];
             //int answer = root.get(label);
              System.out.print(label);
             
             }
        
   
         }
     }
                          

@3bebc408ac68079b7e035f45d686a14d@"
"r03222054","9","0.98","126432","@126b5facdbd1ea267b8d7e28797e38a5@
import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();

    public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);
             
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }

             int [][] table = new int [size][size];
             //System.out.print(size);
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                //  System.out.print(xCor +""\t"" + yCor +""\n"");
                  check[xCor][yCor] =false;
             }

             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                     
                     if(check[i][j])
                     {
                     
                     
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             
                           
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                             
                         }
                                 
                     }
                         
                     }
                 }
                             
                 }
             // System.out.print(x+""\t""+y+""\n"");
              int label = table[x-1][y-1];
             int answer = root.get(label);
              System.out.print(answer);
             
             }
        
   
         }
     }
                          

@126b5facdbd1ea267b8d7e28797e38a5@"
"r03723070","9","1.09","129888","@e334e0cdc36b62836aa8eaa09bce333a@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       //if(data[1][1]==-1)
           //count = 2;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       connect[count] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               int op =Math.max(connect[p],connect[q]);
                               int oq =Math.min(connect[p],connect[q]);
                               connect[q] = oq;
                               connect[p] = oq;
                               for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }
                                    //for(int k =0;k<N*N/2+1;k++){
                                        //if(connect[k] == op)
                                            //connect[k]= oq;
                                    //}
                               }
                               /*else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                  // connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }*/
                                   
                               //connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root left
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }
       
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    



@e334e0cdc36b62836aa8eaa09bce333a@"
"r03525006","2","1.01","129104","@992a050d4d22d2e49cb411e2c49d8ee3@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j-1];
                                if (leftId != -1) {
                                    id[i][j] = id[i][j - 1];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    } else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;

                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = leftId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }
                            }
                        }
                    }
                }
            }

//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(id[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }

//            for (int i = 0; i < idChange.size(); i++)
//                System.out.println(idChange.get(i));

            int[] parents = new int[idLabel-1];
            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + """");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
            if (targetId != -1) {
                if (targetId != parents[targetId-1]) {
                    System.out.println(parents[targetId - 1]);
                } else {
                    System.out.println(targetId);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@992a050d4d22d2e49cb411e2c49d8ee3@"
"r03525006","0","1.07","152224","@b77b447ef3c426aa77a7a2197dec103e@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j-1];
                                if (leftId != -1) {
                                    id[i][j] = id[i][j - 1];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    } else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
//                                    idLabel++;

                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = leftId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }
                            }
                        }
                    }
                }
            }

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    System.out.print(id[i][j] + "" "");
                }
                System.out.println("" "");
            }

            for (int i = 0; i < idChange.size(); i++)
                System.out.println(idChange.get(i));

            int[] parents = new int[idLabel-1];
            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + """");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
            if (targetId != -1) {
                if (targetId != parents[targetId-1]) {
                    System.out.println(parents[targetId - 1]);
                } else {
                    System.out.println(targetId);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@b77b447ef3c426aa77a7a2197dec103e@"
"r04525016","9","1.01","121072","@393bfd961747b0157e7e2cb42256250e@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by PG on 2016/3/16.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];
//            parents[0][0] = 1;
//            parents[1][0] = 1;
            int labelCount = 0;
            int parentsCount = 0;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0 && j == 0) {
                        if (label[i][j] == 0) {
                            labelCount++;
                        } else {
                            label[i][j] = ++labelCount;
                        }
                    } else if (i == 0) {
                        if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
                        }
                    } else if (j == 0) {
                        if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
                        }
                    } else {
                        int left = label[i][j - 1];
                        int top = label[i - 1][j];
                        if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
                        }
                    }
                }
            }


            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


//            //印出label
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(label[i][j] + ""\t"");
//                }
//                System.out.println("" "");
//            }
//
//            System.out.println(parentsCount);
//
//            //印出parents
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[0][i] + ""\t"");
//            }
//            System.out.println("" "");
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[1][i] + ""\t"");
//            }
            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
        boolean okRoot = false;
        while (!okRoot) {
            for (int i = 0; i < index2; i++) {
                if (index1 == parents[0][i]) {
                    index1 = parents[1][i];
                    break;
                }
            }
            okRoot = true;
        }
        return index1;
    }

}


@393bfd961747b0157e7e2cb42256250e@"
"r02b48003","0","0","0","@b756c7de616658f71d05be59f20a5c64@
import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class LabelCC {
    private final int dim;
    private Board_ID    board_id;
    private Board_Label board_label;
    private Board_Open  board_open;
    private UF uf;
    //private QuickFind uf;
    
    public LabelCC (int n) {
        dim = n;
        board_id = new Board_ID(n);
        board_label = new Board_Label(n);
        board_open = new Board_Open(n);
        uf = new UF(n*n);
        //uf = new QuickFind(n*n); // it turns out that for this problem quickUnion (even with path compression) is much more slower than QuickFind 
    } // end constructor
    
    public int getLabel(int row, int col) {
        return board_label.getLabel(row, col);
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {
        board_label.setLabel(row, col, value);
    } // end func setLabel
    
    public void setLabelfromRoot(int row, int col, int rootId) {
        int rootRow = rootId / dim + 1;
        int rootCol = rootId % dim + 1;
        //System.out.println(row + "" "" + col + "" "" +getLabel(row, col) + "" "" + rootId + "" "" + rootRow + "" "" + rootCol);
        setLabel(row, col,
                 board_label.getLabel(rootRow, rootCol));
    } // end func setLabelfromRoot
    
    public void setBlock(int row, int col) {
        board_open.setBlock(row, col);
    } // end func setBlock 
    
    public boolean isBlock(int row, int col) {
        return board_open.isBlock(row, col);
    } // end func isOpen
    
    public boolean isOpen(int row, int col) {
        return board_open.isOpen(row, col);
    } // end func isOpen
    
    public String checkCase(Boolean isOpenUp, Boolean isOpenLf) {
        // case 1: up left neighbors not open or not exist
        // case 2: only up neighbor open and exist
        // case 3: only left neighbor open and exist
        // case 4: up left neighbors exist and open
        String whichCase = """";
        
        if (isOpenUp == null && isOpenLf == null) {whichCase = ""1"";}
        
        if (isOpenUp != null && isOpenLf == null) {
            if (isOpenUp){whichCase = ""2"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp == null && isOpenLf != null) {
            if (isOpenLf){whichCase = ""3"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp != null && isOpenLf != null) {
            if (isOpenUp == true  && isOpenLf == true)  {whichCase = ""4"";}
            if (isOpenUp == true  && isOpenLf == false) {whichCase = ""2"";}
            if (isOpenUp == false && isOpenLf == true)  {whichCase = ""3"";}
            if (isOpenUp == false && isOpenLf == false) {whichCase = ""1"";}
        } // end if
        return whichCase;
    } // end func checkCase
    
    public void passFirst() {
        int label = 1;
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                Integer labelUp  = board_label.getNeighbor(row, col, ""UP"");
                Integer labelLf  = board_label.getNeighbor(row, col, ""LEFT"");
                Integer id       = board_id.getId(row, col);
                Integer idUp     = board_id.getNeighbor(row, col, ""UP"");
                Integer idLf     = board_id.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                
                switch (gridCase) {
                    case ""1"": 
                        //System.out.print(""1 "");
                        setLabel(row, col, label++);
                        break;
                    case ""2"": 
                        //System.out.print(""2 "");
                        uf.union(idUp, id);
                        setLabel(row, col, labelUp);
                        break;
                    case ""3"": 
                        //System.out.print(""3 "");
                        uf.union(idLf, id);
                        setLabel(row, col, labelLf);
                        break;
                    case ""4"": 
                        //System.out.print(""4 "");
                        if (labelUp <= labelLf) {
                            uf.union(idUp, idLf);
                            uf.union(idUp, id);
                            setLabel(row, col, labelUp);
                        } else {
                            uf.union(idLf, idUp);
                            uf.union(idLf, id);
                            setLabel(row, col, labelLf);
                        } // end if-else
                        break;
                    default: 
                        System.out.println(
                            ""Error: LabelCC omit the case: "" + 
                            ""("" + row + "", "" + col + "")"");
                } // end switch
            } // end inner loop
        } // end outer loop
    } // end func passFirst
    
    public void passSecond() {
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                int id = board_id.getId(row, col);
                int root = uf.root(id);
                //int root = uf.find(id);
                setLabelfromRoot(row, col, root);
            } // end inner loop
        } // end outer loop
    } // end func passSecond
    
    public void displayOpen(){ 
        System.out.println(""---Display: Open---------"");
        board_open.display();  }
    public void displayLabel() { 
        System.out.println(""---Display: Label--------"");
        board_label.display(); }
    public void displayID() { 
        System.out.println(""---Display: ID-----------"");
        board_id.display();    }
    /*
    public void displayRoot()  {
        System.out.println(""---Display: Root---------"");
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.print(uf.root(board_id.getId(row, col)) + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayRoot
    //*/
    public void displayCase()  {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {            
                // check if the grid is open
                if (isBlock(row, col)) {
                    System.out.print(""X "");
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                System.out.print(gridCase + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayCase
    public void displayUF() {uf.display();}
    public void displayUFRecord() {
        int numSum = 0;
        System.out.println(""\nRecordRoot:"");
        for(int i: uf.recordRoot){
            System.out.print(i + "" "");
            numSum += i;
        } // end loop
        System.out.println();
        System.out.println(""Size: "" + uf.recordRoot.size());
        System.out.println(""Sum:  "" + numSum);
        System.out.println();
        
        numSum = 0;
        System.out.println(""RecordUnion:"");
        for(int i: uf.recordUnion){
            System.out.print(i + "" "");
            numSum += i;
        } // end loop
        System.out.println();
        System.out.println(""Size: "" + uf.recordRoot.size());
        System.out.println(""Sum:  "" + numSum);
        System.out.println();
        
    } // end func displayUFRecord
    
    public static void main(String[] args) {
        // testing classes
        //Board.main(args);
        //Board_Open.main(args);
        //Board_Label.main(args);
        //Board_ID.main(args);
        //UF.main(args);
        
        // read in the content of a file
        String[] readLines = In.readStrings(args[0]);
        
        // initialization
        String[] line0 = readLines[0].split("","");
        int N         = Integer.valueOf(line0[0]); // prepare for N-by-N grid
        int targetRow = Integer.valueOf(line0[1]); // row of target site: (row, col)
        int targetCol = Integer.valueOf(line0[2]); // col of target site: (row, col)
        LabelCC labelcc = new LabelCC(N);
        
        // iterate through the file
        for (String s: Arrays.copyOfRange(readLines, 1, readLines.length)){
            String[] line = s.split("","");
            //System.out.println(s);
            labelcc.setBlock(Integer.valueOf(line[0]), Integer.valueOf(line[1]));
	} // end loop for
        
        if (labelcc.isBlock(targetRow, targetCol)) {
            System.out.print(0);
            return;
        } // end if
        
        labelcc.passFirst();
        //labelcc.displayLabel();
        
        labelcc.passSecond();
        System.out.print(labelcc.getLabel(targetRow, targetCol));
        //System.out.println(""-------------------------"");
        //labelcc.displayID();
        //labelcc.displayOpen();
        //labelcc.displayCase();
        //labelcc.displayLabel();
        //labelcc.displayUF();
        //labelcc.displayRoot();
        //labelcc.displayUFRecord();
    } // end main
} // end class LabelCC

class UF {
    private int[] id;
    // this is for monitoring the number of function call and loop
    public Queue<Integer> recordRoot  = new Queue<Integer>();
    public Queue<Integer> recordUnion = new Queue<Integer>();
    
    public UF(int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) id[i] = i;
    } // end contructor
    
    public boolean connected(int p, int q) { 
        return root(p) == root(q); 
    } // end func connected
    
    public int root(int i) {
        int recordLoop = 0;
        
        // Follow links to find a root
        while (i != id[i]) {
            recordLoop++;
            id[i] = id[id[i]]; // path compression
            i = id[i];         // search upper node
        } // end while
        
        recordRoot.enqueue(recordLoop);
        recordUnion.enqueue(0);
        
        return i; 
    } // end func root
    
    public void union(int p, int q) {
        recordUnion.enqueue(1);
        
        // Parent: p ; Child: q
        int i = root(p);     // component of p
        int j = root(q);     // component of q
        if (i == j) return;  // if same root, same component
        id[j] = i;           // link component q under component p
                             // Parent: i
                             // Child:  j
    } // end func union
    public void display(){
        System.out.println(Arrays.toString(id));
    } // end func display
} // end class UF

class QuickFind {
    private int[] id;
    public Queue<Integer> recordRoot  = new Queue<Integer>();
    public Queue<Integer> recordUnion = new Queue<Integer>();
    
    public QuickFind(int N){
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }// end constructor
    
    public boolean connected(int p, int q)
    { return root(p) == root(q); }
    
    public int root(int p) {
        recordRoot.enqueue(1);
        return id[p]; 
    }
    
    public void union(int p , int q) {
        int pID = root(p);
        int qID = root(q);
        
        if (pID == qID) return;
        
        for (int i = 0; i < id.length; i++) {
            if (id[i] == qID) id[i] = pID;
        }
        recordUnion.enqueue(id.length);
    } // end func union
    
    public void display(){
        System.out.println(Arrays.toString(id));
    } // end func display
    
} // end class Quickfind

class Board_ID {
    private final int dim;
    private final Board<Integer> board;
    
    public Board_ID (int n) {
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    } // end constructor
    
    public void setId(int row, int col, int value){
        board.setGrid(row-1, col-1, value);
    } // end func setId
    
    public Integer getId(int row, int col){
        return board.getGrid(row-1, col-1);
    } // end func getId
    
    public Integer getNeighbor(int row, int col, String direction){
        return board.getNeighbor(row-1, col-1, direction);
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_ID anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_ID copy() {
        Board_ID board_copy = new Board_ID(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setId(row, col, getId(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, row * dim + col);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_ID

class Board_Label {
    private final int dim;
    private Board<Integer> board;
    
    public Board_Label(int n){
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    }  // end constructor
    
    public Integer getLabel(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getGrid(row-1, col-1);
        //} // end if
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {   
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, value);
        //} // end if
    } // end func setLabel 
    
    public Boolean isLabel(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            if (board.getGrid(row-1, col-1) == -1) { return false; } 
            else                                   { return true; }
        } // end if-else
        //System.out.println(""Error: \n\tClass Board_Label \n\tfunction isLabel \n\tMessage: Out of Boundary"");
        return null;
    } // end func isLabel
    
    public Integer getNeighbor(int row, int col, String direction) {
        return board.getNeighbor(row-1, col-1, direction);
    } // end func Integer
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Label anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Label copy() {
        Board_Label board_copy = new Board_Label(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setLabel(row, col, getLabel(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset(){
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, -1);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_Label

class Board_Open {
    private final int dim;
    private Board<Boolean> board;
    
    public Board_Open(int n){
        board = new Board<Boolean>(n);
        dim = n;
        reset();    
    }  // end constructor
    
    public void setOpen(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, true);
        //} // end if
    } // end func setOpen
    
    public void setBlock(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, false);
        //} // end if
    } // end func setBlock
    
    public Boolean isOpen(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == true;    
        }
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isOpen \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean isBlock(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == false;
        } // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isBlock \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean getNeighbor(int row, int col, String direction) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getNeighbor(row-1, col-1, direction);
        //} // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction getNeighbor \n\tMessage: Out of Boundary"");
        //return null;
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Open anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Open copy() {
        Board_Open board_copy = new Board_Open(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) { board_copy.setOpen(row, col);  } 
                else                  { board_copy.setBlock(row, col); }
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        // default: all open
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, true);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) {System.out.print(""1 "");}
                else                  {System.out.print(""0 "");}
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board_Open

class Board<Item> {
    private final int dim;
    private Item[] board;
    
    public Board(int n) {
        dim = n;
        board = (Item[]) new Object[n*n];
    } // end constructor
    
    public int getDim(){ return dim; }
    
    public Item getGrid(int row, int col){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            return board[row * dim + col];
        } // end if
        return null;
    } // end func getGrid
    
    public void setGrid(int row, int col, Item value){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            board[row * dim + col] = value;
        } // end if
    } // end func setGrid
    
    public Item getNeighbor(int row, int col, String direction) {
        if (!(row >= 0 && col >= 0 && row < dim && col < dim)) {
            return null;
        } // end if
        
        if (direction.equals(""UP"")) {
            if (row > 0) { return getGrid(row-1, col); }
        } // end if
        
        if (direction.equals(""DOWN"")) {
            if (row < (dim - 1)) { return getGrid(row+1, col); }
        } // end if
        
        if (direction.equals(""LEFT"")) {
            if (col > 0) { return getGrid(row, col-1); }
        } // end if
        
        if (direction.equals(""RIGHT"")) {
            if (col < (dim - 1)) { return getGrid(row, col+1); }
        } // end if
        
        return null;
    } // end func getNeighbor
    
    public boolean compare(Board<Item> anotherBoard) { 
        if (anotherBoard.getDim() != dim) {
            return false;
        } // end if
        
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                if (getGrid(row, col) != anotherBoard.getGrid(row, col)) {
                    return false;
                } // end if
            } // end inner loop
        } // end outer loop
        
        return true;
    } // end func compare
    
    public Board copy(){
        Board<Item> board_copy = new Board(dim);
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board_copy.setGrid(row, col, getGrid(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                System.out.print(board[row * dim + col] + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board
@b756c7de616658f71d05be59f20a5c64@"
"r02b48003","10","0.139","157344","@85a40d9014bbc12acee43196898a3c8a@import java.util.Arrays;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author clint
 */
public class LabelCC {
    private final int dim;
    private Board_ID    board_id;
    private Board_Label board_label;
    private Board_Open  board_open;
    private QuicUnion uf;
    //private QuickFind uf;
    
    public LabelCC (int n) {
        dim = n;
        board_id = new Board_ID(n);
        board_label = new Board_Label(n);
        board_open = new Board_Open(n);
        uf = new QuicUnion(n*n);
        //uf = new QuickFind(n*n); // it turns out that for this problem quickUnion (even with path compression) is much more slower than QuickFind 
    } // end constructor
    
    public int getLabel(int row, int col) {
        return board_label.getLabel(row, col);
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {
        board_label.setLabel(row, col, value);
    } // end func setLabel
    
    public void setLabelfromRoot(int row, int col, int rootId) {
        int rootRow = rootId / dim + 1;
        int rootCol = rootId % dim + 1;
        //System.out.println(row + "" "" + col + "" "" +getLabel(row, col) + "" "" + rootId + "" "" + rootRow + "" "" + rootCol);
        setLabel(row, col,
                 board_label.getLabel(rootRow, rootCol));
    } // end func setLabelfromRoot
    
    public void setBlock(int row, int col) {
        board_open.setBlock(row, col);
    } // end func setBlock 
    
    public boolean isBlock(int row, int col) {
        return board_open.isBlock(row, col);
    } // end func isOpen
    
    public boolean isOpen(int row, int col) {
        return board_open.isOpen(row, col);
    } // end func isOpen
    
    public String checkCase(Boolean isOpenUp, Boolean isOpenLf) {
        // case 1: up left neighbors not open or not exist
        // case 2: only up neighbor open and exist
        // case 3: only left neighbor open and exist
        // case 4: up left neighbors exist and open
        String whichCase = """";
        
        if (isOpenUp == null && isOpenLf == null) {whichCase = ""1"";}
        
        if (isOpenUp != null && isOpenLf == null) {
            if (isOpenUp){whichCase = ""2"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp == null && isOpenLf != null) {
            if (isOpenLf){whichCase = ""3"";}
            else         {whichCase = ""1"";}
        } // end if
        
        if (isOpenUp != null && isOpenLf != null) {
            if (isOpenUp == true  && isOpenLf == true)  {whichCase = ""4"";}
            if (isOpenUp == true  && isOpenLf == false) {whichCase = ""2"";}
            if (isOpenUp == false && isOpenLf == true)  {whichCase = ""3"";}
            if (isOpenUp == false && isOpenLf == false) {whichCase = ""1"";}
        } // end if
        return whichCase;
    } // end func checkCase
    
    public void passFirst() {
        int label = 1;
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                Integer labelUp  = board_label.getNeighbor(row, col, ""UP"");
                Integer labelLf  = board_label.getNeighbor(row, col, ""LEFT"");
                Integer id       = board_id.getId(row, col);
                Integer idUp     = board_id.getNeighbor(row, col, ""UP"");
                Integer idLf     = board_id.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                
                switch (gridCase) {
                    case ""1"": 
                        //System.out.print(""1 "");
                        setLabel(row, col, label++);
                        break;
                    case ""2"": 
                        //System.out.print(""2 "");
                        uf.union(idUp, id);
                        setLabel(row, col, labelUp);
                        break;
                    case ""3"": 
                        //System.out.print(""3 "");
                        uf.union(idLf, id);
                        setLabel(row, col, labelLf);
                        break;
                    case ""4"": 
                        //System.out.print(""4 "");
                        if (labelUp <= labelLf) {
                            uf.union(idUp, idLf);
                            uf.union(idUp, id);
                            setLabel(row, col, labelUp);
                        } else {
                            uf.union(idLf, idUp);
                            uf.union(idLf, id);
                            setLabel(row, col, labelLf);
                        } // end if-else
                        break;
                    default: 
                        System.out.println(
                            ""Error: LabelCC omit the case: "" + 
                            ""("" + row + "", "" + col + "")"");
                } // end switch
            } // end inner loop
        } // end outer loop
    } // end func passFirst
    
    public void passSecond() {
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                // check if the grid is open
                if (isBlock(row, col)) {
                    continue;
                } // end if
                int id = board_id.getId(row, col);
                int root = uf.root(id);
                //int root = uf.find(id);
                setLabelfromRoot(row, col, root);
            } // end inner loop
        } // end outer loop
    } // end func passSecond
    
    public void displayOpen(){ 
        System.out.println(""---Display: Open---------"");
        board_open.display();  }
    public void displayLabel() { 
        System.out.println(""---Display: Label--------"");
        board_label.display(); }
    public void displayID() { 
        System.out.println(""---Display: ID-----------"");
        board_id.display();    }
    /*
    public void displayRoot()  {
        System.out.println(""---Display: Root---------"");
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                System.out.print(uf.root(board_id.getId(row, col)) + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayRoot
    //*/
    public void displayCase()  {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {            
                // check if the grid is open
                if (isBlock(row, col)) {
                    System.out.print(""X "");
                    continue;
                } // end if
                
                // if open, check neighbor
                Boolean isOpenUp = board_open.getNeighbor(row, col, ""UP"");
                Boolean isOpenLf = board_open.getNeighbor(row, col, ""LEFT"");
                
                // case 1: up left neighbors not open or not exist
                // case 2: only up neighbor open and exist
                // case 3: only left neighbor open and exist
                // case 4: up left neighbors exist and open        
                String gridCase = checkCase(isOpenUp, isOpenLf);
                System.out.print(gridCase + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func displayCase
    public void displayUF() {uf.display();}
    public void displayUFRecord() {
        int numSum = 0;
        System.out.println(""\nRecordRoot:"");
        for(int i: uf.recordRoot){
            System.out.print(i + "" "");
            numSum += i;
        } // end loop
        System.out.println();
        System.out.println(""Size: "" + uf.recordRoot.size());
        System.out.println(""Sum:  "" + numSum);
        System.out.println();
        
        numSum = 0;
        System.out.println(""RecordUnion:"");
        for(int i: uf.recordUnion){
            System.out.print(i + "" "");
            numSum += i;
        } // end loop
        System.out.println();
        System.out.println(""Size: "" + uf.recordRoot.size());
        System.out.println(""Sum:  "" + numSum);
        System.out.println();
        
    } // end func displayUFRecord
    
    public static void main(String[] args) {
        // testing classes
        //Board.main(args);
        //Board_Open.main(args);
        //Board_Label.main(args);
        //Board_ID.main(args);
        //UF.main(args);
        
        // read in the content of a file
        String[] readLines = In.readStrings(args[0]);
        
        // initialization
        String[] line0 = readLines[0].split("","");
        int N         = Integer.valueOf(line0[0]); // prepare for N-by-N grid
        int targetRow = Integer.valueOf(line0[1]); // row of target site: (row, col)
        int targetCol = Integer.valueOf(line0[2]); // col of target site: (row, col)
        LabelCC labelcc = new LabelCC(N);
        
        // iterate through the file
        for (String s: Arrays.copyOfRange(readLines, 1, readLines.length)){
            String[] line = s.split("","");
            //System.out.println(s);
            labelcc.setBlock(Integer.valueOf(line[0]), Integer.valueOf(line[1]));
	} // end loop for
        
        if (labelcc.isBlock(targetRow, targetCol)) {
            System.out.print(0);
            return;
        } // end if
        
        labelcc.passFirst();
        //labelcc.displayLabel();
        
        labelcc.passSecond();
        System.out.print(labelcc.getLabel(targetRow, targetCol));
        //System.out.println(""-------------------------"");
        //labelcc.displayID();
        //labelcc.displayOpen();
        //labelcc.displayCase();
        //labelcc.displayLabel();
        //labelcc.displayUF();
        //labelcc.displayRoot();
        //labelcc.displayUFRecord();
    } // end main
} // end class LabelCC

class QuicUnion {
    private int[] id;
    // this is for monitoring the number of function call and loop
    public Queue<Integer> recordRoot  = new Queue<Integer>();
    public Queue<Integer> recordUnion = new Queue<Integer>();
    
    public QuicUnion (int N) {
        id = new int[N];
        for (int i = 0; i < N; i++) id[i] = i;
    } // end contructor
    
    public boolean connected(int p, int q) { 
        return root(p) == root(q); 
    } // end func connected
    
    public int root(int i) {
        int recordLoop = 0;
        
        // Follow links to find a root
        while (i != id[i]) {
            recordLoop++;
            id[i] = id[id[i]]; // path compression
            i = id[i];         // search upper node
        } // end while
        
        recordRoot.enqueue(recordLoop);
        recordUnion.enqueue(0);
        
        return i; 
    } // end func root
    
    public void union(int p, int q) {
        recordUnion.enqueue(1);
        
        // Parent: p ; Child: q
        int i = root(p);     // component of p
        int j = root(q);     // component of q
        if (i == j) return;  // if same root, same component
        id[j] = i;           // link component q under component p
                             // Parent: i
                             // Child:  j
    } // end func union
    public void display(){
        System.out.println(Arrays.toString(id));
    } // end func display
} // end class UF

class QuickFind {
    private int[] id;
    public Queue<Integer> recordRoot  = new Queue<Integer>();
    public Queue<Integer> recordUnion = new Queue<Integer>();
    
    public QuickFind(int N){
        id = new int[N];
        for (int i = 0; i < N; i++) {
            id[i] = i;
        }
    }// end constructor
    
    public boolean connected(int p, int q)
    { return root(p) == root(q); }
    
    public int root(int p) {
        recordRoot.enqueue(1);
        return id[p]; 
    }
    
    public void union(int p , int q) {
        int pID = root(p);
        int qID = root(q);
        
        if (pID == qID) return;
        
        for (int i = 0; i < id.length; i++) {
            if (id[i] == qID) id[i] = pID;
        }
        recordUnion.enqueue(id.length);
    } // end func union
    
    public void display(){
        System.out.println(Arrays.toString(id));
    } // end func display
    
} // end class Quickfind

class Board_ID {
    private final int dim;
    private final Board<Integer> board;
    
    public Board_ID (int n) {
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    } // end constructor
    
    public void setId(int row, int col, int value){
        board.setGrid(row-1, col-1, value);
    } // end func setId
    
    public Integer getId(int row, int col){
        return board.getGrid(row-1, col-1);
    } // end func getId
    
    public Integer getNeighbor(int row, int col, String direction){
        return board.getNeighbor(row-1, col-1, direction);
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_ID anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_ID copy() {
        Board_ID board_copy = new Board_ID(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setId(row, col, getId(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, row * dim + col);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_ID

class Board_Label {
    private final int dim;
    private Board<Integer> board;
    
    public Board_Label(int n){
        board = new Board<Integer>(n);
        dim = n;
        reset(); 
    }  // end constructor
    
    public Integer getLabel(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getGrid(row-1, col-1);
        //} // end if
    } // end func getLabel
    
    public void setLabel(int row, int col, int value) {   
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, value);
        //} // end if
    } // end func setLabel 
    
    public Boolean isLabel(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            if (board.getGrid(row-1, col-1) == -1) { return false; } 
            else                                   { return true; }
        } // end if-else
        //System.out.println(""Error: \n\tClass Board_Label \n\tfunction isLabel \n\tMessage: Out of Boundary"");
        return null;
    } // end func isLabel
    
    public Integer getNeighbor(int row, int col, String direction) {
        return board.getNeighbor(row-1, col-1, direction);
    } // end func Integer
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Label anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Label copy() {
        Board_Label board_copy = new Board_Label(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                board_copy.setLabel(row, col, getLabel(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset(){
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, -1);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        board.display();
    } // end func display
} // end class Board_Label

class Board_Open {
    private final int dim;
    private Board<Boolean> board;
    
    public Board_Open(int n){
        board = new Board<Boolean>(n);
        dim = n;
        reset();    
    }  // end constructor
    
    public void setOpen(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, true);
        //} // end if
    } // end func setOpen
    
    public void setBlock(int row, int col) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        board.setGrid(row-1, col-1, false);
        //} // end if
    } // end func setBlock
    
    public Boolean isOpen(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == true;    
        }
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isOpen \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean isBlock(int row, int col) {
        if (row >= 1 && row <= dim && col >= 1 && col <= dim){
            return board.getGrid(row-1, col-1) == false;
        } // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction isBlock \n\tMessage: Out of Boundary"");
        return null;
    } // end func isOpen
    
    public Boolean getNeighbor(int row, int col, String direction) {
        //if (row >= 1 && row <= dim && col >= 1 && col <= dim){
        return board.getNeighbor(row-1, col-1, direction);
        //} // end if
        //System.out.println(""Error: \n\tClass Board_Open \n\tfunction getNeighbor \n\tMessage: Out of Boundary"");
        //return null;
    } // end func getNeighbor
    
    private Board getBoard(){
        return board.copy();
    } // end func getBoard
    
    public boolean compare(Board_Open anotherBoard){
        return board.compare(anotherBoard.getBoard());
    } // end func compared
    
    public Board_Open copy() {
        Board_Open board_copy = new Board_Open(dim);
        
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) { board_copy.setOpen(row, col);  } 
                else                  { board_copy.setBlock(row, col); }
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void reset() {
        // default: all open
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board.setGrid(row, col, true);
            } // end inner loop
        } // end outer loop
    } // end func reset
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 1; row <= dim; row++) {
            for (int col = 1; col <= dim; col++) {
                if (isOpen(row, col)) {System.out.print(""1 "");}
                else                  {System.out.print(""0 "");}
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board_Open

class Board<Item> {
    private final int dim;
    private Item[] board;
    
    public Board(int n) {
        dim = n;
        board = (Item[]) new Object[n*n];
    } // end constructor
    
    public int getDim(){ return dim; }
    
    public Item getGrid(int row, int col){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            return board[row * dim + col];
        } // end if
        return null;
    } // end func getGrid
    
    public void setGrid(int row, int col, Item value){
        if (row >= 0 && col >= 0 && row < dim && col < dim) {
            board[row * dim + col] = value;
        } // end if
    } // end func setGrid
    
    public Item getNeighbor(int row, int col, String direction) {
        if (!(row >= 0 && col >= 0 && row < dim && col < dim)) {
            return null;
        } // end if
        
        if (direction.equals(""UP"")) {
            if (row > 0) { return getGrid(row-1, col); }
        } // end if
        
        if (direction.equals(""DOWN"")) {
            if (row < (dim - 1)) { return getGrid(row+1, col); }
        } // end if
        
        if (direction.equals(""LEFT"")) {
            if (col > 0) { return getGrid(row, col-1); }
        } // end if
        
        if (direction.equals(""RIGHT"")) {
            if (col < (dim - 1)) { return getGrid(row, col+1); }
        } // end if
        
        return null;
    } // end func getNeighbor
    
    public boolean compare(Board<Item> anotherBoard) { 
        if (anotherBoard.getDim() != dim) {
            return false;
        } // end if
        
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                if (getGrid(row, col) != anotherBoard.getGrid(row, col)) {
                    return false;
                } // end if
            } // end inner loop
        } // end outer loop
        
        return true;
    } // end func compare
    
    public Board copy(){
        Board<Item> board_copy = new Board(dim);
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                board_copy.setGrid(row, col, getGrid(row, col));
            } // end inner loop
        } // end outer loop
        return board_copy;
    } // end func copy
    
    public void display() {
        System.out.println(""-------------------------"");
        for (int row = 0; row < dim; row++) {
            for (int col = 0; col < dim; col++) {
                System.out.print(board[row * dim + col] + "" "");
            } // end inner loop
            System.out.println();
        } // end outer loop
        System.out.println(""-------------------------"");
    } // end func display
} // end class Board
@85a40d9014bbc12acee43196898a3c8a@"
"b99611017","4","1.33","186288","@9c5a6349b5f94766f89d641e62b1ed1a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
import java.io.*;
import java.util.Scanner;

public class LabelCC {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            String[] given = token[0].split("","");

            int[] x = new int[token.length - 1];

            int[] y = new int[token.length - 1];

            int size = Integer.parseInt(given[0]);

            int a = Integer.parseInt(given[1]) - 1;

            int b = Integer.parseInt(given[2]) - 1;         //a given site

            for (int i = 0; i < token.length - 1; i++) {

                String[] site = token[i + 1].split("","");

                x[i] = Integer.parseInt(site[0]);

                y[i] = Integer.parseInt(site[1]);

            }

            int[][] map = new int[size][size];

            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    map[i][j] = 1;
                }
            }

            for (int i = 0; i < x.length; i++) {
                map[x[i] - 1][y[i] - 1] = 0;
            }                                      //mapping

            //scanning
            int label = 1;

            for (int i = 0; i < size; i++) //row 1 : special case
            {
                if (i == 0) //[0][0]
                {
                    if (map[0][i] != 0) {
                        map[0][i] = label;
                    } else if (map[0][i] == 0) {
                        map[0][i] = 0;
                    }
                } else {
                    if (map[0][i] == 0) {
                        map[0][i] = 0;
                      //  label++;
                    } else {
                        label++;
                        map[0][i] = label;
                    }

                }

            }

            for (int i = 1; i < size; i++) {                //other rows

                for (int j = 0; j < size; j++) {

                    if (j == 0) {
                        if (map[i - 1][j] == 0 && map[i][j] != 0) //column 1 special case
                        {
                            label++;
                            map[i][j] = label;
                        } else if (map[i - 1][j] != 0 && map[i][j] != 0) {
                            map[i][j] = map[i - 1][j];
                        }
                    } else {

                        if (map[i - 1][j] == 0 && map[i][j - 1] == 0 && map[i][j] != 0) {
                            label++;
                            map[i][j] = label;
                        } else if (map[i - 1][j] != 0 && map[i][j - 1] == 0 && map[i][j] != 0) {
                            map[i][j] = map[i - 1][j];
                        } else if (map[i - 1][j] == 0 && map[i][j - 1] != 0 && map[i][j] != 0) {
                            map[i][j] = map[i][j - 1];
                        } else if (map[i - 1][j] != 0 && map[i][j - 1] != 0 && map[i][j] != 0) {

                            if (map[i - 1][j] > map[i][j - 1]) {
                                map[i][j] = map[i][j - 1];
                            } else if (map[i - 1][j] < map[i][j - 1]) {
                                map[i][j] = map[i - 1][j];
                            } else if (map[i - 1][j] == map[i][j - 1]) {
                                map[i][j] = map[i - 1][j];
                            }
                        }

                    }

                }
            }
            // start connecting
            QuickUnionUF LC = new QuickUnionUF(size * size);

            for (int i = 0; i < size * size; i++) {
                if (i / size == 0 && i % size == 0) {
                    ;
                } else if (i / size == 0 && i % size != 0) {
                    if (map[i / size][i % size - 1] == map[i / size][i % size]) {
                        LC.union(i, i - 1);
                    }

                } else if (i % size == 0 && i / size != 0) {
                    if (map[i / size - 1][i % size] == map[i / size][i % size]) {
                        LC.union(i, i - size);
                    }
                } else if (i / size != 0 && i % size != 0) {
                    if (map[i / size][i % size - 1] == map[i / size][i % size]) {
                        LC.union(i, i - 1);
                    }

                    if (map[i / size - 1][i % size] == map[i / size][i % size]) {
                        LC.union(i, i - size);
                    }
                }
            }

            //start merging
            for (int i = 0; i < size * size; i++) {
                if (i / size == 0 && i % size == 0) //    ( 0 , 0 )
                {
                    ;
                } else if (i / size == 0 && i % size != 0) //row 1
                {
                    if ((map[i / size][i % size] > map[i / size][i % size - 1]) && (map[i / size][i % size - 1] > 0)) {
                        LC.union(i, i - 1);
                    } else if ((map[i / size][i % size - 1] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - 1, i);
                    }
                } else if (i % size == 0 && i / size != 0) //column 1
                {
                    if ((map[i / size][i % size] > map[i / size - 1][i % size] )&& (map[i / size - 1][i % size] > 0)) {
                        LC.union(i, i - size);
                    } else if ((map[i / size - 1][i % size] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - size, i);
                    }
                } else if (i % size != 0 && i / size != 0) {
                    if ((map[i / size][i % size] > map[i / size - 1][i % size]) && (map[i / size - 1][i % size] > 0)) {
                        LC.union(i, i - size);
                    } else if ((map[i / size - 1][i % size] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - size, i);
                    }

                    if ((map[i / size][i % size] > map[i / size][i % size - 1]) && (map[i / size][i % size - 1] > 0)) {
                        LC.union(i, i - 1);
                    } else if ((map[i / size][i % size - 1] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - 1, i);
                    }
                }
            }

            int ans = LC.find(a * size + b);

            System.out.print(map[ans / size][ans % size]);

        } catch (RuntimeException e) {

            throw e;
        }
    }
}

@9c5a6349b5f94766f89d641e62b1ed1a@"
"b99611017","9","1.33","191456","@37ff41af8f181d12115e60004c73614a@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author 許志鵬
 */
import java.io.*;
import java.util.Scanner;

public class LabelCC {

    /**
     * @param args the command line arguments
     * @throws java.io.FileNotFoundException
     */
    @SuppressWarnings(""empty-statement"")
    public static void main(String[] args) throws FileNotFoundException, IOException {
        try {
            InputStream is = new FileInputStream(args[0]);

            InputStreamReader isr = new InputStreamReader(is, ""UTF8"");

            BufferedReader br = new BufferedReader(isr);

            Scanner sn = new Scanner(br);

            StringBuilder buf = new StringBuilder();

            while (sn.hasNext()) {

                buf.append(sn.next()).append(""\n"");

            }

            String str = buf.toString();

            String[] token = str.split(""\n"");

            String[] given = token[0].split("","");

            int[] x = new int[token.length - 1];

            int[] y = new int[token.length - 1];

            int size = Integer.parseInt(given[0]);

            int a = Integer.parseInt(given[1]) - 1;

            int b = Integer.parseInt(given[2]) - 1;         //a given site

            for (int i = 0; i < token.length - 1; i++) {

                String[] site = token[i + 1].split("","");

                x[i] = Integer.parseInt(site[0]);

                y[i] = Integer.parseInt(site[1]);

            }

            int[][] map = new int[size][size];

            for (int i = 0; i < size; i++) {
                for (int j = 0; j < size; j++) {
                    map[i][j] = 1;
                }
            }

            for (int i = 0; i < x.length; i++) {
                map[x[i] - 1][y[i] - 1] = 0;
            }                                      //mapping

            //scanning
            int label = 1;

            for (int i = 0; i < size; i++) //row 1 : special case
            {
                if (i == 0) //[0][0]
                {
                    if (map[0][i] != 0) {
                        map[0][i] = label;
                    } else if (map[0][i] == 0) {
                        map[0][i] = 0;
                    }
                } else {
                    if (map[0][i] == 0) {
                        map[0][i] = 0;
                       // label++;
                    } else {
                        if(map[0][i-1]!=0)
                        {
                            map[0][i] = map[0][i-1];                            
                        }
                        else{
                            label++;
                            map[0][i]=label;
                        }
                    }

                }

            }

            for (int i = 1; i < size; i++) {                //other rows

                for (int j = 0; j < size; j++) {

                    if (j == 0) {
                        if (map[i - 1][j] == 0 && map[i][j] != 0) //column 1 special case
                        {
                            label++;
                            map[i][j] = label;
                        } else if (map[i - 1][j] != 0 && map[i][j] != 0) {
                            map[i][j] = map[i - 1][j];
                        }
                    } else {

                        if (map[i - 1][j] == 0 && map[i][j - 1] == 0 && map[i][j] != 0) {
                            label++;
                            map[i][j] = label;
                        } else if (map[i - 1][j] != 0 && map[i][j - 1] == 0 && map[i][j] != 0) {
                            map[i][j] = map[i - 1][j];
                        } else if (map[i - 1][j] == 0 && map[i][j - 1] != 0 && map[i][j] != 0) {
                            map[i][j] = map[i][j - 1];
                        } else if (map[i - 1][j] != 0 && map[i][j - 1] != 0 && map[i][j] != 0) {

                            if (map[i - 1][j] > map[i][j - 1]) {
                                map[i][j] = map[i][j - 1];
                            } else if (map[i - 1][j] < map[i][j - 1]) {
                                map[i][j] = map[i - 1][j];
                            } else if (map[i - 1][j] == map[i][j - 1]) {
                                map[i][j] = map[i - 1][j];
                            }
                        }

                    }

                }
            }
            // start connecting
            QuickUnionUF LC = new QuickUnionUF(size * size);

            for (int i = 0; i < size * size; i++) {
                if (i / size == 0 && i % size == 0) {
                    ;
                } else if (i / size == 0 && i % size != 0) {
                    if (map[i / size][i % size - 1] == map[i / size][i % size]) {
                        LC.union(i, i - 1);
                    }

                } else if (i % size == 0 && i / size != 0) {
                    if (map[i / size - 1][i % size] == map[i / size][i % size]) {
                        LC.union(i, i - size);
                    }
                } else if (i / size != 0 && i % size != 0) {
                    if (map[i / size][i % size - 1] == map[i / size][i % size]) {
                        LC.union(i, i - 1);
                    }

                    if (map[i / size - 1][i % size] == map[i / size][i % size]) {
                        LC.union(i, i - size);
                    }
                }
            }

            //start merging
            for (int i = 0; i < size * size; i++) {
                if (i / size == 0 && i % size == 0) //    ( 0 , 0 )
                {
                    ;
                } else if (i / size == 0 && i % size != 0) //row 1
                {
                    if ((map[i / size][i % size] > map[i / size][i % size - 1]) && (map[i / size][i % size - 1] > 0)) {
                        LC.union(i, i - 1);
                    } else if ((map[i / size][i % size - 1] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - 1, i);
                    }
                } else if (i % size == 0 && i / size != 0) //column 1
                {
                    if ((map[i / size][i % size] > map[i / size - 1][i % size] )&& (map[i / size - 1][i % size] > 0)) {
                        LC.union(i, i - size);
                    } else if ((map[i / size - 1][i % size] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - size, i);
                    }
                } else if (i % size != 0 && i / size != 0) {
                    if ((map[i / size][i % size] > map[i / size - 1][i % size]) && (map[i / size - 1][i % size] > 0)) {
                        LC.union(i, i - size);
                    } else if ((map[i / size - 1][i % size] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - size, i);
                    }

                    if ((map[i / size][i % size] > map[i / size][i % size - 1]) && (map[i / size][i % size - 1] > 0)) {
                        LC.union(i, i - 1);
                    } else if ((map[i / size][i % size - 1] > map[i / size][i % size]) && (map[i / size][i % size] > 0)) {
                        LC.union(i - 1, i);
                    }
                }
            }

            int ans = LC.find(a * size + b);

            System.out.print(map[ans / size][ans % size]);

        } catch (RuntimeException e) {

            throw e;
        }
    }
}

@37ff41af8f181d12115e60004c73614a@"
"r03723070","5","0.56","105168","@d83d93fad48ab2df3c1566a0021a3fc4@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       //if(data[1][1]==-1)
           //count = 2;
       int [][]connect = new int[N][N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect

                               connect[p][q] = 1;
                                    //for(int k =0;k<N*N/2+1;k++){
                                        //if(connect[k] == op)
                                            //connect[k]= oq;
                                    //}
                               }
                               /*else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                  // connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }*/
                                   
                               //connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root left
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }
       
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       for(int j = 0;j<=N;j++){
           if(connect[data[ans[0]][ans[1]]][j]!=0)
               finalans = j;
               break;
       }
       //int finalans =data[ans[0]][ans[1]];
       //connect have value
       //if(data[ans[0]][ans[1]]!=-1){
       //if(connect[data[ans[0]][ans[1]]]!=0)
       //finalans = connect[data[ans[0]][ans[1]]];
       //else
       //finalans = finalans;
       //}
       //block
       //else
       //finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    



@d83d93fad48ab2df3c1566a0021a3fc4@"
"r03723070","5","0.55","105424","@75ac037fbf3c91c56d7e9a98a3ff86b7@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       //if(data[1][1]==-1)
           //count = 2;
       int [][]connect = new int[N][N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect

                               connect[p][q] = 1;
                                    //for(int k =0;k<N*N/2+1;k++){
                                        //if(connect[k] == op)
                                            //connect[k]= oq;
                                    //}
                               }
                               /*else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                  // connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }*/
                                   
                               //connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root left
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }
       
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to sit
       int finalans =data[ans[0]][ans[1]];
       if(data[ans[0]][ans[1]]!=-1){
           for(int j = 0;j<=N;j++){
           if(connect[data[ans[0]][ans[1]]][j]!=0)
               finalans = j;
               break;
       }    
      }
       else
           finalans=0;
       
       //int finalans =data[ans[0]][ans[1]];
       //connect have value
       //if(data[ans[0]][ans[1]]!=-1){
       //if(connect[data[ans[0]][ans[1]]]!=0)
       //finalans = connect[data[ans[0]][ans[1]]];
       //else
       //finalans = finalans;
       //}
       //block
       //else
       //finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    




@75ac037fbf3c91c56d7e9a98a3ff86b7@"
"r03723070","5","0.54","105456","@861bf3c3ad879bff8a398ad2605c3a04@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       //if(data[1][1]==-1)
           //count = 2;
       int [][]connect = new int[N][N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect

                               connect[p][q] = 1;
                                    //for(int k =0;k<N*N/2+1;k++){
                                        //if(connect[k] == op)
                                            //connect[k]= oq;
                                    //}
                               }
                               /*else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                  // connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }*/
                                   
                               //connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root left
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }
       
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to sit
       int finalans =data[ans[0]][ans[1]];
       if(data[ans[0]][ans[1]]!=-1){
           for(int j = 0;j<N+1;j++){
           if(connect[data[ans[0]][ans[1]]][j]!=0)
               finalans = j;
               break;
       }    
      }
       else
           finalans=0;
       
       //int finalans =data[ans[0]][ans[1]];
       //connect have value
       //if(data[ans[0]][ans[1]]!=-1){
       //if(connect[data[ans[0]][ans[1]]]!=0)
       //finalans = connect[data[ans[0]][ans[1]]];
       //else
       //finalans = finalans;
       //}
       //block
       //else
       //finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    




@861bf3c3ad879bff8a398ad2605c3a04@"
"r03849033","9","0.99","127328","@08b971c780d9f49f0a20ddf605de3005@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        
                    if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@08b971c780d9f49f0a20ddf605de3005@"
"r03723070","6","0.64","105472","@f5a75a4c8e9004449caa0930831babce@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       //if(data[1][1]==-1)
           //count = 2;
       int [][]connect = new int[N*N/2+1][N];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect

                               connect[p][q] = 1;
                                    //for(int k =0;k<N*N/2+1;k++){
                                        //if(connect[k] == op)
                                            //connect[k]= oq;
                                    //}
                               }
                               /*else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                  // connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }*/
                                   
                               //connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root left
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }
       
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to sit
       int finalans =data[ans[0]][ans[1]];
       if(data[ans[0]][ans[1]]!=-1){
           for(int j = 0;j<N+1;j++){
           if(connect[data[ans[0]][ans[1]]][j]!=0)
               finalans = j;
               break;
       }    
      }
       else
           finalans=0;
       
       //int finalans =data[ans[0]][ans[1]];
       //connect have value
       //if(data[ans[0]][ans[1]]!=-1){
       //if(connect[data[ans[0]][ans[1]]]!=0)
       //finalans = connect[data[ans[0]][ans[1]]];
       //else
       //finalans = finalans;
       //}
       //block
       //else
       //finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    




@f5a75a4c8e9004449caa0930831babce@"
"b02611002","6","1.55","152160","@003a6c60e45516a18baa49f114f1101a@import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by zhouyuda on 3/15/16.
 * 題目：http://c4lab.bime.ntu.edu.tw:24080/judge/problem/hw2.html
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // 0.讀檔
            String[] metadata = br.readLine().split("","");
            int N = Integer.parseInt(metadata[0]);


            // 1.宣告
            int[] target = {Integer.parseInt(metadata[1]),Integer.parseInt(metadata[2])};   //目標site的座標
            int matrixSize = N*N;   //matrix的""長度""
            int[] arrMatrix = new int[matrixSize];
            Arrays.fill(arrMatrix,1);//arrMatrix所有元素值初始為一
            int stamp = 0;
            int ID = 0;
            int[] tempMatrix = new int[matrixSize];
            QuickUnionUF labels = new QuickUnionUF(N*N/2); //label = {0,1,2,3,4,5,6,7,}
            int targetID = N*(target[0]-1)+(target[1]-1);//7+8*4


            // 2.將input中的座標set 0
            while(br.ready()){
                String[] strCoor = br.readLine().split("","");   //座標一行行讀進string[] strCoor
                int[] intCoor = Arrays.asList(strCoor).stream().mapToInt(Integer::parseInt).toArray();   //intCoor = Int(strCoor)
                ID = (intCoor[1]-1) + N*(intCoor[0]-1);
                arrMatrix[ID]=0;
            }
            ID=0;    //計步器歸零


            /*/–––––––––––––––––––print整個matrix–––––––––––––––––––––————
            System.out.println(""目前的matrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""[%d,%d:%d]= %d\t"",i,j,N*i+j,arrMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––*/



            //3. first pass
            for(ID=0;ID<matrixSize;ID++){
//                System.out.printf(""\nnow at ID=%d"",ID);

//              ––––––––––––––––––––––––––––––––––––––––––——
//              ––––––––––––––––非第一排時–––––––––––––––––––
//              ––––––––––––––––––––––––––––––––––––––––––——
                if((ID>=N)&&(arrMatrix[ID]!=0)){
                    if(((ID%N!=0)&&(arrMatrix[ID-N]<=0)&&(arrMatrix[ID-1]<=0))||((ID%N==0)&&(arrMatrix[ID-N]<=0))){
                        stamp++;    //若 ""上"" ""左"" 為0/X則stamp++ 並蓋章
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;

                    }else if((ID%N==0)&&(arrMatrix[ID-N]!=0)){
                        tempMatrix[ID] = tempMatrix[ID-N];
//                        System.out.println(""第一列直接取上面"");
                    }else if((arrMatrix[ID-N]!=0)&&(arrMatrix[ID-1]!=0)){
//                        System.out.println(""左上比大小"");
                        if(tempMatrix[ID-N]<=tempMatrix[ID-1]){
                            tempMatrix[ID] = tempMatrix[ID-N];
                            labels.union(tempMatrix[ID-1],tempMatrix[ID-N]);
//                            System.out.printf(""上贏了"");
                        }else{
                            tempMatrix[ID] = tempMatrix[ID-1];
                            labels.union(tempMatrix[ID-N],tempMatrix[ID-1]);
//                            System.out.printf(""左贏了！"");
                        }

                    }else if((arrMatrix[ID-N]!=0)&&(arrMatrix[ID-1]==0)){
                        tempMatrix[ID] = tempMatrix[ID-N];
//                        System.out.println(""[上：ID-N]"");

                    }else if((arrMatrix[ID-1]!=0)&&(arrMatrix[ID-N]==0)){
                        tempMatrix[ID] = tempMatrix[ID-1];
//                        System.out.println(""[左：ID-1]"");
                    }

//                    System.out.printf(""[NORMAL{arrMatrix[ID]=%d}]"",arrMatrix[ID]);



//              ––––––––––––––––––––––––––––––––––––––––––——
//              ––––––––––––––––第一排時–––––––––––––––––––––
//              ––––––––––––––––––––––––––––––––––––––––––——
                }else if((ID<N)&&(ID!=0)){
                    if(arrMatrix[ID-1]<=0){
                        stamp++;
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;
                    }else if(arrMatrix[ID]!=0) {
                        tempMatrix[ID] = tempMatrix[ID - 1];
                    }

//                    System.out.println(""[LINE ONE]"");


//              ––––––––––––––––第一排第一個––––––––––––––––––
                }else if(ID==0){
//                    System.out.println(""[NOW ID 0]"");
                        stamp++;
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;
                }
            }



            //4. second pass
            for(ID=0;ID<matrixSize;ID++){
                if(tempMatrix[ID]!=0){
                    tempMatrix[ID]=labels.find(tempMatrix[ID]);
                }
            }

            //5. return reult
            System.out.println(tempMatrix[targetID]);

/*
            //–––––––––––––––––––print整個matrix–––––––––––––––————––––––
            // ––––
            System.out.println(""目前的arrMatrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""%d\t"",arrMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            //–––––––––––––––––––print整個matrix–––––––––––––––————––––––
            // ––––
            System.out.println(""目前的tempMatrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""%d\t"",tempMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            //––––––––––––––––––––print roots––––––––––––––––––––––––––––
            for (int i=0; i<=10; i++){
                System.out.printf(""root(%d)=%d.\n"",i,labels.find(i));
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            System.out.printf(""ID=%d:%d"",targetID,tempMatrix[targetID]);*/
        }
    }
}
@003a6c60e45516a18baa49f114f1101a@"
"b02611002","6","1.46","153760","@003a6c60e45516a18baa49f114f1101a@import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by zhouyuda on 3/15/16.
 * 題目：http://c4lab.bime.ntu.edu.tw:24080/judge/problem/hw2.html
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // 0.讀檔
            String[] metadata = br.readLine().split("","");
            int N = Integer.parseInt(metadata[0]);


            // 1.宣告
            int[] target = {Integer.parseInt(metadata[1]),Integer.parseInt(metadata[2])};   //目標site的座標
            int matrixSize = N*N;   //matrix的""長度""
            int[] arrMatrix = new int[matrixSize];
            Arrays.fill(arrMatrix,1);//arrMatrix所有元素值初始為一
            int stamp = 0;
            int ID = 0;
            int[] tempMatrix = new int[matrixSize];
            QuickUnionUF labels = new QuickUnionUF(N*N/2); //label = {0,1,2,3,4,5,6,7,}
            int targetID = N*(target[0]-1)+(target[1]-1);//7+8*4


            // 2.將input中的座標set 0
            while(br.ready()){
                String[] strCoor = br.readLine().split("","");   //座標一行行讀進string[] strCoor
                int[] intCoor = Arrays.asList(strCoor).stream().mapToInt(Integer::parseInt).toArray();   //intCoor = Int(strCoor)
                ID = (intCoor[1]-1) + N*(intCoor[0]-1);
                arrMatrix[ID]=0;
            }
            ID=0;    //計步器歸零


            /*/–––––––––––––––––––print整個matrix–––––––––––––––––––––————
            System.out.println(""目前的matrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""[%d,%d:%d]= %d\t"",i,j,N*i+j,arrMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––*/



            //3. first pass
            for(ID=0;ID<matrixSize;ID++){
//                System.out.printf(""\nnow at ID=%d"",ID);

//              ––––––––––––––––––––––––––––––––––––––––––——
//              ––––––––––––––––非第一排時–––––––––––––––––––
//              ––––––––––––––––––––––––––––––––––––––––––——
                if((ID>=N)&&(arrMatrix[ID]!=0)){
                    if(((ID%N!=0)&&(arrMatrix[ID-N]<=0)&&(arrMatrix[ID-1]<=0))||((ID%N==0)&&(arrMatrix[ID-N]<=0))){
                        stamp++;    //若 ""上"" ""左"" 為0/X則stamp++ 並蓋章
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;

                    }else if((ID%N==0)&&(arrMatrix[ID-N]!=0)){
                        tempMatrix[ID] = tempMatrix[ID-N];
//                        System.out.println(""第一列直接取上面"");
                    }else if((arrMatrix[ID-N]!=0)&&(arrMatrix[ID-1]!=0)){
//                        System.out.println(""左上比大小"");
                        if(tempMatrix[ID-N]<=tempMatrix[ID-1]){
                            tempMatrix[ID] = tempMatrix[ID-N];
                            labels.union(tempMatrix[ID-1],tempMatrix[ID-N]);
//                            System.out.printf(""上贏了"");
                        }else{
                            tempMatrix[ID] = tempMatrix[ID-1];
                            labels.union(tempMatrix[ID-N],tempMatrix[ID-1]);
//                            System.out.printf(""左贏了！"");
                        }

                    }else if((arrMatrix[ID-N]!=0)&&(arrMatrix[ID-1]==0)){
                        tempMatrix[ID] = tempMatrix[ID-N];
//                        System.out.println(""[上：ID-N]"");

                    }else if((arrMatrix[ID-1]!=0)&&(arrMatrix[ID-N]==0)){
                        tempMatrix[ID] = tempMatrix[ID-1];
//                        System.out.println(""[左：ID-1]"");
                    }

//                    System.out.printf(""[NORMAL{arrMatrix[ID]=%d}]"",arrMatrix[ID]);



//              ––––––––––––––––––––––––––––––––––––––––––——
//              ––––––––––––––––第一排時–––––––––––––––––––––
//              ––––––––––––––––––––––––––––––––––––––––––——
                }else if((ID<N)&&(ID!=0)){
                    if(arrMatrix[ID-1]<=0){
                        stamp++;
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;
                    }else if(arrMatrix[ID]!=0) {
                        tempMatrix[ID] = tempMatrix[ID - 1];
                    }

//                    System.out.println(""[LINE ONE]"");


//              ––––––––––––––––第一排第一個––––––––––––––––––
                }else if(ID==0){
//                    System.out.println(""[NOW ID 0]"");
                        stamp++;
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;
                }
            }



            //4. second pass
            for(ID=0;ID<matrixSize;ID++){
                if(tempMatrix[ID]!=0){
                    tempMatrix[ID]=labels.find(tempMatrix[ID]);
                }
            }

            //5. return reult
            System.out.println(tempMatrix[targetID]);

/*
            //–––––––––––––––––––print整個matrix–––––––––––––––————––––––
            // ––––
            System.out.println(""目前的arrMatrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""%d\t"",arrMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            //–––––––––––––––––––print整個matrix–––––––––––––––————––––––
            // ––––
            System.out.println(""目前的tempMatrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""%d\t"",tempMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            //––––––––––––––––––––print roots––––––––––––––––––––––––––––
            for (int i=0; i<=10; i++){
                System.out.printf(""root(%d)=%d.\n"",i,labels.find(i));
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            System.out.printf(""ID=%d:%d"",targetID,tempMatrix[targetID]);*/
        }
    }
}
@003a6c60e45516a18baa49f114f1101a@"
"b03611003","10","0.097","127104","@8cb992830b349d248f57b103496e4ced@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;

import java.io.FileReader;
import java.io.BufferedReader;

/**
 *
 * @author 士齊
 *
 *
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    private static int[][] CC;
    private static int[][] borw;
    private static int[] id;
//    CC: 每個格子中的cc
//    borw: 每個格子是黑是白

    public LabelCC(int N) {
        CC = new int[N][N];
        borw = new int[N][N];
        id = new int[(N * N + 1) / 2 + 1];
        for (int i = 0; i < ((N * N + 1) / 2 + 1); i++) {
            id[i] = i;
        }

    }

    private static int root(int i) {
        while (i != id[i]) {
            id[i] = id[id[i]];
            i = id[i];
        }
        return i;
    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

//          part1
            String[] dataf = br.readLine().split("","");

            LabelCC labelcc = new LabelCC(Integer.parseInt(dataf[0]));
            int N = Integer.parseInt(dataf[0]);

            while (Boolean.TRUE) {
                String data = br.readLine();

                if (data != null) {
                    String[] randc = new String[2];
                    randc = data.split("","");
                    borw[Integer.parseInt(randc[0]) - 1][Integer.parseInt(randc[1]) - 1] = 1;
                } else {
                    break;
                }
            }

//           part2
            int labelnow = 1;

            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (borw[i][j] == 0) {
                        switch (i) {
                            case 0:
//                                最左邊一排
                                if (j == 0) {
                                    CC[0][0] = labelnow;
                                    labelnow++;
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        CC[i][j] = CC[i][j - 1];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
                                }
                                break;
                            default:
                                if (j == 0) {
                                    if (borw[i - 1][j] == 0) {
                                        CC[i][j] = CC[i - 1][j];
                                    } else {
                                        CC[i][j] = labelnow;
                                        labelnow++;
                                    }
//                                    最上面一排
                                } else {
                                    if (borw[i][j - 1] == 0) {
                                        if (borw[i - 1][j] == 0) {
//                                            左跟上都有
//                                            if (root(CC[i][j - 1]) > root(CC[i - 1][j])) {
//                                                id[root(CC[i][j - 1])] = root(CC[i - 1][j]);
//                                                CC[i][j] = CC[i - 1][j];
//                                            } else if (root(CC[i][j - 1]) == root(CC[i - 1][j])) {
//                                                CC[i][j] = CC[i - 1][j];
//                                            } else {
//                                                id[root(CC[i - 1][j])] = root(CC[i][j - 1]);
//                                                CC[i][j] = CC[i][j - 1];
//                                            }
                                            if (CC[i][j - 1] > CC[i - 1][j]) {
                                                id[root(CC[i][j - 1])] = root(CC[i - 1][j]);
                                                CC[i][j] = CC[i - 1][j];
                                            } else if (CC[i][j - 1] == CC[i - 1][j]) {
                                                CC[i][j] = CC[i - 1][j];
                                            } else {
                                                id[root(CC[i - 1][j])] = root(CC[i][j - 1]);
                                                CC[i][j] = CC[i][j - 1];
                                            }

                                        } else {
//                                            上有左沒有
                                            CC[i][j] = CC[i][j - 1];
                                        }
                                    } else {
                                        if (borw[i - 1][j] == 0) {
//                                            左有上沒有
                                            CC[i][j] = CC[i - 1][j];
                                        } else {
//                                            都沒有
                                            CC[i][j] = labelnow;
                                            labelnow++;
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }

//            part3
            for (int i = 0; i < (N * N + 1) / 2; i++) {
                id[i] = root(i);
            }

//            for (int i = 0; i < N; i++) {
//                for (int j = 0; j < N; j++) {
//                    if (borw[i][j] == 0) {
//                        CC[i][j] = root(CC[i][j]);
//
//                    }
//                }
//            }
            int r = Integer.parseInt(dataf[1]) - 1;
            int c = Integer.parseInt(dataf[2]) - 1;

            System.out.print(root(CC[r][c]));
//            System.out.print(id[CC[6][4]]);
        }
    }

}

@8cb992830b349d248f57b103496e4ced@"
"r03849033","7","1","124928","@5c23d6ebf9e0ae8b3847892cef0af154@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            if(matrix[0][0]==false){
                    label[xyTo1D(1,1)]=count;
                    count++;                
            }
            for (int r = 0;  r < 1; r++){
                for (int c = 1;  c < n; c++){
                    if(matrix[r][c]==false){             
                        if(matrix[r][c-1]==false)    
                        root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                      else {
                        label[xyTo1D(r,c)]=count;
                        count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //  
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }
                }                   
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}
@5c23d6ebf9e0ae8b3847892cef0af154@"
"r03849033","7","1.01","126352","@051285a336a39a40814067a28bbd14ff@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            if(matrix[0][0]==false){
                    label[xyTo1D(1,1)]=count;
                    count++;                
            }
            for (int r = 0;  r < 1; r++){
                for (int c = 1;  c < n; c++){
                    if(matrix[r][c]==false){             
                        if(matrix[r][c-1]==false)    
                            root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                        else {
                            label[xyTo1D(r,c)]=count;
                            count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //  
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }
                }                   
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}
@051285a336a39a40814067a28bbd14ff@"
"r03849033","2","1.01","127248","@def84f18ff97b66b2f08e56d10ab01fe@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            if(matrix[0][0]==false){
                    label[xyTo1D(0,0)]=count;
                    count++;
            }
            for (int r = 0;  r < 1; r++){
                for (int c = 1;  c < n; c++){
                    if(matrix[r][c]==false){           
                    if(matrix[r][c-1]==false) {   
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); }
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(0,0))]); 
        }            
    }
}

@def84f18ff97b66b2f08e56d10ab01fe@"
"r03849033","9","1.01","128816","@1b27afc9f8f2232ad1dfe546abeaeaa7@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            if(matrix[0][0]==false){
                    label[xyTo1D(0,0)]=count;
                    count++;
            }
            for (int r = 0;  r < 1; r++){
                for (int c = 1;  c < n; c++){
                    if(matrix[r][c]==false){           
                    if(matrix[r][c-1]==false) {   
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); }
                    if(matrix[r][c-1]==true) {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@1b27afc9f8f2232ad1dfe546abeaeaa7@"
"r03849033","9","1.01","122976","@3edcf7994e8a20640fc33ed9d3b4df2d@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            if(matrix[0][0]==false){
                    label[xyTo1D(0,0)]=count;
                    count++;
            }
            for (int r = 0;  r < 1; r++){
                for (int c = 1;  c < n; c++){
                    if(matrix[r][c]==false){           
                    if(matrix[r][c-1]==false) {   
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); }
                    if(matrix[r][c-1]==true) {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //      
                    if( c>0 && matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            if(labelL==labelT){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                        //
                        if(c>0 && matrix[r-1][c]==false && matrix[r][c-1]==true){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        if(c>0 && matrix[r-1][c]==true && matrix[r][c-1]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));  }                        
                        if(c>0 && matrix[r-1][c]==true && matrix[r][c-1]==true){                   
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }
                }
            StdOut.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@3edcf7994e8a20640fc33ed9d3b4df2d@"
"r04228027","0","0","0","@b72165b3160d8e4bc9f8c2ba8f6fdc39@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            return image[id-1]==0;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public boolean isTopRow(int id){
            return id <= 8;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                    root[i-1] = -1;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isTopRow(i) && !isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                        }else{ //此格左邊為blocked
                            if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                if(isBlocked(i-N)){ //上方格為blocked
                                    labelCount+=1;
                                    label[i-1] = labelCount;
                                }else{ //上方格不為bocked
                                    label[i-1] = label[i-N-1];
                                    root[i-1] = root[i-N-1];
                                }}}
                    }else{ //此格在左邊界
                        if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                        }else{ //左格block 採用上方格label
                            if(isBlocked(i-N)){ //上方格為blocked
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //上方格不為bocked
                                label[i-1] = label[i-N-1];
                                root[i-1] = root[i-N-1];
                            }}}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }        
        public void secondPass(){
            for(int i=1; i<=N*N; i++){
                
            }
        }
        
        public void show(){
            System.out.printf(""image: %d\n"",image.length);
            for(int i=0; i<image.length; i++)
                System.out.print(image[i]);
            System.out.print(""\n"");
            System.out.printf(""root: %d\n"",root.length);
            for(int i=0; i<root.length; i++)
                System.out.print(root[i]);
            System.out.print(""\n"");
            System.out.printf(""label: %d\n"",root.length);
            for(int i=0; i<label.length; i++)
                System.out.print(label[i]);
            System.out.print(""\n"");
        }    
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=0; i<label.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",label[i]);
                }else
                    System.out.printf(""%-4d"",label[i]);
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            
            labelMethod AG = new labelMethod(size);
            //AG.show();
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            //System.out.print(Arrays.toString(thePoint)+""\n"");
            //AG.show();
            //AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@b72165b3160d8e4bc9f8c2ba8f6fdc39@"
"r04228027","0","0","0","@59bd5c1058ce76b1d5e7ca5c0a88db1c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            return image[id-1]==0;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public boolean isTopRow(int id){
            return id <= 8;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                    root[i-1] = -1;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isTopRow(i) && !isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                        }else{ //此格左邊為blocked
                            if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                if(isBlocked(i-N)){ //上方格為blocked
                                    labelCount+=1;
                                    label[i-1] = labelCount;
                                }else{ //上方格不為bocked
                                    label[i-1] = label[i-N-1];
                                    root[i-1] = root[i-N-1];
                                }}}
                    }else{ //此格在左邊界
                        if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                        }else{ //左格block 採用上方格label
                            if(isBlocked(i-N)){ //上方格為blocked
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //上方格不為bocked
                                label[i-1] = label[i-N-1];
                                root[i-1] = root[i-N-1];
                            }}}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }        
        public void secondPass(){
            for(int i=1; i<=N*N; i++){
                
            }
        }
        
        public void show(){
            System.out.printf(""image: %d\n"",image.length);
            for(int i=0; i<image.length; i++)
                System.out.print(image[i]);
            System.out.print(""\n"");
            System.out.printf(""root: %d\n"",root.length);
            for(int i=0; i<root.length; i++)
                System.out.print(root[i]);
            System.out.print(""\n"");
            System.out.printf(""label: %d\n"",root.length);
            for(int i=0; i<label.length; i++)
                System.out.print(label[i]);
            System.out.print(""\n"");
        }    
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=0; i<label.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",label[i]);
                }else
                    System.out.printf(""%-4d"",label[i]);
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            
            labelMethod AG = new labelMethod(size);
            //AG.show();
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            //System.out.print(Arrays.toString(thePoint)+""\n"");
            //AG.show();
            //AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@59bd5c1058ce76b1d5e7ca5c0a88db1c@"
"d04631001","10","0.105","132784","@1c216687c9d2c2eb167fabae80b31b8e@//package labelcc;

//import edu.princeton.cs.algs4.QuickFindUF; // mask
//import edu.princeton.cs.algs4.UF; // mask
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) { //args[0]
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int announce_v = Integer.parseInt(data[1]);
            int announce_h = Integer.parseInt(data[2]);
            //System.out.format(""%d\n"", num);
            //System.out.format(""%d\n"", announce_v);
            //System.out.format(""%d\n"", announce_h);
            int[][] matrix = new int[num][num];
            int[][] matrix_label = new int[num][num];
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    matrix[i][j] = 1;
                }
            }
            //for (int x = 0; x < matrix.length; x++) {
            //    for (int y = 0; y < matrix[0].length; y++) {
            //        System.out.print(matrix[x][y] + "" "");
            //   }
            //    System.out.print(""\n"");
            //}
            String block = new String();
            for (int i = 0; i < num * num; i++) {
                if ((block = br.readLine()) == null) {
                    break;
                }
                String[] b = block.split("","");
                int b_v = Integer.parseInt(b[0]);
                int b_h = Integer.parseInt(b[1]);
                matrix[b_v - 1][b_h - 1] = 0;
            }
            //for (int x = 0; x < matrix.length; x++) {
            //    for (int y = 0; y < matrix[0].length; y++) {
            //        System.out.print(matrix[x][y] + "" "");
            //    }
            //    System.out.print(""\n"");
            //}
            QuickFindUF uf = new QuickFindUF(num * num);
            int lab = 0;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (matrix[i][j] == 1) {
                        if (i == 0) {
                            if (j == 0 || matrix[i][j - 1] == 0) {
                                lab = lab + 1;
                                matrix_label[i][j] = lab;
                            } else {
                                matrix_label[i][j] = matrix_label[i][j - 1];
                            }
                        } else if (matrix[i - 1][j] == 1) {
                            if (j == 0 || matrix[i][j - 1] == 0) {
                                matrix_label[i][j] = matrix_label[i - 1][j];
                            } else if (matrix[i][j - 1] == 1) {
                                if (matrix_label[i - 1][j] == matrix_label[i][j - 1]) {/////have to union
                                    matrix_label[i][j] = matrix_label[i][j - 1];
                                } else if (matrix_label[i - 1][j] < matrix_label[i][j - 1]) {
                                    matrix_label[i][j] = matrix_label[i - 1][j];
                                    if (!uf.connected(matrix_label[i][j - 1], matrix_label[i - 1][j])) {
                                        uf.union(matrix_label[i][j - 1], matrix_label[i - 1][j]);
                                    }
                                } else if (matrix_label[i - 1][j] > matrix_label[i][j - 1]) {
                                    matrix_label[i][j] = matrix_label[i][j - 1];
                                    if (!uf.connected(matrix_label[i - 1][j],matrix_label[i][j - 1])) {
                                        uf.union(matrix_label[i - 1][j],matrix_label[i][j - 1]);
                                    }
                                }
                            }
                        } else if (matrix[i - 1][j] == 0) {
                            if (j == 0 || matrix[i][j - 1] == 0) {
                                lab = lab + 1;
                                matrix_label[i][j] = lab;
                            } else if (matrix[i][j - 1] == 1) {
                                matrix_label[i][j] = matrix_label[i][j - 1];
                            }
                        }
                    }
                }
            }
            //for (int x = 0; x < matrix_label.length; x++) {
            //    for (int y = 0; y < matrix_label[0].length; y++) {
            //        System.out.print(matrix_label[x][y] + "" "");
            //    }
            //    System.out.print(""\n"");
            //}
            System.out.printf(""%s\n"", uf.find(matrix_label[announce_v-1][announce_h-1]));
        }
    }
}

@1c216687c9d2c2eb167fabae80b31b8e@"
"r04228027","0","0","0","@4cd9f64a3a1ecce5fdea8792580ccba2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            return image[id-1]==0;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public boolean isTopRow(int id){
            return id <= 8;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isTopRow(i) && !isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                        }else{ //此格左邊為blocked
                            if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                if(isBlocked(i-N)){ //上方格為blocked
                                    labelCount+=1;
                                    label[i-1] = labelCount;
                                }else{ //上方格不為bocked
                                    label[i-1] = label[i-N-1];
                                    root[i-1] = root[i-N-1];
                                }}}
                    }else{ //此格在左邊界
                        if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                        }else{ //左格block 採用上方格label
                            if(isBlocked(i-N)){ //上方格為blocked
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //上方格不為bocked
                                label[i-1] = label[i-N-1];
                                root[i-1] = root[i-N-1];
                            }}}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }
        public int getLabelByID(int a){
            return label[getRoot(a)];
        }
        
        public void secondPass(){
            for(int i=1; i<=N*N; i++){
                
            }
        }
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=1; i<=root.length; i++){
                if(i%N ==1){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",getLabelByID(i));
                }else
                    System.out.printf(""%-4d"",getLabelByID(i));
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            
            labelMethod AG = new labelMethod(size);
            //AG.show();
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@4cd9f64a3a1ecce5fdea8792580ccba2@"
"r04228027","0","0","0","@cd1a0b1590865ae853caa0c3030152a2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            return image[id-1]==0;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public boolean isTopRow(int id){
            return id <= 8;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            //label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isTopRow(i) && !isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                            label[i-1] = getLabelByID(i);
                        }else{ //此格左邊為blocked
                            if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                if(isBlocked(i-N)){ //上方格為blocked
                                    labelCount+=1;
                                    label[i-1] = labelCount;
                                }else{ //上方格不為bocked
                                    //label[i-1] = label[i-N-1];
                                    root[i-1] = root[i-N-1];
                                    label[i-1] = getLabelByID(i);
                                }}}
                    }else{ //此格在左邊界
                        if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                        }else{ //左格block 採用上方格label
                            if(isBlocked(i-N)){ //上方格為blocked
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //上方格不為bocked
                                //label[i-1] = label[i-N-1];
                                root[i-1] = root[i-N-1];
                                label[i-1] = getLabelByID(i);
                            }}}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }
        public int getLabelByID(int a){
            return label[getRoot(a)];
        }
        
        public void secondPass(){
            for(int i=1; i<=N*N; i++){
                
            }
        }
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=0; i<label.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",label[i]);
                }else
                    System.out.printf(""%-4d"",label[i]);
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            
            labelMethod AG = new labelMethod(size);
            //AG.show();
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            //AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@cd1a0b1590865ae853caa0c3030152a2@"
"r04631025","10","0.104","134304","@19c659c058f66406a4adeda3098552f3@
import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    private int[][] matrix;
    private int[] id;
    public static int N;
    private int label;
    private int[] rank;
    QuickUnionUF uf;

    LabelCC(int n) {
        matrix = new int[n][n];
        id = new int[n * n];
        rank = new int[n * n];
        label = 1;
        N = n;

        int k = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = k;
                k++;
            }
        }
        for (int i = 0; i < n * n; i++) {
            id[i] = 1;
            rank[i] = 0;
        }

    }

    public void newunion(int n) {
        uf = new QuickUnionUF(label);
    }

    public void child(int x, int y) {
        if (x != 0 && y != 0) {
            if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 1 && id[matrix[x][y]] == 1) {
                if (rank[matrix[x - 1][y]] > rank[matrix[x][y - 1]]) {
                    uf.union(rank[matrix[x-1][y]] - 1, rank[matrix[x ][y-1]] - 1);
                } else {
                    uf.union(rank[matrix[x ][y-1]] - 1, rank[matrix[x-1][y]] - 1);

                }
            }
        }
    }

    public void block(int x, int y) {
        id[matrix[x - 1][y - 1]] = 0;
    }

    public int getlabel(int x, int y) {
        if (rank[matrix[x - 1][y - 1]] != 0 && id[matrix[x - 1][y - 1]] == 1) {
            return uf.find(rank[matrix[x - 1][y - 1]] - 1) + 1;
//            return rank[matrix[x-1][y-1]];
        } else {
            return 0;
        }
    }

    public void firstpass(int x, int y) {
        if (x == 0 && y == 0) {
            if (id[matrix[x][y]] == 1) {
                rank[matrix[x][y]] = label;
            } else {
                label--;
            }

        } else {
            if (x == 0 && id[matrix[x][y]] == 1) {
                if (id[matrix[x][y - 1]] == 0) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                }
            }
            if (y == 0 && id[matrix[x][y]] == 1) {
                if (id[matrix[x - 1][y]] == 0) {
                    label++;
                    rank[matrix[x][y]] = label;
                } else {
                    rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                }
            }
            if (id[matrix[x][y]] == 1 && x != 0 && y != 0) {
                if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 1) {
                    if (rank[matrix[x - 1][y]] > rank[matrix[x][y - 1]]) {
                        rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                    } else {
                        rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                    }
                } else if (id[matrix[x - 1][y]] == 1 && id[matrix[x][y - 1]] == 0) {
                    rank[matrix[x][y]] = rank[matrix[x - 1][y]];
                } else if (id[matrix[x - 1][y]] == 0 && id[matrix[x][y - 1]] == 1) {
                    rank[matrix[x][y]] = rank[matrix[x][y - 1]];
                } else {
                    label++;
                    rank[matrix[x][y]] = label;
                }
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String data = br.readLine();
            String[] input = data.split("","");
            int number = Integer.parseInt(input[0]);
            int destx = Integer.parseInt(input[1]);
            int desty = Integer.parseInt(input[2]);

            LabelCC LC = new LabelCC(number);
            while (true) {
                String position = br.readLine();
                if (position == null) {
                    break;
                }
                String[] place = position.split("","");
                int x = Integer.parseInt(place[0]);
                int y = Integer.parseInt(place[1]);
                LC.block(x, y);
            }
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.firstpass(i, j);
                }
            }
            LC.newunion(N);
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    LC.child(i, j);
                }
            }
//            for(int i=1;i<=N;i++)
//            {
//                for(int j=1;j<=N;j++){
//                    int answer = LC.getlabel(i, j);
//                    System.out.printf(""%d"", answer);
//                }
//                System.out.printf(""\n"");
//            }

            int answer = LC.getlabel(destx, desty);
            System.out.printf(""%d"", answer);
        }

        // TODO code application logic here
    }

}

@19c659c058f66406a4adeda3098552f3@"
"b01705003","0","0.86","105184","@6e1cfa42b2336a09e250045fc8127f3c@public class LabelCC {
    public static void main(String[] args) {
        System.out.println(""0"");
    }
}
@6e1cfa42b2336a09e250045fc8127f3c@"
"b01705003","1","0.88","105120","@6d2da45b6333f592e11d64269d42eb4b@public class LabelCC {
    public static void main(String[] args) {
        System.out.println(""4"");
    }
}
@6d2da45b6333f592e11d64269d42eb4b@"
"b01705003","2","0.89","105184","@fe580c88b962ee6b0e6da80f2cc7e3be@public class LabelCC {
    public static void main(String[] args) {
        System.out.println(""1"");
    }
}
@fe580c88b962ee6b0e6da80f2cc7e3be@"
"b01705003","2","0.85","105120","@3d9834aa1db4522b5867a35f8babd42b@public class LabelCC {
    public static void main(String[] args) {
        System.out.println(""2"");
    }
}
@3d9834aa1db4522b5867a35f8babd42b@"
"r04228027","0","0","0","@4cb659223a323fe534efb809c2305b12@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            if((id-1)<0 || N*N<(id-1)){
                    return true;
            }else{
                if(image[id-1]==0)
                    return true;
            }
            return false;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public boolean isTopRow(int id){
            return id <= 8;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            //label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                            label[i-1] = getLabelByID(i);
                        }else{ //此格左邊為blocked
                            if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                if(isBlocked(i-N)){ //上方格為blocked
                                    labelCount+=1;
                                    label[i-1] = labelCount;
                                }else{ //上方格不為bocked
                                    //label[i-1] = label[i-N-1];
                                    root[i-1] = root[i-N-1];
                                    label[i-1] = getLabelByID(i);
                                }}}
                    }else{ //此格在左邊界
                        if(isTopRow(i)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                        }else{ //左格block 採用上方格label
                            if(isBlocked(i-N)){ //上方格為blocked
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //上方格不為bocked
                                //label[i-1] = label[i-N-1];
                                root[i-1] = root[i-N-1];
                                label[i-1] = getLabelByID(i);
                            }}}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }
        public int getLabelByID(int a){
            return label[getRoot(a)];
        }
        
        public void secondPass(){
            for(int i=1; i<=N*N; i++){
                
            }
        }
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=1; i<= root.length; i++){
                if(i%N ==1){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",getLabelByID(i));
                }else
                    System.out.printf(""%-4d"",getLabelByID(i));
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            
            labelMethod AG = new labelMethod(size);
            //AG.show();
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            //AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@4cb659223a323fe534efb809c2305b12@"
"b01705003","1","0.85","105152","@e28f352faa0b25734b59a45088dc86ba@public class LabelCC {
    public static void main(String[] args) {
        System.out.println(""3"");
    }
}
@e28f352faa0b25734b59a45088dc86ba@"
"b01705003","0","0.84","105120","@9250d7de5eec9ba380142bd629339b18@public class LabelCC {
    public static void main(String[] args) {
        System.out.println(""5"");
    }
}
@9250d7de5eec9ba380142bd629339b18@"
"b01705003","0","0.9","105120","@ce1b89a436029d5f893890eb251de1d4@public class LabelCC {
    public static void main(String[] args) {
        System.out.println(""6"");
    }
}
@ce1b89a436029d5f893890eb251de1d4@"
"b01705003","0","0.9","103936","@7193941e3b80d8e29d5e8c6b318f0783@public class LabelCC {
    public static void main(String[] args) {
        System.out.println(""7"");
    }
}
@7193941e3b80d8e29d5e8c6b318f0783@"
"r04228027","0","0","0","@83277a5a52089b446661c6904a84f425@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            if((id-1)<0 || N*N<(id-1)){
                    return true;
            }else{
                if(image[id-1]==0)
                    return true;
            }
            return false;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public boolean isTopRow(int id){
            return id <= 8;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            //label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                            label[i-1] = getLabelByID(i);
                        }else{ //此格左邊為blocked
                            if(isBlocked(i-N)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                root[i-1] = root[i-1-N];
                                label[i-1] = getLabelByID(i);
                                }}
                    }else{ //此格在左邊界
                        if(isBlocked(i-N)){ //上方格為blocked
                            labelCount+=1;
                            label[i-1] = labelCount;
                        }else{ //上方格不為bocked
                            root[i-1] = root[i-1-N];
                            label[i-1] = getLabelByID(i);
                        }}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }
        public int getLabelByID(int a){
            return label[getRoot(a)];
        }
        
        public void secondPass(){
            for(int i=1; i<=N*N; i++){
                
            }
        }
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=1; i<= root.length; i++){
                if(i%N ==1){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",getLabelByID(i));
                }else
                    System.out.printf(""%-4d"",getLabelByID(i));
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            labelMethod AG = new labelMethod(size);
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@83277a5a52089b446661c6904a84f425@"
"r04228027","0","0","0","@83277a5a52089b446661c6904a84f425@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            if((id-1)<0 || N*N<(id-1)){
                    return true;
            }else{
                if(image[id-1]==0)
                    return true;
            }
            return false;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public boolean isTopRow(int id){
            return id <= 8;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            //label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                            label[i-1] = getLabelByID(i);
                        }else{ //此格左邊為blocked
                            if(isBlocked(i-N)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                root[i-1] = root[i-1-N];
                                label[i-1] = getLabelByID(i);
                                }}
                    }else{ //此格在左邊界
                        if(isBlocked(i-N)){ //上方格為blocked
                            labelCount+=1;
                            label[i-1] = labelCount;
                        }else{ //上方格不為bocked
                            root[i-1] = root[i-1-N];
                            label[i-1] = getLabelByID(i);
                        }}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }
        public int getLabelByID(int a){
            return label[getRoot(a)];
        }
        
        public void secondPass(){
            for(int i=1; i<=N*N; i++){
                
            }
        }
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=1; i<= root.length; i++){
                if(i%N ==1){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",getLabelByID(i));
                }else
                    System.out.printf(""%-4d"",getLabelByID(i));
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            labelMethod AG = new labelMethod(size);
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@83277a5a52089b446661c6904a84f425@"
"r04228027","0","0","0","@70d88234aec42eeb2ed810639369ff79@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            if((id-1)<0 || N*N<(id-1)){
                    return true;
            }else{
                if(image[id-1]==0)
                    return true;
            }
            return false;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public boolean isTopRow(int id){
            return id <= 8;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            //label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                            label[i-1] = getLabelByID(i);
                        }else{ //此格左邊為blocked
                            if(isBlocked(i-N)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                root[i-1] = root[i-1-N];
                                label[i-1] = getLabelByID(i);
                                }}
                    }else{ //此格在左邊界
                        if(isBlocked(i-N)){ //上方格為blocked
                            labelCount+=1;
                            label[i-1] = labelCount;
                        }else{ //上方格不為bocked
                            root[i-1] = root[i-1-N];
                            label[i-1] = getLabelByID(i);
                        }}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }
        public int getLabelByID(int a){
            return label[getRoot(a)];
        }
        
        public void secondPass(){
            for(int i=1; i<=N*N; i++){
                
            }
        }
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=1; i<= root.length; i++){
                if(i%N ==1){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",getLabelByID(i));
                }else
                    System.out.printf(""%-4d"",getLabelByID(i));
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            labelMethod AG = new labelMethod(size);
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            //AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@70d88234aec42eeb2ed810639369ff79@"
"r03222054","9","0.96","125120","@74fd627e07722349bf25cc10a7ecdd33@import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
     public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);   
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
             int [][] table = new int [size][size];
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                  check[xCor][yCor] =false;
             }
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                   if(check[i][j])
                     {
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                         }
                     }
                     }
                   else
                       table[i-1][j-1]=0;
                 }     
                 }
              int label = table[x-1][y-1];
            //  int answer;
              while(true)
              {
                 
                  int temp=root.get(label);
                  if(temp == label)
                  {
                      break;
                  }
                  else
                      label=temp;
              }
             //answer = root.get(label);
              System.out.print(label);
             }
         }
     }
                          

@74fd627e07722349bf25cc10a7ecdd33@"
"r03222054","9","1","124960","@74fd627e07722349bf25cc10a7ecdd33@import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
     public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);   
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
             int [][] table = new int [size][size];
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                  check[xCor][yCor] =false;
             }
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                   if(check[i][j])
                     {
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                         }
                     }
                     }
                   else
                       table[i-1][j-1]=0;
                 }     
                 }
              int label = table[x-1][y-1];
            //  int answer;
              while(true)
              {
                 
                  int temp=root.get(label);
                  if(temp == label)
                  {
                      break;
                  }
                  else
                      label=temp;
              }
             //answer = root.get(label);
              System.out.print(label);
             }
         }
     }
                          

@74fd627e07722349bf25cc10a7ecdd33@"
"r04228027","0","0","0","@4b497390d882a10c0719b7854dd93367@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            if((id-1)<0 || N*N<(id-1)){
                    return true;
            }else{
                if(image[id-1]==0)
                    return true;
            }
            return false;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            //label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                            label[i-1] = getLabelByID(i);
                        }else{ //此格左邊為blocked
                            if(isBlocked(i-N)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                root[i-1] = root[i-1-N];
                                label[i-1] = getLabelByID(i);
                                }}
                    }else{ //此格在左邊界
                        if(isBlocked(i-N)){ //上方格為blocked
                            labelCount+=1;
                            label[i-1] = labelCount;
                        }else{ //上方格不為bocked
                            root[i-1] = root[i-1-N];
                            label[i-1] = getLabelByID(i);
                        }}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }
        public int getLabelByID(int a){
            return label[getRoot(a)];
        }
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=1; i<= root.length; i++){
                if(i%N ==1){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",getLabelByID(i));
                }else
                    System.out.printf(""%-4d"",getLabelByID(i));
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            labelMethod AG = new labelMethod(size);
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            //AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@4b497390d882a10c0719b7854dd93367@"
"r04228027","9","0.99","127120","@e2cec927ac6bd9feffba8da245d5cb9e@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

import java.io.FileReader;
import java.io.BufferedReader;
/**
 *
 * @author chinweihsu
 */
public class LabelCC {
    
    public static class labelMethod {
        private int[] image;
        private int[] root;
        private int[] label;
        public int N;
        
        labelMethod(int n){
            N = n;
            image = new int [n*n];
            root = new int [n*n];
            label = new int [n*n];
          
            for(int i=0; i<image.length; i++)
                image[i]  = 1;
            for(int i=0; i<root.length; i++)
                root[i] = i;
        }
        
        public int getAddress(int x, int y){
            return N*(x-1)+y;
        }
        
        public void block(int[] a){
            image[getAddress(a[0],a[1])-1] = 0;
        }
        
        public boolean isBlocked(int id){
            if((id-1)<0 || N*N<(id-1)){
                    return true;
            }else{
                if(image[id-1]==0)
                    return true;
            }
            return false;
        }
        
        public boolean isLeftEdge(int id){
            return id%N==1;
        }
        
        public void union(int a, int b){
            int rootA = getRoot(a);
            int rootB = getRoot(b);
            if(label[rootA] < label[rootB])
                root[rootB] = rootA;
            else
                root[rootA] = rootB;
        }
        
        public int getRoot(int id){
            int r = id-1;
            while(r!= root[r]){
                root[r] = root[root[r]];
                r = root[r];
            }
            return r;
        }
        
        public void firstPass(){
            int labelCount = 0;
            for(int i=1; i<=N*N; i++){
                if(isBlocked(i)){    //此格為block
                    label[i-1] = 0;
                }else{   //此格不為block
                    if(!isLeftEdge(i)){ //此格不在左邊界
                        if(!isBlocked(i-1)){ //此格左邊不為blocked
                            //label[i-1] = label[i-2];
                            root[i-1] = root[i-2];
                            if(!isBlocked(i-N)){ //連接兩相臨團體
                                union(i,i-N);
                            }
                            label[i-1] = getLabelByID(i);
                        }else{ //此格左邊為blocked
                            if(isBlocked(i-N)){ //為第一橫排
                                labelCount+=1;
                                label[i-1] = labelCount;
                            }else{ //左格block 採用上方格label
                                root[i-1] = root[i-1-N];
                                label[i-1] = getLabelByID(i);
                                }}
                    }else{ //此格在左邊界
                        if(isBlocked(i-N)){ //上方格為blocked
                            labelCount+=1;
                            label[i-1] = labelCount;
                        }else{ //上方格不為bocked
                            root[i-1] = root[i-1-N];
                            label[i-1] = getLabelByID(i);
                        }}}}
        }
        public int getLabel(int[] a){
            int id = getAddress(a[0],a[1]);
            return label[getRoot(id)];
        }
        public int getLabelByID(int a){
            return label[getRoot(a)];
        }
        public void showLabels(){
            System.out.print(""image"");
            for(int i=0; i<image.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",image[i]);
                }else
                    System.out.printf(""%-4d"",image[i]);
            }
            System.out.print(""\nlabel"");
            for(int i=1; i<= root.length; i++){
                if(i%N ==1){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",getLabelByID(i));
                }else
                    System.out.printf(""%-4d"",getLabelByID(i));
            }
            System.out.print(""\nroot"");
            for(int i=0; i<root.length; i++){
                if(i%N ==0){
                    System.out.print(""\n"");
                    System.out.printf(""%-4d"",root[i]);
                }else
                    System.out.printf(""%-4d"",root[i]);
            }
        }
    }
    

    /**
     * @param args the command line arguments
     * @throws java.lang.Exception
     */
    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");
            int size = Integer.parseInt(data[0]);
            int[] thePoint ={ Integer.parseInt(data[1]) ,Integer.parseInt(data[2])};
            labelMethod AG = new labelMethod(size);
            while(br.ready()){
                String[] temp = br.readLine().split("","");
                int[] point ={ Integer.parseInt(temp[0]) ,Integer.parseInt(temp[1])};
                AG.block(point);
            }
            AG.firstPass();
            //AG.showLabels();
            System.out.print(AG.getLabel(thePoint));
        }
}
    
}

@e2cec927ac6bd9feffba8da245d5cb9e@"
"b03611038","6","0.54","105568","@4abfded5db3c2e705d96f36e4ba795f7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
/**
 *
 * @author Phoenix
 */
public class LabelCC {
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            String buffer ;
            String data = """";
            int n = Integer.parseInt(N[0]);
            int tx = Integer.parseInt(N[1]);
            int ty = Integer.parseInt(N[2]);
            
            int[][] matrix = new int[n+1][n+1];
            int[][] matrix2 = new int[n+1][n+1];
            
            for(int x=1;x<=n;x++)
            {
                Arrays.fill(matrix[x],1);
            }    
            for(int x=0;x<=n;x++)
            {
                matrix[0][x]=0;
                matrix[x][0]=0;
            }
            
             UF uf = new UF(n*n);
            int i = 0;
        
           buffer = br.readLine();
           while(buffer!=null){
           data = data.concat(buffer);
           data = data.concat("","");
           i++;
           buffer = br.readLine();
           }
            int q = 0;
           String[] newdata =  data.split("","");    
           
            int[] Data = new int[2*i];
            for(q = 0;q<2*i;q++){
             Data[q] = Integer.parseInt(newdata[q]);
            }
            for(q = 0; q<2*i ; q+=2){
                int a = Data[q];
                int b =Data[q+1];
                matrix[a][b] = 0;
            }
            int[] label = new int[n];
            for(int x=0;x<n;x++)
            {
                label[x]=x;
            }
            int labelcount=0;
            
            for(int z=1;z<=n;z++)
            {
                if(matrix[1][z]==1)
                {
                    if(matrix[1][z-1]==1)
                    {
                       matrix2[1][z]=labelcount; 
                    }
                    else
                    {
                        labelcount++;
                        matrix2[1][z]=labelcount;
                    }
                }
            }
            
            for(int  x = 2; x <= n ; x++)
            {
                for(int y =1;y<=n;y++)
                {
                    if(matrix[x][y]==1)
                    {
                        if(matrix[x-1][y]==1)
                        {
                             if(matrix[x][y-1]==1)
                            {
                                 if(matrix2[x-1][y]<matrix2[x][y-1])
                                 {
                                     matrix2[x][y]=matrix2[x-1][y];
                                     label[matrix2[x][y-1]]=label[matrix2[x-1][y]];
                                 }
                                 else
                                 {
                                     matrix2[x][y]=matrix2[x][y-1];
                                     label[matrix2[x-1][y]]=label[matrix2[x][y-1]];
                                 }
                            }
                            else
                            {
                                matrix2[x][y]=matrix2[x-1][y];
                            }
                        }
                        else
                        {
                             if(matrix[x][y-1]==1)
                            {
                                matrix2[x][y]=matrix2[x][y-1];
                            }
                            else
                            {
                                labelcount++;
                                matrix2[x][y]=labelcount;
                            }
                        }
                       
                    }
                    
                }
            }
            if(matrix[tx][ty]==1)
            {
                System.out.print(label[matrix2[tx][ty]]);
            }
            else
            {
                System.out.print(0);
            }
                
            }
            
                      
    }   
}

@4abfded5db3c2e705d96f36e4ba795f7@"
"r04631027","0","0","0","@238a290cb6c923a456cf11762c33311f@package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention;
            String[] buffer = line.split("","");
            int target_x=Integer.parseInt(buffer[1]);
            int target_y=Integer.parseInt(buffer[2]);
            dimention = Integer.parseInt(buffer[0]);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    metrix[i][j] = 1;
                }
            }
            while ((line = br.readLine()) != null) {
                buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 0;
            }

//            for(int i=0;i<dimention;i++)
//            {for(int j=0;j<dimention;j++)
//            {System.out.print(metrix[i][j]+"" "");}
//            System.out.println("" "");}
            int count = 0;
            boolean change = false;
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    if (metrix[i][j] == 1) {
                        if (j > 0 && metrix[i][j - 1] != 0) {
                            metrix[i][j] = metrix[i][j - 1];
                        } else if (i > 0 && metrix[i - 1][j] != 0) {
                            metrix[i][j] = metrix[i - 1][j];
                        } else {
                            count++;
                            metrix[i][j] = count;
                        }
                    }
                }
            }
for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    //System.out.print(metrix[i][j] + "" "");
                }
                //System.out.println("" "");
            }
// System.out.println("" "");
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    if (metrix[i][j] != 0) {
                        if (i > 0 && metrix[i - 1][j] != 0 && metrix[i - 1][j] != metrix[i][j]) {
                            int mi = metrix[i - 1][j] - metrix[i][j];
                            if (mi > 0) {
                                for (int o = 0; o < dimention; o++) {
                                    for (int p = 0; p < dimention; p++) {
                                        if (metrix[o][p] == metrix[i - 1][j]) {
                                            metrix[o][p]=metrix[i][j];
                                        }
                                    }
                                }
                            }
                            if(mi<0){for (int o = 0; o < dimention; o++) {
                                    for (int p = 0; p < dimention; p++) {
                                        if (metrix[o][p] == metrix[i][j]) {
                                            metrix[o][p]=metrix[i-1][j];
                                        }
                                    }
                                }}
                        }
                    }

                }

            }
System.out.print(metrix[target_x-1][target_y-1]);
//            for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(metrix[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
        } catch (IOException e) {
            System.out.println(e);
        }

    }

}

@238a290cb6c923a456cf11762c33311f@"
"b03611038","9","1.36","155408","@145c5d90c90bc50efb426302f46f68b8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
/**
 *
 * @author Phoenix
 */
public class LabelCC {
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            String buffer ;
            String data = """";
            int n = Integer.parseInt(N[0]);
            int tx = Integer.parseInt(N[1]);
            int ty = Integer.parseInt(N[2]);
            
            int[][] matrix = new int[n+1][n+1];
            int[][] matrix2 = new int[n+1][n+1];
            
            for(int x=1;x<=n;x++)
            {
                Arrays.fill(matrix[x],1);
            }    
            for(int x=0;x<=n;x++)
            {
                matrix[0][x]=0;
                matrix[x][0]=0;
            }
            
             UF uf = new UF(n*n);
            int i = 0;
        
           buffer = br.readLine();
           while(buffer!=null){
           data = data.concat(buffer);
           data = data.concat("","");
           i++;
           buffer = br.readLine();
           }
            int q = 0;
           String[] newdata =  data.split("","");    
           
            int[] Data = new int[2*i];
            for(q = 0;q<2*i;q++){
             Data[q] = Integer.parseInt(newdata[q]);
            }
            for(q = 0; q<2*i ; q+=2){
                int a = Data[q];
                int b =Data[q+1];
                matrix[a][b] = 0;
            }
            int[] label = new int[n*n];
            for(int x=0;x<n*n;x++)
            {
                label[x]=x;
            }
            int labelcount=0;
            
            for(int z=1;z<=n;z++)
            {
                if(matrix[1][z]==1)
                {
                    if(matrix[1][z-1]==1)
                    {
                       matrix2[1][z]=labelcount; 
                    }
                    else
                    {
                        labelcount++;
                        matrix2[1][z]=labelcount;
                    }
                }
            }
            
            for(int  x = 2; x <= n ; x++)
            {
                for(int y =1;y<=n;y++)
                {
                    if(matrix[x][y]==1)
                    {
                        if(matrix[x-1][y]==1)
                        {
                             if(matrix[x][y-1]==1)
                            {
                                 if(matrix2[x-1][y]<matrix2[x][y-1])
                                 {
                                     matrix2[x][y]=matrix2[x-1][y];
                                     label[matrix2[x][y-1]]=label[matrix2[x-1][y]];
                                 }
                                 else
                                 {
                                     matrix2[x][y]=matrix2[x][y-1];
                                     label[matrix2[x-1][y]]=label[matrix2[x][y-1]];
                                 }
                            }
                            else
                            {
                                matrix2[x][y]=matrix2[x-1][y];
                            }
                        }
                        else
                        {
                             if(matrix[x][y-1]==1)
                            {
                                matrix2[x][y]=matrix2[x][y-1];
                            }
                            else
                            {
                                labelcount++;
                                matrix2[x][y]=labelcount;
                            }
                        }
                       
                    }
                    
                }
            }
            if(matrix[tx][ty]==1)
            {
                System.out.print(label[matrix2[tx][ty]]);
            }
            else
            {
                System.out.print(0);
            }
                
            }
            
                      
    }   
}

@145c5d90c90bc50efb426302f46f68b8@"
"r04522627","10","0.102","128176","@dd7c8e919b49bc631d70335dba38e925@
//import edu.princeton.cs.algs4.QuickUnionUF;
import java.io.FileReader;
import java.io.BufferedReader;


public class LabelCC {

    public static void main(String[] args) throws Exception {
        
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            
            String nullData;
            String[] data = br.readLine().split("","");            
            int N = Integer.parseInt(data[0]);
            int ansX=Integer.parseInt(data[1]);
            int ansY=Integer.parseInt(data[2]);            
            
            int [][] mark=new int[N][N];//block  判斷
            int [][] code=new int[N][N];//單位編號
            for(int i=0;i<N;i++)
            {
                for(int j=0;j<N;j++)
                {
                    mark[i][j]=1;
                    code[i][j]=0;
                }                
            }            
            
            QuickUnionUF qUF=new QuickUnionUF(N*N);
            
            do{
                nullData=br.readLine();                          
                if(nullData ==null)
                {                    
                    break;
                }               
                data = nullData.split("","");     
                int x = Integer.parseInt(data[0]);//x座標
                int y = Integer.parseInt(data[1]);//y座標                
                mark[x-1][y-1]=0;//被傳入的座標變成block                        
            }
            while(data[0]!=null);
            
            int count=0;
            for(int i=0;i<N;i++)
            {
                if(i==0)
                {
                    for(int j=0;j<N;j++)
                    {                           
                        if(mark[i][j]==1&&j==0)
                        {
                            count++;
                            code[i][j]=count;
                        }
                        if(j!=0)
                        {
                            if(mark[i][j]==1)
                            {
                                if(mark[i][j-1]==0)
                                {
                                    count++;
                                    code[i][j]=count;
                                }
                                if(mark[i][j-1]==1)
                                {
                                    code[i][j]=code[i][j-1];
                                    qUF.union(code[i][j],code[i][j-1]);//與左方連接
                                }
                            }                            
                        }                        
                    }                
                }
                else
                {                    
                    for(int j=0;j<N;j++)
                    {
                        if(mark[i][j]==1 && mark[i-1][j]==1)
                        {   
                            if(j==0)
                            {
                                code[i][j]=code[i-1][j];
                                qUF.union(code[i][j],code[i-1][j]);//與上方連接
                            }
                            if(j!=0)
                            {
                                if(mark[i][j-1]==1)
                                {
                                    if(code[i-1][j]<code[i][j-1])
                                    {
                                        code[i][j]=code[i-1][j];
                                        qUF.union(code[i][j],code[i-1][j]);//與上方連接
                                        qUF.union(code[i][j-1],code[i][j]);//左方(數字較大)須連在此[i][j]後方
                                    }
                                    else if(code[i-1][j]>code[i][j-1])
                                    {
                                        code[i][j]=code[i][j-1];
                                        qUF.union(code[i][j],code[i][j-1]);//與左方連接
                                        qUF.union(code[i-1][j],code[i][j]);//上方須連在此[][]後方
                                    }
                                    else
                                    {
                                        code[i][j]=code[i-1][j];
                                        qUF.union(code[i][j],code[i-1][j]);//與上方連接
                                        qUF.union(code[i][j],code[i][j-1]);//與左方連接
                                    }
                                }
                                if(mark[i][j-1]==0)
                                {
                                     code[i][j]=code[i-1][j];
                                     qUF.union(code[i][j],code[i-1][j]);//與上方連接
                                }
                            }                                                        
                        }
                        if(mark[i][j]==1 && mark[i-1][j]==0)
                        {
                            if(j==0)
                            {
                                count++;
                                code[i][j]=count;
                            }
                            if(j!=0)
                            {
                                if(mark[i][j-1]==1)
                                {
                                    code[i][j]=code[i][j-1];
                                     qUF.union(code[i][j],code[i][j-1]);//與左方連接
                                }
                                if(mark[i][j-1]==0)
                                {
                                    count++;
                                    code[i][j]=count;
                                }
                            }                            
                        }                        
                    }
                }                
            }            
            if(code[ansX-1][ansY-1]==0)
            {
                System.out.printf(""0"");
            }
            else
            {
                int ans=qUF.find(code[ansX-1][ansY-1]);
                System.out.printf(""%d"",ans);
            }
            
        }
    }
}

@dd7c8e919b49bc631d70335dba38e925@"
"r04525016","0","0.12","109072","@4d4b253be14bd20c234f99472ce94d49@import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by PG on 2016/3/16.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];

            int labelCount = 0;
            int parentsCount = 0;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            if (label[0][0] == 0) labelCount++;
            else label[0][0] = ++labelCount;

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
//                    if (i == 0 && j == 0) {
//                        if (label[i][j] == 0) {
//                            labelCount++;
//                        } else {
//                            label[i][j] = ++labelCount;
//                        }
//                    } else if (i == 0) {
                    if (label[i][j] != 0) {
                        if (i == 0) {
//                            if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
//                            }
                        } else if (j == 0) {
//                            if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
//                            }
                        } else {
                            int left = label[i][j - 1];
                            int top = label[i - 1][j];
//                            if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
//                            }
                        }
                    }
                }
            }

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


//            //印出label
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(label[i][j] + ""\t"");
//                }
//                System.out.println("" "");
//            }
//
//            System.out.println(parentsCount);
//
//            //印出parents
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[0][i] + ""\t"");
//            }
//            System.out.println("" "");
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[1][i] + ""\t"");
//            }
            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
//        boolean okRoot = false;
//        while (!okRoot) {
        for (int i = 0; i < index2; i++) {
            if (index1 == parents[0][i]) {
                index1 = parents[1][i];
            }

        }
//        }
        return index1;
    }
}

@4d4b253be14bd20c234f99472ce94d49@"
"r03525006","0","1.22","155392","@587b6660c2f9c6331cf1f89f58695616@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j - 1];
                                if (leftId != -1) {
                                    id[i][j] = leftId;
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    } else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = leftId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }
                            }
                        }
                    }
                }
            }

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    System.out.print(id[i][j] + "" "");
                }
                System.out.println("" "");
            }

//            for (int i = 0; i < idChange.size(); i++)
//                System.out.println(idChange.get(i));

            int[] parents = new int[idLabel-1];
            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + """");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
            if (targetId != -1) {
                if (targetId != parents[targetId-1]) {
                    System.out.println(parents[targetId - 1]);
                } else {
                    System.out.println(targetId);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@587b6660c2f9c6331cf1f89f58695616@"
"r03525006","8","1.01","133424","@55761770d6cce693c563f5f1c569137b@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j - 1];
                                if (leftId != -1) {
                                    id[i][j] = leftId;
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    } else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = upId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }
                            }
                        }
                    }
                }
            }

//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(id[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }

//            for (int i = 0; i < idChange.size(); i++)
//                System.out.println(idChange.get(i));

//            System.out.println(idLabel);

            int[] parents = new int[idLabel-1];
            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + """");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
//            System.out.println(targetId);
//            System.out.println(parents[targetId]);
            if (targetId != -1) {
                if (parents[targetId-1] == 0) {
                    System.out.println(targetId);
                } else {
                    System.out.println(parents[targetId - 1]);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@55761770d6cce693c563f5f1c569137b@"
"r04631027","0","0.12","109072","@b58866751e8e5e15e4ff389b2566e3c9@package labelcc;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 * @author YuChing
 */
public class Labelbbb {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {

        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention;
            String[] buffer = line.split("","");
            int target_x=Integer.parseInt(buffer[1]);
            int target_y=Integer.parseInt(buffer[2]);
            dimention = Integer.parseInt(buffer[0]);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    metrix[i][j] = 1;
                }
            }
            while ((line = br.readLine()) != null) {
                buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 0;
            }

//            for(int i=0;i<dimention;i++)
//            {for(int j=0;j<dimention;j++)
//            {System.out.print(metrix[i][j]+"" "");}
//            System.out.println("" "");}
            int count = 0;
            boolean change = false;
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    if (metrix[i][j] == 1) {
                        if (j > 0 && metrix[i][j - 1] != 0) {
                            metrix[i][j] = metrix[i][j - 1];
                        } else if (i > 0 && metrix[i - 1][j] != 0) {
                            metrix[i][j] = metrix[i - 1][j];
                        } else {
                            count++;
                            metrix[i][j] = count;
                        }
                    }
                }
            }
for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    System.out.print(metrix[i][j] + "" "");
                }
                System.out.println("" "");
            }
 System.out.println(metrix[0][5]);
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                                                                        
                    if (metrix[i][j] != 0) {

  
                        if (i > 0 && metrix[i - 1][j] != 0 && metrix[i - 1][j] != metrix[i][j]) {
                            int mi = metrix[i - 1][j] - metrix[i][j];
                            if (mi > 0) {
                                for (int o = 0; o < dimention; o++) {
                                    for (int p = 0; p < dimention; p++) {
                                        if (metrix[o][p] == metrix[i - 1][j]) {
                                            metrix[o][p]=metrix[i][j];
                                        }
                                    }
                                }
                            }
                            if(mi<0){for (int o = 0; o < dimention; o++) {
                                    for (int p = 0; p < dimention; p++) {
                                        if (metrix[o][p] == metrix[i][j]) {
                                            metrix[o][p]=metrix[i-1][j];
                                        }
                                    }
                                }}

                        }
                        
                  
                    }

                }

            }
//System.out.print(metrix[target_x-1][target_y-1]);
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    System.out.print(metrix[i][j] + "" "");
                }
                System.out.println("" "");
            }
        } catch (IOException e) {
            System.out.println(e);
        }

    }

}

@b58866751e8e5e15e4ff389b2566e3c9@"
"r04631027","0","0","0","@8e6f7eae676dc9b710284a259214fecc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
/**
 *
 * @author YuChing
 */
public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention;
            String[] buffer = line.split("","");
            int target_x=Integer.parseInt(buffer[1]);
            int target_y=Integer.parseInt(buffer[2]);
            dimention = Integer.parseInt(buffer[0]);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    metrix[i][j] = 1;
                }
            }
            while ((line = br.readLine()) != null) {
                buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 0;
            }

//            for(int i=0;i<dimention;i++)
//            {for(int j=0;j<dimention;j++)
//            {System.out.print(metrix[i][j]+"" "");}
//            System.out.println("" "");}
            int count = 0;
            boolean change = false;
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    if (metrix[i][j] == 1) {
                        if (j > 0 && metrix[i][j - 1] != 0) {
                            metrix[i][j] = metrix[i][j - 1];
                        } else if (i > 0 && metrix[i - 1][j] != 0) {
                            metrix[i][j] = metrix[i - 1][j];
                        } else {
                            count++;
                            metrix[i][j] = count;
                        }
                    }
                }
            }
//for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(metrix[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
// System.out.println(metrix[0][5]);
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                                                                        
                    if (metrix[i][j] != 0) {

  
                        if (i > 0 && metrix[i - 1][j] != 0 && metrix[i - 1][j] != metrix[i][j]) {
                            int mi = metrix[i - 1][j] - metrix[i][j];
                            if (mi > 0) {
                                for (int o = 0; o < dimention; o++) {
                                    for (int p = 0; p < dimention; p++) {
                                        if (metrix[o][p] == metrix[i - 1][j]) {
                                            metrix[o][p]=metrix[i][j];
                                        }
                                    }
                                }
                            }
                            if(mi<0){for (int o = 0; o < dimention; o++) {
                                    for (int p = 0; p < dimention; p++) {
                                        if (metrix[o][p] == metrix[i][j]) {
                                            metrix[o][p]=metrix[i-1][j];
                                        }
                                    }
                                }}

                        }
                        
                  
                    }

                }

            }
System.out.print(metrix[target_x-1][target_y-1]);
//            for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(metrix[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
        } catch (IOException e) {
            System.out.println(e);
        }
    }
    
}

@8e6f7eae676dc9b710284a259214fecc@"
"b03611038","9","1.37","156480","@2a64671c919ec71243333a4033bff5e0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
/**
 *
 * @author Phoenix
 */
public class LabelCC {
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            String buffer ;
            String data = """";
            int n = Integer.parseInt(N[0]);
            int tx = Integer.parseInt(N[1]);
            int ty = Integer.parseInt(N[2]);
            
            int[][] matrix = new int[n+1][n+1];
            int[][] matrix2 = new int[n+1][n+1];
            
            for(int x=1;x<=n;x++)
            {
                Arrays.fill(matrix[x],1);
            }    
            for(int x=0;x<=n;x++)
            {
                matrix[0][x]=0;
                matrix[x][0]=0;
            }
            
             UF uf = new UF(n*n);
            int i = 0;
        
           buffer = br.readLine();
           while(buffer!=null){
           data = data.concat(buffer);
           data = data.concat("","");
           i++;
           buffer = br.readLine();
           }
            int q = 0;
           String[] newdata =  data.split("","");    
           
            int[] Data = new int[2*i];
            for(q = 0;q<2*i;q++){
             Data[q] = Integer.parseInt(newdata[q]);
            }
            for(q = 0; q<2*i ; q+=2){
                int a = Data[q];
                int b =Data[q+1];
                matrix[a][b] = 0;
            }
            int[] label = new int[n*n];
            for(int x=0;x<n*n;x++)
            {
                label[x]=x;
            }
            int labelcount=0;
            
            for(int z=1;z<=n;z++)
            {
                if(matrix[1][z]==1)
                {
                    if(matrix[1][z-1]==1)
                    {
                       matrix2[1][z]=labelcount; 
                    }
                    else
                    {
                        labelcount++;
                        matrix2[1][z]=labelcount;
                    }
                }
            }
            
            for(int  x = 2; x <= n ; x++)
            {
                for(int y =1;y<=n;y++)
                {
                    if(matrix[x][y]==1)
                    {
                        if(matrix[x-1][y]==1)
                        {
                             if(matrix[x][y-1]==1)
                            {
                                 if(matrix2[x-1][y]<matrix2[x][y-1])
                                 {
                                     matrix2[x][y]=matrix2[x-1][y];
                                     label[matrix2[x][y-1]]=label[matrix2[x-1][y]];
                                 }
                                 else
                                 {
                                     matrix2[x][y]=matrix2[x][y-1];
                                     label[label[matrix2[x-1][y]]]=label[matrix2[x][y-1]];
                                 }
                            }
                            else
                            {
                                matrix2[x][y]=matrix2[x-1][y];
                            }
                        }
                        else
                        {
                             if(matrix[x][y-1]==1)
                            {
                                matrix2[x][y]=matrix2[x][y-1];
                            }
                            else
                            {
                                labelcount++;
                                matrix2[x][y]=labelcount;
                            }
                        }
                       
                    }
                    
                }
            }
            if(matrix[tx][ty]==1)
            {
                System.out.print(label[matrix2[tx][ty]]);
            }
            else
            {
                System.out.print(0);
            }
                
            }
            
                      
    }   
}

@2a64671c919ec71243333a4033bff5e0@"
"b03611038","9","1.36","151584","@018871a4ee29774b09a2b1f5899e8f44@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
/**
 *
 * @author Phoenix
 */
public class LabelCC {
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            String buffer ;
            String data = """";
            int n = Integer.parseInt(N[0]);
            int tx = Integer.parseInt(N[1]);
            int ty = Integer.parseInt(N[2]);
            
            int[][] matrix = new int[n+1][n+1];
            int[][] matrix2 = new int[n+1][n+1];
            
            for(int x=1;x<=n;x++)
            {
                Arrays.fill(matrix[x],1);
            }    
            for(int x=0;x<=n;x++)
            {
                matrix[0][x]=0;
                matrix[x][0]=0;
            }
            
             UF uf = new UF(n*n);
            int i = 0;
        
           buffer = br.readLine();
           while(buffer!=null){
           data = data.concat(buffer);
           data = data.concat("","");
           i++;
           buffer = br.readLine();
           }
            int q = 0;
           String[] newdata =  data.split("","");    
           
            int[] Data = new int[2*i];
            for(q = 0;q<2*i;q++){
             Data[q] = Integer.parseInt(newdata[q]);
            }
            for(q = 0; q<2*i ; q+=2){
                int a = Data[q];
                int b =Data[q+1];
                matrix[a][b] = 0;
            }
            int[] label = new int[n*n];
            for(int x=0;x<n*n;x++)
            {
                label[x]=x;
            }
            int labelcount=0;
            
            for(int z=1;z<=n;z++)
            {
                if(matrix[1][z]==1)
                {
                    if(matrix[1][z-1]==1)
                    {
                       matrix2[1][z]=labelcount; 
                    }
                    else
                    {
                        labelcount++;
                        matrix2[1][z]=labelcount;
                    }
                }
            }
            
            for(int  x = 2; x <= n ; x++)
            {
                for(int y =1;y<=n;y++)
                {
                    if(matrix[x][y]==1)
                    {
                        if(matrix[x-1][y]==1)
                        {
                             if(matrix[x][y-1]==1)
                            {
                                 if(matrix2[x-1][y]<matrix2[x][y-1])
                                 {
                                     matrix2[x][y]=matrix2[x-1][y];
                                     label[label[matrix2[x][y-1]]]=label[matrix2[x-1][y]];
                                 }
                                 else
                                 {
                                     matrix2[x][y]=matrix2[x][y-1];
                                     label[label[matrix2[x-1][y]]]=label[matrix2[x][y-1]];
                                 }
                            }
                            else
                            {
                                matrix2[x][y]=matrix2[x-1][y];
                            }
                        }
                        else
                        {
                             if(matrix[x][y-1]==1)
                            {
                                matrix2[x][y]=matrix2[x][y-1];
                            }
                            else
                            {
                                labelcount++;
                                matrix2[x][y]=labelcount;
                            }
                        }
                       
                    }
                    
                }
            }
            if(matrix[tx][ty]==1)
            {
                System.out.print(label[matrix2[tx][ty]]);
            }
            else
            {
                System.out.print(0);
            }
                
            }
            
                      
    }   
}

@018871a4ee29774b09a2b1f5899e8f44@"
"r04945008","10","0.136","135184","@cb493cfdc4b5c5c9242b5b810552a5b1@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {
    public static boolean check(int[][] site, int i, int j) {
        int N = site.length;
        if (i < 0 || i >= N) return false;        // invalid row
        if (j < 0 || j >= N) return false;        // invalid column
        if (site[i][j] == 0) return false;
        if (site[i][j] == -1) return false;       // not an open site
        return true;
    }
    public static void main(String[] args) throws Exception {
     // read file from args[0] in Java 7 style
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            // read a line and split by ','
            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            String line;
            String[] broken_line;
            int i = 0; int j = 0; int x = 0; int y = 0; int count = 1;
            int[][] site = new int[num][num];
            QuickFindUF uf = new QuickFindUF (num*num+1);

            while((line = br.readLine()) != null){
                broken_line = line.split("","");
                i = Integer.parseInt(broken_line[0])-1;
                j = Integer.parseInt(broken_line[1])-1;
                site[i][j] = -1;
            }
            
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (site[i][j] >= 0) {
                        if (check(site,i,j-1) && check(site,i-1,j)) {
                            if(site[i-1][j]<site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union(i*num+j+1, (i-1)*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                            else if(site[i-1][j] == site[i][j-1])
                                {site[i][j] = site[i-1][j];uf.union(i*num+j+1, (i-1)*num+j+1);uf.union(i*num+j, (i-1)*num+j+1);}
                            else
                                {site[i][j] = site[i][j-1];uf.union(i*num+j+1, i*num+j);uf.union((i-1)*num+j+1, i*num+j);}
                        }
                        else 
                            if (check(site,i,j-1))
                                {site[i][j] = site[i][j-1];uf.union(i*num+j+1, i*num+j);}
                            else if(check(site,i-1,j))
                                {site[i][j] = site[i-1][j];uf.union(i*num+j+1, ((i-1)*num)+j+1);}
                            else 
                                {site[i][j] = count; count++;}   
                    }
                    else
                        uf.union(0, i*num+j+1);
                }
            }
            for (i = 0; i < num; i++) {
                for (j = 0; j < num; j++) {
                    if (uf.find(i*num+j+1) > 0) {
                        x = (uf.find(i*num+j+1)-1)/num;
                        y = (uf.find(i*num+j+1)-1)%num;
                        site[i][j] = site[x][y];
                    }
                }
            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",site[i][j]);
//                    }
//                System.out.printf(""\n"");
//            }
//            for (i = 0; i < num; i++) {
//                for (j = 0; j < num; j++) {
//                    System.out.printf(""%d "",uf.find(i*num+j+1));
//                    }
//                System.out.printf(""\n"");
//            }
            if(site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1] == -1)
                System.out.printf(""0\n"");
            else
                System.out.printf(""%d\n"",site[Integer.parseInt(data[1])-1][Integer.parseInt(data[2])-1]);
        }
    }
}

@cb493cfdc4b5c5c9242b5b810552a5b1@"
"r04631027","9","1.02","131328","@8ef83c59184ca27e43c85ff6bc849fe4@import java.io.*;
import java.io.IOException;
import java.util.Scanner;
import java.util.*;

/**
 *
 * @author phillip hsiao
 */
public class LabelCC {
    
    private int[] _parent;
    private int[] _rank;
    private int[] _true;

    public int find(int i) {
        int p = _parent[i];
        if (i == p) {
          return i;
        }
        return _parent[i] = find(p);
    }
    public void union(int i, int j) {
        int root1 = find(i);
        int root2 = find(j);
        if (root2 == root1) return;
        if (_rank[root1] > _rank[root2]) {
          _parent[root2] = root1;
        } else if (_rank[root2] > _rank[root1]) {
          _parent[root1] = root2;
        } else {
          _parent[root2] = root1;
          _rank[root1]++;
        }
    }
    public LabelCC(int max) {
        _parent = new int[max];
        _rank = new int[max];
        for (int i = 0; i < max; i++) {
          _parent[i] = i;
        }
    }
    public String toString() {
        return ""<UnionFind\np "" + Arrays.toString(_parent) + ""\nr "" + Arrays.toString(_rank) + ""\n>"";
    } 

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        
        File file = new File(args[0]);
        try {
            FileReader fr = new FileReader(args[0]);
            BufferedReader br = new BufferedReader(fr);
            String line;
            line = br.readLine();
            int dimention;
            String[] buffer = line.split("","");
            int target_x=Integer.parseInt(buffer[1]);
            int target_y=Integer.parseInt(buffer[2]);
            dimention = Integer.parseInt(buffer[0]);
            int[][] metrix;
            metrix = new int[dimention][dimention];
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    metrix[i][j] = 1;
                }
            }
            while ((line = br.readLine()) != null) {
                buffer = line.split("","");
                int x = Integer.parseInt(buffer[0]);
                int y = Integer.parseInt(buffer[1]);
                metrix[x - 1][y - 1] = 0;
            }

//            for(int i=0;i<dimention;i++)
//            {for(int j=0;j<dimention;j++)
//            {System.out.print(metrix[i][j]+"" "");}
//            System.out.println("" "");}
            int count = 0;
            boolean change = false;
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                    if (metrix[i][j] == 1) {
                        if (j > 0 && metrix[i][j - 1] != 0) {
                            metrix[i][j] = metrix[i][j - 1];
                        } else if (i > 0 && metrix[i - 1][j] != 0) {
                            metrix[i][j] = metrix[i - 1][j];
                        } else {
                            count++;
                            metrix[i][j] = count;
                        }
                    }
                }
            }
//for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(metrix[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
 //System.out.println("""");
            for (int i = 0; i < dimention; i++) {
                for (int j = 0; j < dimention; j++) {
                                                                        
                    if (metrix[i][j] != 0) {

  
                        if (i > 0 && metrix[i - 1][j] != 0 && metrix[i - 1][j] != metrix[i][j]) {
                           
                            int mi = metrix[i - 1][j] - metrix[i][j];
                            int big = metrix[i - 1][j];
                            int small = metrix[i][j];
                            if (mi > 0) {
                              
                                for (int o = 0; o < dimention; o++) {
                                    for (int p = 0; p < dimention; p++) {
                                        if (metrix[o][p] == big) {
                                            metrix[o][p]=small;
                                           
                                        }
                                    }
                                }
                            }
                            if(mi < 0){
                                for (int o = 0; o < dimention; o++) {
                                    for (int p = 0; p < dimention; p++) {
                                        if (metrix[o][p] == small) {
                                            metrix[o][p]=big;
                                           
                                        }
                                    }
                                }
                            }

                        }
                        
                  
                    }

                }
//               
            }

//            for (int i = 0; i < dimention; i++) {
//                for (int j = 0; j < dimention; j++) {
//                    System.out.print(metrix[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }
            System.out.print(metrix[target_x-1][target_y-1]);
        } catch (IOException e) {
            System.out.println(e);
        }
        // TODO code application logic here
    }
}
@8ef83c59184ca27e43c85ff6bc849fe4@"
"r04921012","8","0.76","125056","@dc0e918b7ba18c712c104dc568840864@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                if (table.get(Math.max(label[y][x-1],label[y-1][x] )-1)>Math.min(label[y][x-1],label[y-1][x] )){
                    table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
                }
                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*            for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1)+1;
                }
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@dc0e918b7ba18c712c104dc568840864@"
"b03611038","10","0.154","158864","@eaf0356e6aa6e7e2d6d7dec2b97c97c8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.Arrays;
/**
 *
 * @author Phoenix
 */
public class LabelCC {
    public static void main(String[] args)  throws Exception{
        
        try(BufferedReader br =  new BufferedReader(new FileReader(args[0]))){
                       
            String[] N = br.readLine().split("","");
            String buffer ;
            String data = """";
            int n = Integer.parseInt(N[0]);
            int tx = Integer.parseInt(N[1]);
            int ty = Integer.parseInt(N[2]);
            
            int[][] matrix = new int[n+1][n+1];
            int[][] matrix2 = new int[n+1][n+1];
            
            for(int x=1;x<=n;x++)
            {
                Arrays.fill(matrix[x],1);
            }    
            for(int x=0;x<=n;x++)
            {
                matrix[0][x]=0;
                matrix[x][0]=0;
            }
            
               UF uf = new UF(n*n);
            int i = 0;
        
           buffer = br.readLine();
           while(buffer!=null){
           data = data.concat(buffer);
           data = data.concat("","");
           i++;
           buffer = br.readLine();
           }
            int q = 0;
           String[] newdata =  data.split("","");    
           
            int[] Data = new int[2*i];
            for(q = 0;q<2*i;q++){
             Data[q] = Integer.parseInt(newdata[q]);
            }
            for(q = 0; q<2*i ; q+=2){
                int a = Data[q];
                int b =Data[q+1];
                matrix[a][b] = 0;
            }
            int[] label = new int[n*n];
            for(int x=0;x<n*n;x++)
            {
                label[x]=x;
            }
            int labelcount=0;
            
            for(int z=1;z<=n;z++)
            {
                if(matrix[1][z]==1)
                {
                    if(matrix[1][z-1]==1)
                    {
                       matrix2[1][z]=labelcount; 
                    }
                    else
                    {
                        labelcount++;
                        matrix2[1][z]=labelcount;
                    }
                }
            }
            
            for(int  x = 2; x <= n ; x++)
            {
                for(int y =1;y<=n;y++)
                {
                    if(matrix[x][y]==1)
                    {
                        if(matrix[x-1][y]==1)
                        {
                             if(matrix[x][y-1]==1)
                            {
                                 if(matrix2[x-1][y]<matrix2[x][y-1])
                                 {
                                     matrix2[x][y]=matrix2[x-1][y];
                                     for(int c=0;c<n*n;c++)
                                     {
                                         if(label[c]==label[matrix2[x][y-1]])
                                         {label[c]=label[matrix2[x-1][y]];}
                                     }
                                 }
                                 else
                                 {
                                     matrix2[x][y]=matrix2[x][y-1];
                                     for(int c=0;c<n*n;c++)
                                     {
                                         if(label[c]==label[matrix2[x-1][y]])
                                         {label[c]=label[matrix2[x][y-1]];}
                                     }
                                     //label[matrix2[x-1][y]]=label[matrix2[x][y-1]];
                                 }
                            }
                            else
                            {
                                matrix2[x][y]=matrix2[x-1][y];
                            }
                        }
                        else
                        {
                             if(matrix[x][y-1]==1)
                            {
                                matrix2[x][y]=matrix2[x][y-1];
                            }
                            else
                            {
                                labelcount++;
                                matrix2[x][y]=labelcount;
                            }
                        }
                       
                    }
                    
                }
            }
            if(matrix[tx][ty]==1)
            {
                System.out.print(label[matrix2[tx][ty]]);
            }
            else
            {
                System.out.print(0);
            }
                
            }
            
                      
    }   
}

@eaf0356e6aa6e7e2d6d7dec2b97c97c8@"
"r03723070","6","0.64","105472","@485b4f90bafbbde61802100b0707a224@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    private int[] id;
    public LabelCC(int N)
{
int []id = new int[N];
for (int i = 0; i < N; i++) id[i] = i;
}
    private int root(int i)
{
while (i != id[i]) i = id[i];
return i;
}
 public void union(int p, int q)
{
int i = Math.min(root(p),root(q));
int j = Math.max(root(p),root(q));
id[j] = i;
}   
    
    
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //System.out.printf(""%s,%d,%d\n"",input[0],ans[0],ans[1]);
       //set all input data for the first line, check ans[0][1]
       
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
      /* for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               //System.out.printf(""%d"", data[i][j]);
               data[i][j] = -1;
           }
       }*/
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       //if(data[1][1]==-1)
           //count = 2;
       int [][]connect = new int[N*N/2+1][N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect

                               connect[p][q] = 1;
                               }
                               /*else if(connect[p]!=0&&connect[q]==0){
                                   int op =Math.max(connect[p],q);
                                   int oq =Math.min(connect[p],q);
                                   connect[q] = Math.min(q,connect[p]);
                                   connect[p] = Math.min(q,connect[p]);
                                   
                                   }
                               else if(connect[p]==0&&connect[q]!=0){
                                  // connect[q] =connect[q];
                                   connect[p] =connect[q];
                               }*/
                                   
                               //connect[q] = Math.max(Math.min(q,connect[p]),0);
                           }
                          
                           //min root left
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }
       
        //System.out.printf(""\n""); 
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to sit
       int finalans =data[ans[0]][ans[1]];
       if(data[ans[0]][ans[1]]!=-1){
           for(int j = 0;j<N+1;j++){
           if(connect[data[ans[0]][ans[1]]][j]!=0)
               finalans = j;
               break;
       }    
      }
       else
           finalans=0;       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
    




@485b4f90bafbbde61802100b0707a224@"
"b02611002","0","0.98","117712","@eec3e992b3af873f16b0afdfb272d589@import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by zhouyuda on 3/15/16.
 * 題目：http://c4lab.bime.ntu.edu.tw:24080/judge/problem/hw2.html
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // 0.讀檔
            String[] metadata = br.readLine().split("","");
            int N = Integer.parseInt(metadata[0]);


            // 1.宣告
            int[] target = {Integer.parseInt(metadata[1]),Integer.parseInt(metadata[2])};   //目標site的座標
            int matrixSize = N*N;   //matrix的""長度""
            int[] arrMatrix = new int[matrixSize];
            Arrays.fill(arrMatrix,1);//arrMatrix所有元素值初始為一
            int stamp = 0;
            int ID = 0;
            int[] tempMatrix = new int[matrixSize];
            QuickUnionUF labels = new QuickUnionUF(N*N/2); //label = {0,1,2,3,4,5,6,7,}
            int targetID = N*(target[0]-1)+(target[1]-1);//7+8*4


            // 2.將input中的座標set 0
            while(br.ready()){
                String[] strCoor = br.readLine().split("","");   //座標一行行讀進string[] strCoor
                int[] intCoor = Arrays.asList(strCoor).stream().mapToInt(Integer::parseInt).toArray();   //intCoor = Int(strCoor)
                ID = (intCoor[1]-1) + N*(intCoor[0]-1);
                arrMatrix[ID]=0;
            }
            ID=0;    //計步器歸零


            /*/–––––––––––––––––––print整個matrix–––––––––––––––––––––————
            System.out.println(""目前的matrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""[%d,%d:%d]= %d\t"",i,j,N*i+j,arrMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––*/



            //3. first pass
            for(ID=0;ID<matrixSize;ID++){
                System.out.printf(""\nnow at ID=%d"",ID);

//              ––––––––––––––––––––––––––––––––––––––––––——
//              ––––––––––––––––非第一排時–––––––––––––––––––
//              ––––––––––––––––––––––––––––––––––––––––––——
                if((ID>=N)&&(arrMatrix[ID]!=0)){
                    if(((ID%N!=0)&&(arrMatrix[ID-N]<=0)&&(arrMatrix[ID-1]<=0))||((ID%N==0)&&(arrMatrix[ID-N]<=0))){
                        stamp++;    //若 ""上"" ""左"" 為0/X則stamp++ 並蓋章
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;

                    }else if((ID%N==0)&&(arrMatrix[ID-N]!=0)){
                        tempMatrix[ID] = tempMatrix[ID-N];
                        System.out.println(""第一列直接取上面"");
                    }else if((arrMatrix[ID-N]!=0)&&(arrMatrix[ID-1]!=0)){
                        System.out.println(""左上比大小"");
                        if(tempMatrix[ID-N]<=tempMatrix[ID-1]){
                            tempMatrix[ID] = tempMatrix[ID-N];
                            labels.union(tempMatrix[ID-1],tempMatrix[ID-N]);
                            System.out.printf(""上贏了"");
                        }else{
                            tempMatrix[ID] = tempMatrix[ID-1];
                            labels.union(tempMatrix[ID-N],tempMatrix[ID-1]);
                            System.out.printf(""左贏了！"");
                        }

                    }else if((arrMatrix[ID-N]!=0)&&(arrMatrix[ID-1]==0)){
                        tempMatrix[ID] = tempMatrix[ID-N];
                        System.out.println(""[上：ID-N]"");

                    }else if((arrMatrix[ID-1]!=0)&&(arrMatrix[ID-N]==0)){
                        tempMatrix[ID] = tempMatrix[ID-1];
                        System.out.println(""[左：ID-1]"");
                    }

                    System.out.printf(""[NORMAL{arrMatrix[ID]=%d}]"",arrMatrix[ID]);



//              ––––––––––––––––––––––––––––––––––––––––––——
//              ––––––––––––––––第一排時–––––––––––––––––––––
//              ––––––––––––––––––––––––––––––––––––––––––——
                }else if((ID<N)&&(ID!=0)&&(arrMatrix[ID]!=0)){
                    if(arrMatrix[ID-1]<=0){
                        stamp++;
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;
                    }else if(arrMatrix[ID]!=0) {
                        tempMatrix[ID] = tempMatrix[ID - 1];
                    }

                    System.out.println(""[LINE ONE]"");


//              ––––––––––––––––第一排第一個––––––––––––––––––
                }else if((ID==0)&&(arrMatrix[ID]!=0)){
//                    System.out.println(""[NOW ID 0]"");
                        stamp++;
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;
                }
            }

            //–––––––––––––––––––print整個tempMatrix–––––––––––––––————––––––
            // ––––
            System.out.println(""目前的tempMatrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""%d\t"",tempMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

            //4. second pass
            for(ID=0;ID<matrixSize;ID++){
                if(tempMatrix[ID]!=0){
                    tempMatrix[ID]=labels.find(tempMatrix[ID]);
                }
            }

            //5. return reult
            System.out.println(tempMatrix[targetID]);


            //–––––––––––––––––––print整個matrix–––––––––––––––————––––––
            // ––––
            System.out.println(""目前的arrMatrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""%d\t"",arrMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            //–––––––––––––––––––print整個tempMatrix–––––––––––––––————––––––
            // ––––
            System.out.println(""目前的tempMatrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""%d\t"",tempMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            //––––––––––––––––––––print roots––––––––––––––––––––––––––––
            for (int i=0; i<N*N/2; i++){
                System.out.printf(""root(%d)=%d.\n"",i,labels.find(i));
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
            System.out.printf(""ID=%d:%d"",targetID,tempMatrix[targetID]);
        }
    }
}
@eec3e992b3af873f16b0afdfb272d589@"
"r03723070","9","1.07","131696","@163c4bb6a0a7ab32d06b7d67a40cafb0@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int []connect = new int[N*N/2+1];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       connect[count] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               int op =Math.max(connect[p],connect[q]);
                               int oq =Math.min(connect[p],connect[q]);
                               connect[q] = oq;
                               connect[p] = oq;
                               for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
       if(connect[data[ans[0]][ans[1]]]!=0)
       finalans = connect[data[ans[0]][ans[1]]];
       else
       finalans = finalans;
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   
@163c4bb6a0a7ab32d06b7d67a40cafb0@"
"b02611002","9","1.45","151568","@1fb28da83e5a9717abcfa74130a8c1c5@import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * Created by zhouyuda on 3/15/16.
 * 題目：http://c4lab.bime.ntu.edu.tw:24080/judge/problem/hw2.html
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            // 0.讀檔
            String[] metadata = br.readLine().split("","");
            int N = Integer.parseInt(metadata[0]);


            // 1.宣告
            int[] target = {Integer.parseInt(metadata[1]),Integer.parseInt(metadata[2])};   //目標site的座標
            int matrixSize = N*N;   //matrix的""長度""
            int[] arrMatrix = new int[matrixSize];
            Arrays.fill(arrMatrix,1);//arrMatrix所有元素值初始為一
            int stamp = 0;
            int ID = 0;
            int[] tempMatrix = new int[matrixSize];
            QuickUnionUF labels = new QuickUnionUF(N*N/2); //label = {0,1,2,3,4,5,6,7,}
            int targetID = N*(target[0]-1)+(target[1]-1);//7+8*4


            // 2.將input中的座標set 0
            while(br.ready()){
                String[] strCoor = br.readLine().split("","");   //座標一行行讀進string[] strCoor
                int[] intCoor = Arrays.asList(strCoor).stream().mapToInt(Integer::parseInt).toArray();   //intCoor = Int(strCoor)
                ID = (intCoor[1]-1) + N*(intCoor[0]-1);
                arrMatrix[ID]=0;
            }
            ID=0;    //計步器歸零


            /*/–––––––––––––––––––print整個matrix–––––––––––––––––––––————
            System.out.println(""目前的matrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
                    System.out.printf(""[%d,%d:%d]= %d\t"",i,j,N*i+j,arrMatrix[N*i+j]);
                }
                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––*/



            //3. first pass
            for(ID=0;ID<matrixSize;ID++){
//                System.out.printf(""\nnow at ID=%d"",ID);

//              ––––––––––––––––––––––––––––––––––––––––––——
//              ––––––––––––––––非第一排時–––––––––––––––––––
//              ––––––––––––––––––––––––––––––––––––––––––——
                if((ID>=N)&&(arrMatrix[ID]!=0)){
                    if(((ID%N!=0)&&(arrMatrix[ID-N]<=0)&&(arrMatrix[ID-1]<=0))||((ID%N==0)&&(arrMatrix[ID-N]<=0))){
                        stamp++;    //若 ""上"" ""左"" 為0/X則stamp++ 並蓋章
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;

                    }else if((ID%N==0)&&(arrMatrix[ID-N]!=0)){
                        tempMatrix[ID] = tempMatrix[ID-N];
//                        System.out.println(""第一列直接取上面"");
                    }else if((arrMatrix[ID-N]!=0)&&(arrMatrix[ID-1]!=0)){
//                        System.out.println(""左上比大小"");
                        if(tempMatrix[ID-N]<=tempMatrix[ID-1]){
                            tempMatrix[ID] = tempMatrix[ID-N];
                            labels.union(tempMatrix[ID-1],tempMatrix[ID-N]);
//                            System.out.printf(""上贏了"");
                        }else{
                            tempMatrix[ID] = tempMatrix[ID-1];
                            labels.union(tempMatrix[ID-N],tempMatrix[ID-1]);
//                            System.out.printf(""左贏了！"");
                        }

                    }else if((arrMatrix[ID-N]!=0)&&(arrMatrix[ID-1]==0)){
                        tempMatrix[ID] = tempMatrix[ID-N];
//                        System.out.println(""[上：ID-N]"");

                    }else if((arrMatrix[ID-1]!=0)&&(arrMatrix[ID-N]==0)){
                        tempMatrix[ID] = tempMatrix[ID-1];
//                        System.out.println(""[左：ID-1]"");
                    }

//                    System.out.printf(""[NORMAL{arrMatrix[ID]=%d}]"",arrMatrix[ID]);



//              ––––––––––––––––––––––––––––––––––––––––––——
//              ––––––––––––––––第一排時–––––––––––––––––––––
//              ––––––––––––––––––––––––––––––––––––––––––——
                }else if((ID<N)&&(ID!=0)&&(arrMatrix[ID]!=0)){
                    if(arrMatrix[ID-1]<=0){
                        stamp++;
                        arrMatrix[ID]=stamp;
                        tempMatrix[ID]=stamp;
                    }else if(arrMatrix[ID]!=0) {
                        tempMatrix[ID] = tempMatrix[ID - 1];
                    }

//                    System.out.println(""[LINE ONE]"");


//              ––––––––––––––––第一排第一個––––––––––––––––––
                }else if((ID==0)&&(arrMatrix[ID]!=0)){
//                    System.out.println(""[NOW ID 0]"");
                    stamp++;
                    arrMatrix[ID]=stamp;
                    tempMatrix[ID]=stamp;
                }
            }

            //–––––––––––––––––––print整個tempMatrix–––––––––––––––————––––––
            // ––––
//            System.out.println(""目前的tempMatrix長這樣：\n"");
            for (int i=0; i<N; i++){
                for (int j=0; j<N; j++){
//                    System.out.printf(""%d\t"",tempMatrix[N*i+j]);
                }
//                System.out.println(""\n"");
            }
            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

            //4. second pass
            for(ID=0;ID<matrixSize;ID++){
                if(tempMatrix[ID]!=0){
                    tempMatrix[ID]=labels.find(tempMatrix[ID]);
                }
            }

            //5. return reult
            System.out.println(tempMatrix[targetID]);

//
//            //–––––––––––––––––––print整個matrix–––––––––––––––————––––––
//            // ––––
//            System.out.println(""目前的arrMatrix長這樣：\n"");
//            for (int i=0; i<N; i++){
//                for (int j=0; j<N; j++){
//                    System.out.printf(""%d\t"",arrMatrix[N*i+j]);
//                }
//                System.out.println(""\n"");
//            }
//            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
//            //–––––––––––––––––––print整個tempMatrix–––––––––––––––————––––––
//            // ––––
//            System.out.println(""目前的tempMatrix長這樣：\n"");
//            for (int i=0; i<N; i++){
//                for (int j=0; j<N; j++){
//                    System.out.printf(""%d\t"",tempMatrix[N*i+j]);
//                }
//                System.out.println(""\n"");
//            }
//            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
//            //––––––––––––––––––––print roots––––––––––––––––––––––––––––
//            for (int i=0; i<N*N/2; i++){
//                System.out.printf(""root(%d)=%d.\n"",i,labels.find(i));
//            }
//            //–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––
//            System.out.printf(""ID=%d:%d"",targetID,tempMatrix[targetID]);
        }
    }
}
@1fb28da83e5a9717abcfa74130a8c1c5@"
"r04921065","8","0.86","128416","@e7fba856c0d98725fc59c1bd48f51ed6@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*            for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1)+1;
                }
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@e7fba856c0d98725fc59c1bd48f51ed6@"
"r03849033","9","0.98","124144","@749ec75c384bf51c386db3d61658cd72@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        
                    if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            System.out.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@749ec75c384bf51c386db3d61658cd72@"
"r03723070","8","1.01","138384","@a0bd60c6fd2f0f29e78046f4811c81eb@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[j][0] = p;
                               connect[j][1] = q;
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       for(int i = 0;i<N*N;i++){
           for(int j = 0; j<N*N;N++){
           if(connect[i][0] == connect[j][1])
               connect[j][1] = connect[i][0];
           }
       }
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<N*N;N++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][0],finalans);
           }
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   
@a0bd60c6fd2f0f29e78046f4811c81eb@"
"r04921012","8","1.01","129856","@b1c998a2e6ec2b0f60071372eed2d8ae@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                if (table.get(Math.max(label[y][x-1],label[y-1][x] )-1)>Math.min(label[y][x-1],label[y-1][x] )){
                    table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
                }
                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*           for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1);
                    System.out.println(out);
                }
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@b1c998a2e6ec2b0f60071372eed2d8ae@"
"r03723070","8","1.04","132320","@b64af60258afa69f20ad8dd458f789b6@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               countforconnect=+1;
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       for(int i = 0;i<N*N;i++){
           for(int j = 0; j<N*N;N++){
           if(connect[i][0] == connect[j][1])
               connect[j][1] = connect[i][0];
           }
       }
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<N*N;N++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][0],finalans);
           }
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   
@b64af60258afa69f20ad8dd458f789b6@"
"r04921012","0","1.01","128032","@93be51f2ce33f984138d917333b154e1@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                if (table.get(Math.max(label[y][x-1],label[y-1][x] )-1)>Math.min(label[y][x-1],label[y-1][x] )){
                    table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
                }
                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*           for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1);
                    
                }System.out.println(out);
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@93be51f2ce33f984138d917333b154e1@"
"r03723070","3","0.26","104336","@f8d103e73447a028495ae80da749eef5@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               countforconnect=+1;
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       for(int i = 0;i<countforconnect;i++){
           for(int j = 0; j<countforconnect;N++){
           if(connect[i][0] == connect[j][1])
               connect[j][1] = connect[i][0];
           }
       }
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<N*N;N++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][0],finalans);
           }
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   
@f8d103e73447a028495ae80da749eef5@"
"r03723070","8","1.02","134432","@c1002f4da81bb055cce1ae416a9d0c57@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               countforconnect=+1;
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       for(int i = 0;i<countforconnect;i++){
           for(int j = 0; j<countforconnect;j++){
           if(connect[i][0] == connect[j][1])
               connect[j][1] = connect[i][0];
           }
       }
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<N*N;N++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][0],finalans);
           }
       }
       //block
       else
       finalans = 0;
       
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   
@c1002f4da81bb055cce1ae416a9d0c57@"
"r04921012","9","1.01","128512","@a3972ad6a82631a51b1b17332a1137c5@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                if (table.get(Math.max(label[y][x-1],label[y-1][x] )-1)>Math.min(label[y][x-1],label[y-1][x] )){
                    table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
                }
                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*           for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1);
                    
                }//System.out.println(out);
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@a3972ad6a82631a51b1b17332a1137c5@"
"r03723070","8","1.01","128272","@3a9bb668b157c64d0efbb6de68783360@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               countforconnect=+1;
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       for(int i = 0;i<countforconnect;i++){
           for(int j = 0; j<countforconnect;j++){
           if(connect[i][0] == connect[j][1])
               connect[j][1] = connect[i][0];
           }
       }
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][0],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   
@3a9bb668b157c64d0efbb6de68783360@"
"r03723070","8","1.01","130048","@44335dc91bdb46082affbe3459292995@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               countforconnect=+1;
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       for(int i = 0;i<countforconnect;i++){
           for(int j = 0; j<countforconnect;j++){
           if(connect[i][0] == connect[j][1])
               connect[j][1] = connect[i][1];
           }
       }
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][0],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   
@44335dc91bdb46082affbe3459292995@"
"r04921012","9","1","131504","@058d9c2d96ab2d318baee7fba4f9cbd6@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                //if (table.get(Math.max(label[y][x-1],label[y-1][x] )-1)>Math.min(label[y][x-1],label[y-1][x] )){
                    table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
                //}
                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*           for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1);
                    
                }//System.out.println(out);
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@058d9c2d96ab2d318baee7fba4f9cbd6@"
"r03849033","4","1.13","171920","@b47774aec8f4707e1654a90d4210f07c@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
public class LabelCC {
    public int[][] labeledMatrix;

    public LabelCC(int[][] matrix) {
        ArrayList<ArrayList<Integer>> linked = new ArrayList<ArrayList<Integer>>();
        int[][] labels = new int[matrix.length][matrix[0].length];

        int NextLabel = 0;

        //First pass
        for(int i=0; i<matrix.length; i++) {
            for( int j=0; j<matrix.length; j++) {
                labels[i][j] = 0;
            }
        }

        for(int i=0; i<matrix.length; i++) {
            for(int j=0; j<matrix[0].length; j++) {
                if(matrix[i][j] != 0) {

                    //Labels of neighbors
                    ArrayList<Integer> neighbors = new ArrayList<Integer>();
                    for(int ni=-1; ni<=1; ni++) {
                        for(int nj=-1; nj<=1; nj++) {
                            if(i+ni<0 || j+nj<0 || i+ni>labels.length-1 || j+nj>labels[0].length-1) {
                                continue;
                            }
                            else {
                                if(i+ni == 0 && i+nj == 0) continue;
                                if(labels[i+ni][j+nj] != 0) neighbors.add(labels[i+ni][j+nj]);
                            }
                        }
                    }

                    if(neighbors.size() == 0) {
                        ArrayList<Integer> tempArrayList = new ArrayList<Integer>();
                        tempArrayList.add(NextLabel);
                        linked.add(NextLabel, tempArrayList);
                        labels[i][j] = NextLabel;
                        NextLabel++;
                    }
                    else {

                        labels[i][j]=1000*1000;
                        for(int neighbor : neighbors) {
                            if(neighbor < labels[i][j]) labels[i][j] = neighbor;
                        }

                        for(int neighbor : neighbors) {
                            linked.set(neighbor,union(linked.get(neighbor),neighbors));
                        }
                    }
                }

            }
        }

        //Second pass
        for(int i=0; i<matrix.length; i++) {
            for(int j=0; j<matrix[0].length; j++) {
                ArrayList<Integer> EquivalentLabels = linked.get(labels[i][j]);
                labels[i][j]=1000*1000;
                for(int label : EquivalentLabels) {
                    if(label < labels[i][j]) labels[i][j]=label;
                }
            }
        }

        labeledMatrix = labels;
    }

    //union: http://stackoverflow.com/questions/5283047/intersection-and-union-of-arraylists-in-java
    public <T> ArrayList<T> union(ArrayList<T> list1, ArrayList<T> list2) {
        Set<T> set = new HashSet<T>();

        set.addAll(list1);
        set.addAll(list2);

        return new ArrayList<T>(set);
    }

    public int[][] getLabeledMatrix() {
        return labeledMatrix;
    } 

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            int n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            
            int[][] matrix = new int[n][n];
                for(int i=0; i<n; i++) {
                    for(int j=0; j<n; j++) {
                        matrix[i][j]=1;
                    }
                }
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=0;}

        LabelCC matrixComponents = new LabelCC(matrix);
        int[][] newMatrix = matrixComponents.getLabeledMatrix();

System.out.print(newMatrix[x-1][y-1]);
 
        }            
    }
}

@b47774aec8f4707e1654a90d4210f07c@"
"r04921012","9","0.98","125008","@ded5a005f9b0449bbcdb4186434fec81@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }else{
                num++;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                if (table.get(Math.max(label[y][x-1],label[y-1][x] )-1)>Math.min(label[y][x-1],label[y-1][x] )){
                    table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
                }
                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*           for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1);
                    
                }//System.out.println(out);
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@ded5a005f9b0449bbcdb4186434fec81@"
"r04921105","0","0","0","@954ad5bb90e0444b4ab6e2929dd7a819@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC{
    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            int dim = Integer.parseInt(data[0]);//得到維度
            int targetx = Integer.parseInt(data[1])-1;//目標 X座標
            int targety = Integer.parseInt(data[2])-1;//目標     Y座標
            // System.out.print (dim);
             //System.out.print (""\n"");
             
            String[] open_str;
            
            int[][] matrix = new int [dim][dim];//拿來看blocked sites分布的matrix
            int[][] lmatrix = new int [dim][dim];//拿來貼label的matrix
            
            //創立一個矩陣裡面的數字=1，代表全部無blocked sites
             for (int i = 0 ;i<matrix.length;i++){
              for(int j=0;j<matrix[0].length;j++){
              matrix[i][j]=1;    
                }
            }
            //print剛剛創立的矩陣
           /* for (int[] matrix3 : matrix) {
                for (int j = 0; j<matrix[0].length; j++) {
                    System.out.print(matrix3[j]);
                }
                System.out.print(""\n"");
            }
             
             System.out.print(""\n"");
             */
             int x,y;
         //將有blocked sites的座標表示出    
          while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1; 
               matrix[x][y] = 0;        
          }
             //print剛剛有blocked sites的矩陣
           /* for (int[] matrix3 : matrix) {
                for (int j = 0; j<matrix[0].length; j++) {
                    System.out.print(matrix3[j]);
                }
                System.out.print(""\n"");
            }
             System.out.print(""\n"");*/
//以上完成讀檔 以下開始判斷答案////以上完成讀檔 以下開始判斷答案////以上完成讀檔 以下開始判斷答案////以上完成讀檔 以下開始判斷答案//
            int label = 1;
            //first one 
            for(int i=0;i<dim;i++){
                for(int j =0;j<dim;j++){
                    if(matrix[i][j]==0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0)//判斷上面的site是否為blocked site
                        matrix[i][j] = matrix[i-1][j];
                    else if(j != 0 && matrix[i][j-1] != 0)//判斷左邊的site是否為blocked site
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = label;
                        label++;//label編號增加
                    }
                 }
            }   
            //print pass 1 result
            for (int[] matrix1 : matrix) {
                for (int j = 0; j<matrix[0].length; j++) {
                    System.out.print(matrix1[j]);
                }
                System.out.print(""\n"");
            }
            
            //連起label
            int len = 0;
            int[][] parent = new int[dim*dim][2];
            
            for(int i=0;i<dim;i++){
                for(int j=0;j<dim;j++){
                     if (matrix[i][j] == 0)
                        continue;
                        if ((matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                            if(matrix[i][j] > matrix[i][j-1]){
                                parent[len][1] = matrix[i][j];
                                parent[len][0] = matrix[i][j-1];}
                            else{
                                parent[len][0] = matrix[i][j];
                                parent[len][1] = matrix[i][j-1];}
                            len++;
                        }
                }
            }
            
            System.out.println(dim);
            for (int i=0; i < len; i++)
            System.out.printf(""(%d,%d)\n"",parent[i][0],parent[i][1]);
            
            for(int X = 0; X < len; X++){
                for(int i = 0;i < dim; i++){
                    for(int j = 0;j < dim; j++){
                        if(matrix[i][j] == parent[X][1]){
                            matrix[i][j] = parent[X][0];
                            
                        }    
                    }
                }
            
            }    
            
            
            
            System.out.print(matrix[targetx][targety]);
            
        
            
                   
                        
         }       
    
    }
}

@954ad5bb90e0444b4ab6e2929dd7a819@"
"r03723070","9","1.07","126128","@2dc32034116b046d2384cbd447472d15@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       for(int i = 0;i<countforconnect;i++){
           for(int j = 0; j<countforconnect;j++){
               //System.out.printf(""connect[%d][0] is %d connect[%d][1] is %d\n"",j,connect[j][0],j,connect[j][1]);
           if(connect[i][0] == connect[j][1])
               connect[j][1] = connect[i][1];
           }
       }
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   
@2dc32034116b046d2384cbd447472d15@"
"r04921012","0","0","0","@4779c0f1b009434a3593ef9eb5ddfae4@package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
                System.out.println(num);
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));

                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;

                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*           for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            
            
            
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1);
                    
                }//System.out.println(out);
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@4779c0f1b009434a3593ef9eb5ddfae4@"
"r04921012","0","0.96","128304","@c334757f6df2b48bbea5dfe0a59682da@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
                System.out.println(num);
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));

                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;

                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*           for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            
            
            
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1);
                    
                }//System.out.println(out);
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@c334757f6df2b48bbea5dfe0a59682da@"
"r04921012","0","1.01","129312","@191322fee97d4b171a6269d1e1804c2a@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
                System.out.println(num);
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                if (table.get(Math.max(label[y][x-1],label[y-1][x] )-1)>Math.min(label[y][x-1],label[y-1][x] )){
                    table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
                }
                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;

                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
           /*for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            
            
            
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1);
                    
                }//System.out.println(out);
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@191322fee97d4b171a6269d1e1804c2a@"
"r04525016","0","1","128896","@b74ce12a403904d2c02f7d545b680b65@import java.io.BufferedReader;
import java.io.FileReader;


/**
 * Created by cavitation on 2016/3/18.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];
            parents[0][0] = 1;
            parents[1][0] = 1;
            int labelCount = 0;
            int parentsCount = 1;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0 && j == 0) {
                        if (label[i][j] == 0) {
                            labelCount++;
                        } else {
                            label[i][j] = ++labelCount;
                        }
                    } else if (i == 0) {
                        if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
                        }
                    } else if (j == 0) {
                        if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
                        }
                    } else {
                        int left = label[i][j - 1];
                        int top = label[i - 1][j];
                        if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
                        }
                    }
                }
            }


            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


//            //印出label
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(label[i][j] + ""\t"");
//                }
//                System.out.println("" "");
//            }
//
//            System.out.println(parentsCount);
//
//            //印出parents
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[0][i] + ""\t"");
//            }
//            System.out.println("" "");
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[1][i] + ""\t"");
//            }
//            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
        boolean okRoot = false;
//        while (!okRoot) {
        for (int i = 0; i < index2; i++) {
            if (index1 == parents[0][i]) {
                index1 = parents[1][i];
            }
//                if (parents[0][i] == parents[1][i]) okRoot = true;
        }
//        }
        return index1;
    }

}

@b74ce12a403904d2c02f7d545b680b65@"
"r04921105","8","0.96","125200","@b13253bd0eb571a650357183e3a59783@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC{
    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            int dim = Integer.parseInt(data[0]);//得到維度
            int targetx = Integer.parseInt(data[1])-1;//目標 X座標
            int targety = Integer.parseInt(data[2])-1;//目標     Y座標
            // System.out.print (dim);
             //System.out.print (""\n"");
             
            String[] open_str;
            
            int[][] matrix = new int [dim][dim];//拿來看blocked sites分布的matrix
            int[][] lmatrix = new int [dim][dim];//拿來貼label的matrix
            
            //創立一個矩陣裡面的數字=1，代表全部無blocked sites
             for (int i = 0 ;i<matrix.length;i++){
              for(int j=0;j<matrix[0].length;j++){
              matrix[i][j]=1;    
                }
            }
            //print剛剛創立的矩陣
           /* for (int[] matrix3 : matrix) {
                for (int j = 0; j<matrix[0].length; j++) {
                    System.out.print(matrix3[j]);
                }
                System.out.print(""\n"");
            }
             
             System.out.print(""\n"");
             */
             int x,y;
         //將有blocked sites的座標表示出    
          while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1; 
               matrix[x][y] = 0;        
          }
             //print剛剛有blocked sites的矩陣
           /* for (int[] matrix3 : matrix) {
                for (int j = 0; j<matrix[0].length; j++) {
                    System.out.print(matrix3[j]);
                }
                System.out.print(""\n"");
            }
             System.out.print(""\n"");*/
//以上完成讀檔 以下開始判斷答案////以上完成讀檔 以下開始判斷答案////以上完成讀檔 以下開始判斷答案////以上完成讀檔 以下開始判斷答案//
            int label = 1;
            //first one 
            for(int i=0;i<dim;i++){
                for(int j =0;j<dim;j++){
                    if(matrix[i][j]==0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0)//判斷上面的site是否為blocked site
                        matrix[i][j] = matrix[i-1][j];
                    else if(j != 0 && matrix[i][j-1] != 0)//判斷左邊的site是否為blocked site
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = label;
                        label++;//label編號增加
                    }
                 }
            }   
            //print pass 1 result
            //for (int[] matrix1 : matrix) {
                //for (int j = 0; j<matrix[0].length; j++) {
                   // System.out.print(matrix1[j]);
               // }
                //System.out.print(""\n"");
            //}
            
            //連起label
            int len = 0;
            int[][] parent = new int[dim*dim][2];
            
            for(int i=0;i<dim;i++){
                for(int j=0;j<dim;j++){
                     if (matrix[i][j] == 0)
                        continue;
                      if (j!=0&&(matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                          if(matrix[i][j] > matrix[i][j-1]){
                              parent[len][1] = matrix[i][j];
                              parent[len][0] = matrix[i][j-1];
                          }
                          else {
                              parent[len][0] = matrix[i][j];
                            parent[len][1] = matrix[i][j-1];
                          }
                       
                        }
                }
            }
            
           
            for (int i=0; i < len; i++)
            System.out.printf(""(%d,%d)\n"",parent[i][0],parent[i][1]);
            
            for(int X = 0; X < len; X++){
                for(int i = 0;i < dim; i++){
                    for(int j = 0;j < dim; j++){
                        if(matrix[i][j] == parent[X][1]){
                            matrix[i][j] = parent[X][0];
                            
                        }    
                    }
                }
            
            }    
            
            
            
            System.out.print(matrix[targetx][targety]);
            
        
            
                   
                        
         }       
    
    }
}


@b13253bd0eb571a650357183e3a59783@"
"r04525016","0","1.01","128800","@b74ce12a403904d2c02f7d545b680b65@import java.io.BufferedReader;
import java.io.FileReader;


/**
 * Created by cavitation on 2016/3/18.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];
            parents[0][0] = 1;
            parents[1][0] = 1;
            int labelCount = 0;
            int parentsCount = 1;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0 && j == 0) {
                        if (label[i][j] == 0) {
                            labelCount++;
                        } else {
                            label[i][j] = ++labelCount;
                        }
                    } else if (i == 0) {
                        if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
                        }
                    } else if (j == 0) {
                        if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
                        }
                    } else {
                        int left = label[i][j - 1];
                        int top = label[i - 1][j];
                        if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
                        }
                    }
                }
            }


            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


//            //印出label
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(label[i][j] + ""\t"");
//                }
//                System.out.println("" "");
//            }
//
//            System.out.println(parentsCount);
//
//            //印出parents
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[0][i] + ""\t"");
//            }
//            System.out.println("" "");
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[1][i] + ""\t"");
//            }
//            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
        boolean okRoot = false;
//        while (!okRoot) {
        for (int i = 0; i < index2; i++) {
            if (index1 == parents[0][i]) {
                index1 = parents[1][i];
            }
//                if (parents[0][i] == parents[1][i]) okRoot = true;
        }
//        }
        return index1;
    }

}

@b74ce12a403904d2c02f7d545b680b65@"
"r04525016","9","1.02","123072","@6a325dca8d992f4f78338d15560c948d@import java.io.BufferedReader;
import java.io.FileReader;


/**
 * Created by cavitation on 2016/3/18.
 */
public class LabelCC {
    public static void main(String args[]) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);
            int targetRow = Integer.parseInt(data[1]) - 1;  // array index從0開始，所以讀取時將座標減1
            int targetColumn = Integer.parseInt(data[2]) - 1;

            int[][] label = new int[num][num];
            int[][] parents = new int[2][num * num];
            parents[0][0] = 1;
            parents[1][0] = 1;
            int labelCount = 0;
            int parentsCount = 1;

            // 將label矩陣內值設為-1(因為預設為0)
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    label[i][j] = -1;
                }
            }

            while (br.ready()) {
                String[] temp = br.readLine().split("","");
                int rowBlocked = Integer.parseInt(temp[0]) - 1;
                int columnBlocked = Integer.parseInt(temp[1]) - 1;
                label[rowBlocked][columnBlocked] = 0;
            }
            br.close();

            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0 && j == 0) {
                        if (label[i][j] == 0) {
                            labelCount++;
                        } else {
                            label[i][j] = ++labelCount;
                        }
                    } else if (i == 0) {
                        if (label[i][j] != 0) {
                            if (label[i][j - 1] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i][j - 1];
                            }
                        }
                    } else if (j == 0) {
                        if (label[i][j] != 0) {
                            if (label[i - 1][j] == 0) {
                                label[i][j] = ++labelCount;
                            } else {
                                label[i][j] = label[i - 1][j];
                            }
                        }
                    } else {
                        int left = label[i][j - 1];
                        int top = label[i - 1][j];
                        if (label[i][j] != 0) {
                            if (left == 0 && top == 0) {
                                label[i][j] = ++labelCount;
                            } else if (left == 0) {
                                label[i][j] = top;
                            } else if (top == 0) {
                                label[i][j] = left;
                            } else {
                                if (left > top) {
                                    label[i][j] = top;
                                    parents[0][parentsCount] = left;
                                    parents[1][parentsCount] = top;
                                    parentsCount++;
                                } else {
                                    label[i][j] = left;
                                    if (left != top) {
                                        parents[0][parentsCount] = top;
                                        parents[1][parentsCount] = left;
                                        parentsCount++;
                                    }
                                }
                            }
                        }
                    }
                }
            }


            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {

                    label[i][j] = getRoot(parents, label[i][j], parentsCount);
                }
            }


//            //印出label
//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(label[i][j] + ""\t"");
//                }
//                System.out.println("" "");
//            }
//
//            System.out.println(parentsCount);
//
//            //印出parents
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[0][i] + ""\t"");
//            }
//            System.out.println("" "");
//            for (int i = 0; i < parentsCount; i++) {
//                System.out.print(parents[1][i] + ""\t"");
//            }
            System.out.println(label[targetRow][targetColumn]);
        }
    }


    public static int getRoot(int[][] parents, int index1, int index2) {
        boolean okRoot = false;
//        while (!okRoot) {
        for (int i = 0; i < index2; i++) {
            if (index1 == parents[0][i]) {
                index1 = parents[1][i];
            }
//                if (parents[0][i] == parents[1][i]) okRoot = true;
        }
//        }
        return index1;
    }

}

@6a325dca8d992f4f78338d15560c948d@"
"r04921012","9","1.01","132000","@56b650d4bfada385f6ed40d9208245ea@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }else{
                num++;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                //if (table.get(Math.max(label[y][x-1],label[y-1][x] )-1)>Math.min(label[y][x-1],label[y-1][x] )){
                    table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
                //}
                
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*           for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1);
                    
                }//System.out.println(out);
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}
@56b650d4bfada385f6ed40d9208245ea@"
"r04921105","8","0.97","125856","@31cd1015c864435dfc9ad1f33413cdb3@import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC{
    public static void main(String[] args) throws Exception{
                try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){                    
            
            String[] data = br.readLine().split("","");
            int dim = Integer.parseInt(data[0]);//得到維度
            int targetx = Integer.parseInt(data[1])-1;//目標 X座標
            int targety = Integer.parseInt(data[2])-1;//目標     Y座標
            // System.out.print (dim);
             //System.out.print (""\n"");
             
            String[] open_str;
            
            int[][] matrix = new int [dim][dim];//拿來看blocked sites分布的matrix
            int[][] lmatrix = new int [dim][dim];//拿來貼label的matrix
            
            //創立一個矩陣裡面的數字=1，代表全部無blocked sites
             for (int i = 0 ;i<matrix.length;i++){
              for(int j=0;j<matrix[0].length;j++){
              matrix[i][j]=1;    
                }
            }
            //print剛剛創立的矩陣
           /* for (int[] matrix3 : matrix) {
                for (int j = 0; j<matrix[0].length; j++) {
                    System.out.print(matrix3[j]);
                }
                System.out.print(""\n"");
            }
             
             System.out.print(""\n"");
             */
             int x,y;
         //將有blocked sites的座標表示出    
          while( br.ready() ){
                open_str = br.readLine().split("","");
                x = Integer.parseInt(open_str[0])-1;
                y = Integer.parseInt(open_str[1])-1; 
               matrix[x][y] = 0;        
          }
             //print剛剛有blocked sites的矩陣
           /* for (int[] matrix3 : matrix) {
                for (int j = 0; j<matrix[0].length; j++) {
                    System.out.print(matrix3[j]);
                }
                System.out.print(""\n"");
            }
             System.out.print(""\n"");*/
//以上完成讀檔 以下開始判斷答案////以上完成讀檔 以下開始判斷答案////以上完成讀檔 以下開始判斷答案////以上完成讀檔 以下開始判斷答案//
            int label = 1;
           
            for(int i=0;i<dim;i++){
                for(int j =0;j<dim;j++){
                    if(matrix[i][j]==0)
                        continue;
                    if(i != 0 && matrix[i-1][j] != 0)//判斷上面的site是否為blocked site
                        matrix[i][j] = matrix[i-1][j];
                    else if(j != 0 && matrix[i][j-1] != 0)//判斷左邊的site是否為blocked site
                        matrix[i][j] = matrix[i][j-1];
                    else {
                        matrix[i][j] = label;
                        label++;//label編號增加
                    }
                 }
            }   
            //print pass 1 result
            //for (int[] matrix1 : matrix) {
                //for (int j = 0; j<matrix[0].length; j++) {
                   // System.out.print(matrix1[j]);
               // }
                //System.out.print(""\n"");
            //}
            
            //連起label
            int len = 0;
            int[][] parent = new int[dim*dim][2];
            
            for(int i=0;i<dim;i++){
                for(int j=0;j<dim;j++){
                     if (matrix[i][j] == 0)
                        continue;
                      if (j!=0&&(matrix[i][j-1]!=0) && (matrix[i][j-1] != matrix[i][j])){
                          if(matrix[i][j] > matrix[i][j-1]){
                              parent[len][1] = matrix[i][j];
                              parent[len][0] = matrix[i][j-1];
                          }
                          else {
                              parent[len][0] = matrix[i][j];
                            parent[len][1] = matrix[i][j-1];
                          }
                       
                        }
                }
            }
            
           
          //  for (int i=0; i < len; i++)
           // System.out.printf(""(%d,%d)\n"",parent[i][0],parent[i][1]);
            
            for(int X = 0; X < len; X++){
                for(int i = 0;i < dim; i++){
                    for(int j = 0;j < dim; j++){
                        if(matrix[i][j] == parent[X][1]){
                            matrix[i][j] = parent[X][0];
                            
                        }    
                    }
                }
            
            }    
            
            
            
            System.out.print(matrix[targetx][targety]);
            
        
            
                   
                        
         }       
    
    }
}


@31cd1015c864435dfc9ad1f33413cdb3@"
"r03525006","0","1.01","133616","@f0c01eead351e2c6a234da23112496e6@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j - 1];
                                if (leftId != -1) {
                                    id[i][j] = leftId;
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    } else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = upId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }
                            }
                        }
                    }
                }
            }

//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(id[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }

//            for (int i = 0; i < idChange.size(); i++)
//                System.out.println(idChange.get(i));

//            System.out.println(idLabel);

            int[] parents = new int[idLabel-1];

            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                if (parents[Integer.parseInt(parentId[0])-1] == 0) {
                    parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
                } else {
                    parents[Integer.parseInt(parentId[1])-1] = parents[Integer.parseInt(parentId[0])-1];
                }
            }


            for (int i = 0; i < parents.length; i++) {
                    System.out.print(parents[i] + """");
                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
//            System.out.println(targetId);
//            System.out.println(parents[targetId]);
            if (targetId != -1) {
                if (parents[targetId-1] == 0) {
                    System.out.println(targetId);
                } else {
                    System.out.println(parents[targetId - 1]);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@f0c01eead351e2c6a234da23112496e6@"
"r03849033","9","0.98","126000","@af718b860c815b75e9ebddd64614612f@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        
                    if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }

                }
                              
            System.out.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@af718b860c815b75e9ebddd64614612f@"
"r03525006","8","1","128704","@2c792f08e2e35a0d703e2c183102de90@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j - 1];
                                if (leftId != -1) {
                                    id[i][j] = leftId;
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    } else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = upId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }
                            }
                        }
                    }
                }
            }

//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(id[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }

//            for (int i = 0; i < idChange.size(); i++)
//                System.out.println(idChange.get(i));

//            System.out.println(idLabel);

            int[] parents = new int[idLabel-1];

            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                if (parents[Integer.parseInt(parentId[0])-1] == 0) {
                    parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
                } else {
                    parents[Integer.parseInt(parentId[1])-1] = parents[Integer.parseInt(parentId[0])-1];
                }
            }


//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + """");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
//            System.out.println(targetId);
//            System.out.println(parents[targetId]);
            if (targetId != -1) {
                if (parents[targetId-1] == 0) {
                    System.out.println(targetId);
                } else {
                    System.out.println(parents[targetId - 1]);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@2c792f08e2e35a0d703e2c183102de90@"
"r03222054","9","0.94","121376","@74fd627e07722349bf25cc10a7ecdd33@import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
     public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);   
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
             int [][] table = new int [size][size];
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                  check[xCor][yCor] =false;
             }
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                   if(check[i][j])
                     {
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                 root.set(left,above);
                             }
                         }
                     }
                     }
                   else
                       table[i-1][j-1]=0;
                 }     
                 }
              int label = table[x-1][y-1];
            //  int answer;
              while(true)
              {
                 
                  int temp=root.get(label);
                  if(temp == label)
                  {
                      break;
                  }
                  else
                      label=temp;
              }
             //answer = root.get(label);
              System.out.print(label);
             }
         }
     }
                          

@74fd627e07722349bf25cc10a7ecdd33@"
"r03849033","9","0.96","125184","@7507d12fcd93b0e02fa067126e1e959f@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        
                    if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=rootT;                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }
                }                  
            System.out.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@7507d12fcd93b0e02fa067126e1e959f@"
"r03849033","9","1","123536","@7582e581f8f30404da17950e480a010e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        
                    if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=rootT;                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }
                }                  
            System.out.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@7582e581f8f30404da17950e480a010e@"
"r03849033","9","0.95","121600","@8f1c326c889a0a85327935366a7d0a53@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;
    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }
    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     
    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            for (int r = 0;  r < 1; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        
                    if(c>0 && matrix[r][c-1]==false)    
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); 
                else {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //
                        else if( matrix[r][c-1]==false ){
                            if( matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            else if(labelL>labelT){
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            else{
                                root[xyTo1D(r,c)]=rootT;                            
                            }
                            }
                            else{root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));}
                        }
                        //
                        else if(matrix[r-1][c]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        else{                      
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }
                }                  
            System.out.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@8f1c326c889a0a85327935366a7d0a53@"
"r03723070","9","1","126992","@920bf32981bbc785181c18037ec6fb94@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       /*for(int i = 0;i<countforconnect;i++){
           for(int j = 0; j<countforconnect;j++){
               //System.out.printf(""connect[%d][0] is %d connect[%d][1] is %d\n"",j,connect[j][0],j,connect[j][1]);
           if(connect[i][0] == connect[j][1])
               connect[j][1] = connect[i][1];
           }
       }*/
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   

@920bf32981bbc785181c18037ec6fb94@"
"r04631035","7","0.9","111920","@d8cd367226035ab9fa675cf4ef27f2bb@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;/*

 /*
 * @author Pan
 */


public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
        String[] numbersArray = target.split("" "");
        //System.out.println(numbersArray[0]);
        String[] num = numbersArray[0].split("",""); //num:維度,目標位置

        int stringCount = Integer.parseInt(num[0]); //維度轉數字
        String[][] matrix = new String[stringCount][stringCount]; //建立空矩陣
        int targetr = Integer.parseInt(num[1]); //目標位置row
        int targetc = Integer.parseInt(num[2]); //目標位置col

        UF uf = new UF(stringCount * stringCount + 2);  //開List
        //ArrayList<Integer> replace = new ArrayList<Integer>();

        //放0
        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);
            matrix[input1 - 1][input2 - 1] = ""0""; //位置從0,0開始
        }
        //放1
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (matrix[i][j] == null) {
                    matrix[i][j] = ""1"";
                    // System.out.println(matrix[i][j]);
                }
            }
        }

        int zero = 0; //判斷前一個不是0,> 2的話則為黑格連續
        int label = 1; //標籤數字

        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (!""0"".equals(matrix[i][j])) {

                    if (i - 1 < 0 && j - 1 < 0) { //沒上沒左
                        String labels = Integer.toString(label);
                        matrix[i][j] = labels;
                    }
                    if (i - 1 >= 0 && j - 1 < 0) { //有上沒左
                        if (""0"".equals(matrix[i - 1][j])) {
                            label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                        }
                        if (!""0"".equals(matrix[i - 1][j])) {
                            matrix[i][j] = matrix[i - 1][j];
                        }

                    }
                    if (i - 1 < 0 && j - 1 >= 0) { //沒上有左
                        if (""0"".equals(matrix[i][j - 1])) {
                            label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                        }
                        if (!""0"".equals(matrix[i][j - 1])) {
                            matrix[i][j] = matrix[i][j - 1];
                        }
                    }
                    if (i - 1 >= 0 && j - 1 >= 0) { //有上有左
                        if (""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //左0上0
                            label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //上非0左0

                            matrix[i][j] = matrix[i - 1][j];
                        }
                        if (""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上0左非0

                            matrix[i][j] = matrix[i][j - 1];
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上左皆非0
                            int left = Integer.valueOf(matrix[i][j - 1]);
                            int up = Integer.valueOf(matrix[i - 1][j]);
                            if (left > up) {

                                matrix[i][j] = matrix[i - 1][j];
                                uf.union(up, left);
                                //System.out.println(uf.find(4));
                            }
                            if (up > left) {
                                matrix[i][j] = matrix[i][j - 1];
                                uf.union(left, up);
                                //System.out.println(uf.find(4));
                            }
                            if (up == left) {
                                matrix[i][j] = matrix[i][j - 1];
                            }

                        }

                    }

                }

            }
        }
        //System.out.println(uf.find(4));
        int[] change = new int[stringCount * stringCount];
        int[] parent = new int[stringCount * stringCount];
        int k = 0;
        for (int i = 0; i < stringCount * stringCount + 2; i++) {
            if (i != uf.find(i)) {
                change[k] = i;
                parent[k] = uf.find(i);
                k++;
            }
        }
        //System.out.println(change[3]);
        //System.out.println(parent.length);

        //System.out.println(label);
        //int b = 0;
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                for (int l = 0; l < stringCount * stringCount; l++) {
                    String c = Integer.toString(change[l]);
                    if (c.equals(matrix[i][j])) {
                        matrix[i][j] = Integer.toString(parent[l]);

                    }
                }

            }
        }
        System.out.println(matrix[targetr - 1][targetc - 1]);

    }
}

@d8cd367226035ab9fa675cf4ef27f2bb@"
"r03723070","8","0.91","124592","@12f11099134ef996219332f4ba4f5af4@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N/2+1][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
       //show second step the primitve metrix
       /*for (int i = 0;i<N+1;i++ ){
           for (int j = 0;j<N+1;j++ ){
               if(data[i][j] != -1)
                   System.out.printf("" %d"", data[i][j]); 
               else
               System.out.printf(""%d"", data[i][j]);
               if(j==N)
               System.out.printf(""\n"", data[i][j]);  
           }
       }*/
       //print all connect
       /*for (int i =0;i< N*N/2+1;i++){
            if(connect[i]!=0)
            System.out.printf(""connect[%d] is %d\n"",i,connect[i]);
       }*/
       /*for(int i = 0;i<countforconnect;i++){
           for(int j = 0; j<countforconnect;j++){
               //System.out.printf(""connect[%d][0] is %d connect[%d][1] is %d\n"",j,connect[j][0],j,connect[j][1]);
           if(connect[i][0] == connect[j][1])
               connect[j][1] = connect[i][1];
           }
       }*/
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   

@12f11099134ef996219332f4ba4f5af4@"
"r03222054","8","1","121504","@039ad8b3e9c59d92093d47b985a6061e@import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
     public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);   
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
             int [][] table = new int [size][size];
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                  check[xCor][yCor] =false;
             }
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                   if(check[i][j])
                     {
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                             //   root.set(above, left);
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                           //      root.set(left,above);
                             }
                         }
                     }
                     }
                   else
                       table[i-1][j-1]=0;
                 }     
                 }
              int label = table[x-1][y-1];
            //  int answer;
              while(true)
              {
                 
                  int temp=root.get(label);
                  if(temp == label)
                  {
                      break;
                  }
                  else
                      label=temp;
              }
             //answer = root.get(label);
              System.out.print(label);
             }
         }
     }
                          

@039ad8b3e9c59d92093d47b985a6061e@"
"r03222054","9","0.93","126928","@508d038bc51169fde8fab1b3014d96be@import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
     public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);   
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
             int [][] table = new int [size][size];
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                  check[xCor][yCor] =false;
             }
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                   if(check[i][j])
                     {
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above, left);
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                root.set(left,above);
                             }
                         }
                     }
                     }
                   else
                       table[i-1][j-1]=0;
                 }     
                 }
              int label = table[x-1][y-1];
            //  int answer;
              while(true)
              {
                 
                  int temp=root.get(label);
                  if(temp == label)
                  {
                      break;
                  }
                  else
                      label=temp;
              }
             //answer = root.get(label);
              System.out.print(label);
             }
         }
     }
                          

@508d038bc51169fde8fab1b3014d96be@"
"r03723070","9","0.99","129584","@ddc7bf6da7ec9592e77a346bfd9e30be@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                           data[i][j] = data[i][j-1]; 
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   

@ddc7bf6da7ec9592e77a346bfd9e30be@"
"r03525006","8","0.98","130432","@5d9c81144265b204e16c076c99bea63a@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j - 1];
                                if (leftId != -1) {
                                    id[i][j] = leftId;
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    } else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = upId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }
                            }
                        }
                    }
                }
            }

//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(id[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }

//            for (int i = 0; i < idChange.size(); i++)
//                System.out.println(idChange.get(i));

//            System.out.println(idLabel);

            int[] parents = new int[idLabel-1];
            int ha = 0;
            int repeatId = 0;
            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                if (parents[Integer.parseInt(parentId[0])-1] == 0) {
                    parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
                } else {
                    repeatId = Integer.parseInt(parentId[0]);
                    ha++;
                    parents[Integer.parseInt(parentId[1])-1] = parents[Integer.parseInt(parentId[0])-1];
                }
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + """");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
//            System.out.println(targetId);
//            System.out.println(parents[targetId]);
            if (targetId != -1) {
                if (parents[targetId-1] == 0) {
                    if (targetId > repeatId)
                        System.out.println(targetId-ha);
                    else
                        System.out.println(targetId);
                } else {
                    if (parents[targetId - 1] > repeatId)
                        System.out.println(parents[targetId - 1]-ha);
                    else
                        System.out.println(parents[targetId - 1]);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@5d9c81144265b204e16c076c99bea63a@"
"r04631035","7","0.89","111776","@b116c50a32f97401cb6cc0cb2d8c5252@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;/*

 /*
 * @author Pan
 */


public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
        String[] numbersArray = target.split("" "");
        //System.out.println(numbersArray[0]);
        String[] num = numbersArray[0].split("",""); //num:維度,目標位置

        int stringCount = Integer.parseInt(num[0]); //維度轉數字
        String[][] matrix = new String[stringCount][stringCount]; //建立空矩陣
        int targetr = Integer.parseInt(num[1]); //目標位置row
        int targetc = Integer.parseInt(num[2]); //目標位置col

        UF uf = new UF(stringCount * stringCount);  //開List
        //ArrayList<Integer> replace = new ArrayList<Integer>();

        //放0
        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);
            matrix[input1 - 1][input2 - 1] = ""0""; //位置從0,0開始
        }
        //放1
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (matrix[i][j] == null) {
                    matrix[i][j] = ""1"";
                    // System.out.println(matrix[i][j]);
                }
            }
        }

        int zero = 0; //判斷前一個不是0,> 2的話則為黑格連續
        int label = 1; //標籤數字

        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (!""0"".equals(matrix[i][j])) {

                    if (i - 1 < 0 && j - 1 < 0) { //沒上沒左
                        String labels = Integer.toString(label);
                        matrix[i][j] = labels;
                    }
                    if (i - 1 >= 0 && j - 1 < 0) { //有上沒左
                        if (""0"".equals(matrix[i - 1][j])) {
                            label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                        }
                        if (!""0"".equals(matrix[i - 1][j])) {
                            matrix[i][j] = matrix[i - 1][j];
                        }

                    }
                    if (i - 1 < 0 && j - 1 >= 0) { //沒上有左
                        if (""0"".equals(matrix[i][j - 1])) {
                            label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                        }
                        if (!""0"".equals(matrix[i][j - 1])) {
                            matrix[i][j] = matrix[i][j - 1];
                        }
                    }
                    if (i - 1 >= 0 && j - 1 >= 0) { //有上有左
                        if (""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //左0上0
                            label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //上非0左0

                            matrix[i][j] = matrix[i - 1][j];
                        }
                        if (""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上0左非0

                            matrix[i][j] = matrix[i][j - 1];
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上左皆非0
                            int left = Integer.valueOf(matrix[i][j - 1]);
                            int up = Integer.valueOf(matrix[i - 1][j]);
                            if (left > up) {

                                matrix[i][j] = matrix[i - 1][j];
                                uf.union(up, left);
                                //System.out.println(uf.find(4));
                            }
                            if (up > left) {
                                matrix[i][j] = matrix[i][j - 1];
                                uf.union(left, up);
                                //System.out.println(uf.find(4));
                            }
                            if (up == left) {
                                matrix[i][j] = matrix[i][j - 1];
                            }

                        }

                    }

                }

            }
        }
        //System.out.println(uf.find(4));
        int[] change = new int[stringCount * stringCount];
        int[] parent = new int[stringCount * stringCount];
        int k = 0;
        for (int i = 0; i < stringCount * stringCount; i++) {
            if (i != uf.find(i)) {
                change[k] = i;
                parent[k] = uf.find(i);
                k++;
            }
        }
        //System.out.println(change[3]);
        //System.out.println(parent.length);

        //System.out.println(label);
        //int b = 0;
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                for (int l = 0; l < stringCount * stringCount; l++) {
                    String c = Integer.toString(change[l]);
                    if (c.equals(matrix[i][j])) {
                        matrix[i][j] = Integer.toString(parent[l]);

                    }
                }

            }
        }
        System.out.println(matrix[targetr - 1][targetc - 1]);

    }
}

@b116c50a32f97401cb6cc0cb2d8c5252@"
"r03525006","8","1.01","133696","@444f691188d0678d9ebaff8d84db8293@import java.io.FileReader;
import java.io.BufferedReader;
import java.util.ArrayList;
/**
 * Created by ASUS on 2016/3/11.
 */
public class LabelCC {
    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");
            int num = Integer.parseInt(data[0]);

            int[][] id = new int[num][num];

            ArrayList<String> lines = new ArrayList<String>();
            ArrayList<String> idChange = new ArrayList<String>();

            while (br.ready())
                lines.add(br.readLine());
            br.close();

            for (String line : lines) {
                String[] coordinates = line.split("","");
                int row = Integer.parseInt(coordinates[0]) - 1;
                int col = Integer.parseInt(coordinates[1]) - 1 ;
                id[row][col] = -1;
            }

            int idLabel = 1;
            for (int i = 0; i < num; i++) {
                for (int j = 0; j < num; j++) {
                    if (i == 0) {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                id[i][j] = idLabel;
                                idLabel++;
                            } else {
                                int leftId = id[i][j - 1];
                                if (leftId != -1) {
                                    id[i][j] = leftId;
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            }
                        }
                    } else {
                        if (id[i][j] != -1) {
                            if (j == 0) {
                                if (id[i - 1][j] != -1) {
                                    id[i][j] = id[i - 1][j];
                                } else {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                }
                            } else {
                                int upId = id[i - 1][j];
                                int leftId = id[i][j - 1];
                                Boolean isUpId = (upId == -1);
                                Boolean isLeftId = (leftId == -1);
                                if (isUpId && isLeftId) {
                                    id[i][j] = idLabel;
                                    idLabel++;
                                } else if (!isUpId && !isLeftId){
                                    if (upId > leftId) {
                                        id[i][j] = upId;
                                        String numberChange = upId + "","" + leftId;
                                        idChange.add(numberChange);
                                    } else if (upId == leftId) {
                                        id[i][j] = upId;
                                    } else {
                                        id[i][j] = leftId;
                                        String numberChange = leftId + "","" + upId;
                                        idChange.add(numberChange);
                                    }
                                } else {
                                    if (isUpId)
                                        id[i][j] = leftId;
                                    if (isLeftId)
                                        id[i][j] = upId;
                                }
                            }
                        }
                    }
                }
            }

//            for (int i = 0; i < num; i++) {
//                for (int j = 0; j < num; j++) {
//                    System.out.print(id[i][j] + "" "");
//                }
//                System.out.println("" "");
//            }

//            for (int i = 0; i < idChange.size(); i++)
//                System.out.println(idChange.get(i));

//            System.out.println(idLabel);

            int[] parents = new int[idLabel-1];

            for (int i = 0; i < idChange.size(); i++) {
                String[] parentId = idChange.get(i).split("","");
                if (parents[Integer.parseInt(parentId[0])-1] == 0) {
                    parents[Integer.parseInt(parentId[0])-1] = Integer.parseInt(parentId[1]);
                } else {
                    parents[Integer.parseInt(parentId[1])-1] = parents[Integer.parseInt(parentId[0])-1];
                }
            }

//            for (int i = 0; i < parents.length; i++) {
//                    System.out.print(parents[i] + """");
//                }

            int targetRow = Integer.parseInt(data[1]);
            int targetCol = Integer.parseInt(data[2]);
            int targetId = id[targetRow-1][targetCol-1];
//            System.out.println(targetId);
//            System.out.println(parents[targetId]);
            if (targetId != -1) {
                if (parents[targetId-1] == 0) {
                    System.out.println(targetId);
                } else {
                    System.out.println(parents[targetId - 1]);
                }
            } else {
                System.out.println(0);
            }

        }
    }
}
@444f691188d0678d9ebaff8d84db8293@"
"r03723070","8","0.92","127552","@86a3fa195f595ad499933cc670cd654b@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N/2+2][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){
                            
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                           else
                               data[i][j] = data[i][j-1];
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   

@86a3fa195f595ad499933cc670cd654b@"
"r03222054","9","0.99","124576","@7ae4d5c66f535a7c6703122466235e66@import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
     public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);   
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
             int [][] table = new int [size][size];
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                  check[xCor][yCor] =false;
             }
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                   if(check[i][j])
                     {
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above,root.get( left));
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                root.set(left,root.get(above));
                             }
                         }
                     }
                     }
                   else
                       table[i-1][j-1]=0;
                 }     
                 }
              int label = table[x-1][y-1];
            //  int answer;
              while(true)
              {
                 
                  int temp=root.get(label);
                  if(temp == label)
                  {
                      break;
                  }
                  else
                      label=temp;
              }
             //answer = root.get(label);
              System.out.print(label);
             }
         }
     }
                          

@7ae4d5c66f535a7c6703122466235e66@"
"r04631035","7","0.89","110720","@20b1881a0a89d3ae782e1f4be35e0c4f@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;/*

 /*
 * @author Pan
 */


public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
        String[] numbersArray = target.split("" "");
        //System.out.println(numbersArray[0]);
        String[] num = numbersArray[0].split("",""); //num:維度,目標位置

        int stringCount = Integer.parseInt(num[0]); //維度轉數字
        String[][] matrix = new String[stringCount][stringCount]; //建立空矩陣
        int targetr = Integer.parseInt(num[1]); //目標位置row
        int targetc = Integer.parseInt(num[2]); //目標位置col

        UF uf = new UF(stringCount * stringCount);  //開List
        //ArrayList<Integer> replace = new ArrayList<Integer>();

        //放0
        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);
            matrix[input1 - 1][input2 - 1] = ""0""; //位置從0,0開始
        }
        //放1
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (matrix[i][j] == null) {
                    matrix[i][j] = ""1"";
                    // System.out.println(matrix[i][j]);
                }
            }
        }

        int label = 1; //標籤數字

        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (!""0"".equals(matrix[i][j])) {

                    if (i - 1 < 0 && j - 1 < 0) { //沒上沒左
                        String labels = Integer.toString(label);
                        matrix[i][j] = labels;
                        label++;
                    }
                    if (i - 1 >= 0 && j - 1 < 0) { //有上沒左
                        if (""0"".equals(matrix[i - 1][j])) {
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                            label++;
                        }
                        if (!""0"".equals(matrix[i - 1][j])) {
                            matrix[i][j] = matrix[i - 1][j];
                        }

                    }
                    if (i - 1 < 0 && j - 1 >= 0) { //沒上有左
                        if (""0"".equals(matrix[i][j - 1])) {
                            //label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                            label++;
                        }
                        if (!""0"".equals(matrix[i][j - 1])) {
                            matrix[i][j] = matrix[i][j - 1];
                        }
                    }
                    if (i - 1 >= 0 && j - 1 >= 0) { //有上有左
                        if (""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //左0上0
                            //label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                            label++;
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //上非0左0

                            matrix[i][j] = matrix[i - 1][j];
                        }
                        if (""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上0左非0

                            matrix[i][j] = matrix[i][j - 1];
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上左皆非0
                            int left = Integer.valueOf(matrix[i][j - 1]);
                            int up = Integer.valueOf(matrix[i - 1][j]);
                            if (left > up) {

                                matrix[i][j] = matrix[i - 1][j];
                                uf.union(up, left);
                                //System.out.println(uf.find(4));
                            }
                            if (up > left) {
                                matrix[i][j] = matrix[i][j - 1];
                                uf.union(left, up);
                                //System.out.println(uf.find(4));
                            }
                            if (up == left) {
                                matrix[i][j] = matrix[i][j - 1];
                            }

                        }

                    }

                }

            }
        }
        //System.out.println(uf.find(4));
        int[] change = new int[stringCount * stringCount];
        int[] parent = new int[stringCount * stringCount];
        int k = 0;
        for (int i = 0; i < stringCount * stringCount; i++) {
            if (i != uf.find(i)) {
                change[k] = i;
                parent[k] = uf.find(i);
                k++;
            }
        }
        //System.out.println(change[3]);
        //System.out.println(parent.length);

        //System.out.println(label);
        //int b = 0;
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                for (int l = 0; l < stringCount * stringCount; l++) {
                    String c = Integer.toString(change[l]);
                    if (c.equals(matrix[i][j])) {
                        matrix[i][j] = Integer.toString(parent[l]);

                    }
                }

            }
        }
        System.out.println(matrix[targetr - 1][targetc - 1]);

    }
}

@20b1881a0a89d3ae782e1f4be35e0c4f@"
"r03723070","9","1","131392","@15e42c0b18fd235aca341a8c96819415@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){                          
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                           else
                               data[i][j] = data[i][j-1];
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   

@15e42c0b18fd235aca341a8c96819415@"
"r03723070","9","1.02","126784","@15e42c0b18fd235aca341a8c96819415@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0){                          
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                           else
                               data[i][j] = data[i][j-1];
                        }
                   else
                           data[i][j] =data[i-1][j];
                       }
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   

@15e42c0b18fd235aca341a8c96819415@"
"r03723070","9","1.01","127184","@eaba15e6a3e57eeb17c5705c7261b5fd@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0 && data[i-1][j] > 0){                          
                           if( data[i-1][j] > 0){
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            }
                           
                        }
                   else
                           data[i][j] =Math.max(data[i-1][j],data[i][j-1]);
                       }
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   

@eaba15e6a3e57eeb17c5705c7261b5fd@"
"r03723070","9","0.99","125200","@13f0291955264cb4378620b087238a4f@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0 && data[i-1][j] > 0){                          
                          
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                            
                           
                        }
                   else
                           data[i][j] =Math.max(data[i-1][j],data[i][j-1]);
                       }
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       }
       //block
       else
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   

@13f0291955264cb4378620b087238a4f@"
"r03222054","9","0.97","120480","@5816306a038fd5b0a624789de0e086fb@import java.util.Vector;
import java.io.FileReader;
import java.io.BufferedReader;
public class LabelCC 
{   
    static  int count =0;
    static int size;
     static  Vector <Integer>root =new Vector<>();
     public static void main(String[] args) throws Exception 
    {
         try (BufferedReader br = new BufferedReader(new FileReader(args[0])))
         {
            String[] line = br.readLine().split("","");
           size= Integer.parseInt(line[0]);
            int x=Integer.parseInt(line[1]);
             int y=Integer.parseInt(line[2]);   
             boolean[][] check=new boolean[size+2][size+2];
             for (int i=1; i<size+1; i++)
             {
                for(int j=1; j<size+1; j++)
                {
                    check[i][j]=true;
                }
             }
             int [][] table = new int [size][size];
             String Line;
             root.add(count);
             while((Line = br.readLine())!=null )
             {
                 String[] data = Line.split("","");
                 int xCor = Integer.parseInt(data[0]);
                  int yCor = Integer.parseInt(data[1]);
                  check[xCor][yCor] =false;
             }
             for (int i= 1; i<size+1; i++)
             {
                 for (int j=1; j<size+1; j++)
                 {
                   if(check[i][j])
                     {
                     if(!check[i-1][j] )
                     {
                         if(! check[i][j-1])
                         {
                             count++;
                             table[i-1][j-1] =count;
                             root.add(count);
                             //   System.out.print(""(""+i +"",""+ j+"")\n\n"");
                         }
                         else 
                         {
                             table[i-1][j-1]=table[i-1][j-2];
                         }
                     }
                 
                     else
                     {
                         if(!check[i][j-1])
                         {
                             table[i-1][j-1]=table[i-2][j-1];
                         }
                         
                         else
                         {
                             int above = table[i-1][j-2];
                             int left = table[i-2][j-1];
                             if (above>=left)
                             {
                                 table[i-1][j-1]= left;
                                root.set(above,root.get( left));
                             }
                             else
                             {
                                 table[i-1][j-1] = above;
                                root.set(left,root.get(above));
                             }
                         }
                     }
                     }
                   else
                       table[i-1][j-1]=0;
                 }     
                 }
              int label = table[x-1][y-1];
            //  int answer;
            //  while(true)
              //{
                 
                  int temp=root.get(label);
//                  if(temp == label)
//                  {
//                      break;
//                  }
//                  else
//                      label=temp;
//              }
//             //answer = root.get(label);
              System.out.print(temp);
             }
         }
     }
                          

@5816306a038fd5b0a624789de0e086fb@"
"r03723070","9","1","127696","@60cbf53e65c489788f85669f9c1d88a3@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 )&& (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0 && data[i-1][j] > 0){                                                   
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               /*for(int k =0;k<N*N/2+1;k++){
                                        if(connect[k] == op)
                                            connect[k]= oq;
                               }*/
                        }
                   else
                           data[i][j] =Math.max(data[i-1][j],data[i][j-1]);
                       }
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       //if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       //}
       //block
       if(data[ans[0]][ans[1]]==-1)
       finalans = 0;
       System.out.printf(""%d\n"",finalans);
        
       }
    }
   

@60cbf53e65c489788f85669f9c1d88a3@"
"r03849033","9","1.02","127328","@3df1d53f4bfc1d12e17012e676514fe6@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            if(matrix[0][0]==false){
                    label[xyTo1D(0,0)]=count;
                    count++;
            }
            for (int r = 0;  r < 1; r++){
                for (int c = 1;  c < n; c++){
                    if(matrix[r][c]==false){           
                    if(matrix[r][c-1]==false) {   
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); }
                    if(matrix[r][c-1]==true) {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            else {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //      
                    if( c>0 && matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            if(labelL==labelT){
                                root[xyTo1D(r,c)]=rootT;                            
                            }
                            }
                        //
                        if(c>0 && matrix[r-1][c]==false && matrix[r][c-1]==true){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        if(c>0 && matrix[r-1][c]==true && matrix[r][c-1]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));  }                        
                        if(c>0 && matrix[r-1][c]==true && matrix[r][c-1]==true){                   
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }
                }
             System.out.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@3df1d53f4bfc1d12e17012e676514fe6@"
"r04631035","9","2.87","179744","@9c68152985a1b334e8fa0b7448cc80df@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;/*

 /*
 * @author Pan
 */


public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
        String[] numbersArray = target.split("" "");
        //System.out.println(numbersArray[0]);
        String[] num = numbersArray[0].split("",""); //num:維度,目標位置

        int stringCount = Integer.parseInt(num[0]); //維度轉數字
        String[][] matrix = new String[stringCount][stringCount]; //建立空矩陣
        int targetr = Integer.parseInt(num[1]); //目標位置row
        int targetc = Integer.parseInt(num[2]); //目標位置col

        UF uf = new UF(stringCount * stringCount);  //開List
        //ArrayList<Integer> replace = new ArrayList<Integer>();

        //放0
        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);
            matrix[input1 - 1][input2 - 1] = ""0""; //位置從0,0開始
        }
        //放1
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (matrix[i][j] == null) {
                    matrix[i][j] = ""1"";
                    // System.out.println(matrix[i][j]);
                }
            }
        }

        int label = 1; //標籤數字

        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (!""0"".equals(matrix[i][j])) {

                    if (i - 1 < 0 && j - 1 < 0) { //沒上沒左
                        String labels = Integer.toString(label);
                        matrix[i][j] = labels;
                        label++;
                    }
                    if (i - 1 >= 0 && j - 1 < 0) { //有上沒左
                        if (""0"".equals(matrix[i - 1][j])) {
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                            label++;
                        }
                        if (!""0"".equals(matrix[i - 1][j])) {
                            matrix[i][j] = matrix[i - 1][j];
                        }

                    }
                    if (i - 1 < 0 && j - 1 >= 0) { //沒上有左
                        if (""0"".equals(matrix[i][j - 1])) {
                            //label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                            label++;
                        }
                        if (!""0"".equals(matrix[i][j - 1])) {
                            matrix[i][j] = matrix[i][j - 1];
                        }
                    }
                    if (i - 1 >= 0 && j - 1 >= 0) { //有上有左
                        if (""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //左0上0
                            //label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                            label++;
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //上非0左0

                            matrix[i][j] = matrix[i - 1][j];
                        }
                        if (""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上0左非0

                            matrix[i][j] = matrix[i][j - 1];
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上左皆非0
                            int left = Integer.valueOf(matrix[i][j - 1]);
                            int up = Integer.valueOf(matrix[i - 1][j]);
                            if (left > up) {

                                matrix[i][j] = matrix[i - 1][j];
                                uf.union(up, left);
                                //System.out.println(uf.find(4));
                            }
                            if (up > left) {
                                matrix[i][j] = matrix[i][j - 1];
                                uf.union(left, up);
                                //System.out.println(uf.find(4));
                            }
                            if (up == left) {
                                matrix[i][j] = Integer.toString(up);
                            }

                        }

                    }

                }

            }
        }
        //System.out.println(uf.find(4));
        int[] change = new int[stringCount * stringCount];
        int[] parent = new int[stringCount * stringCount];
        int k = 0;
        for (int i = 0; i < stringCount * stringCount; i++) {
            if (i != uf.find(i)) {
                change[k] = i;
                parent[k] = uf.find(i);
                k++;
            }
        }
        //System.out.println(change[3]);
        //System.out.println(parent.length);

        //System.out.println(label);
        //int b = 0;
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                for (int l = 0; l < stringCount * stringCount; l++) {
                    String c = Integer.toString(change[l]);
                    if(change[l]==0){
                        break;
                    }
                    if (c.equals(matrix[i][j])) {
                        matrix[i][j] = Integer.toString(parent[l]);

                    }
                }

            }
        }
        System.out.println(matrix[targetr - 1][targetc - 1]);

    }
}

@9c68152985a1b334e8fa0b7448cc80df@"
"r03723070","9","0.99","124944","@ed89888419588653332457652af2fba0@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 ) && (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0 && data[i-1][j] > 0){                                                   
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                        }
                   else
                           data[i][j] =Math.max(data[i-1][j],data[i][j-1]);
                       }
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       //if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       //}
       //block
       if(data[ans[0]][ans[1]]==-1)
       finalans = 0;
       System.out.printf(""%d\n"",finalans);        
       }
    }
   

@ed89888419588653332457652af2fba0@"
"r03723070","3","1.02","135136","@166f81a764bc562154ef30b7b70956b8@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               //if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 ) && (data[i-1][j] <= 0)&&data[i][j]!=-1){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0 && data[i-1][j] > 0&&data[i][j]!=-1){                                                   
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               connect[countforconnect][0] = p;
                               connect[countforconnect][1] = q;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                        }
                     else if (data[i][j-1]>0 || data[i-1][j] > 0&&data[i][j]!=-1)
                           data[i][j] =Math.max(data[i-1][j],data[i][j-1]);
                       
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       //if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       //}
       //block
       if(data[ans[0]][ans[1]]==-1)
       finalans = 0;
       System.out.printf(""%d\n"",finalans);        
       }
    }
   

@166f81a764bc562154ef30b7b70956b8@"
"r04631035","9","2.82","173312","@7eb28a5b547fcabfaa1e557cccb0b585@
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.*;
//import edu.princeton.cs.algs4.*;/*

 /*
 * @author Pan
 */


public class LabelCC {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        // TODO code application logic here
        In in = new In(args[0]);
//                    System.out.println(in);
//                    System.out.println(""**"");
//               String[] data = in.readLine().split("","");
//               System.out.println(data[1]);
        String line;
        String target = """";

        while ((line = in.readLine()) != null) {
            target += line + "" "";
        }
        String[] numbersArray = target.split("" "");
        //System.out.println(numbersArray[0]);
        String[] num = numbersArray[0].split("",""); //num:維度,目標位置

        int stringCount = Integer.parseInt(num[0]); //維度轉數字
        String[][] matrix = new String[stringCount][stringCount]; //建立空矩陣
        int targetr = Integer.parseInt(num[1]); //目標位置row
        int targetc = Integer.parseInt(num[2]); //目標位置col

        UF uf = new UF(stringCount * stringCount);  //開List
        //ArrayList<Integer> replace = new ArrayList<Integer>();

        //放0
        for (int i = 1; i < numbersArray.length; i++) {
            String[] input = numbersArray[i].split("",""); //
            int input1 = Integer.parseInt(input[0]);
            int input2 = Integer.parseInt(input[1]);
            matrix[input1 - 1][input2 - 1] = ""0""; //位置從0,0開始
        }
        //放1
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (matrix[i][j] == null) {
                    matrix[i][j] = ""1"";
                    // System.out.println(matrix[i][j]);
                }
            }
        }

        int label = 1; //標籤數字

        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                if (!""0"".equals(matrix[i][j])) {

                    if (i - 1 < 0 && j - 1 < 0) { //沒上沒左
                        String labels = Integer.toString(label);
                        matrix[i][j] = labels;
                        label++;
                    }
                    if (i - 1 >= 0 && j - 1 < 0) { //有上沒左
                        if (""0"".equals(matrix[i - 1][j])) {
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                            label++;
                        }
                        if (!""0"".equals(matrix[i - 1][j])) {
                            matrix[i][j] = matrix[i - 1][j];
                        }

                    }
                    if (i - 1 < 0 && j - 1 >= 0) { //沒上有左
                        if (""0"".equals(matrix[i][j - 1])) {
                            //label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                            label++;
                        }
                        if (!""0"".equals(matrix[i][j - 1])) {
                            matrix[i][j] = matrix[i][j - 1];
                        }
                    }
                    if (i - 1 >= 0 && j - 1 >= 0) { //有上有左
                        if (""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //左0上0
                            //label++;
                            String labels = Integer.toString(label);
                            matrix[i][j] = labels;
                            label++;
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && ""0"".equals(matrix[i][j - 1])) { //上非0左0

                            matrix[i][j] = matrix[i - 1][j];
                        }
                        if (""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上0左非0

                            matrix[i][j] = matrix[i][j - 1];
                        }
                        if (!""0"".equals(matrix[i - 1][j]) && !""0"".equals(matrix[i][j - 1])) { //上左皆非0
                            int left = Integer.valueOf(matrix[i][j - 1]);
                            int up = Integer.valueOf(matrix[i - 1][j]);
                            if (left > up) {

                                matrix[i][j] = matrix[i - 1][j];
                                uf.union(up, left);
                                //System.out.println(uf.find(4));
                            }
                            if (up > left) {
                                matrix[i][j] = matrix[i][j - 1];
                                uf.union(left, up);
                                //System.out.println(uf.find(4));
                            }
                            if (up == left) {
                                matrix[i][j] = Integer.toString(up);
                            }

                        }

                    }

                }

            }
        }
        //System.out.println(uf.find(4));
        int[] change = new int[stringCount * stringCount];
        int[] parent = new int[stringCount * stringCount];
        int k = 0;
        for (int i = 0; i < stringCount * stringCount; i++) {
            if (i != uf.find(i)) {
                change[k] = i;
                parent[k] = uf.find(i);
                k++;
            }
        }
        //System.out.println(change[3]);
        //System.out.println(parent.length);

        //System.out.println(label);
        //int b = 0;
        for (int i = 0; i < stringCount; i++) {
            for (int j = 0; j < stringCount; j++) {
                for (int l = 0; l < stringCount * stringCount; l++) {
                    String c = Integer.toString(change[l]);
                    if (change[l] == 0) {
                        break;
                    }
                    if (c.equals(matrix[i][j])) {
                        matrix[i][j] = Integer.toString(parent[l]);

                    }
                }

            }
        }
        System.out.println(matrix[targetr - 1][targetc - 1]);

    }
}

@7eb28a5b547fcabfaa1e557cccb0b585@"
"r03849033","9","0.99","123344","@5b4c0d72092ea55b338e300c84cdc23b@
import java.io.BufferedReader;
import java.io.FileReader;

public class LabelCC {
public static int n;
public static int count=1;
public static int[] label;
public static int[] root;
public static boolean[][] matrix;

    public static int xyTo1D(int i, int j) {
        return i*n+j;
    }

    public static int findroot( int i) {
        while(i!=root[i]){    
            root[i]=root[root[i]];
            i=root[i];
        }
        return i;
    }     

    public static void main(String[] args) throws Exception {
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data = br.readLine().split("","");

            n = Integer.parseInt(data[0]);
            int x = Integer.parseInt(data[1]);
            int y = Integer.parseInt(data[2]);
            label = new int[n*n];
            root = new int[n*n];
            for (int i = 0; i < n*n; i++){
                root[i]=i;
            }
            
            matrix = new boolean[n][n];
            for (int i = 0; i < n*n; i++){                
                String da = br.readLine();
                if(da==null){break;}
                String[] d = da.split("","");
                int p = Integer.parseInt(d[0]);
                int q = Integer.parseInt(d[1]);
                matrix[p-1][q-1]=true;}

            //srart
            if(matrix[0][0]==false){
                    label[xyTo1D(0,0)]=count;
                    count++;
            }
            for (int r = 0;  r < 1; r++){
                for (int c = 1;  c < n; c++){
                    if(matrix[r][c]==false){           
                    if(matrix[r][c-1]==false) {   
                    root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1)); }
                    if(matrix[r][c-1]==true) {
                    label[xyTo1D(r,c)]=count;
                    count++;
                     }                
                } }  }            
            
            for (int r = 1;  r < n; r++){
                for (int c = 0;  c < n; c++){
                    if(matrix[r][c]==false){
                        //
                        if(c==0){
                            if(matrix[r-1][c]==false)
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));                           
                            if(matrix[r-1][c]==true) {
                                label[xyTo1D(r,c)]=count;
                                count++;
                            }
                        }                                
                        //      
                    if( c>0 && matrix[r][c-1]==false && matrix[r-1][c]==false){
                            int rootL = findroot(xyTo1D(r,c-1));                            
                            int rootT = findroot(xyTo1D(r-1,c));
                            int labelL = label[rootL];
                            int labelT = label[rootT];                           
                            if(labelL<labelT){
                                label[rootT]=0;
                                root[rootT]=rootL;
                                root[xyTo1D(r,c)]=rootL;                        
                            }
                            if(labelL>labelT){
                                label[rootL]=0;
                                root[rootL]=rootT;
                                root[xyTo1D(r,c)]=rootT;                          
                            }
                            if(labelL==labelT){
                                root[xyTo1D(r,c)]=rootT;                            
                            }
                            }
                        //
                        if(c>0 && matrix[r-1][c]==false && matrix[r][c-1]==true){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r-1,c));  }
                        if(c>0 && matrix[r-1][c]==true && matrix[r][c-1]==false){
                                root[xyTo1D(r,c)]=findroot(xyTo1D(r,c-1));  }                        
                        if(c>0 && matrix[r-1][c]==true && matrix[r][c-1]==true){                   
                            label[xyTo1D(r,c)]=count;
                            count++;
                            }
                        }
                    }
                }
             System.out.println(label[findroot(xyTo1D(x-1,y-1))]); 
        }            
    }
}

@5b4c0d72092ea55b338e300c84cdc23b@"
"r04921065","0","0.098","105840","@0608c01d0447e3003238498005c1f797@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import labelCC.QuickFindUF;

/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }

            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
        
@0608c01d0447e3003238498005c1f797@"
"r04921065","0",NULL,NULL,"@0618e5d5ccd253cbdc1707fc0beb2957@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import labelCC.QuickFindUF;

/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }

            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
@0618e5d5ccd253cbdc1707fc0beb2957@"
"r04921065","0","0.106","105488","@d09c6ca5efdb1463f24caa98e341cfdc@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import labelCC.QuickFindUF;

/**
 *
 * @author steven
 */import edu.princeton.cs.algs4.StdIn;
import edu.princeton.cs.algs4.StdOut;
import java.awt.Label;

/**
 *  The <tt>QuickFindUF</tt> class represents a <em>union-find data type</em>
 *  (also known as the <em>disjoint-sets data type</em>).
 *  It supports the <em>union</em> and <em>find</em> operations,
 *  along with a <em>connected</em> operation for determining whether
 *  two sites are in the same component and a <em>count</em> operation that
 *  returns the total number of components.
 *  <p>
 *  The union-find data type models connectivity among a set of <em>N</em>
 *  sites, named 0 through <em>N</em> &ndash; 1.
 *  The <em>is-connected-to</em> relation must be an 
 *  <em>equivalence relation</em>:
 *  <ul>
 *  <p><li> <em>Reflexive</em>: <em>p</em> is connected to <em>p</em>.
 *  <p><li> <em>Symmetric</em>: If <em>p</em> is connected to <em>q</em>,
 *          then <em>q</em> is connected to <em>p</em>.
 *  <p><li> <em>Transitive</em>: If <em>p</em> is connected to <em>q</em>
 *          and <em>q</em> is connected to <em>r</em>, then
 *          <em>p</em> is connected to <em>r</em>.
 *  </ul>
 *  <p>
 *  An equivalence relation partitions the sites into
 *  <em>equivalence classes</em> (or <em>components</em>). In this case,
 *  two sites are in the same component if and only if they are connected.
 *  Both sites and components are identified with integers between 0 and
 *  <em>N</em> &ndash; 1. 
 *  Initially, there are <em>N</em> components, with each site in its
 *  own component.  The <em>component identifier</em> of a component
 *  (also known as the <em>root</em>, <em>canonical element</em>, <em>leader</em>,
 *  or <em>set representative</em>) is one of the sites in the component:
 *  two sites have the same component identifier if and only if they are
 *  in the same component.
 *  <ul>
 *  <p><li><em>union</em>(<em>p</em>, <em>q</em>) adds a
 *         connection between the two sites <em>p</em> and <em>q</em>.
 *         If <em>p</em> and <em>q</em> are in different components,
 *         then it replaces
 *         these two components with a new component that is the union of
 *         the two.
 *  <p><li><em>find</em>(<em>p</em>) returns the component
 *         identifier of the component containing <em>p</em>.
 *  <p><li><em>connected</em>(<em>p</em>, <em>q</em>)
 *         returns true if both <em>p</em> and <em>q</em>
 *         are in the same component, and false otherwise.
 *  <p><li><em>count</em>() returns the number of components.
 *  </ul>
 *  <p>
 *  The component identifier of a component can change
 *  only when the component itself changes during a call to
 *  <em>union</em>&mdash;it cannot change during a call
 *  to <em>find</em>, <em>connected</em>, or <em>count</em>.
 *  <p>
 *  This implementation uses quick find.
 *  Initializing a data structure with <em>N</em> sites takes linear time.
 *  Afterwards, the <em>find</em>, <em>connected</em>, and <em>count</em>
 *  operations take constant time but the <em>union</em> operation
 *  takes linear time.
 *  For alternate implementations of the same API, see
 *  {@link UF}, {@link QuickUnionUF}, and {@link WeightedQuickUnionUF}.
 *
 *  <p>
 *  For additional documentation, see <a href=""http://algs4.cs.princeton.edu/15uf"">Section 1.5</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */

// class QuickFindUF {
//    public  int[] id;    // id[i] = component identifier of i
//    private int count;   // number of components
//
//    /**
//     * Initializes an empty union-find data structure with <tt>N</tt> sites
//     * <tt>0</tt> through <tt>N-1</tt>. Each site is initially in its own 
//     * component.
//     *
//     * @param  N the number of sites
//     * @throws IllegalArgumentException if <tt>N &lt; 0</tt>
//     */
//    public QuickFindUF(int N) {
//        count = N;
//        id = new int[N];
//        for (int i = 0; i < N; i++)
//            id[i] = i;
//    }
//
//  
//   
//    
//    
//    /**
//     * Returns the number of components.
//     *
//     * @return the number of components (between <tt>1</tt> and <tt>N</tt>)
//     */
//    public int count() {
//        return count;
//    }
//  
//    /**
//     * Returns the component identifier for the component containing site <tt>p</tt>.
//     *
//     * @param  p the integer representing one site
//     * @return the component identifier for the component containing site <tt>p</tt>
//     * @throws IndexOutOfBoundsException unless <tt>0 &le; p &lt; N</tt>
//     */
//    public int find(int p) {
//        validate(p);
//        return id[p];
//    }
//
//    // validate that p is a valid index
//    private void validate(int p) {
//        int N = id.length;
//        if (p < 0 || p >= N) {
//            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
//        }
//    }
//
//    /**
//     * Returns true if the the two sites are in the same component.
//     *
//     * @param  p the integer representing one site
//     * @param  q the integer representing the other site
//     * @return <tt>true</tt> if the two sites <tt>p</tt> and <tt>q</tt> are in the same component;
//     *         <tt>false</tt> otherwise
//     * @throws IndexOutOfBoundsException unless
//     *         both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
//     */
//    public boolean connected(int p, int q) {
//        validate(p);
//        validate(q);
//        return id[p] == id[q];
//    }
//  
//    /**
//     * Merges the component containing site <tt>p</tt> with the 
//     * the component containing site <tt>q</tt>.
//     *
//     * @param  p the integer representing one site
//     * @param  q the integer representing the other site
//     * @throws IndexOutOfBoundsException unless
//     *         both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
//     */
//    public void union(int p, int q) {
//        validate(p);
//        validate(q);
//        int pID = id[p];   // needed for correctness
//        int qID = id[q];   // to reduce the number of array accesses
//
//        // p and q are already in the same component
//        if (pID == qID) return;
//
//        for (int i = 0; i < id.length; i++)
//            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
//        count--;
//    }
//
//    /**
//     * Reads in a sequence of pairs of integers (between 0 and N-1) from standard input, 
//     * where each integer represents some site;
//     * if the sites are in different components, merge the two components
//     * and print the pair to standard output.
//     */
////    public static void main(String[] args) {
////        int N = StdIn.readInt();
////        QuickFindUF uf = new QuickFindUF(N);
////        while (!StdIn.isEmpty()) {
////            int p = StdIn.readInt();
////            int q = StdIn.readInt();
////            if (uf.connected(p, q)) continue;
////            uf.union(p, q);
////            StdOut.println(p + "" "" + q);
////        }
////        StdOut.println(uf.count() + "" components"");
////    }
//
//}
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }

            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
        
    
   


@d09c6ca5efdb1463f24caa98e341cfdc@"
"r04921065","0","0.098","105840","@750ffeaef11cb14f9fc1056316892bdd@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import labelCC.QuickFindUF;



/**
 *  The <tt>QuickFindUF</tt> class represents a <em>union-find data type</em>
 *  (also known as the <em>disjoint-sets data type</em>).
 *  It supports the <em>union</em> and <em>find</em> operations,
 *  along with a <em>connected</em> operation for determining whether
 *  two sites are in the same component and a <em>count</em> operation that
 *  returns the total number of components.
 *  <p>
 *  The union-find data type models connectivity among a set of <em>N</em>
 *  sites, named 0 through <em>N</em> &ndash; 1.
 *  The <em>is-connected-to</em> relation must be an 
 *  <em>equivalence relation</em>:
 *  <ul>
 *  <p><li> <em>Reflexive</em>: <em>p</em> is connected to <em>p</em>.
 *  <p><li> <em>Symmetric</em>: If <em>p</em> is connected to <em>q</em>,
 *          then <em>q</em> is connected to <em>p</em>.
 *  <p><li> <em>Transitive</em>: If <em>p</em> is connected to <em>q</em>
 *          and <em>q</em> is connected to <em>r</em>, then
 *          <em>p</em> is connected to <em>r</em>.
 *  </ul>
 *  <p>
 *  An equivalence relation partitions the sites into
 *  <em>equivalence classes</em> (or <em>components</em>). In this case,
 *  two sites are in the same component if and only if they are connected.
 *  Both sites and components are identified with integers between 0 and
 *  <em>N</em> &ndash; 1. 
 *  Initially, there are <em>N</em> components, with each site in its
 *  own component.  The <em>component identifier</em> of a component
 *  (also known as the <em>root</em>, <em>canonical element</em>, <em>leader</em>,
 *  or <em>set representative</em>) is one of the sites in the component:
 *  two sites have the same component identifier if and only if they are
 *  in the same component.
 *  <ul>
 *  <p><li><em>union</em>(<em>p</em>, <em>q</em>) adds a
 *         connection between the two sites <em>p</em> and <em>q</em>.
 *         If <em>p</em> and <em>q</em> are in different components,
 *         then it replaces
 *         these two components with a new component that is the union of
 *         the two.
 *  <p><li><em>find</em>(<em>p</em>) returns the component
 *         identifier of the component containing <em>p</em>.
 *  <p><li><em>connected</em>(<em>p</em>, <em>q</em>)
 *         returns true if both <em>p</em> and <em>q</em>
 *         are in the same component, and false otherwise.
 *  <p><li><em>count</em>() returns the number of components.
 *  </ul>
 *  <p>
 *  The component identifier of a component can change
 *  only when the component itself changes during a call to
 *  <em>union</em>&mdash;it cannot change during a call
 *  to <em>find</em>, <em>connected</em>, or <em>count</em>.
 *  <p>
 *  This implementation uses quick find.
 *  Initializing a data structure with <em>N</em> sites takes linear time.
 *  Afterwards, the <em>find</em>, <em>connected</em>, and <em>count</em>
 *  operations take constant time but the <em>union</em> operation
 *  takes linear time.
 *  For alternate implementations of the same API, see
 *  {@link UF}, {@link QuickUnionUF}, and {@link WeightedQuickUnionUF}.
 *
 *  <p>
 *  For additional documentation, see <a href=""http://algs4.cs.princeton.edu/15uf"">Section 1.5</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */

// class QuickFindUF {
//    public  int[] id;    // id[i] = component identifier of i
//    private int count;   // number of components
//
//    /**
//     * Initializes an empty union-find data structure with <tt>N</tt> sites
//     * <tt>0</tt> through <tt>N-1</tt>. Each site is initially in its own 
//     * component.
//     *
//     * @param  N the number of sites
//     * @throws IllegalArgumentException if <tt>N &lt; 0</tt>
//     */
//    public QuickFindUF(int N) {
//        count = N;
//        id = new int[N];
//        for (int i = 0; i < N; i++)
//            id[i] = i;
//    }
//
//  
//   
//    
//    
//    /**
//     * Returns the number of components.
//     *
//     * @return the number of components (between <tt>1</tt> and <tt>N</tt>)
//     */
//    public int count() {
//        return count;
//    }
//  
//    /**
//     * Returns the component identifier for the component containing site <tt>p</tt>.
//     *
//     * @param  p the integer representing one site
//     * @return the component identifier for the component containing site <tt>p</tt>
//     * @throws IndexOutOfBoundsException unless <tt>0 &le; p &lt; N</tt>
//     */
//    public int find(int p) {
//        validate(p);
//        return id[p];
//    }
//
//    // validate that p is a valid index
//    private void validate(int p) {
//        int N = id.length;
//        if (p < 0 || p >= N) {
//            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
//        }
//    }
//
//    /**
//     * Returns true if the the two sites are in the same component.
//     *
//     * @param  p the integer representing one site
//     * @param  q the integer representing the other site
//     * @return <tt>true</tt> if the two sites <tt>p</tt> and <tt>q</tt> are in the same component;
//     *         <tt>false</tt> otherwise
//     * @throws IndexOutOfBoundsException unless
//     *         both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
//     */
//    public boolean connected(int p, int q) {
//        validate(p);
//        validate(q);
//        return id[p] == id[q];
//    }
//  
//    /**
//     * Merges the component containing site <tt>p</tt> with the 
//     * the component containing site <tt>q</tt>.
//     *
//     * @param  p the integer representing one site
//     * @param  q the integer representing the other site
//     * @throws IndexOutOfBoundsException unless
//     *         both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
//     */
//    public void union(int p, int q) {
//        validate(p);
//        validate(q);
//        int pID = id[p];   // needed for correctness
//        int qID = id[q];   // to reduce the number of array accesses
//
//        // p and q are already in the same component
//        if (pID == qID) return;
//
//        for (int i = 0; i < id.length; i++)
//            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
//        count--;
//    }
//
//    /**
//     * Reads in a sequence of pairs of integers (between 0 and N-1) from standard input, 
//     * where each integer represents some site;
//     * if the sites are in different components, merge the two components
//     * and print the pair to standard output.
//     */
////    public static void main(String[] args) {
////        int N = StdIn.readInt();
////        QuickFindUF uf = new QuickFindUF(N);
////        while (!StdIn.isEmpty()) {
////            int p = StdIn.readInt();
////            int q = StdIn.readInt();
////            if (uf.connected(p, q)) continue;
////            uf.union(p, q);
////            StdOut.println(p + "" "" + q);
////        }
////        StdOut.println(uf.count() + "" components"");
////    }
//
//}
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }

            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
        
    
   


@750ffeaef11cb14f9fc1056316892bdd@"
"r04921065","0","0.098","105840","@37b53b9aa8a427ef0b2b0a601a2be9a9@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import labelCC.QuickFindUF;



/**
 *  The <tt>QuickFindUF</tt> class represents a <em>union-find data type</em>
 *  (also known as the <em>disjoint-sets data type</em>).
 *  It supports the <em>union</em> and <em>find</em> operations,
 *  along with a <em>connected</em> operation for determining whether
 *  two sites are in the same component and a <em>count</em> operation that
 *  returns the total number of components.
 *  <p>
 *  The union-find data type models connectivity among a set of <em>N</em>
 *  sites, named 0 through <em>N</em> &ndash; 1.
 *  The <em>is-connected-to</em> relation must be an 
 *  <em>equivalence relation</em>:
 *  <ul>
 *  <p><li> <em>Reflexive</em>: <em>p</em> is connected to <em>p</em>.
 *  <p><li> <em>Symmetric</em>: If <em>p</em> is connected to <em>q</em>,
 *          then <em>q</em> is connected to <em>p</em>.
 *  <p><li> <em>Transitive</em>: If <em>p</em> is connected to <em>q</em>
 *          and <em>q</em> is connected to <em>r</em>, then
 *          <em>p</em> is connected to <em>r</em>.
 *  </ul>
 *  <p>
 *  An equivalence relation partitions the sites into
 *  <em>equivalence classes</em> (or <em>components</em>). In this case,
 *  two sites are in the same component if and only if they are connected.
 *  Both sites and components are identified with integers between 0 and
 *  <em>N</em> &ndash; 1. 
 *  Initially, there are <em>N</em> components, with each site in its
 *  own component.  The <em>component identifier</em> of a component
 *  (also known as the <em>root</em>, <em>canonical element</em>, <em>leader</em>,
 *  or <em>set representative</em>) is one of the sites in the component:
 *  two sites have the same component identifier if and only if they are
 *  in the same component.
 *  <ul>
 *  <p><li><em>union</em>(<em>p</em>, <em>q</em>) adds a
 *         connection between the two sites <em>p</em> and <em>q</em>.
 *         If <em>p</em> and <em>q</em> are in different components,
 *         then it replaces
 *         these two components with a new component that is the union of
 *         the two.
 *  <p><li><em>find</em>(<em>p</em>) returns the component
 *         identifier of the component containing <em>p</em>.
 *  <p><li><em>connected</em>(<em>p</em>, <em>q</em>)
 *         returns true if both <em>p</em> and <em>q</em>
 *         are in the same component, and false otherwise.
 *  <p><li><em>count</em>() returns the number of components.
 *  </ul>
 *  <p>
 *  The component identifier of a component can change
 *  only when the component itself changes during a call to
 *  <em>union</em>&mdash;it cannot change during a call
 *  to <em>find</em>, <em>connected</em>, or <em>count</em>.
 *  <p>
 *  This implementation uses quick find.
 *  Initializing a data structure with <em>N</em> sites takes linear time.
 *  Afterwards, the <em>find</em>, <em>connected</em>, and <em>count</em>
 *  operations take constant time but the <em>union</em> operation
 *  takes linear time.
 *  For alternate implementations of the same API, see
 *  {@link UF}, {@link QuickUnionUF}, and {@link WeightedQuickUnionUF}.
 *
 *  <p>
 *  For additional documentation, see <a href=""http://algs4.cs.princeton.edu/15uf"">Section 1.5</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 */

// class QuickFindUF {
//    public  int[] id;    // id[i] = component identifier of i
//    private int count;   // number of components
//
//    /**
//     * Initializes an empty union-find data structure with <tt>N</tt> sites
//     * <tt>0</tt> through <tt>N-1</tt>. Each site is initially in its own 
//     * component.
//     *
//     * @param  N the number of sites
//     * @throws IllegalArgumentException if <tt>N &lt; 0</tt>
//     */
//    public QuickFindUF(int N) {
//        count = N;
//        id = new int[N];
//        for (int i = 0; i < N; i++)
//            id[i] = i;
//    }
//
//  
//   
//    
//    
//    /**
//     * Returns the number of components.
//     *
//     * @return the number of components (between <tt>1</tt> and <tt>N</tt>)
//     */
//    public int count() {
//        return count;
//    }
//  
//    /**
//     * Returns the component identifier for the component containing site <tt>p</tt>.
//     *
//     * @param  p the integer representing one site
//     * @return the component identifier for the component containing site <tt>p</tt>
//     * @throws IndexOutOfBoundsException unless <tt>0 &le; p &lt; N</tt>
//     */
//    public int find(int p) {
//        validate(p);
//        return id[p];
//    }
//
//    // validate that p is a valid index
//    private void validate(int p) {
//        int N = id.length;
//        if (p < 0 || p >= N) {
//            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
//        }
//    }
//
//    /**
//     * Returns true if the the two sites are in the same component.
//     *
//     * @param  p the integer representing one site
//     * @param  q the integer representing the other site
//     * @return <tt>true</tt> if the two sites <tt>p</tt> and <tt>q</tt> are in the same component;
//     *         <tt>false</tt> otherwise
//     * @throws IndexOutOfBoundsException unless
//     *         both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
//     */
//    public boolean connected(int p, int q) {
//        validate(p);
//        validate(q);
//        return id[p] == id[q];
//    }
//  
//    /**
//     * Merges the component containing site <tt>p</tt> with the 
//     * the component containing site <tt>q</tt>.
//     *
//     * @param  p the integer representing one site
//     * @param  q the integer representing the other site
//     * @throws IndexOutOfBoundsException unless
//     *         both <tt>0 &le; p &lt; N</tt> and <tt>0 &le; q &lt; N</tt>
//     */
//    public void union(int p, int q) {
//        validate(p);
//        validate(q);
//        int pID = id[p];   // needed for correctness
//        int qID = id[q];   // to reduce the number of array accesses
//
//        // p and q are already in the same component
//        if (pID == qID) return;
//
//        for (int i = 0; i < id.length; i++)
//            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
//        count--;
//    }
//
//    /**
//     * Reads in a sequence of pairs of integers (between 0 and N-1) from standard input, 
//     * where each integer represents some site;
//     * if the sites are in different components, merge the two components
//     * and print the pair to standard output.
//     */
////    public static void main(String[] args) {
////        int N = StdIn.readInt();
////        QuickFindUF uf = new QuickFindUF(N);
////        while (!StdIn.isEmpty()) {
////            int p = StdIn.readInt();
////            int q = StdIn.readInt();
////            if (uf.connected(p, q)) continue;
////            uf.union(p, q);
////            StdOut.println(p + "" "" + q);
////        }
////        StdOut.println(uf.count() + "" components"");
////    }
//
//}
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private  QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }

            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
        
    
   


@37b53b9aa8a427ef0b2b0a601a2be9a9@"
"r04921065","0","0","0","@1794ca40c572d3ccbc6c20cb9a8f818b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import labelCC.QuickFindUF;




 class QuickFindUF {
    public  int[] id;    // id[i] = component identifier of i
    private int count;   // number of components

   
    public QuickFindUF(int N) {
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }

  
   
    
    
    
    public int count() {
        return count;
    }
  
 
    public int find(int p) {
        validate(p);
        return id[p];
    }

  
    private void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
        }
    }

    
    public boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
  
   
    public void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
        count--;
    }

  

}
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }

            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
        
    
   


@1794ca40c572d3ccbc6c20cb9a8f818b@"
"r04921065","0","0","0","@0f6b6f1bf34fa4ba0e102d02acee9ab0@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import labelCC.QuickFindUF;




 class QuickFindUF {
    public  int[] id;    // id[i] = component identifier of i
    private int count;   // number of components

   
    public QuickFindUF(int N) {
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }

  
   
    
    
    
    public int count() {
        return count;
    }
  
 
    public int find(int p) {
        validate(p);
        return id[p];
    }

  
    private void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
        }
    }

    
    public boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
  
   
    public void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
        count--;
    }

  

}
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }

            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
        
    
   


@0f6b6f1bf34fa4ba0e102d02acee9ab0@"
"r04921065","0","0","0","@afabdbb5fab5306678ddc961fb8ca0c2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */



//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import labelCC.QuickFindUF;




 class QuickFindUF {
    public  int[] id;    // id[i] = component identifier of i
    private int count;   // number of components

   
    public QuickFindUF(int N) {
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }

  
   
    
    
    
    public int count() {
        return count;
    }
  
 
    public int find(int p) {
        validate(p);
        return id[p];
    }

  
    private void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
        }
    }

    
    public boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
  
   
    public void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
        count--;
    }

  

}
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }
             //System.out.println(qf.id[0]);
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
@afabdbb5fab5306678ddc961fb8ca0c2@"
"r04921065","0","0.106","105488","@5cc866387da0f14627f76dd358e149e8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import labelCC.QuickFindUF;




// class QuickFindUF {
//    public  int[] id;    // id[i] = component identifier of i
//    private int count;   // number of components
//
//   
//    public QuickFindUF(int N) {
//        count = N;
//        id = new int[N];
//        for (int i = 0; i < N; i++)
//            id[i] = i;
//    }
//
//  
//   
//    
//    
//    
//    public int count() {
//        return count;
//    }
//  
// 
//    public int find(int p) {
//        validate(p);
//        return id[p];
//    }
//
//  
//    private void validate(int p) {
//        int N = id.length;
//        if (p < 0 || p >= N) {
//            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
//        }
//    }
//
//    
//    public boolean connected(int p, int q) {
//        validate(p);
//        validate(q);
//        return id[p] == id[q];
//    }
//  
//   
//    public void union(int p, int q) {
//        validate(p);
//        validate(q);
//        int pID = id[p];   // needed for correctness
//        int qID = id[q];   // to reduce the number of array accesses
//
//        // p and q are already in the same component
//        if (pID == qID) return;
//
//        for (int i = 0; i < id.length; i++)
//            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
//        count--;
//    }
//
//  
//
//}
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }
             //System.out.println(qf.id[0]);
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
@5cc866387da0f14627f76dd358e149e8@"
"r04921065","8","0.84","128240","@ce67e7359d4b1c55e0ff1f06087bdeb0@//package labelcc;
 
import java.io.BufferedReader;
import java.io.FileReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
 
 
/**
 *
 * @author steven
 */
public class LabelCC {
    private boolean[][] opened;
    private int[][] label;
    private int size;
    private int num=0;
    //private int[] table;
    private ArrayList<Integer> table=new ArrayList<Integer>();
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        opened = new boolean[size][size];
        label =new int [size][size];
        //table.add(0);
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void open(int i, int j) {
        opened[i][j] = true;
    }
    public void Label(int y, int x){
        if(x==0 && y==0){
            if(!isOpen(y,x)){
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if(x>0 && y>0){
            if (isLabel(y-1,x) && isLabel(y, x-1)){
                label[y][x]=Math.min(label[y][x-1],label[y-1][x] );
                table.set(Math.max(label[y][x-1],label[y-1][x] )-1,Math.min(label[y][x-1],label[y-1][x] ));
            }else if(isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else if(isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (y==0 && x>0){
            if (isLabel(y,x-1)){
                label[y][x]=label[y][x-1];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
        if (x==0 && y>0){
            if (isLabel(y-1,x)){
                label[y][x]=label[y-1][x];
            }else{
                num++;
                table.add(num);
                label[y][x]=num;
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    public boolean isOpen(int i, int j) {
        return opened[i][j];
    }
    public boolean isLabel(int y,int x){
        return label[y][x]!=0;
    }
 
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        int out;
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N= Integer.parseInt(data[0]);
            int[] target=new int[2];
            target[0]=Integer.parseInt(data[2]);
            target[1]=Integer.parseInt(data[1]);
            target[0]--;
            target[1]--;
            LabelCC matrix=new LabelCC(N);
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[1]);
                int y =Integer.parseInt(xy[0]);
                x--;
                y--;
                matrix.open(y,x);
                }
            }
 
            for (int y=0;y<N;y++){
                for (int x=0;x<N;x++){
                    if (!matrix.isOpen(y,x)){
                        matrix.Label(y, x);
                    }
                }
            }
/*            for (int i =0;i<N;i++){
                for(int j =0;j<N;j++){
                    System.out.print(matrix.label[i][j]+"" "");
                }
                System.out.println(' ');
            }
            for (int i=0;i<7;i++){
                System.out.print(matrix.table.get(i));
            }System.out.println("" "");*/
           
            //System.out.print(matrix.isOpen(target[1],target[0]));
            if (!matrix.isOpen(target[1],target[0])){
 
                out=matrix.label[target[1]][target[0]];
                while (out!=matrix.table.get(out-1)){
                    out=matrix.table.get(matrix.table.get(out-1)-1)+1;
                }
            }else{
                out=0;
            }
        }
        System.out.println(out);
    }
   
}

@ce67e7359d4b1c55e0ff1f06087bdeb0@"
"r04921065","0","0.098","105840","@fd70ac8c53a2a580dab0929a9ab9430c@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import labelCC.QuickFindUF;
import labelCC.QuickFindUF;




// class QuickFindUF {
//    public  int[] id;    // id[i] = component identifier of i
//    private int count;   // number of components
//
//   
//    public QuickFindUF(int N) {
//        count = N;
//        id = new int[N];
//        for (int i = 0; i < N; i++)
//            id[i] = i;
//    }
//
//  
//   
//    
//    
//    
//    public int count() {
//        return count;
//    }
//  
// 
//    public int find(int p) {
//        validate(p);
//        return id[p];
//    }
//
//  
//    private void validate(int p) {
//        int N = id.length;
//        if (p < 0 || p >= N) {
//            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
//        }
//    }
//
//    
//    public boolean connected(int p, int q) {
//        validate(p);
//        validate(q);
//        return id[p] == id[q];
//    }
//  
//   
//    public void union(int p, int q) {
//        validate(p);
//        validate(q);
//        int pID = id[p];   // needed for correctness
//        int qID = id[q];   // to reduce the number of array accesses
//
//        // p and q are already in the same component
//        if (pID == qID) return;
//
//        for (int i = 0; i < id.length; i++)
//            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
//        count--;
//    }
//
//  
//
//}
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }
             //System.out.println(qf.id[0]);
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
@fd70ac8c53a2a580dab0929a9ab9430c@"
"r04921065","0","0.098","105840","@871c496e672990f7b9e074594a847cb7@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import labelCC.QuickFindUF;




// class QuickFindUF {
//    public  int[] id;    // id[i] = component identifier of i
//    private int count;   // number of components
//
//   
//    public QuickFindUF(int N) {
//        count = N;
//        id = new int[N];
//        for (int i = 0; i < N; i++)
//            id[i] = i;
//    }
//
//  
//   
//    
//    
//    
//    public int count() {
//        return count;
//    }
//  
// 
//    public int find(int p) {
//        validate(p);
//        return id[p];
//    }
//
//  
//    private void validate(int p) {
//        int N = id.length;
//        if (p < 0 || p >= N) {
//            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
//        }
//    }
//
//    
//    public boolean connected(int p, int q) {
//        validate(p);
//        validate(q);
//        return id[p] == id[q];
//    }
//  
//   
//    public void union(int p, int q) {
//        validate(p);
//        validate(q);
//        int pID = id[p];   // needed for correctness
//        int qID = id[q];   // to reduce the number of array accesses
//
//        // p and q are already in the same component
//        if (pID == qID) return;
//
//        for (int i = 0; i < id.length; i++)
//            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
//        count--;
//    }
//
//  
//
//}
public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }
             //System.out.println(qf.id[0]);
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
@871c496e672990f7b9e074594a847cb7@"
"r04921065","0","0","0","@e80fc11623a6fd561e84cc7e4ba39310@import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import labelCC.QuickFindUF;
import QuickFindUF;



// class QuickFindUF {
//    public  int[] id;    // id[i] = component identifier of i
//    private int count;   // number of components
//
//   
//    public QuickFindUF(int N) {
//        count = N;
//        id = new int[N];
//        for (int i = 0; i < N; i++)
//            id[i] = i;
//    }
//
//  
//   
//    
//    
//    
//    public int count() {
//        return count;
//    }
//  
// 
//    public int find(int p) {
//        validate(p);
//        return id[p];
//    }
//
//  
//    private void validate(int p) {
//        int N = id.length;
//        if (p < 0 || p >= N) {
//            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
//        }
//    }
//
//    
//    public boolean connected(int p, int q) {
//        validate(p);
//        validate(q);
//        return id[p] == id[q];
//    }
//  
//   
//    public void union(int p, int q) {
//        validate(p);
//        validate(q);
//        int pID = id[p];   // needed for correctness
//        int qID = id[q];   // to reduce the number of array accesses
//
//        // p and q are already in the same component
//        if (pID == qID) return;
//
//        for (int i = 0; i < id.length; i++)
//            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
//        count--;
//    }
//}



public class LabelCC {
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }
             //System.out.println(qf.id[0]);
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
@e80fc11623a6fd561e84cc7e4ba39310@"
"r04921065","10","0.188","174096","@e7a356944c6c436162dcefbfafc86ccf@

import java.io.FileReader;
import java.io.BufferedReader;

public class LabelCC {

    public static void main(String[] args) throws Exception {

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {

            String[] data = br.readLine().split("","");

            int size = Integer.parseInt(data[0]);
            int[] target = new int[2];
            target[0] = Integer.parseInt(data[1]);
            target[1] = Integer.parseInt(data[2]);

            String open;

            int num = 0;
            String openstring = """";
            while ((open = br.readLine()) != null) {
                openstring = openstring + open + "" "";
                ++num;
            }
            String[] temp = new String[num];
            String[] temp2 = new String[num];
            int[][] match = new int[num][2];
            temp = openstring.split("" "");
            for (int i = 0; i < num; ++i) {
                temp2 = temp[i].split("","");
                for (int j = 0; j < 2; ++j) {
                    match[i][j] = Integer.parseInt(temp2[j]);
                }
            }
            int[] state = new int[size * size];
            int[] number = new int[size * size];
            int[] idt = new int[size * size];

            for (int i = 0; i < size * size; ++i) {
                number[i] = 0;  //陣列 2D->1D
                state[i] = 1;  //label 陣列 2D-1D
                idt[i] = i;    //陣列
            }
            QuickFindUF wei = new QuickFindUF(size * size);
            int now = 1;
            int reg = 0;   //index

            for (int i = 0; i < num; ++i) {    
                reg = (match[i][0] - 1) * size + match[i][1] - 1; //index
                state[reg] = 0;  // block location
            }

            for (int i = 0; i < size * size; ++i) {
                if (state[i] == 1) {
                    int neigh = 0;
                    if (i % size != 0 && state[i - 1] == 1 && i - size > -1 && state[i - size] == 0 || i % size != 0 && state[i - 1] == 1 && i - size < 0) {//111111111111
                        wei.union(idt[i], idt[i - 1]);
                        number[i] = number[i - 1];
                        ++neigh;
                    }
                    if (i - size > -1 && state[i - size] == 1 && i % size != 0 && state[i - 1] == 1) {//22222222
                        if (number[i - 1] > number[i - size]) {
                            wei.union(idt[i], idt[i - size]);
                            wei.union(idt[i-1], idt[i]);
                            number[i] = number[i - size];
                            ++neigh;
                        } else {
                            wei.union(idt[i], idt[i - 1]);
                            wei.union(idt[i-size], idt[i]);
                            number[i] = number[i - 1];
                            ++neigh;
                        }

                    }
                    if (i - size > -1 && state[i - size] == 1 && i % size != 0 && state[i - 1] == 0 || i - size > -1 && state[i - size] == 1 && i % size == 0) {
                        wei.union(idt[i], idt[i - size]);
                        number[i] = number[i - size];
                        ++neigh;

                    }

                    if (neigh == 0) {
                        number[i] = now;
                        ++now;
                    }

                }
            }

            for (int i = 0; i < size * size; ++i) {
                number[i] = number[wei.find(i)];
            }
            
            System.out.println(number[ (target[0]-1)*size+target[1]-1  ]);

        }

    }
}

@e7a356944c6c436162dcefbfafc86ccf@"
"r04921065","8","0.96","129856","@4c17524e0d9f61bbb10f35506ae918c1@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
//package labelcc;


//import java.io.BufferedReader;
//import java.io.FileReader;
//import java.io.IOException;


import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
//import edu.princeton.cs.algs4.QuickFindUF;
//import labelCC.QuickFindUF;




 class QuickFindUFF {
    public  int[] id;    // id[i] = component identifier of i
    private int count;   // number of components

   
    public QuickFindUFF(int N) {
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }

  
   
    
    
    
    public int count() {
        return count;
    }
  
 
    public int find(int p) {
        validate(p);
        return id[p];
    }

  
    private void validate(int p) {
        int N = id.length;
        if (p < 0 || p >= N) {
            throw new IndexOutOfBoundsException(""index "" + p + "" is not between 0 and "" + (N-1));
        }
    }

    
    public boolean connected(int p, int q) {
        validate(p);
        validate(q);
        return id[p] == id[q];
    }
  
   
    public void union(int p, int q) {
        validate(p);
        validate(q);
        int pID = id[p];   // needed for correctness
        int qID = id[q];   // to reduce the number of array accesses

        // p and q are already in the same component
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;  // p(小樹) 全部變 q(大樹) 的child
        count--;
    }
}



    public class LabelCC{
    
    private boolean[][] closed;
    private int[][] label;
    private int size;
    private int num;
    private int[] table;
    private static QuickFindUFF qf ;
    
    /**
     * Creates N-by-N grid, with all sites blocked.
     */
    public LabelCC(int N) {
        size = N;
        //qf = new WeightedQuickUnionUF(size * size + 2);
        closed = new boolean[size][size];
        label =new int[size][size];
        table = new int[size*size];
        qf = new QuickFindUFF(size * size);
        num = 0;
        
        
    }
 
    /**
     * Opens site (row i, column j) if it is not already.
     */
    public void close(int i, int j) {
        closed[i-1][j-1] = true;
    }
    public void Label(int i, int j){
        int temp = getQFIndex(i,j);
        if(i==0 && j==0){
            if(!isClose(i,j)){
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                label[i][j]=Math.min(label[i][j-1],label[i-1][j] );
                table[temp]=label[i][j];
            }else if(isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else if(isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                table[temp]=num;
                label[i][j]=num;
            }
        }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                label[i][j]=label[i][j-1];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                label[i][j]=label[i-1][j];
                table[temp]=label[i][j];
            }else{
                num++;
                label[i][j]=num;
                table[temp]=label[i][j];
            }
        }
    }
    /**
     * Is site (row i, column j) open?
     */
    private int getQFIndex(int i, int j) { //Object Method
        return size * i + j;
    }
    
    public boolean isClose(int i, int j) {
        return closed[i][j];
    }
    public boolean isLabel(int i,int j){
        return label[i][j]!=0;
    }
    
    public void change(int i,int j){
        int temp = size*i+j;
        qf.id[temp] = table[temp];
    }
 
    public void un(int i,int j){
        //qf.id[i*size+j] = table[i*size+j];
        if(i==0 && j==0){
            return;
        }
        if(i>0 && j>0){
            if (isLabel(i-1,j) && isLabel(i, j-1)){
                //int temp =Math.min(label[i][j-1],label[i-1][j] );
                if (label[i][j-1]>=label[i-1][j]){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
               }else{qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
            }
            
            else if(isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }else if(isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }else{
                return;
            }
                
           }
        if (i==0 && j>0){
            if (isLabel(i,j-1)){
                qf.union(getQFIndex(i,j),getQFIndex(i,j-1));
            }
        }
        
        if (j==0 && i>0){
            if (isLabel(i-1,j)){
                qf.union(getQFIndex(i,j),getQFIndex(i-1,j));
            }
        }
    }
    
    
    
    
    public static void main(String[] args)throws Exception {
        // TODO code application logic here
        try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
            String[] data=br.readLine().split("","");
            int N = Integer.parseInt(data[0]);
//            target[1]=Integer.parseInt(data[2]);
//            target[0]=Integer.parseInt(data[1]);
            int a1 = Integer.parseInt(data[1]);  // target1
            int a2 = Integer.parseInt(data[2]);  // target2
            a1--;
            a2--;
            //System.out.println(num);
            LabelCC matrix = new LabelCC(N);
            
            String read;
            while((read=br.readLine())!=null){
                if (read.isEmpty()){}else{
                String[] xy = read.split("","");
                int x =Integer.parseInt(xy[0]);
                int y =Integer.parseInt(xy[1]);

                matrix.close(x,y);
                }
            }

            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.Label(i, j);
                    }
                }
            }
            
//            for (int i = 0; i < N*N; ++i) {
//                table[i] = 0;  //陣列 2D->1D
//            }
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                   matrix.change(i, j);
                    }
                }
             //System.out.println(qf.id[0]);
            
            for (int i=0;i<N;i++){
                for (int j=0;j<N;j++){
                    if (!matrix.isClose(i,j)){
                        matrix.un(i, j);
                    }
                }
            }

            int goal = N * a1 + a2;
           // System.out.println(a1);
           // System.out.println(a2);
            
            if(!matrix.isClose(a1,a2)){
            System.out.println(qf.id[goal]);
            }
            else{
             System.out.println(""0"");
            }
            
            
            
           
  
    } 
        }
        }
        
    
   


@4c17524e0d9f61bbb10f35506ae918c1@"
"r04631036","0","0.138","183456","@842ecf219d50220f378a4ce7aba53aa2@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Arthur
 */
import java.io.BufferedReader;
import java.io.FileReader;

public class Calculator {

    private String[] data;
    public Stack<String> op;

    Calculator() {
        //setstring(a);

    }

    double ans(String e) {
        String[] input = e.split("" "");
        Stack<String> operator = new Stack<String>();
        Stack<Double> value = new Stack<Double>();
        for (int i = 0; i < input.length; i++) {
            String s = input[i];
            if (s.equals(""("")) ; else if (s.equals(""+"")) {
                operator.push(s);
            } else if (s.equals(""*"")) {
                operator.push(s);
            } else if (s.equals(""/"")) {
                operator.push(s);
            } else if (s.equals(""-"")) {
                operator.push(s);
            } else if (s.equals("")"")) {
                String op = operator.pop();
                if (op.equals(""+"")) {
                    value.push(value.pop() + value.pop());
                } else if (op.equals(""*"")) {
                    value.push(value.pop() * value.pop());
                } else if (op.equals(""/"")) {
                    double k = value.pop();
                    double m = value.pop();
                    value.push(m / k);
                } else if (op.equals(""-"")) {
                    double k = value.pop();
                    double m = value.pop();
                    value.push(m - k);
                }
            } else {
                value.push(Double.parseDouble(s));
            }

//            String s=data[i];
//        if(!data[i].equals(""+"") && !data[i].equals(""-"") && !data[i].equals(""*"") && !data[i].equals(""/"") && !data[i].equals(""("") && !data[i].equals("")"") )
//        value.push(Double.parseDouble(s));
//        if(data[i].equals(""+""))
//            operator.push(s);
//        if(data[i].equals(""-""))
//            operator.push(s);
//        if(data[i].equals(""*""))
//            operator.push(s);
//        if(data[i].equals(""/""))
//            operator.push(s);
//        if(data[i].equals("")""))
//        {
//            String op= operator.pop();
//            if(op.equals(""+""))
//                value.push(value.pop()+value.pop());
//            else if(op.equals(""*""))
//                value.push(value.pop()*value.pop());
//            else if(op.equals(""-""))
//                value.push(value.pop()-value.pop());
//            else if(op.equals(""/""))
//                value.push(value.pop()/value.pop());
//        }
        }
        return value.pop();
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String datadata;
            datadata = br.readLine();
            Calculator cct = new Calculator();
            //cct.printeq();
            double a = cct.ans(datadata);
            System.out.printf(""%f"", a);

        } catch (Exception e) {
//    System.err.println(""-1"");
            System.out.printf(""error"");
        }
        // TODO code application logic here
    }

}

@842ecf219d50220f378a4ce7aba53aa2@"
"b02611019","3","1.04","130496","@9c3758bf10b2cac9c8c2c70c7a6148cf@
import java.io.BufferedReader;
import java.io.FileReader;

/**
 * Created by User on 2016/3/15.
 */
public class LabelCC {

    public int dimension;
    public int target_x;
    public int target_y;
    public Node[][] nodes;
    public Node topnode;
    public Node buttonnode;
    public int label_count;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            //     try(BufferedReader br = new BufferedReader(new FileReader(""test.txt""))){
            String[] first_row = br.readLine().split("","");

            int dimension = Integer.parseInt(first_row[0]);
            int target_x = Integer.parseInt(first_row[1]);
            int target_y = Integer.parseInt(first_row[2]);

            LabelCC labelCC = new LabelCC(dimension, target_x, target_y);
            String line;

            while ((line = br.readLine()) != null) {
                String[] data = line.split("","");
                int x = Integer.parseInt(data[0]);
                int y = Integer.parseInt(data[1]);
                x = x - 1;
                y = y - 1;
                labelCC.close_point(x, y);
                //System.out.println(data[0]+"",""+data[1]);
            }
//            for (int i = 0; i < dimension; i++) {
//                for (int j = 0; j < dimension; j++) {
//                  labelCC.nodes[i][j].showNodeinfo();
//                  StdOut.print("" "");
//                }
//                StdOut.print(""\n"");
//            }
            for (int i = 0; i < dimension; i++) {
                for (int j = 0; j < dimension; j++) {
                    if (labelCC.nodes[i][j] == null) {
                        labelCC.open_point(i, j);

                    }
                }
            }
//                           for(int i=0;i<dimension;i++){
//             for(int j=0;j<dimension;j++){
//             if(labelCC.nodes[i][j].open) {
//
//             labelCC.nodes[i][j].showNodeinfo();
//             }
//             }
//             }
            //檢查~~~~~~~~~~~~~~~~
//            for (int i = 0; i < dimension; i++) {
//                for (int j = 0; j < dimension; j++) {
//                  labelCC.nodes[i][j].showNodeinfo();
//                  StdOut.print("" "");
//                }
//                StdOut.print(""\n"");
//            }
            System.out.println(Integer.toString(labelCC.showLabel()));

            /*  for(int i=0; i<dimension;i++){
             for(int j=0;j<dimension;j++){
             if(percolation.nodes[i][j]!=null)
             percolation.nodes[i][j].showNodeinfo();
             }
             }*/
            /*            if(percolation.isConnect())
             System.out.println(""Connected"");
             else
             System.out.println(""Disconnected"");*/
            br.close();
        }

    }

    public LabelCC(int dimension, int target_x, int target_y) {
        this.dimension = dimension;
        this.target_x = target_x;
        this.target_y = target_y;
        this.nodes = new Node[dimension][dimension];
        label_count = 0;
    }

    public void Union(Node A, Node B) {
        if (A.root() != B.root()) {
            if (A.root().label >= B.root().label) {
                B.root().label = A.root().label;
            } else {
                A.root().label = B.root().label;
            }

            if (B.root().numberOfnode < A.root().numberOfnode) {
                B.root().numberOfnode += A.root().numberOfnode;
                A.root().parent = B.root();
            } else {
                A.root().numberOfnode += B.root().numberOfnode;
                B.root().parent = A.root();
            }
        }

    }

    public void open_point(int x, int y) {
        //System.out.println(String.valueOf(x)+"",""+String.valueOf(y));
        boolean add_label1, add_label2;

        nodes[x][y] = new Node(x + 1, y + 1, true, 1, label_count);
        if (!(y <= 0)) {
            if (nodes[x][y - 1].open) {
                this.Union(nodes[x][y - 1], nodes[x][y]);
                add_label1 = false;
            } else {
                add_label1 = true;
            }
        } else {
            add_label1 = true;
        }

        if (!(x <= 0)) {
            if (nodes[x - 1][y].open) {
                this.Union(nodes[x - 1][y], nodes[x][y]);
                add_label2 = false;
            } else {
                add_label2 = true;
            }
        } else {
            add_label2 = true;
        }
        if (add_label1 & add_label2) {
            label_count++;
            nodes[x][y].label = label_count;
        }
    }

    public void close_point(int x, int y) {
        nodes[x][y] = new Node(x + 1, y + 1, false, 0, 0);
    }

    public int showLabel() {
        if (this.target_x > dimension || this.target_y > dimension) {
            return 0;
        } else {
            return this.nodes[target_x - 1][target_y - 1].root().label;
        }
    }

    public static class Node {

        public int x, y;
        public Node parent;
        public boolean open;
        public int numberOfnode;
        public int label;

        public Node(int x, int y, boolean open, int numberOfnode, int label) {
            this.x = x;
            this.y = y;
            this.parent = this;
            this.open = open;
            this.numberOfnode = numberOfnode;
            this.label = label;
        }

        public Node root() {
            if (this.parent == this) {
                //System.out.println(""my root is""+Integer.toString(this));
                return this;
            } else {
                return this.parent.root();
            }
        }

        public void showNodeinfo() {
            System.out.print(Integer.toString(this.root().label));
        }

    }

}

@9c3758bf10b2cac9c8c2c70c7a6148cf@"
"b02611019","8","1","127728","@4b0ccc2cdfa8b20385209d7ed285d48b@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author user
 */

public class LabelCC {
    
    public static void main(String[] args) throws Exception{
       BufferedReader br = new BufferedReader(new FileReader(args[0]));
       String [] input = br.readLine().split("","");//read txt
       int N = Integer.parseInt(input[0]);
       int [] ans = new int [2];
       ans[0] = Integer.parseInt(input[1]);
       ans[1] = Integer.parseInt(input[2]);
       //open the metrix and set all entry to -1
       int [][] data = new int [N+1][N+1];
       //read all data into metrix
       String data0 = br.readLine();
       while(data0!=null){
          //set the site block
          String [] data1 = data0.split("","");
          int x = Integer.parseInt(data1[0]);
          int y = Integer.parseInt(data1[1]);
              data[x][y] = -1;
              //System.out.printf(""%d\n"",data[x][y]);
          data0 = br.readLine();
       }   
       //now assigne the number to all site but blocked site
       int count = 1;
       int countforconnect = 0;
       int [][]connect = new int[N*N][2];
       for(int i =1;i<N+1;i++){
           for(int j =1;j<N+1;j++){
               //if the site is not block
               if(data[i][j]!=-1){
                   //check the left and top, if it is all not blocked
                   if((data[i][j-1]<=0 ) && (data[i-1][j] <= 0)){
                       // opent the site
                       data[i][j] = count;
                       count += 1;
                   }
                   //check the left and top, if it open site
                       //System.out.printf("" carry data[%d][%d] is %d\n"",i,j,data[i][j]);             
                     else if(data[i][j-1]>0 && data[i-1][j] > 0){                                                   
                               data[i][j] = Math.min(data[i][j-1],data[i-1][j]);
                               int p = Math.max(data[i][j-1],data[i-1][j]);
                               int q = Math.min(data[i][j-1],data[i-1][j]);
                           //max's root to min
                           //both not connect
                               connect[countforconnect][0] = q;
                               connect[countforconnect][1] = p;
                               //System.out.printf(""countforconnect is %d\n"",countforconnect);
                               countforconnect++;
                        }
                   else
                           data[i][j] =Math.max(data[i-1][j],data[i][j-1]);
                       }
                   
            }
        }       
           
       //equal to site
       int finalans =data[ans[0]][ans[1]];
       //connect have value
       //if(data[ans[0]][ans[1]]!=-1){
           for(int i = 0; i<countforconnect;i++){
               if(connect[i][0] == data[ans[0]][ans[1]])
                   finalans = Math.min(connect[i][1],finalans);
           }
       //}
       //block
       if(data[ans[0]][ans[1]]==-1)
       finalans = 0;
       System.out.printf(""%d\n"",finalans);        
       }
    }
   

@4b0ccc2cdfa8b20385209d7ed285d48b@"
