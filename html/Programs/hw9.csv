"r04945025","10","0.097","105840","@645d8dfebc536030c9b2f1cf156fdccf@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class Expression {

    private Stack<Node>nodes;
    static Node treeroot;
    static Stack<String> st;
    static int N = 0;
    
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] str = infix.split("""");
        st = new Stack<String>();
        nodes = new Stack<Node>();

        for (int i = 0; i < str.length; i++) {
            st.push(str[i]);
            if(i>0&&!(str[i].equals(""+"")||str[i].equals(""-"")||str[i].equals(""*"")||str[i].equals(""/"")||str[i].equals(""("")||str[i].equals("")""))){
                if(!(str[i-1].equals(""+"")||str[i-1].equals(""-"")||str[i-1].equals(""*"")||str[i-1].equals(""/"")||str[i-1].equals(""("")||str[i-1].equals("")""))){
                    st.pop();
                    st.push(st.pop()+str[i]);
                }
            }
                
            if (str[i].equals("")"")) {
                st.pop();
                String rightstr = st.pop();
                String oper = st.pop();
                String leftstr = st.pop();

                if (!leftstr.equals(""Tree"") && !rightstr.equals(""Tree"")) {
                    Node left = new Node(null, null, leftstr);
                    Node right = new Node(null, null, rightstr);
                    nodes.push(new Node(left, right, oper));
                    st.pop();
                    st.push(""Tree"");
                    N = N + 3;
//                    StdOut.print(root.getRight().getValue());
                } else if (leftstr.equals(""Tree"")&& !rightstr.equals(""Tree"")) {
                    Node root = nodes.pop();
                    Node oldroot = new Node(root.getLeft(), root.getRight(), root.getValue());
                    Node newroot = new Node(null,null,null);
                    newroot.setValue(oper);
                    newroot.setLeft(oldroot);
                    Node right = new Node(null, null, rightstr);
                    newroot.setRight(right);
                    nodes.push(newroot);
                    st.pop();
                    st.push(""Tree"");
                    N = N + 2;
                } else if (!leftstr.equals(""Tree"") &&rightstr.equals(""Tree"")) {
                    Node root = nodes.pop();
                    Node oldroot = new Node(root.getLeft(), root.getRight(), root.getValue());
                    Node newroot = new Node(null,null,null);
                    newroot.setValue(oper);
                    newroot.setRight(oldroot);
                    Node left = new Node(null, null, leftstr);
                    newroot.setLeft(left);
                    nodes.push(newroot);
                    st.pop();
                    st.push(""Tree"");
                    N = N + 2;
                }else if (leftstr.equals(""Tree"") &&rightstr.equals(""Tree"")) {
                    Node rightroot = nodes.pop();
                    Node leftroot = nodes.pop();
                    Node newroot = new Node(null,null,null);
                    newroot.setLeft(leftroot);
                    newroot.setRight(rightroot);
                    newroot.setValue(oper);
                    nodes.push(newroot);
                    st.pop();
                    st.push(""Tree"");
                    N = N + 1;
                }
            }

        }
        treeroot = nodes.pop();
        return (treeroot);
    }

    static ArrayList<Node> prefixal;

    public void TraversePre(Node node) {
        prefixal.add(node);
        if (node.getLeft() != null) {
            TraversePre(node.getLeft());
        }
        if (node.getRight() != null) {
            TraversePre(node.getRight());
        }

    }

    public Node[] PrintPrefix() {
        Node[] prefix = new Node[N];
        int curnum = 0;
        prefixal = new ArrayList<Node>();
        TraversePre(treeroot);
        for (int i = 0; i < N; i++) {
            prefix[i] = prefixal.get(i);
        }
        return (prefix);
    }

    static ArrayList<Node> postfixal;

    public void TraversePost(Node node) {

        if (node.getLeft() != null) {
            TraversePost(node.getLeft());
        }
        if (node.getRight() != null) {
            TraversePost(node.getRight());
        }
        postfixal.add(node);

    }

    public Node[] PrintPostfix() {
        Node[] postfix = new Node[N];
        int curnum = 0;
        postfixal = new ArrayList<Node>();
        TraversePost(treeroot);
        for (int i = 0; i < N; i++) {
            postfix[i] = postfixal.get(i);
        }
        return (postfix);
    }

    public static double Operate(String op, double a, double b) {
        if (op.equals(""+"")) {
            return (a + b);
        } else if (op.equals(""-"")) {
            return (a - b);
        } else if (op.equals(""*"")) {
            return (a * b);
        } else if (op.equals(""/"")) {
            return (a / b);
        } else {
            return 0;
        }
    }

    public double Evaluation(Node node) {

        if (node.getLeft() == null && node.getRight() == null) {
            return Double.parseDouble(node.getValue());
        } else {
            return Operate(node.getValue(), Evaluation(node.getLeft()), Evaluation(node.getRight()));
        }

    }

    public double Evaluation() {
        return Evaluation(treeroot);
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String read = br.readLine();
        Expression ex = new Expression();
        ex.Infix2BT(read);

//        StdOut.print(ex.treeroot.getRight().getValue());
//        for (Node node : ex.PrintPrefix()) {
//            StdOut.print(node.getValue());
//        }
        StdOut.print(ex.Evaluation());
    }
}

@645d8dfebc536030c9b2f1cf156fdccf@"
"r04447001","6","1.02","105920","@1fdc19fca198ff8b1967193c327421c8@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
/**
 *
 * @author jerry
 */
public class Expression{
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){ 
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        char[] infixchar = infix.toCharArray();
        char[] postfixchar = postfixer(infixchar);
        Stack<Node> stack = new Stack<Node>();
		for (int i = 0; i < postfixchar.length; i++) {
			Node node = new Node(null,null,String.valueOf(postfixchar[i]));
			switch (postfixchar[i]) {
			case '0':case '1':case '2':case '3':case '4':
			case '5':case '6':case '7':case '8':case '9':
				stack.push(node);
				break;
			case '+':case '-':case '/':case '*':
				node.setRight(stack.pop());
				node.setLeft(stack.pop());
				stack.push(node);
				break;
			default:
			}
		}
        this.root = stack.pop();
        return root;
    } 


    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        Queue<Node> q = new Queue<Node>();
        PrintPrefix(root,q);
        int N = q.size();
        Node[] result = new Node[N];
        int i = 0;
        for(Node x:q){
            result[i++] = x;
        }
        return result;
    }
    
    private void  PrintPrefix(Node x,Queue<Node> q){
        if(x == null) return;
        q.enqueue(x);
        PrintPrefix(x.getLeft(),q);
        PrintPrefix(x.getRight(),q);
    }
    
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Queue<Node> q = new Queue<Node>();
        PrintPostfix(root,q);
        int N = q.size();
        Node[] result = new Node[N];
        int i = 0;
        for(Node x:q){
            result[i++] = x;
        }
        return result;        
    }
    
    private void PrintPostfix(Node x,Queue<Node> q){
        if(x == null) return;
        PrintPostfix(x.getLeft(),q);
        PrintPostfix(x.getRight(),q);
        q.enqueue(x);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] nodes = PrintPostfix();
        Stack<Double> s = new Stack<Double>();
        for(int i = 0; i < nodes.length;i++){
            String data = nodes[i].getValue();
            if(data.equals(""+"")){s.push(s.pop()+s.pop());}
            else if(data.equals(""*"")){s.push(s.pop()*s.pop());}
            else if(data.equals(""-"")){
                double first = s.pop();
                double second = s.pop();
                s.push(second-first);
            }
            else if(data.equals(""/"")){
                double first = s.pop();
                double second = s.pop();
                s.push(second/first);
            }            
            else{s.push(Double.parseDouble(data));}
        }
        Double answer = s.pop();
        return(answer);
    }
    
    public static void main(String[] args) {
        Expression test = new Expression();
        String teststr = ""((7*3+2))"";
        char[] testpost = test.postfixer(teststr.toCharArray());
        for(int i = 0; i < testpost.length;i++){
            System.out.print(testpost[i]+"" "");
        }
        System.out.println();
        test.Infix2BT(teststr);
        Node[] result = test.PrintPrefix();
        for(int i = 0; i < result.length; i++){
            System.out.print(result[i].getValue()+"" "");
        }
        System.out.println();
        Node[] result2 = test.PrintPostfix();
        for(int i = 0; i < result2.length; i++){
            System.out.print(result2[i].getValue()+"" "");
        }        
        System.out.println();
        System.out.print(test.Evaluation());
    }
    
    
    // function to convert infix to postix, convert first than create the tree
	public static char[] postfixer(char[] infix) {
		// create a new stack of character type
		Stack<Character> stack = new Stack<Character>();
		// create an array 'result' which is the same length as of infix and
		// type char
		char[] result = new char[infix.length];
		// set count as the counter for the operations on result
		// increment after every use
		int count = 0;
		for (int i = 0; i < infix.length; i++) {
			// System.out.println(result);
			switch (infix[i]) {
			case '0':case '1':case '2':case '3':case '4':
			case '5':case '6':case '7':case '8':case '9':
				result[count] = infix[i];
				count++;
				break;
			case '(':
				stack.push(infix[i]);
				break;
			case ')':
				while ( (!stack.isEmpty()) && (stack.peek() == '(')) {
					stack.pop();
				}
				if ((!stack.isEmpty())) {
					result[count] = stack.pop();
					count++;
                                        if((stack.peek() == '(')) stack.pop(); 
				}
				break;
			case '+':case '*':case '-':case '/':
				if ((!stack.isEmpty()) && (stack.peek() != '(')) {
					char checker = stack.peek();
					// if 0, same. if 1, more. if 2, less.
					int decider = checkPrecedence(infix[i], checker);
					if (decider == 1) {
						stack.push(infix[i]);
					} 
                                        else {
						result[count] = stack.pop();
						count++;
						stack.push(infix[i]);
					}
				} 
                                else {
					stack.push(infix[i]);
				}
				break;
			default:
				System.out.println(""Invalid Data"");
			}
		}
		while ((!stack.isEmpty())) {
                        result[count] = stack.pop();
			count++;
		}
		return result;
	}

		
	public static int checkPrecedence(char a, char b) {
            int decider = 0; 
		switch (a) {
		case '/':
			switch (b) {
			case '/':decider = 0;break;
			case '*':decider = 1;break;
			case '+':decider = 1;break;
			case '-':decider = 1;break;
                        default:
			}
			break;
		case '*':
			switch (b) {
			case '/':decider = 2;break;
			case '*':decider = 0;break;
			case '+':decider = 1;break;
			case '-':decider = 1;break;
			default:
			}
			break;
		case '+':
			switch (b) {
			case '/':decider = 2;break;
			case '*':decider = 2;break;
			case '+':decider = 0;break;
			case '-':decider = 1;break;
			default:
			}
			break;
		case '-':
			switch (b) {
			case '/':decider = 2;break;
			case '*':decider = 2;break;
			case '+':decider = 2;break;
			case '-':decider = 0;break;
			default:
			}
			break;
		default:
		}
                return decider;
	}
}

    

@1fdc19fca198ff8b1967193c327421c8@"
"r04447001","6","0.98","105920","@edac5849c2c546b25c9288b836d12657@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
/**
 *
 * @author jerry
 */
public class Expression{
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){ 
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        char[] infixchar = infix.toCharArray();
        char[] postfixchar = postfixer(infixchar);
        Stack<Node> stack = new Stack<Node>();
		for (int i = 0; i < postfixchar.length; i++) {
			Node node = new Node(null,null,String.valueOf(postfixchar[i]));
			switch (postfixchar[i]) {
			case '0':case '1':case '2':case '3':case '4':
			case '5':case '6':case '7':case '8':case '9':
				stack.push(node);
				break;
			case '+':case '-':case '/':case '*':
				node.setRight(stack.pop());
				node.setLeft(stack.pop());
				stack.push(node);
				break;
			default:
			}
		}
        this.root = stack.pop();
        return root;
    } 


    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        Queue<Node> q = new Queue<Node>();
        PrintPrefix(root,q);
        int N = q.size();
        Node[] result = new Node[N];
        int i = 0;
        for(Node x:q){
            result[i++] = x;
        }
        return result;
    }
    
    private void  PrintPrefix(Node x,Queue<Node> q){
        if(x == null) return;
        q.enqueue(x);
        PrintPrefix(x.getLeft(),q);
        PrintPrefix(x.getRight(),q);
    }
    
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Queue<Node> q = new Queue<Node>();
        PrintPostfix(root,q);
        int N = q.size();
        Node[] result = new Node[N];
        int i = 0;
        for(Node x:q){
            result[i++] = x;
        }
        return result;        
    }
    
    private void PrintPostfix(Node x,Queue<Node> q){
        if(x == null) return;
        PrintPostfix(x.getLeft(),q);
        PrintPostfix(x.getRight(),q);
        q.enqueue(x);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] nodes = PrintPostfix();
        Stack<Double> s = new Stack<Double>();
        for(int i = 0; i < nodes.length;i++){
            String data = nodes[i].getValue();
            if(data.equals(""+"")){s.push(s.pop()+s.pop());}
            else if(data.equals(""*"")){s.push(s.pop()*s.pop());}
            else if(data.equals(""-"")){
                double first = s.pop();
                double second = s.pop();
                s.push(second-first);
            }
            else if(data.equals(""/"")){
                double first = s.pop();
                double second = s.pop();
                s.push(second/first);
            }            
            else{s.push(Double.parseDouble(data));}
        }
        Double answer = s.pop();
        return(answer);
    }
    
    public static void main(String[] args) {
        Expression test = new Expression();
        String teststr = ""(4+(((4*2)/2)/3))"";
        char[] testpost = test.postfixer(teststr.toCharArray());
        for(int i = 0; i < testpost.length;i++){
            System.out.print(testpost[i]+"" "");
        }
        System.out.println();
        test.Infix2BT(teststr);
        Node[] result = test.PrintPrefix();
        for(int i = 0; i < result.length; i++){
            System.out.print(result[i].getValue()+"" "");
        }
        System.out.println();
        Node[] result2 = test.PrintPostfix();
        for(int i = 0; i < result2.length; i++){
            System.out.print(result2[i].getValue()+"" "");
        }        
        System.out.println();
        System.out.print(test.Evaluation());
    }
    
    
    // function to convert infix to postix, convert first than create the tree
	public static char[] postfixer(char[] infix) {
		// create a new stack of character type
		Stack<Character> stack = new Stack<Character>();
		// create an array 'result' which is the same length as of infix and
		// type char
		char[] result = new char[infix.length];
		// set count as the counter for the operations on result
		// increment after every use
		int count = 0;
		for (int i = 0; i < infix.length; i++) {
			// System.out.println(result);
			switch (infix[i]) {
			case '0':case '1':case '2':case '3':case '4':
			case '5':case '6':case '7':case '8':case '9':
				result[count] = infix[i];
				count++;
				break;
			case '(':
				stack.push(infix[i]);
				break;
			case ')':
				while ( (!stack.isEmpty()) && (stack.peek() == '(')) {
					stack.pop();
				}
				if ((!stack.isEmpty())) {
					result[count] = stack.pop();
					count++;
                                        if((stack.peek() == '(')) stack.pop(); 
				}
				break;
			case '+':case '*':case '-':case '/':
					stack.push(infix[i]);
				break;
			default:
				System.out.println(""Invalid Data"");
			}
		}
		while ((!stack.isEmpty())) {
                        result[count] = stack.pop();
			count++;
		}
		return result;
	}
}

@edac5849c2c546b25c9288b836d12657@"
"r04447001","6","0.98","105968","@9664651b19b6141462a7ed3b67f2021b@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
/**
 *
 * @author jerry
 */
public class Expression{
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){ 
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        this.root = null;//nullify the root
        char[] infixchar = infix.toCharArray();
        char[] postfixchar = postfixer(infixchar);
        Stack<Node> stack = new Stack<Node>();
		for (int i = 0; i < postfixchar.length; i++) {
			Node node = new Node(null,null,String.valueOf(postfixchar[i]));
			switch (postfixchar[i]) {
			case '0':case '1':case '2':case '3':case '4':
			case '5':case '6':case '7':case '8':case '9':
				stack.push(node);
				break;
			case '+':case '-':case '/':case '*':
				node.setRight(stack.pop());
				node.setLeft(stack.pop());
				stack.push(node);
				break;
			default:
			}
		}
        this.root = stack.pop();
        return root;
    } 


    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        Queue<Node> q = new Queue<Node>();
        PrintPrefix(root,q);
        int N = q.size();
        Node[] result = new Node[N];
        int i = 0;
        for(Node x:q){
            result[i++] = x;
        }
        return result;
    }
    
    private void  PrintPrefix(Node x,Queue<Node> q){
        if(x == null) return;
        q.enqueue(x);
        PrintPrefix(x.getLeft(),q);
        PrintPrefix(x.getRight(),q);
    }
    
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Queue<Node> q = new Queue<Node>();
        PrintPostfix(root,q);
        int N = q.size();
        Node[] result = new Node[N];
        int i = 0;
        for(Node x:q){
            result[i++] = x;
        }
        return result;        
    }
    
    private void PrintPostfix(Node x,Queue<Node> q){
        if(x == null) return;
        PrintPostfix(x.getLeft(),q);
        PrintPostfix(x.getRight(),q);
        q.enqueue(x);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] nodes = PrintPostfix();
        Stack<Double> s = new Stack<Double>();
        for(int i = 0; i < nodes.length;i++){
            String data = nodes[i].getValue();
            if(data.equals(""+"")){s.push(s.pop()+s.pop());}
            else if(data.equals(""*"")){s.push(s.pop()*s.pop());}
            else if(data.equals(""-"")){
                double first = s.pop();
                double second = s.pop();
                s.push(second-first);
            }
            else if(data.equals(""/"")){
                double first = s.pop();
                double second = s.pop();
                s.push(second/first);
            }            
            else{s.push(Double.parseDouble(data));}
        }
        Double answer = s.pop();
        return(answer);
    }
    
    public static void main(String[] args) {
        Expression test = new Expression();
        String teststr = ""((4+2)*(4-2))"";
        char[] testpost = test.postfixer(teststr.toCharArray());
        for(int i = 0; i < testpost.length;i++){
            System.out.print(testpost[i]+"" "");
        }
        System.out.println();
        test.Infix2BT(teststr);
        Node[] result = test.PrintPrefix();
        for(int i = 0; i < result.length; i++){
            System.out.print(result[i].getValue()+"" "");
        }
        System.out.println();
        Node[] result2 = test.PrintPostfix();
        for(int i = 0; i < result2.length; i++){
            System.out.print(result2[i].getValue()+"" "");
        }        
        System.out.println();
        System.out.print(test.Evaluation());
    }
    
    
    // function to convert infix to postix, convert first than create the tree
	public static char[] postfixer(char[] infix) {
		// create a new stack of character type
		Stack<Character> stack = new Stack<Character>();
		// create an array 'result' which is the same length as of infix and
		// type char
		char[] result = new char[infix.length];
		// set count as the counter for the operations on result
		// increment after every use
		int count = 0;
		for (int i = 0; i < infix.length; i++) {
			// System.out.println(result);
			switch (infix[i]) {
			case '0':case '1':case '2':case '3':case '4':
			case '5':case '6':case '7':case '8':case '9':
				result[count] = infix[i];
				count++;
				break;
			case '(':
				stack.push(infix[i]);
				break;
			case ')':
				while ( (!stack.isEmpty()) && (stack.peek() == '(')) {
					stack.pop();
				}
				if ((!stack.isEmpty())) {
					result[count] = stack.pop();
					count++;
                                        if((stack.peek() == '(')) stack.pop(); 
				}
				break;
			case '+':case '*':case '-':case '/':
					stack.push(infix[i]);
				break;
			default:
				System.out.println(""Invalid Data"");
			}
		}
		while ((!stack.isEmpty())) {
                        result[count] = stack.pop();
			count++;
		}
		return result;
	}
}

@9664651b19b6141462a7ed3b67f2021b@"
"r04546032","6","0.59","105424","@369bb7b45a967da5070b29858c0446c7@
import java.io.BufferedReader;
import java.io.FileReader;



/**
 * @author CHIN LUNG
 */
public class Expression {
    private Node root;
    private static Stack<Node> operator = new Stack<Node>();
    private static Stack<Node> values = new Stack<Node>();
    private  int N;           // number of key-value pairs in the B-tree
    private  Node[] outcome;
    private double answers;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = scanf(infix);outcome = new Node[N];
        answers = ans(infix);
        return(root);
    }

    
    //中 左 右 traversal
    int a = 0;
    
    public Node[] preOrder(Node node) {
         if ( node != null ) { 
         outcome[a] = node; a++;
         //System.out.print(""[""+outcome[a].getValue()+""]"");         
         preOrder(node.getLeft());  // 走訪左子樹         
         preOrder(node.getRight()); // 走訪右子樹
         }
         return outcome;
   }
    
    public Node[] PrintPrefix(){
        if(root == null)
        {
            throw new NullPointerException();
        }
        else{
                outcome = new Node[N];
        }
        return preOrder(root);
    }
    //左 右 中
    int i = 0;
    
    public Node[] postOrder(Node node) {
      if ( node != null ) {  
         postOrder(node.getLeft());  // 走訪左子樹
         postOrder(node.getRight()); // 走訪右子樹
         outcome[i] = node; i++;
         //System.out.print(""[""+outcome[i].getValue()+""]"");
         
      }
      return outcome;
   }
    
    public Node[] PrintPostfix(){
        if(root == null)
        {
             throw new NullPointerException();
        }
        else{
            outcome = new Node[N];
        }     
        return postOrder(root);
    }

    public double Evaluation(){
        if(root == null)
        {
            throw new NullPointerException();
        }       
        Double answer = answers;
        
        
        
        
        return(answer);
    }
    
    public Node scanf(String e)
    {
        Node ops;
        Node vals ;       
        String data[] = new String[e.length()];//將得到的字串先存下來
        for(int i = 0; i < e.length() ;i++)
        {
            data[i] =e.substring(i, i+1);
        }
    
       //先將前序轉為後序
       for(int i = 0; i < data.length;i++)
       {
               if(data[i].equals(""(""));
               else if(data[i].equals(""+"")){ ops = new Node(null,null,""+"");ops.setValue(""+"");operator.push(ops);N++;}
               else if(data[i].equals(""-"")){ ops = new Node(null,null,""-"");ops.setValue(""-"");operator.push(ops);N++;}
               else if(data[i].equals(""*"")){ ops = new Node(null,null,""*"");ops.setValue(""*"");operator.push(ops);N++;}
               else if(data[i].equals(""/"")) {ops = new Node(null,null,""/"");ops.setValue(""/"");operator.push(ops);N++;}
               else if(data[i].equals("")"")) 
               {
                  Node op = operator.pop();
                  Node right = values.pop();
                  Node left = values.pop();
                  op.setRight(right);    
                  op.setLeft (left);
                  values.push(op);
               }
               else 
               {
                   vals = new Node(null,null,data[i]);
                   vals.setValue(data[i]);
                   values.push(vals);
                   N++;
               }
           }
		return values.pop();
    }
    
    
    
    public Double ans(String e)
    {
       Stack<String> ops = new Stack<String>();
       Stack<Double> vals = new Stack<Double>();
         String data[] = new String[e.length()];//將得到的字串先存下來
        for(int i = 0; i < e.length() ;i++)
        {
            data[i] =e.substring(i, i+1);
        }
    
       //先將前序轉為後序
       for(int i = 0; i < data.length;i++)
       {
               if(data[i].equals(""(""));
               else if(data[i].equals(""+"")) ops.push(data[i]);
               else if(data[i].equals(""-"")) ops.push(data[i]);
               else if(data[i].equals(""*"")) ops.push(data[i]);
               else if(data[i].equals(""/"")) ops.push(data[i]);
               else if(data[i].equals("")""))
               {
                  String op = ops.pop();
                  if(op.equals(""+"")) vals.push(vals.pop() + vals.pop());
                  else if(op.equals(""-"")) vals.push(-vals.pop() + vals.pop());
                  else if(op.equals(""*"")) vals.push(vals.pop() * vals.pop());
                  else if(op.equals(""/"")) vals.push(1/vals.pop() * vals.pop());
               }
               else vals.push(Double.parseDouble(data[i]));
           }
		return vals.pop();
    }
    
    
        public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String number = br.readLine();
            Expression ee = new Expression();
            ee.Infix2BT(number);
            ee.PrintPostfix();
            System.out.println(""\n"");
            ee.PrintPrefix();
            System.out.println(ee.Evaluation());
        }
    }
}

@369bb7b45a967da5070b29858c0446c7@"
"r03525008","9","0.87","105536","@0f19e1ba112a3dd9e726611d69aad1fe@import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){

        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String num = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char c = infix.charAt(i);
            switch (c){
                case '(':
                    num = """";
                    break;
                case '+':
                case '-':
                case '*':
                case '/':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    ops.push(new Node(null , null , c + """"));
                    break;
                case ')':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    Node op = ops.pop();
                    Node val2 = vals.pop();
                    Node val1 = vals.pop();
                    op.setLeft(val1);
                    op.setRight(val2);
                    root = op;
                    vals.push(op);
                    break;
                default:
                    num += c;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        List<Node> list = new ArrayList<Node>();
        PrintPrefixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPrefixHelper(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        PrintPrefixHelper(list, root.getLeft());
        PrintPrefixHelper(list , root.getRight());
    }

    public Node[] PrintPostfix(){
        List<Node> list = new ArrayList<Node>();
        PrintPostfixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPostfixHelper(List<Node> list, Node root){
        if (root == null) return;
        PrintPostfixHelper(list, root.getLeft());
        PrintPostfixHelper(list, root.getRight());
        list.add(root);
    }

    public double Evaluation(){
        Node[] nodes =  this.PrintPostfix();
        Stack<Double> values = new Stack<Double>();
        for (Node node:nodes) {
            String str = node.getValue();
            if (str.equals(""+"")){
                values.push( values.pop() + values.pop() );
            } else if (str.equals(""-"")){
                values.push( - values.pop() + values.pop() );
            } else if (str.equals(""*"")){
                values.push( values.pop() * values.pop() );
            } else if (str.equals(""/"")){
                values.push( 1/values.pop() * values.pop() );
            } else {
                values.push(Double.parseDouble(str));
            }
        }
        return values.pop();
    }
}
@0f19e1ba112a3dd9e726611d69aad1fe@"
"r04921094","5","0.5","105920","@7c21161adab53d238f9cde7b46f12201@//import edu.princeton.cs.algs4.Stack;
//import edu.princeton.cs.algs4.In;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        String[] infixes = infix.split("""");
        length = 0;


        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"")){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        root = operandStack.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = new Node[length];
        prefixBuilder(prefix, 0, root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[length];
        postfixBuilder(postfix, length - 1, root);
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue());
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue());
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@7c21161adab53d238f9cde7b46f12201@"
"r03525008","9","0.86","105472","@1524fe3a10feacb5db69005da137fdf9@import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){

        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String num = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char c = infix.charAt(i);
            switch (c){
                case '(':
                    num = """";
                    break;
                case '+':
                case '-':
                case '*':
                case '/':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    ops.push(new Node(null , null , c + """"));
                    break;
                case ')':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    Node op = ops.pop();
                    Node val2 = vals.pop();
                    Node val1 = vals.pop();
                    op.setLeft(val1);
                    op.setRight(val2);
                    root = op;
                    vals.push(op);
                    break;
                default:
                    num += c;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        List<Node> list = new ArrayList<Node>();
        PrintPrefixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPrefixHelper(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        PrintPrefixHelper(list, root.getLeft());
        PrintPrefixHelper(list , root.getRight());
    }

    public Node[] PrintPostfix(){
        List<Node> list = new ArrayList<Node>();
        PrintPostfixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPostfixHelper(List<Node> list, Node root){
        if (root == null) return;
        PrintPostfixHelper(list, root.getLeft());
        PrintPostfixHelper(list, root.getRight());
        list.add(root);
    }

    public double Evaluation(){
        Node[] nodes =  this.PrintPostfix();
        Stack<Double> values = new Stack<Double>();
        for (Node node:nodes) {
            String str = node.getValue();
            switch (str) {
                case ""+"":
                    values.push(values.pop() + values.pop());
                    break;
                case ""-"":
                    values.push(-values.pop() + values.pop());
                    break;
                case ""*"":
                    values.push(values.pop() * values.pop());
                    break;
                case ""/"":
                    values.push(1 / values.pop() * values.pop());
                    break;
                default:
                    values.push(Double.parseDouble(str));
                    break;
            }
        }
        return values.pop();
    }
}
@1524fe3a10feacb5db69005da137fdf9@"
"r03525008","10","0.098","105632","@1a0ebf837e24c715b8b96919b34d4176@import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){

        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String num = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char c = infix.charAt(i);
            switch (c){
                case '(':
                    num = """";
                    break;
                case '+':
                case '-':
                case '*':
                case '/':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    ops.push(new Node(null , null , c + """"));
                    break;
                case ')':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    Node op = ops.pop();
                    Node val2 = vals.pop();
                    Node val1 = vals.pop();
                    op.setLeft(val1);
                    op.setRight(val2);
                    root = op;
                    vals.push(op);
                    break;
                default:
                    num += c;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPrefixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPrefixHelper(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        PrintPrefixHelper(list, root.getLeft());
        PrintPrefixHelper(list , root.getRight());
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPostfixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPostfixHelper(List<Node> list, Node root){
        if (root == null) return;
        PrintPostfixHelper(list, root.getLeft());
        PrintPostfixHelper(list, root.getRight());
        list.add(root);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] nodes =  this.PrintPostfix();
        Stack<Double> values = new Stack<Double>();
        for (Node node:nodes) {
            String str = node.getValue();
            switch (str) {
                case ""+"":
                    values.push(values.pop() + values.pop());
                    break;
                case ""-"":
                    values.push(-values.pop() + values.pop());
                    break;
                case ""*"":
                    values.push(values.pop() * values.pop());
                    break;
                case ""/"":
                    values.push(1 / values.pop() * values.pop());
                    break;
                default:
                    values.push(Double.parseDouble(str));
                    break;
            }
        }
        return values.pop();
    }
}
@1a0ebf837e24c715b8b96919b34d4176@"
"r04447001","10","0.098","105920","@cf401714e673acc8b838a009fda2cbb6@/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
*/
/**
 *
 * @author jerry
 */
public class Expression{
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){ 
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        this.root = null;//nullify the root
        String[] infixchar = infix.split(""(?<=[-+*/()])|(?=[-+*/()])"");
        String[] postfixchar = postfixer(infixchar);
        Stack<Node> stack = new Stack<Node>();
		for (int i = 0; i < postfixchar.length; i++) {
			Node node = new Node(null,null,postfixchar[i]);
                        if(postfixchar[i].equals(""+"") || postfixchar[i].equals(""-"") || postfixchar[i].equals(""*"") || postfixchar[i].equals(""/"")){
        		node.setRight(stack.pop());
			node.setLeft(stack.pop());
			stack.push(node);                
                        }
                        else{
                        stack.push(node);
                        }
		}
        this.root = stack.pop();
        return root;
    } 


    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        Queue<Node> q = new Queue<Node>();
        PrintPrefix(root,q);
        int N = q.size();
        Node[] result = new Node[N];
        int i = 0;
        for(Node x:q){
            result[i++] = x;
        }
        return result;
    }
    
    private void  PrintPrefix(Node x,Queue<Node> q){
        if(x == null) return;
        q.enqueue(x);
        PrintPrefix(x.getLeft(),q);
        PrintPrefix(x.getRight(),q);
    }
    
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Queue<Node> q = new Queue<Node>();
        PrintPostfix(root,q);
        int N = q.size();
        Node[] result = new Node[N];
        int i = 0;
        for(Node x:q){
            result[i++] = x;
        }
        return result;        
    }
    
    private void PrintPostfix(Node x,Queue<Node> q){
        if(x == null) return;
        PrintPostfix(x.getLeft(),q);
        PrintPostfix(x.getRight(),q);
        q.enqueue(x);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] nodes = PrintPostfix();
        Stack<Double> s = new Stack<Double>();
        for(int i = 0; i < nodes.length;i++){
            String data = nodes[i].getValue();
            if(data.equals(""+"")){s.push(s.pop()+s.pop());}
            else if(data.equals(""*"")){s.push(s.pop()*s.pop());}
            else if(data.equals(""-"")){
                double first = s.pop();
                double second = s.pop();
                s.push(second-first);
            }
            else if(data.equals(""/"")){
                double first = s.pop();
                double second = s.pop();
                s.push(second/first);
            }            
            else{s.push(Double.parseDouble(data));}
        }
        Double answer = s.pop();
        return(answer);
    }
    
    public static void main(String[] args) {
        String str1 = ""((4+2)*(4-2))"";
        String[] str2 = str1.split(""(?<=[-+*/()])|(?=[-+*/()])"");
        for(int i = 0; i < str2.length; i++){
        System.out.print(str2[i]+ "" "");
        }
        System.out.println();
        String[] str3 = postfixer(str2);
        for(int i = 0; i < str3.length; i++){
        System.out.print(str3[i]+ "" "");
        }
        System.out.println();        
        
        
        Expression test = new Expression();
        String teststr = ""((4+2)*(4-2))"";
        test.Infix2BT(teststr);
        Node[] result = test.PrintPrefix();
        for(int i = 0; i < result.length; i++){
            System.out.print(result[i].getValue()+"" "");
        }
        System.out.println();
        Node[] result2 = test.PrintPostfix();
        for(int i = 0; i < result2.length; i++){
            System.out.print(result2[i].getValue()+"" "");
        }        
        System.out.println();
        System.out.print(test.Evaluation());
        System.out.println();    
    }
    
    
    // function to convert infix to postix, convert first than create the tree
	public static String[] postfixer(String[] infix) {
		// create a new stack of character type
		Stack<String> stack = new Stack<String>();
		// create an array 'result' which is the same length as of infix and
		// type char
		String[] result = new String[infix.length];
		// set count as the counter for the operations on result
		// increment after every use
		int count = 0;
		for (int i = 0; i < infix.length; i++) {
			// System.out.println(result);
                        if(infix[i].equals(""("")){
                            stack.push(infix[i]);
                        }
                        else if(infix[i].equals("")"")){
                        	while ( (!stack.isEmpty()) && (stack.peek().equals(""(""))) {
					stack.pop();
				}
				if ((!stack.isEmpty())) {
					result[count] = stack.pop();
					count++;
                                        if(stack.peek().equals(""("")) stack.pop(); 
				}
                        }
                        else if(infix[i].equals(""+"") || infix[i].equals(""-"") || infix[i].equals(""*"") || infix[i].equals(""/"")){
                        stack.push(infix[i]);
                        }
                        else{
                        result[count] = infix[i];
			count++;                        
                        }
		}
		while ((!stack.isEmpty())) {
                        result[count] = stack.pop();
			count++;
		}
                String[] result2 = new String[count];
                for(int i = 0; i < count; i++) result2[i] = result[i];
		return result2;
	}
}

@cf401714e673acc8b838a009fda2cbb6@"
"b02611019","10","0.1","105872","@c3dbf7b50aac7e8948ccdfae24c4cacf@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

public class Expression {

    private Stack<Node>nodes;
    static Node treeroot;
    static Stack<String> st;
    static int N = 0;
    
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] str = infix.split("""");
        st = new Stack<String>();
        nodes = new Stack<Node>();

        for (int i = 0; i < str.length; i++) {
            st.push(str[i]);
            if(i>0&&!(str[i].equals(""+"")||str[i].equals(""-"")||str[i].equals(""*"")||str[i].equals(""/"")||str[i].equals(""("")||str[i].equals("")""))){
                if(!(str[i-1].equals(""+"")||str[i-1].equals(""-"")||str[i-1].equals(""*"")||str[i-1].equals(""/"")||str[i-1].equals(""("")||str[i-1].equals("")""))){
                    st.pop();
                    st.push(st.pop()+str[i]);
                }
            }
                
            if (str[i].equals("")"")) {
                st.pop();
                String rightstr = st.pop();
                String oper = st.pop();
                String leftstr = st.pop();

                if (!leftstr.equals(""Tree"") && !rightstr.equals(""Tree"")) {
                    Node left = new Node(null, null, leftstr);
                    Node right = new Node(null, null, rightstr);
                    nodes.push(new Node(left, right, oper));
                    st.pop();
                    st.push(""Tree"");
                    N = N + 3;
//                    StdOut.print(root.getRight().getValue());
                } else if (leftstr.equals(""Tree"")&& !rightstr.equals(""Tree"")) {
                    Node root = nodes.pop();
                    Node oldroot = new Node(root.getLeft(), root.getRight(), root.getValue());
                    Node newroot = new Node(null,null,null);
                    newroot.setValue(oper);
                    newroot.setLeft(oldroot);
                    Node right = new Node(null, null, rightstr);
                    newroot.setRight(right);
                    nodes.push(newroot);
                    st.pop();
                    st.push(""Tree"");
                    N = N + 2;
                } else if (!leftstr.equals(""Tree"") &&rightstr.equals(""Tree"")) {
                    Node root = nodes.pop();
                    Node oldroot = new Node(root.getLeft(), root.getRight(), root.getValue());
                    Node newroot = new Node(null,null,null);
                    newroot.setValue(oper);
                    newroot.setRight(oldroot);
                    Node left = new Node(null, null, leftstr);
                    newroot.setLeft(left);
                    nodes.push(newroot);
                    st.pop();
                    st.push(""Tree"");
                    N = N + 2;
                }else if (leftstr.equals(""Tree"") &&rightstr.equals(""Tree"")) {
                    Node rightroot = nodes.pop();
                    Node leftroot = nodes.pop();
                    Node newroot = new Node(null,null,null);
                    newroot.setLeft(leftroot);
                    newroot.setRight(rightroot);
                    newroot.setValue(oper);
                    nodes.push(newroot);
                    st.pop();
                    st.push(""Tree"");
                    N = N + 1;
                }
            }

        }
        treeroot = nodes.pop();
        return (treeroot);
    }

    static ArrayList<Node> prefixal;

    public void TraversePre(Node node) {
        prefixal.add(node);
        if (node.getLeft() != null) {
            TraversePre(node.getLeft());
        }
        if (node.getRight() != null) {
            TraversePre(node.getRight());
        }

    }

    public Node[] PrintPrefix() {
        Node[] prefix = new Node[N];
        int curnum = 0;
        prefixal = new ArrayList<Node>();
        TraversePre(treeroot);
        for (int i = 0; i < N; i++) {
            prefix[i] = prefixal.get(i);
        }
        return (prefix);
    }

    static ArrayList<Node> postfixal;

    public void TraversePost(Node node) {

        if (node.getLeft() != null) {
            TraversePost(node.getLeft());
        }
        if (node.getRight() != null) {
            TraversePost(node.getRight());
        }
        postfixal.add(node);

    }

    public Node[] PrintPostfix() {
        Node[] postfix = new Node[N];
        int curnum = 0;
        postfixal = new ArrayList<Node>();
        TraversePost(treeroot);
        for (int i = 0; i < N; i++) {
            postfix[i] = postfixal.get(i);
        }
        return (postfix);
    }

    public static double Operate(String op, double a, double b) {
        if (op.equals(""+"")) {
            return (a + b);
        } else if (op.equals(""-"")) {
            return (a - b);
        } else if (op.equals(""*"")) {
            return (a * b);
        } else if (op.equals(""/"")) {
            return (a / b);
        } else {
            return 0;
        }
    }

    public double Evaluation(Node node) {

        if (node.getLeft() == null && node.getRight() == null) {
            return Double.parseDouble(node.getValue());
        } else {
            return Operate(node.getValue(), Evaluation(node.getLeft()), Evaluation(node.getRight()));
        }

    }

    public double Evaluation() {
        return Evaluation(treeroot);
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new FileReader(args[0]));
        String read = br.readLine();
        Expression ex = new Expression();
        ex.Infix2BT(read);

//        StdOut.print(ex.treeroot.getRight().getValue());
        for (Node node : ex.PrintPrefix()) {
            StdOut.print(node.getValue());
        }
        StdOut.print(ex.Evaluation());
    }
}

@c3dbf7b50aac7e8948ccdfae24c4cacf@"
"r04921094","0","0.91","105840","@bf8c6ed89769df6ee58fb06fc31a45b0@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    // System.out.println(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
                // System.out.println(reg + ""????/""+ stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 0; i<infixes.length; i++){
            System.out.println(i + "": "" + infixes[i]);
        }

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"")){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                System.out.println(operate.getValue());
                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        root = operandStack.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = new Node[length];
        prefixBuilder(prefix, 0, root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[length];
        postfixBuilder(postfix, length - 1, root);
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue());
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue());
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@bf8c6ed89769df6ee58fb06fc31a45b0@"
"r04921094","9","0.85","105856","@b9206483e09c49190078c72a9d803d64@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

//author: ymy

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    // System.out.println(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
                // System.out.println(reg + ""????/""+ stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        // for(int i = 0; i<infixes.length; i++){
        //     System.out.println(i + "": "" + infixes[i]);
        // }

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"")){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                //System.out.println(operate.getValue());
                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        root = operandStack.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = new Node[length];
        prefixBuilder(prefix, 0, root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[length];
        postfixBuilder(postfix, length - 1, root);
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue());
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue());
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@b9206483e09c49190078c72a9d803d64@"
"r04921051","10","0.099","105840","@e89cb2a82c1a2b62e4146842a32e417b@import java.util.ArrayList;
import java.util.List;
import java.util.NoSuchElementException;

public class Expression{
 
    public static void main(String[] args) {
        String input = ""(4+(((4*2)/2)/3))"";
        
        Expression test = new Expression();
        test.Infix2BT(input);
        
        print(test.PrintPrefix());
        
        print(test.PrintPostfix()); 
        
        System.out.println(test.Evaluation()); 
        
    } 

    public static void print(Node[] pf){
        for (Node pf1 : pf) {
            System.out.printf(pf1.getValue() + "" "");
        }
        System.out.println();        
    }           
    
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    
        Stack<Node> ops = new Stack<>();        
        Stack<Node> vals = new Stack<>();    
        
        boolean flag = false;
        for(int i =0;i < infix.length();i++) {
        String s = infix.substring(i, i+1);
        switch(s) {
            case ""("":
                flag = true;
                break;
            case ""+"" :
            case ""-"" :
            case ""*"" :
            case ""/"" :
                flag = true;
                ops.push(new Node(null,null,s));
                break;
            case "")"":
                flag = true;
                if(!ops.isEmpty()){
                   Node op = ops.pop();
                   op.setRight(vals.pop());
                   op.setLeft(vals.pop());
                   vals.push(op);
                }
                break;
            default:
                if(flag)
                vals.push(new Node(null,null,s));                
                else{
                Node temp = vals.pop();
                temp.setValue(temp.getValue()+s);
                vals.push(temp);
                }
                flag = false;
        }}
        
        root = vals.pop();         
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> p = new ArrayList<Node>();
        getPrefix(p,root);
        return p.toArray(new Node[p.size()]);
    }

    public void getPrefix(List<Node> out,Node pf){
        if(pf == null) return;    
        out.add(pf);
        getPrefix(out,pf.getLeft());
        getPrefix(out,pf.getRight());       
    }      
      
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();        
        List<Node> p = new ArrayList<Node>();
        getPostfix(p,root);
        return p.toArray(new Node[p.size()]);
    }
    
    public void getPostfix(List<Node> out,Node pf){
        if(pf == null) return;          
        getPostfix(out,pf.getLeft());
        getPostfix(out,pf.getRight());    
        out.add(pf);
    }          

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Stack<Double> vals = new Stack<>();
        Node[] e = PrintPostfix();
        for (Node e1 : e) {
            String s = e1.getValue();
            Double a,b;
            switch(s){
                case ""+"":
                    vals.push(vals.pop() + vals.pop());
                    break;
                case ""*"":
                    vals.push(vals.pop() * vals.pop());
                    break;
                case ""-"":
                    a = vals.pop();
                    b = vals.pop();
                    vals.push(b - a);
                    break;
                case ""/"":
                    a = vals.pop();
                    b = vals.pop();
                    vals.push(b / a);
                    break;
                default:
                    vals.push(Double.parseDouble(s));
            }
        }
        
        
        return vals.pop();
    }
}

@e89cb2a82c1a2b62e4146842a32e417b@"
"r04921051","10","0.096","105824","@7a1221a5cb3b9466480214e5a7860165@import java.util.ArrayList;
import java.util.List;

public class Expression{
 
    public static void main(String[] args) {
        String input = ""(4+(((4*2)/2)/3))""; 
        
        Expression test = new Expression();
        
        test.Infix2BT(input);    
        
        print(test.PrintPrefix());        
        print(test.PrintPostfix());        
        System.out.println(test.Evaluation()); 
        
    } 

    public static void print(Node[] pf){
        for (Node pf1 : pf) {
            System.out.printf(pf1.getValue() + "" "");
        }
        System.out.println();        
    }           

    private Node root;
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    
        Stack<Node> ops = new Stack<>();        
        Stack<Node> vals = new Stack<>();    
        
        boolean flag = false;
        for(int i =0;i < infix.length();i++) {
        String s = infix.substring(i, i+1);
        switch(s) {
            case ""("":
                flag = true;
                break;
            case ""+"" :
            case ""-"" :
            case ""*"" :
            case ""/"" :
                flag = true;
                ops.push(new Node(null,null,s));
                break;
            case "")"":
                flag = true;
                if(!ops.isEmpty()){
                   Node op = ops.pop();
                   op.setRight(vals.pop());
                   op.setLeft(vals.pop());
                   vals.push(op);
                }
                break;
            default:
                if(flag)
                vals.push(new Node(null,null,s));                
                else{
                Node temp = vals.pop();
                temp.setValue(temp.getValue()+s);
                vals.push(temp);
                }
                flag = false;
        }}
        
        root = vals.pop();         
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> p;
        p = new ArrayList<>();
        getPrefix(p,root);
        return p.toArray(new Node[p.size()]);
    }

    public void getPrefix(List<Node> out,Node pf){
        if(pf == null) return;    
        out.add(pf);
        getPrefix(out,pf.getLeft());
        getPrefix(out,pf.getRight());       
    }      
      
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();        
        List<Node> p;
        p = new ArrayList<>();
        getPostfix(p,root);
        return p.toArray(new Node[p.size()]);
    }
    
    public void getPostfix(List<Node> out,Node pf){
        if(pf == null) return;          
        getPostfix(out,pf.getLeft());
        getPostfix(out,pf.getRight());    
        out.add(pf);
    }          

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        Stack<Double> vals = new Stack<>();
        Node[] e = PrintPostfix();
        for (Node e1 : e) {
            String s = e1.getValue();
            Double a,b;
            switch(s){
                case ""+"":
                    vals.push(vals.pop() + vals.pop());
                    break;
                case ""*"":
                    vals.push(vals.pop() * vals.pop());
                    break;
                case ""-"":
                    a = vals.pop();
                    b = vals.pop();
                    vals.push(b - a);
                    break;
                case ""/"":
                    a = vals.pop();
                    b = vals.pop();
                    vals.push(b / a);
                    break;
                default:
                    vals.push(Double.parseDouble(s));
            }
        }

        return vals.pop();
    }
}

@7a1221a5cb3b9466480214e5a7860165@"
"r04546032","10","0.096","105952","@d587544b5c732f3168f68b68c4a0e44a@
import java.io.BufferedReader;
import java.io.FileReader;



/**
 * @author CHIN LUNG
 */
public class Expression {
    private Node root;
    private static Stack<Node> operator = new Stack<Node>();
    private static Stack<Node> values = new Stack<Node>();
    private  int N;           // number of key-value pairs in the B-tree
    private  Node[] outcome;
    private double answers;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = scanf(infix);outcome = new Node[N];
        answers = ans(infix);
        return(root);
    }

    
    //中 左 右 traversal
    int a = 0;
    
    public Node[] preOrder(Node node) {
         if ( node != null ) { 
         outcome[a] = node; a++;
         //System.out.print(""[""+outcome[a].getValue()+""]"");         
         preOrder(node.getLeft());  // 走訪左子樹         
         preOrder(node.getRight()); // 走訪右子樹
         }
         return outcome;
   }
    
    public Node[] PrintPrefix(){
        if(root == null)
        {
            throw new NullPointerException();
        }
        else{
                outcome = new Node[N];
        }
        return preOrder(root);
    }
    //左 右 中
    int i = 0;
    
    public Node[] postOrder(Node node) {
      if ( node != null ) {  
         postOrder(node.getLeft());  // 走訪左子樹
         postOrder(node.getRight()); // 走訪右子樹
         outcome[i] = node; i++;
         //System.out.print(""[""+outcome[i].getValue()+""]"");
         
      }
      return outcome;
   }
    
    public Node[] PrintPostfix(){
        if(root == null)
        {
             throw new NullPointerException();
        }
        else{
            outcome = new Node[N];
        }     
        return postOrder(root);
    }

    public double Evaluation(){
        if(root == null)
        {
            throw new NullPointerException();
        }       
        Double answer = answers;
                
        return(answer);
    }
    
    //處理百位數十位數千位數小數等等
    public String[] handle(String[] data)
    {
        Queue number = new Queue();
        Queue equation = new Queue();
        String c;
        int count = 0;
        
        for(int i = 0 ; i < data.length;i++)
        {
            if(data[i].equals(""("") || data[i].equals(""*"") || data[i].equals(""/"") || data[i].equals(""+"")|| data[i].equals(""-"") || data[i].equals("")""))
            {
                equation.enqueue(data[i]);
            }
            //if(data[i].equals(""("")!= true&&data[i].equals(""*"")!= true&&data[i].equals(""/"")!= true&&data[i].equals(""+"")!= true&&data[i].equals(""-"")!= true&&data[i].equals("")"") != true)
            else
            {
                 number.enqueue(data[i]);
                 if(data[i+1].equals(""("") || data[i+1].equals(""*"") || data[i+1].equals(""/"") || data[i+1].equals(""+"")|| data[i+1].equals(""-"") || data[i+1].equals("")""))
                 {
                     c = number.dequeue().toString();
                     if(number.isEmpty())
                     {
                         equation.enqueue(c);
                     }
                   if(number.isEmpty() != true)
                   {
                        while(number.isEmpty()!= true)
                        {
                            String n= number.dequeue().toString();
                            c +=n;
                        }
                     equation.enqueue(c);
                    }
//                 if(data[i].equals("".""))
//                 {                    
//                     count = number.size()-1;
                 }
            }
            
        }
        String [] out = new String[equation.size()];
        while(equation.isEmpty()!= true)
        {
            out[count] = equation.dequeue().toString();
            count++;
        }
        count=0;
        return out;
        
    }
    
    
    public Node scanf(String e)
    {
        Node ops;
        Node vals ;       
        String data[] = new String[e.length()];//將得到的字串先存下來
        
        for(int i = 0; i < e.length() ;i++)
        {
            data[i] =e.substring(i, i+1);
        }
        String datas[] = handle(data);
        
        
    
       //先將前序轉為後序
       for(int i = 0; i < datas.length;i++)
       {
               if(datas[i].equals(""(""));
               else if(datas[i].equals(""+"")){ ops = new Node(null,null,""+"");ops.setValue(""+"");operator.push(ops);N++;}
               else if(datas[i].equals(""-"")){ ops = new Node(null,null,""-"");ops.setValue(""-"");operator.push(ops);N++;}
               else if(datas[i].equals(""*"")){ ops = new Node(null,null,""*"");ops.setValue(""*"");operator.push(ops);N++;}
               else if(datas[i].equals(""/"")) {ops = new Node(null,null,""/"");ops.setValue(""/"");operator.push(ops);N++;}
               else if(datas[i].equals("")"")) 
               {
                  Node op = operator.pop();
                  Node right = values.pop();
                  Node left = values.pop();
                  op.setRight(right);    
                  op.setLeft (left);
                  values.push(op);
               }
               else 
               {
                   vals = new Node(null,null,datas[i]);
                   vals.setValue(datas[i]);
                   values.push(vals);
                   N++;
               }
           }
		return values.pop();
    }
    
    
    
    public Double ans(String e)
    {
        Stack<String> ops = new Stack<String>();
        Stack<Double> vals = new Stack<Double>();
        String data[] = new String[e.length()];//將得到的字串先存下來
        for(int i = 0; i < e.length() ;i++)
        {
            data[i] =e.substring(i, i+1);
        }
        String datas[] = handle(data);
       //先將前序轉為後序
       for(int i = 0; i < datas.length;i++)
       {
               if(datas[i].equals(""(""));
               else if(datas[i].equals(""+"")) ops.push(datas[i]);
               else if(datas[i].equals(""-"")) ops.push(datas[i]);
               else if(datas[i].equals(""*"")) ops.push(datas[i]);
               else if(datas[i].equals(""/"")) ops.push(datas[i]);
               else if(datas[i].equals("")""))
               {
                  String op = ops.pop();
                  if(op.equals(""+"")) vals.push(vals.pop() + vals.pop());
                  else if(op.equals(""-"")) vals.push(-vals.pop() + vals.pop());
                  else if(op.equals(""*"")) vals.push(vals.pop() * vals.pop());
                  else if(op.equals(""/"")) vals.push(1/vals.pop() * vals.pop());
               }
               else vals.push(Double.parseDouble(datas[i]));
           }
		return vals.pop();
    }
    
    
        public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String number = br.readLine();
            Expression ee = new Expression();
            ee.Infix2BT(number);
            ee.PrintPostfix();
            System.out.println(""\n"");
            ee.PrintPrefix();
            System.out.println(ee.Evaluation());
        }
    }
}

@d587544b5c732f3168f68b68c4a0e44a@"
"r04921094","9","0.89","105824","@fcb3aef07f3f5e5e799ffd79eb459c31@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        root = operandStack.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = new Node[length];
        prefixBuilder(prefix, 0, root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[length];
        postfixBuilder(postfix, length - 1, root);
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@fcb3aef07f3f5e5e799ffd79eb459c31@"
"r04942099","10","0.097","105616","@562b85b786b8a3d28b8968fd9f2a48c8@
public class Expression {

    private Node root;
    public int size = 1;
    public int opsize = 0;
    public int pcounter = 0;
    public Node[] p;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        int lengthb = infix.length();
        int counter0 = 0;
        int counter1 = 0;
        int sidelo = 0;
        char[] weib = infix.toCharArray();
        for (int i = 0; i < lengthb; i++) {
            if (weib[i] == ')') {
                counter0++;
            }
        }
        opsize = counter0 * 2 + 1;
        String[] wei = new String[counter0 * 4 + 1];
        for (int i = 0; i < lengthb; i++) {
            if (weib[i] == '(' || weib[i] == ')' || weib[i] == '+' || weib[i] == '-' || weib[i] == '*' || weib[i] == '/') {
                wei[counter1] = String.valueOf(weib[i]);
                counter1++;
            } else if (weib[i - 1] == '(' || weib[i - 1] == ')' || weib[i - 1] == '+' || weib[i - 1] == '-' || weib[i - 1] == '*' || weib[i - 1] == '/') {
                sidelo = i;
                if (weib[i + 1] == '(' || weib[i + 1] == ')' || weib[i + 1] == '+' || weib[i + 1] == '-' || weib[i + 1] == '*' || weib[i + 1] == '/') {
                    wei[counter1] = String.valueOf(weib[i]);
                    counter1++;
                }
            } else if (weib[i + 1] == '(' || weib[i + 1] == ')' || weib[i + 1] == '+' || weib[i + 1] == '-' || weib[i + 1] == '*' || weib[i + 1] == '/') {
                String temp = """";
                for (int j = sidelo; j < i + 1; j++) {
                    temp = temp + String.valueOf(weib[j]);
                }
                wei[counter1] = temp;
                counter1++;
            }
        }
        int length = wei.length;
        Stack<String> ops = new Stack<String>();
        Stack<Node> vals = new Stack<Node>();
        for (int i = 0; i < length; ++i) {
            String s = wei[i];
            //System.out.println(s);
            if (s.equals(""("")); else if (s.equals(""+"")) {
                ops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(s);
            } else if (s.equals("")"")) {
                size += 2;
                Node right = vals.pop();
                Node left = vals.pop();
                Node feng = new Node(left, right, ops.pop());
                root = feng;
                vals.push(feng);

            } else {
                vals.push(new Node(null, null, s));
            }
        }

        return root;
    }

    public Node[] PrintPrefix() {
        Node[] prefix = new Node[size];
        int order = 0;
        if (root == null) {
            throw new NullPointerException();
        }
        Stack<Node> stack = new Stack<Node>();
        stack.push(root);
        while (!stack.isEmpty()) {
            Node n = stack.pop();
            prefix[order] = n;
            order++;
            if (n.getRight() != null) {
                stack.push(n.getRight());
            }
            if (n.getLeft() != null) {
                stack.push(n.getLeft());
            }
        }
        return prefix;
    }

    public void postOrder(Node input) {
        if (input != null) {
            postOrder(input.getLeft());
            postOrder(input.getRight());
            p[pcounter] = input;
            pcounter++;
        }
    }

    public Node[] PrintPostfix() {
        Node[] postfix = new Node[size];
        if (root == null) {
            throw new NullPointerException();
        }
        //p = null;
        pcounter = 0;
        p = new Node[size];
        postOrder(root);
        for (int i = 0; i < size; i++) {
            postfix[i] = p[i];
        }
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        if (root == null) {
            throw new NullPointerException();
        }
        Node[] value = PrintPostfix();
        Stack<String> node = new Stack<String>();
        String v1;
        String v2;
        String v3;
        double an;
        for (int i = 0; i < size; i++) {
            String s = value[i].getValue();
            if (s.equals(""+"")) {
                v2 = node.pop();
                v1 = node.pop();
                an = Double.parseDouble(v1) + Double.parseDouble(v2);
                v3 = String.valueOf(an);
                node.push(v3);
            } else if (s.equals(""-"")) {
                v2 = node.pop();
                v1 = node.pop();
                an = Double.parseDouble(v1) - Double.parseDouble(v2);
                v3 = String.valueOf(an);
                node.push(v3);
            } else if (s.equals(""*"")) {
                v2 = node.pop();
                v1 = node.pop();
                an = Double.parseDouble(v1) * Double.parseDouble(v2);
                v3 = String.valueOf(an);
                node.push(v3);
            } else if (s.equals(""/"")) {
                v2 = node.pop();
                v1 = node.pop();
                an = Double.parseDouble(v1) / Double.parseDouble(v2);
                v3 = String.valueOf(an);
                node.push(v3);
            }else{
                node.push(s);
            }

        }
        answer = Double.parseDouble(node.peek());
        return answer;
    }

}

@562b85b786b8a3d28b8968fd9f2a48c8@"
"r04921094","9","1","105824","@b3045678095a4f09b34338c00998eb1b@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        if(!operandStack.isEmpty()){
            root = operandStack.pop();
        }else{
            root = null;
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root != null){
            Node[] prefix = new Node[length];
            prefixBuilder(prefix, 0, root);
            return prefix;
        }
        else{
            return null;
        }
    }
  
    public Node[] PrintPostfix(){
        if(root != null){
            Node[] postfix = new Node[length];
            postfixBuilder(postfix, length - 1, root);
            return postfix;
        }
        else{
            return null;
        }
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@b3045678095a4f09b34338c00998eb1b@"
"r04921094","0","0.89","105824","@6239d3d91d749036401811de2e154936@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        if(!operandStack.isEmpty()){
            root = operandStack.pop();
        }else{
            root = null;
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root != null){
            Node[] prefix = new Node[length];
            prefixBuilder(prefix, 0, root);
            return prefix;
        }
        else{
            return new Node(null, null, ""0"");
        }
    }
  
    public Node[] PrintPostfix(){
        if(root != null){
            Node[] postfix = new Node[length];
            postfixBuilder(postfix, length - 1, root);
            return postfix;
        }
        else{
            return new Node(null, null, ""0"");
        }
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@6239d3d91d749036401811de2e154936@"
"r04921094","9","0.95","105872","@4d6f0a7b5c73d43a0bdf8b0deaf114c3@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        if(!operandStack.isEmpty()){
            root = operandStack.pop();
        }else{
            root = null;
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root != null){
            Node[] prefix = new Node[length];
            prefixBuilder(prefix, 0, root);
            return prefix;
        }
        else{
            return new Node[] { new Node(null, null, ""0"") };
        }
    }
  
    public Node[] PrintPostfix(){
        if(root != null){
            Node[] postfix = new Node[length];
            postfixBuilder(postfix, length - 1, root);
            return postfix;
        }
        else{
            return new Node[] { new Node(null, null, ""0"") };
        }
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@4d6f0a7b5c73d43a0bdf8b0deaf114c3@"
"r04921094","0","0.097","105616","@accba105bf81f5826d21213a7dc032db@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        if(!operandStack.isEmpty()){
            root = operandStack.pop();
        }else{
            root = null;
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root != null){
            Node[] prefix = new Node[length];
            prefixBuilder(prefix, 0, root);
            return prefix;
        }
        else{
            throw new IllegalArgumentException();
            return new Node[] { new Node(null, null, ""0"") };
        }
    }
  
    public Node[] PrintPostfix(){
        if(root != null){
            Node[] postfix = new Node[length];
            postfixBuilder(postfix, length - 1, root);
            return postfix;
        }
        else{
            throw new IllegalArgumentException();
            return new Node[] { new Node(null, null, ""0"") };
        }
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@accba105bf81f5826d21213a7dc032db@"
"r04921094","9","0.88","105872","@18b508b9a75e4303aa8616fe60ae9e8c@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        if(!operandStack.isEmpty()){
            root = operandStack.pop();
        }else{
            root = null;
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root != null){
            Node[] prefix = new Node[length];
            prefixBuilder(prefix, 0, root);
            return prefix;
        }
        else{
            throw new IllegalArgumentException();
            //return new Node[] { new Node(null, null, ""0"") };
        }
    }
  
    public Node[] PrintPostfix(){
        if(root != null){
            Node[] postfix = new Node[length];
            postfixBuilder(postfix, length - 1, root);
            return postfix;
        }
        else{
            throw new IllegalArgumentException();
            //return new Node[] { new Node(null, null, ""0"") };
        }
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@18b508b9a75e4303aa8616fe60ae9e8c@"
"r04921094","9","0.95","105840","@bf53d8b5e326960aeae6038c9e20c3bb@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        if(!operandStack.isEmpty()){
            root = operandStack.pop();
        }else{
            root = null;
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root != null){
            Node[] prefix = new Node[length];
            prefixBuilder(prefix, 0, root);
            return prefix;
        }
        else{
            return new Node[0];
        }
    }
  
    public Node[] PrintPostfix(){
        if(root != null){
            Node[] postfix = new Node[length];
            postfixBuilder(postfix, length - 1, root);
            return postfix;
        }
        else{
            return new Node[0];
        }
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@bf53d8b5e326960aeae6038c9e20c3bb@"
"r04921094","9","0.98","105872","@1b192a945c973d8b9320fcf879e345b0@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        if(!operandStack.isEmpty()){
            root = operandStack.pop();
        }else{
            root = null;
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        if(root != null){
            prefix = new Node[length];
            prefixBuilder(prefix, 0, root);
            return prefix;
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        if(root != null){
            postfix = new Node[length];
            postfixBuilder(postfix, length - 1, root);
            return postfix;
        }
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@1b192a945c973d8b9320fcf879e345b0@"
"r04921094","2","0.27","105872","@4e07f9b20531680fc414f655c19e3418@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        if(!operandStack.isEmpty()){
            root = operandStack.pop();
        }else{
            root = null;
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        if(root != null){
            prefix = new Node[length];
            prefixBuilder(prefix, 0, root);
            return prefix;
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        if(root != null){
            postfix = new Node[length];
            postfixBuilder(postfix, length - 1, root);
            return postfix;
        }
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        throw new NullPointerException();
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        throw new NullPointerException();
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@4e07f9b20531680fc414f655c19e3418@"
"r04921094","10","0.099","105904","@4c7565b85e028464c2e6894db275501a@//import edu.princeton.cs.algs4.*;
import java.util.ArrayList;

public class Expression{
  
    private Node root;
    private int length = 0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operandStack = new Stack<Node> ();
        Stack<Node> operateStack = new Stack<Node> ();
        ArrayList<String> stringReg = new ArrayList<String> ();
        String[] infixes;
        String[] stringSplit = infix.split("""");;
        String reg = new String();

        length = 0;

        for(int i = 0; i < stringSplit.length; i++){
            if(stringSplit[i].equals(""+"") || stringSplit[i].equals(""-"") ||
               stringSplit[i].equals(""*"") || stringSplit[i].equals(""/"") ||
               stringSplit[i].equals(""("") || stringSplit[i].equals("")"")){
                if(!reg.equals("""")){
                    stringReg.add(reg);
                    reg = new String ();
                }
                stringReg.add(stringSplit[i]);
            }
            else{
                reg = reg.concat(stringSplit[i]);
            }
        }

        infixes = new String[stringReg.size()];
        infixes = stringReg.toArray(infixes);

        for(int i = 1; i < infixes.length; i++){
            if(infixes[i].equals("")"") && !operateStack.isEmpty()){
                Node operate = operateStack.pop();
                Node right = operandStack.pop();
                Node left = operandStack.pop();

                operate.setRight(right);
                operate.setLeft(left);
                operandStack.push(operate);
            }
            else if(infixes[i].equals(""+"") || infixes[i].equals(""-"") ||
                    infixes[i].equals(""*"") || infixes[i].equals(""/"")){
                operateStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
            else if(!infixes[i].equals(""("") && !infixes[i].equals("")"")){
                operandStack.push(new Node(null, null, infixes[i]));
                ++length;
            }
        }
        if(!operandStack.isEmpty()){
            root = operandStack.pop();
        }else{
            root = null;
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        if(root != null){
            prefix = new Node[length];
            prefixBuilder(prefix, 0, root);
            return prefix;
        }
        throw new NullPointerException();
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        if(root != null){
            postfix = new Node[length];
            postfixBuilder(postfix, length - 1, root);
            return postfix;
        }
        throw new NullPointerException();
    }

    public double Evaluation(){
        double answer = 0;
        Node calcuate = new Node(null, null, root.getValue());
        deepCopy(root, calcuate);
        answer = recursicive(calcuate);
        return answer;
    }

    private int prefixBuilder(Node[] prefix, int index, Node now){
        prefix[index++] = now;
        if(now.getLeft() != null){
            index = prefixBuilder(prefix, index, now.getLeft());
            index = prefixBuilder(prefix, index, now.getRight());
        }
        return index;
    }

    private int postfixBuilder(Node[] postfix, int index, Node now){
        postfix[index--] = now;
        if(now.getLeft() != null){
            index = postfixBuilder(postfix, index, now.getRight());
            index = postfixBuilder(postfix, index, now.getLeft());
        }
        return index;
    }

    private void deepCopy(Node now, Node copy){
        if(now.getLeft() != null){
            copy.setLeft(new Node(null, null, now.getLeft().getValue()));
            deepCopy(now.getLeft(), copy.getLeft());
        }
        if(now.getRight() != null){
            copy.setRight(new Node(null, null, now.getRight().getValue()));
            deepCopy(now.getRight(), copy.getRight());
        }
    }

    private double recursicive (Node now){
        String value = now.getValue();
        if(now.getRight() == null && now.getLeft() == null){
            return Double.parseDouble(value);
        }
        else{
            if(value.equals(""+"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left + right;
            }
            else if(value.equals(""-"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left - right;
            }
            else if(value.equals(""*"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left * right;
            }
            else if(value.equals(""/"")){
                double left = recursicive(now.getLeft());
                double right = recursicive(now.getRight());
                return left / right;
            }
        }
        return 0;
    }

    public static void main(String[] args) {
        Expression e = new Expression();
        Node[] prefix;
        Node[] postfix;
        In in = new In(args[0]);

        e.Infix2BT(in.readLine());

        prefix = e.PrintPrefix();
        for(int i = 0; i < prefix.length; i++){
            System.out.print(prefix[i].getValue() + "" "");
        }
        System.out.println();
        postfix = e.PrintPostfix();
        for(int i = 0; i < postfix.length; i++){
            System.out.print(postfix[i].getValue() + "" "");
        }
        System.out.println();
        System.out.println(e.Evaluation());
    }
}
@4c7565b85e028464c2e6894db275501a@"
"r04921051","10","0.099","105840","@03f9b0f53c2d41ed281d18efa956c921@import java.util.*;
import java.util.NoSuchElementException;

public class Expression{

    public static void main(String[] args) {
        String input = ""(2.71828/12)"";
        
        Expression test = new Expression();
        test.Infix2BT(input);
        
        //print(test.PrintInfix());
        print(test.PrintPrefix());
        print(test.PrintPostfix());        
        System.out.println(test.Evaluation());
               
    }    
  
    private Node root;
    private String[] input;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String e){
        List<String> p = new ArrayList<>();                        
        

        
        int counter = 0;
        int c = 0;
        while(c < e.length()){
            counter = c;
            String a = e.substring(c,c+1);
            if(a.equals(""("") || a.equals("")"") || a.equals(""+"") || a.equals(""-"") || a.equals(""*"") || a.equals(""/"")){    
            p.add(a);
            c++;}
            else{            
            int temp = c+1; 
            String b = e.substring(temp,temp+1);
            while(!(b.equals("")"") || b.equals(""+"") || b.equals(""-"") || b.equals(""*"") || b.equals(""/""))){            
            temp++;
            b = e.substring(temp,temp+1);
            }
            p.add(e.substring(c,temp));
            c = temp;
            }
        }
        
        
        input = new String[p.size()];
        input = p.toArray(input);
        
        Stack<Node> ops = new Stack<>();        
        Stack<Node> vals = new Stack<>();
        
        for (String s : input) {
            if (s.equals(""("")) ;
            else if (s.equals(""+"") || s.equals(""-"") || s.equals(""*"") || s.equals(""/"")) {ops.push(new Node(null,null,s));}
            else if (s.equals("")""))
            {
                if(ops.isEmpty());
                else{
                Node a = ops.pop();
                a.setRight(vals.pop());
                a.setLeft(vals.pop());
                vals.push(a);}
            }
            else vals.push(new Node(null,null,s));         
        }
        
        root = vals.pop();
        return(root);
    }

    public Node[] PrintInfix(){
        if(root == null) throw new NullPointerException();
        List<Node> n = new ArrayList<>();
        for (String input1 : input) {    
                n.add(new Node(null, null, input1));
        }

        Node[] infix = new Node[n.size()];
        infix = n.toArray(infix);
        
        return(infix);        
                
    }    
    
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> n = new ArrayList<>();
        Stack<Node> stack = new Stack<>(); 
                
        stack.push(root);  
    
         while(stack.isEmpty()==false){  
             Node node = stack.pop();
             n.add(node);
 
             if((node.getRight() == null)==false){  
                 stack.push(node.getRight());  
             }  
             if((node.getLeft() == null)==false){  
                 stack.push(node.getLeft());  
             }  
    
         }  


        Node[] prefix = new Node[n.size()];
        prefix = n.toArray(prefix);
        
        return(prefix);
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> n = new ArrayList<>();
        Stack<Node> s = new Stack<>(); 
        
        Node current = root;
        
    while( true ) {  
    
        if(( current == null )==false) {  
             if(( current.getRight() == null )==false)   
              s.push( current.getRight() );  
             s.push( current );  
             current = current.getLeft();  
             continue;  
        }  

        if(s.isEmpty())
            break;
        current = s.pop( );
        
        if( (current.getRight() == null)==false && s.isEmpty( )==false && current.getRight() == s.peek() ) {  
            s.pop( );  
            s.push( current );  
            current = current.getRight();} 
        else {  
            n.add(current);
            current = null;  
        }  
    } 
        Node[] postfix = new Node[n.size()];
        postfix = n.toArray(postfix);
        
        return(postfix);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        Stack<String> ops = new Stack<>();        
        Stack<Double> vals = new Stack<>();
        
        for (String s : input) {
            if (s.equals(""("")) ;
            else if (s.equals(""+"") || s.equals(""-"")) ops.push(s);
            else if (s.equals(""*"") || s.equals(""/"")) ops.push(s);
            else if (s.equals("")""))
            {
                if(ops.isEmpty());
                else{
                String op = ops.pop();
                if (op.equals(""+"")) vals.push(vals.pop() + vals.pop());
                else if (op.equals(""-"")) {
                    double a = vals.pop();
                    vals.push(vals.pop() - a);
                }
                else if (op.equals(""*"")) vals.push(vals.pop() * vals.pop());
                else if (op.equals(""/"")) {
                    double a = vals.pop();
                    vals.push(vals.pop() / a);
                }}
            }
            else vals.push(Double.parseDouble(s));
        }
        return(vals.pop());
    }
    
    public static void print(Node[] pf){
        for(int i = 0; i < pf.length;i++){
            System.out.printf(pf[i].getValue()+"" "");
        }
        System.out.println();        
    }
    
}
@03f9b0f53c2d41ed281d18efa956c921@"
"b03611015","0","0.099","105904","@9c4a6897dee9f6c82fbd45be23cfc5a0@
import java.util.ArrayList;
import java.util.List;


public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] x = infix.split("""");
        Stack<Node> val = new Stack<>();
        Stack<Node> ops = new Stack<>();
        for (int i = 0; i < infix.length(); i++) {
            String c = x[i];
            if (c.equals(""("")); 
            else if (c.equals(""+"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals(""-"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals(""*"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals(""/"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals("")"")) {
                Node op = ops.pop();
                Node v1 = val.pop();
                Node v2 = val.pop();
                op.setLeft(v1);
                op.setRight(v2);
                root = op;
                val.push(op);
            } else {
                val.push(new Node(null, null, c));
            }

        }

        return root;

    }

   private void PrintPrefixHelper(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        PrintPrefixHelper(list, root.getLeft());
        PrintPrefixHelper(list , root.getRight());
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPostfixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPostfixHelper(List<Node> list, Node root){
        if (root == null) return;
        PrintPostfixHelper(list, root.getLeft());
        PrintPostfixHelper(list, root.getRight());
        list.add(root);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] nodes =  this.PrintPostfix();
        Stack<Double> values = new Stack<Double>();
        for (Node node:nodes) {
            String str = node.getValue();
            switch (str) {
                case ""+"":
                    values.push(values.pop() + values.pop());
                    break;
                case ""-"":
                    values.push(-values.pop() + values.pop());
                    break;
                case ""*"":
                    values.push(values.pop() * values.pop());
                    break;
                case ""/"":
                    values.push(1 / values.pop() * values.pop());
                    break;
                default:
                    values.push(Double.parseDouble(str));
                    break;
            }
        }
        return values.pop();
    }
}

@9c4a6897dee9f6c82fbd45be23cfc5a0@"
"b03611015","1","0.97","105856","@29c810e017f04893d34a2f16c5f08b29@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;


public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] x = infix.split("""");
        Stack<Node> val = new Stack<>();
        Stack<Node> ops = new Stack<>();
        for (int i = 0; i < infix.length(); i++) {
            String c = x[i];
            if (c.equals(""("")); 
            else if (c.equals(""+"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals(""-"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals(""*"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals(""/"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals("")"")) {
                Node op = ops.pop();
                Node v1 = val.pop();
                Node v2 = val.pop();
                op.setLeft(v1);
                op.setRight(v2);
                root = op;
                val.push(op);
            } else {
                val.push(new Node(null, null, c));
            }

        }

        return root;

    }
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPrefixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

   private void PrintPrefixHelper(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        PrintPrefixHelper(list, root.getLeft());
        PrintPrefixHelper(list , root.getRight());
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPostfixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPostfixHelper(List<Node> list, Node root){
        if (root == null) return;
        PrintPostfixHelper(list, root.getLeft());
        PrintPostfixHelper(list, root.getRight());
        list.add(root);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] nodes =  this.PrintPostfix();
        Stack<Double> values = new Stack<Double>();
        for (Node node:nodes) {
            String str = node.getValue();
            switch (str) {
                case ""+"":
                    values.push(values.pop() + values.pop());
                    break;
                case ""-"":
                    values.push(-values.pop() + values.pop());
                    break;
                case ""*"":
                    values.push(values.pop() * values.pop());
                    break;
                case ""/"":
                    values.push(1 / values.pop() * values.pop());
                    break;
                default:
                    values.push(Double.parseDouble(str));
                    break;
            }
        }
        return values.pop();
    }

 public static void main(String[] args) throws Exception {
        String infix = ""(4+(((4*2)/2)/3))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for(Node n:prefixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for(Node n:postfixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());

       
       
            
    }
}

@29c810e017f04893d34a2f16c5f08b29@"
"b03611015","6","1","105840","@52391a132ec987564b96fce6d7961c20@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;


public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] x = infix.split("""");
        Stack<Node> val = new Stack<>();
        Stack<Node> ops = new Stack<>();
        for (int i = 0; i < infix.length(); i++) {
            String c = x[i];
            if (c.equals(""("")); 
            else if (c.equals(""+"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals(""-"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals(""*"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals(""/"")) {
                ops.push(new Node(null, null, c));
            } else if (c.equals("")"")) {
                Node op = ops.pop();
                Node v2 = val.pop();
                Node v1 = val.pop();
                op.setLeft(v1);
                op.setRight(v2);
                root = op;
                val.push(op);
            } else {
                val.push(new Node(null, null, c));
            }

        }

        return root;

    }
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPrefixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

   private void PrintPrefixHelper(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        PrintPrefixHelper(list, root.getLeft());
        PrintPrefixHelper(list , root.getRight());
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPostfixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPostfixHelper(List<Node> list, Node root){
        if (root == null) return;
        PrintPostfixHelper(list, root.getLeft());
        PrintPostfixHelper(list, root.getRight());
        list.add(root);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] nodes =  this.PrintPostfix();
        Stack<Double> values = new Stack<Double>();
        for (Node node:nodes) {
            String str = node.getValue();
            switch (str) {
                case ""+"":
                    values.push(values.pop() + values.pop());
                    break;
                case ""-"":
                    values.push(-values.pop() + values.pop());
                    break;
                case ""*"":
                    values.push(values.pop() * values.pop());
                    break;
                case ""/"":
                    values.push(1 / values.pop() * values.pop());
                    break;
                default:
                    values.push(Double.parseDouble(str));
                    break;
            }
        }
        return values.pop();
    }

 public static void main(String[] args) throws Exception {
        String infix = ""(4+(((4*2)/2)/3))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for(Node n:prefixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for(Node n:postfixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());

       
       
            
    }
}

@52391a132ec987564b96fce6d7961c20@"
"b03611023","6","0.95","105856","@99974168ca04cd1bfa857dce3c5984c6@public class Expression{
  
    private Node root;
    private int size;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        
        int len = infix.length();
        Stack<String> ops = new Stack<>();
        Stack<String> val = new Stack<>();
        root = null;
        for(int i = 0;i<len;i++){
            String temp = infix.substring(i, i+1);
            if(temp.equals(""("")) ;
            else if(temp.equals(""+"")) ops.push(temp);
            else if(temp.equals(""-"")) ops.push(temp);
            else if(temp.equals(""*"")) ops.push(temp);
            else if(temp.equals(""/"")) ops.push(temp);
           
            else if(temp.equals("")"")) {
                String op = ops.pop();
                if(root==null){
                    Node c = new Node(null,null,val.pop()); size++;
                    Node a = new Node(null,null,val.pop()); size++;
                    Node b = new Node(a,c,op);  
                    size++;
                    root = b;
                    val.push(root.getValue());
                }
                else{
                    String cc = val.pop();
                    String aa = val.pop();
                    if(this.find(cc)){
                        Node a = new Node(null,null,aa); size++;
                        Node b = new Node(a,root,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else{
                        Node c = new Node(null,null,cc); size++;
                        Node b = new Node(root,c,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                }               
            }                
            else{
                  int j = i+1;
                  String wa = infix.substring(j, j+1);
                  while(this.find(wa)!=true){
                      j++;
                      wa = infix.substring(j, j+1);
                  }
                  wa = infix.substring(i, j);
                  i = j-1;
                  val.push(wa);
                    }
        }
        return root;
    }

    public Node[] PrintPrefix(){
         if(root ==null) throw new NullPointerException();
         
        Node[] prefix = new Node[size];
        this.pre(root, prefix, 0);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root ==null) throw new NullPointerException();
        
        Node[] postfix = new Node[size];
        this.post(root, postfix, 0);       
        return postfix;
    }
    
    public double Evaluation(){
        double answer ;
        Node[] po = this.PrintPostfix();
        Stack<Double> ans = new Stack<>();
        for(int i = 0;i<size;i++){
            if(po[i].getValue().equals(""+"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a+b);
            }
            else  if(po[i].getValue().equals(""-"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a-b);
            }
            else  if(po[i].getValue().equals(""*"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a*b);
            }
            else  if(po[i].getValue().equals(""/"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a/b);
            }
            else{
                double a = Double.parseDouble(po[i].getValue());
                ans.push(a);
            }
        }
        answer = ans.pop();
        return answer;
    }
    
    public boolean find(String a){
        if(a.equals(""+"") || a.equals(""-"") || a.equals(""*"")
                || a.equals(""/"") || a.equals("")""))
        return true;
        else return false;
    }
    
   public int getsize(){
       return size;
   }
   public int pre(Node a, Node[] b, int i){
       b[i] = a;
       i++;
       if(a.getLeft()!=null)
           i = this.pre(a.getLeft(), b, i);
       if(a.getRight()!=null)
           i = this.pre(a.getRight(), b, i);
       return i;
   }
   public int post(Node a, Node[] b, int i){
        if(a.getLeft()!=null)
          i =this.post(a.getLeft(), b, i);          
        if(a.getRight()!=null)
          i =this.post(a.getRight(), b, i);           
       b[i] = a;
       i++;          
      return i;
   }
}

@99974168ca04cd1bfa857dce3c5984c6@"
"b03611023","6","0.98","105872","@4537c185df32ce535ead3f076490840d@public class Expression{
  
    private Node root;
    private int size;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        
        int len = infix.length();
        Stack<String> ops = new Stack<>();
        Stack<String> val = new Stack<>();
        root = null;
        for(int i = 0;i<len;i++){
            
            String temp = infix.substring(i, i+1);
            if(temp.equals(""("")) ;
            else if(temp.equals(""+"")) ops.push(temp);
            else if(temp.equals(""-"")) ops.push(temp);
            else if(temp.equals(""*"")) ops.push(temp);
            else if(temp.equals(""/"")) ops.push(temp);
           
            else if(temp.equals("")"")) {
                if(ops.isEmpty()){
                    if(val.isEmpty()){
                        root = null;
                        break;
                    }
            String cc = val.pop();
            Node b = new Node(null,null, cc);
            root = b;
            size = 1;
            break;        
                }
                String op = ops.pop();
                if(root==null){
                    Node c = new Node(null,null,val.pop()); size++;
                    Node a = new Node(null,null,val.pop()); size++;
                    Node b = new Node(a,c,op);  
                    size++;
                    root = b;
                    val.push(root.getValue());
                }
                else{
                    String cc = val.pop();
                    String aa = val.pop();
                    if(this.find(cc)){
                        Node a = new Node(null,null,aa); size++;
                        Node b = new Node(a,root,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else{
                        Node c = new Node(null,null,cc); size++;
                        Node b = new Node(root,c,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                }               
            }                
            else{
                  int j = i+1;
                  String wa = infix.substring(j, j+1);
                  while(this.find(wa)!=true){
                      j++;
                      wa = infix.substring(j, j+1);
                  }
                  wa = infix.substring(i, j);
                  i = j-1;
                  val.push(wa);
                    }
        }
       
        return root;
    }

    public Node[] PrintPrefix(){
         if(root ==null) throw new NullPointerException();
         
        Node[] prefix = new Node[size];
        this.pre(root, prefix, 0);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root ==null) throw new NullPointerException();
        
        Node[] postfix = new Node[size];
        this.post(root, postfix, 0);       
        return postfix;
    }
    
    public double Evaluation(){
         if(root ==null) throw new NullPointerException();
        double answer ;
        Node[] po = this.PrintPostfix();
        Stack<Double> ans = new Stack<>();
        for(int i = 0;i<size;i++){
            if(po[i].getValue().equals(""+"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a+b);
            }
            else  if(po[i].getValue().equals(""-"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a-b);
            }
            else  if(po[i].getValue().equals(""*"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a*b);
            }
            else  if(po[i].getValue().equals(""/"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a/b);
            }
            else{
                double a = Double.parseDouble(po[i].getValue());
                ans.push(a);
            }
        }
        answer = ans.pop();
        return answer;
    }
    
    public boolean find(String a){
        if(a.equals(""+"") || a.equals(""-"") || a.equals(""*"")
                || a.equals(""/"") || a.equals("")""))
        return true;
        else return false;
    }
    
   public int getsize(){
       return size;
   }
   public int pre(Node a, Node[] b, int i){
       b[i] = a;
       i++;
       if(a.getLeft()!=null)
           i = this.pre(a.getLeft(), b, i);
       if(a.getRight()!=null)
           i = this.pre(a.getRight(), b, i);
       return i;
   }
   public int post(Node a, Node[] b, int i){
        if(a.getLeft()!=null)
          i =this.post(a.getLeft(), b, i);          
        if(a.getRight()!=null)
          i =this.post(a.getRight(), b, i);           
       b[i] = a;
       i++;          
      return i;
   }
}

@4537c185df32ce535ead3f076490840d@"
"b03611023","10","0.098","105904","@1ff7397c528a41543fd476831ae21f2f@public class Expression{
  
    private Node root;
    private int size;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        
        int len = infix.length();
        Stack<String> ops = new Stack<>();
        Stack<String> val = new Stack<>();
        Stack<Node> im = new Stack<>();
        root = null;
        for(int i = 0;i<len;i++){
            
            String temp = infix.substring(i, i+1);
            if(temp.equals(""("")) ;
            else if(temp.equals(""+"")) ops.push(temp);
            else if(temp.equals(""-"")) ops.push(temp);
            else if(temp.equals(""*"")) ops.push(temp);
            else if(temp.equals(""/"")) ops.push(temp);
           
            else if(temp.equals("")"")) {
                if(ops.isEmpty()){
                    if(val.isEmpty()){
                        root = null;
                        break;
                    }
                 String cc = val.pop();
                 Node b = new Node(null,null, cc);
                 root = b;
                 size = 1;
                 break;        
                }
                String op = ops.pop();
                if(root==null){
                    Node c = new Node(null,null,val.pop()); size++;
                    Node a = new Node(null,null,val.pop()); size++;
                    Node b = new Node(a,c,op);  
                    size++;
                    root = b;
                    val.push(root.getValue());
                }
                else{
                    String cc = val.pop();
                    String aa = val.pop();
                    if(this.find(aa)==true && this.find(cc)==true){
                        root.setValue(op);
                        val.push(root.getValue());
                    }
                    else if(this.find(cc)){
                        Node a = new Node(null,null,aa); size++;
                        Node b = new Node(a,root,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else if(this.find(aa)){
                        Node c = new Node(null,null,cc); size++;
                        Node b = new Node(root,c,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else{
                       Node c = new Node(null,null,cc); size++;
                       Node a = new Node(null,null,aa); size++;
                       Node b = new Node(a,c,op); size++;
                       val.push(b.getValue());
                       Node d = new Node(root,b,null); size++;
                       root = d;
                    }
                }               
            }                
            else{
                  int j = i+1;
                  String wa = infix.substring(j, j+1);
                  while(this.find(wa)!=true){
                      j++;
                      wa = infix.substring(j, j+1);
                  }
                  wa = infix.substring(i, j);
                  i = j-1;
                  val.push(wa);
                    }
        }
       
        return root;
    }

    public Node[] PrintPrefix(){
         if(root ==null) throw new NullPointerException();
         
        Node[] prefix = new Node[size];
        this.pre(root, prefix, 0);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root ==null) throw new NullPointerException();
        
        Node[] postfix = new Node[size];
        this.post(root, postfix, 0);       
        return postfix;
    }
    
    public double Evaluation(){
         if(root ==null) throw new NullPointerException();
        double answer ;
        Node[] po = this.PrintPostfix();
        Stack<Double> ans = new Stack<>();
        for(int i = 0;i<size;i++){
            if(po[i].getValue().equals(""+"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a+b);
            }
            else  if(po[i].getValue().equals(""-"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a-b);
            }
            else  if(po[i].getValue().equals(""*"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a*b);
            }
            else  if(po[i].getValue().equals(""/"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a/b);
            }
            else{
                double a = Double.parseDouble(po[i].getValue());
                ans.push(a);
            }
        }
        answer = ans.pop();
        return answer;
    }
    
    public boolean find(String a){
        if(a.equals(""+"") || a.equals(""-"") || a.equals(""*"")
                || a.equals(""/"") || a.equals("")""))
        return true;
        else return false;
    }
    
   public int getsize(){
       return size;
   }
   public int pre(Node a, Node[] b, int i){
       b[i] = a;
       i++;
       if(a.getLeft()!=null)
           i = this.pre(a.getLeft(), b, i);
       if(a.getRight()!=null)
           i = this.pre(a.getRight(), b, i);
       return i;
   }
   public int post(Node a, Node[] b, int i){
        if(a.getLeft()!=null)
          i =this.post(a.getLeft(), b, i);          
        if(a.getRight()!=null)
          i =this.post(a.getRight(), b, i);           
       b[i] = a;
       i++;          
      return i;
   }
}

@1ff7397c528a41543fd476831ae21f2f@"
"r03525008","10","0.094","105584","@1d02748cfa6b144461e19637927aa011@import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){

        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String num = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char c = infix.charAt(i);
            switch (c){
                case '(':
                    num = """";
                    break;
                case '+':
                case '-':
                case '*':
                case '/':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    ops.push(new Node(null , null , c + """"));
                    break;
                case ')':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    Node op = ops.pop();
                    Node val2 = vals.pop();
                    Node val1 = vals.pop();
                    op.setLeft(val1);
                    op.setRight(val2);
                    root = op;
                    vals.push(op);
                    break;
                default:
                    num += c;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPrefixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPrefixHelper(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        PrintPrefixHelper(list, root.getLeft());
        PrintPrefixHelper(list , root.getRight());
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPostfixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPostfixHelper(List<Node> list, Node root){
        if (root == null) return;
        PrintPostfixHelper(list, root.getLeft());
        PrintPostfixHelper(list, root.getRight());
        list.add(root);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        return EvaluationHelper(root);
    }

    private double EvaluationHelper(Node root){
        switch (root.getValue()) {
            case ""+"":
                return EvaluationHelper(root.getLeft()) + EvaluationHelper(root.getRight());
            case ""-"":
                return EvaluationHelper(root.getLeft()) - EvaluationHelper(root.getRight());
            case ""*"":
                return EvaluationHelper(root.getLeft()) * EvaluationHelper(root.getRight());
            case ""/"":
                return EvaluationHelper(root.getLeft()) / EvaluationHelper(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }
    }

    public double Evaluation_NonRecursive(){
        if(root == null) throw new NullPointerException();
        Node[] nodes =  this.PrintPostfix();
        Stack<Double> values = new Stack<Double>();
        for (Node node:nodes) {
            String str = node.getValue();
            switch (str) {
                case ""+"":
                    values.push(values.pop() + values.pop());
                    break;
                case ""-"":
                    values.push(-values.pop() + values.pop());
                    break;
                case ""*"":
                    values.push(values.pop() * values.pop());
                    break;
                case ""/"":
                    values.push(1 / values.pop() * values.pop());
                    break;
                default:
                    values.push(Double.parseDouble(str));
                    break;
            }
        }
        return values.pop();
    }

}
@1d02748cfa6b144461e19637927aa011@"
"r04921044","5","0.98","105856","@529377222eae2a9fce3f22f40c065479@
import java.util.*;

public class Expression{

    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String postfix = Infix2Postfix(infix);
        String[] operands = postfix.split("" "");

        Stack<Node> nodes = new Stack<> ();

        for (int i=1; i<operands.length; ++i) {
            String operand = operands[i];
            if (operand.charAt(0) >= '0' && operand.charAt(0) <= '9') {
                Node node = new Node(null, null, operand);
                nodes.push(node);
            }
            else {
                Node right = nodes.pop();
                Node left = nodes.pop();
                Node node = new Node(left, right, operand);
                nodes.push(node);
            }
        }

        root = nodes.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        return printPrefix(root);
    }

    private Node[] printPrefix(Node node) {
        // mid, left, right
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPrefix(node.getLeft());
        Node[] rightNodes = printPrefix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        result[0] = node;
        System.arraycopy(leftNodes, 0, result, 1, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length+1, rightNodes.length);

        return result;
    }

    public Node[] PrintPostfix(){
        return printPostfix(root);
    }

    private Node[] printPostfix(Node node) {
        // left, right, mid
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPostfix(node.getLeft());
        Node[] rightNodes = printPostfix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        System.arraycopy(leftNodes, 0, result, 0, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length, rightNodes.length);
        result[leftNodes.length + rightNodes.length] = node;

        return result;
    }

    public double Evaluation(){
        double answer = 0;
        return answer;
    }

    private String Infix2Postfix(String infix) {
        // infix to postfix
        Stack<Character> stack = new Stack<> ();
        String postfix = """";
        for (int i=0; i<infix.length(); ++i) {
            char c = infix.charAt(i);
            switch (c) {
                case '(':
                    stack.push(c);
                    break;

                case ')':
                    while (stack.peek() != '(') {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    // top-- ???
                    stack.pop();
                    break;

                case '+':
                case '-':
                case '*':
                case '/':
                    while (priority(stack.peek()) > priority(c)) {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    stack.push(c);
                    break;

                default:
                    if (i==0 || !(infix.charAt(i-1)>='0' && infix.charAt(i-1)<='9')) {
                        postfix += ' ';
                    }
                    postfix += c;
                    break;
            }
        }

        return postfix;
    }

    private int priority (char operand) {
        switch(operand) {
            case '+':
            case '-':
                return 1;

            case '*':
            case '/':
                return 2;

            default:
                return 0;
        }
    }
}

@529377222eae2a9fce3f22f40c065479@"
"r04921044","7","0.98","105936","@4b38f284b357c4942f3c77d8ddb48197@
import java.util.*;

public class Expression{

    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String postfix = Infix2Postfix(infix);
        String[] operands = postfix.split("" "");

        Stack<Node> nodes = new Stack<> ();

        for (int i=1; i<operands.length; ++i) {
            String operand = operands[i];
            if (operand.charAt(0) >= '0' && operand.charAt(0) <= '9') {
                Node node = new Node(null, null, operand);
                nodes.push(node);
            }
            else {
                Node right = nodes.pop();
                Node left = nodes.pop();
                Node node = new Node(left, right, operand);
                nodes.push(node);
            }
        }

        root = nodes.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        return printPrefix(root);
    }

    private Node[] printPrefix(Node node) {
        // mid, left, right
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPrefix(node.getLeft());
        Node[] rightNodes = printPrefix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        result[0] = node;
        System.arraycopy(leftNodes, 0, result, 1, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length+1, rightNodes.length);

        return result;
    }

    public Node[] PrintPostfix(){
        return printPostfix(root);
    }

    private Node[] printPostfix(Node node) {
        // left, right, mid
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPostfix(node.getLeft());
        Node[] rightNodes = printPostfix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        System.arraycopy(leftNodes, 0, result, 0, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length, rightNodes.length);
        result[leftNodes.length + rightNodes.length] = node;

        return result;
    }

    public double Evaluation(){
        return evaluation(root);
    }

    private double evaluation(Node node) {
        String value = node.getValue();
        if (value.charAt(0) == '+' ||
            value.charAt(0) == '-' ||
            value.charAt(0) == '*' ||
            value.charAt(0) == '/') {
            double left = evaluation(node.getLeft());
            double right = evaluation(node.getRight());
            switch (value.charAt(0)) {
                case '+':
                    return left + right;
                case '-':
                    return left - right;
                case '*':
                    return left * right;
                case '/':
                    return left / right;
                default:
                    return 0;
            }
        }
        else {
            return Double.parseDouble(node.getValue());
        }
    }

    private String Infix2Postfix(String infix) {
        // infix to postfix
        Stack<Character> stack = new Stack<> ();
        String postfix = """";
        for (int i=0; i<infix.length(); ++i) {
            char c = infix.charAt(i);
            switch (c) {
                case '(':
                    stack.push(c);
                    break;

                case ')':
                    while (stack.peek() != '(') {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    stack.pop();
                    break;

                case '+':
                case '-':
                case '*':
                case '/':
                    while (priority(stack.peek()) > priority(c)) {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    stack.push(c);
                    break;

                default:
                    if (i==0 || !(infix.charAt(i-1)>='0' && infix.charAt(i-1)<='9')) {
                        postfix += ' ';
                    }
                    postfix += c;
                    break;
            }
        }

        return postfix;
    }

    private int priority (char operand) {
        switch(operand) {
            case '+':
            case '-':
                return 1;

            case '*':
            case '/':
                return 2;

            default:
                return 0;
        }
    }
}

@4b38f284b357c4942f3c77d8ddb48197@"
"r04921051","10","0.097","105856","@3963982cb4d27dd422e2e8c31e3575b7@import java.util.ArrayList;
import java.util.List;

public class Expression{
         
    private Node root;
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    
        Stack<Node> ops = new Stack<>();        
        Stack<Node> vals = new Stack<>();    
        
        boolean flag = false;
        for(int i =0;i < infix.length();i++) {
        String s = infix.substring(i, i+1);
        switch(s) {
            case ""("":
                flag = true;
                break;
            case ""+"" : case ""-"" : case ""*"" : case ""/"" :
                flag = true;
                ops.push(new Node(null,null,s));
                break;
            case "")"":
                flag = true;
                if(!ops.isEmpty()){
                   Node op = ops.pop();
                   op.setRight(vals.pop());
                   op.setLeft(vals.pop());
                   vals.push(op);
                }
                break;
            default:
                if(flag)
                vals.push(new Node(null,null,s));                
                else{
                Node temp = vals.pop();
                temp.setValue(temp.getValue()+s);
                vals.push(temp);
                }
                flag = false;
        }}       
        root = vals.pop();         
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> p;
        p = new ArrayList<>();
        getPrefix(p,root);
        return p.toArray(new Node[p.size()]);
    }

    public void getPrefix(List<Node> out,Node pf){
        if(pf == null) return;    
        out.add(pf);
        getPrefix(out,pf.getLeft());
        getPrefix(out,pf.getRight());       
    }      
      
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();        
        List<Node> p;
        p = new ArrayList<>();
        getPostfix(p,root);
        return p.toArray(new Node[p.size()]);
    }
    
    public void getPostfix(List<Node> out,Node pf){
        if(pf == null) return;          
        getPostfix(out,pf.getLeft());
        getPostfix(out,pf.getRight());    
        out.add(pf);
    }          

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        return getEvaluation(root);
    }
    
    public double getEvaluation(Node pf){
        switch(pf.getValue()){
            case ""+"":
                return getEvaluation(pf.getLeft()) + getEvaluation(pf.getRight());
            case ""-"":
                return getEvaluation(pf.getLeft()) - getEvaluation(pf.getRight());
            case ""*"":
                return getEvaluation(pf.getLeft()) * getEvaluation(pf.getRight());
            case ""/"":
                return getEvaluation(pf.getLeft()) / getEvaluation(pf.getRight());
            default:
                return Double.parseDouble(pf.getValue());
        }
    }      
}

@3963982cb4d27dd422e2e8c31e3575b7@"
"r04921044","0","0.98","105856","@8351bbb9e56407784828c0a51b25ed86@
import java.util.*;

public class Expression{

    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String postfix = Infix2Postfix(infix);
        String[] operands = postfix.split("" "");

        Stack<Node> nodes = new Stack<> ();

        for (int i=1; i<operands.length; ++i) {
            String operand = operands[i];
            if (operand.charAt(0) >= '0' && operand.charAt(0) <= '9') {
                Node node = new Node(null, null, operand);
                nodes.push(node);
            }
            else {
                Node right = nodes.pop();
                Node left = nodes.pop();
                Node node = new Node(left, right, operand);
                nodes.push(node);
            }
        }

        root = null;
        if (!nodes.empty()) {
            root = nodes.pop();
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if (root == null) {
            throw new NullPointerException();
        }

        return printPrefix(root);
    }

    private Node[] printPrefix(Node node) {
        // mid, left, right
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPrefix(node.getLeft());
        Node[] rightNodes = printPrefix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        result[0] = node;
        System.arraycopy(leftNodes, 0, result, 1, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length+1, rightNodes.length);

        return result;
    }

    public Node[] PrintPostfix(){
        if (root == null) {
            throw new NullPointerException();
        }

        return printPostfix(root);
    }

    private Node[] printPostfix(Node node) {
        // left, right, mid
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPostfix(node.getLeft());
        Node[] rightNodes = printPostfix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        System.arraycopy(leftNodes, 0, result, 0, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length, rightNodes.length);
        result[leftNodes.length + rightNodes.length] = node;

        return result;
    }

    public double Evaluation(){
        if (root == null) {
            throw new NullPointerException();
        }

        return evaluation(root);
    }

    private double evaluation(Node node) {
        String value = node.getValue();
        if (value.charAt(0) == '+' ||
            value.charAt(0) == '-' ||
            value.charAt(0) == '*' ||
            value.charAt(0) == '/') {
            double left = evaluation(node.getLeft());
            double right = evaluation(node.getRight());
            switch (value.charAt(0)) {
                case '+':
                    return left + right;
                case '-':
                    return left - right;
                case '*':
                    return left * right;
                case '/':
                    return left / right;
                default:
                    return 0;
            }
        }
        else {
            return Double.parseDouble(node.getValue());
        }
    }

    private String Infix2Postfix(String infix) {
        // infix to postfix
        Stack<Character> stack = new Stack<> ();
        String postfix = """";
        for (int i=0; i<infix.length(); ++i) {
            char c = infix.charAt(i);
            switch (c) {
                case '(':
                    stack.push(c);
                    break;

                case ')':
                    while (stack.peek() != '(') {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    if (!stack.empty()) {
                        stack.pop();
                    }
                    break;

                case '+':
                case '-':
                case '*':
                case '/':
                    while (priority(stack.peek()) > priority(c)) {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    stack.push(c);
                    break;

                default:
                    if (i==0 || !((infix.charAt(i-1)>='0' && infix.charAt(i-1)<='9') || infix.charAt(i-1)=='.')) {
                        postfix += ' ';
                    }
                    postfix += c;
                    break;
            }
        }

        System.out.println(postfix);

        return postfix;
    }

    private int priority (char operand) {
        switch(operand) {
            case '+':
            case '-':
                return 1;

            case '*':
            case '/':
                return 2;

            default:
                return 0;
        }
    }
}

@8351bbb9e56407784828c0a51b25ed86@"
"r04921044","1","0.99","105536","@fd39b92ad7ccd7f5aca8b2b796e14a0f@
import java.util.*;

public class Expression{

    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String postfix = Infix2Postfix(infix);
        String[] operands = postfix.split("" "");

        java.util.Stack<Node> nodes = new java.util.Stack<> ();

        for (int i=1; i<operands.length; ++i) {
            String operand = operands[i];
            if (operand.charAt(0) >= '0' && operand.charAt(0) <= '9') {
                Node node = new Node(null, null, operand);
                nodes.push(node);
            }
            else {
                Node right = nodes.pop();
                Node left = nodes.pop();
                Node node = new Node(left, right, operand);
                nodes.push(node);
            }
        }

        root = null;
        if (!nodes.empty()) {
            root = nodes.pop();
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if (root == null) {
            throw new NullPointerException();
        }

        return printPrefix(root);
    }

    private Node[] printPrefix(Node node) {
        // mid, left, right
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPrefix(node.getLeft());
        Node[] rightNodes = printPrefix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        result[0] = node;
        System.arraycopy(leftNodes, 0, result, 1, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length+1, rightNodes.length);

        return result;
    }

    public Node[] PrintPostfix(){
        if (root == null) {
            throw new NullPointerException();
        }

        return printPostfix(root);
    }

    private Node[] printPostfix(Node node) {
        // left, right, mid
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPostfix(node.getLeft());
        Node[] rightNodes = printPostfix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        System.arraycopy(leftNodes, 0, result, 0, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length, rightNodes.length);
        result[leftNodes.length + rightNodes.length] = node;

        return result;
    }

    public double Evaluation(){
        if (root == null) {
            throw new NullPointerException();
        }

        return evaluation(root);
    }

    private double evaluation(Node node) {
        String value = node.getValue();
        if (value.charAt(0) == '+' ||
            value.charAt(0) == '-' ||
            value.charAt(0) == '*' ||
            value.charAt(0) == '/') {
            double left = evaluation(node.getLeft());
            double right = evaluation(node.getRight());
            switch (value.charAt(0)) {
                case '+':
                    return left + right;
                case '-':
                    return left - right;
                case '*':
                    return left * right;
                case '/':
                    return left / right;
                default:
                    return 0;
            }
        }
        else {
            return Double.parseDouble(node.getValue());
        }
    }

    private String Infix2Postfix(String infix) {
        // infix to postfix
        java.util.Stack<Character> stack = new java.util.Stack<> ();
        String postfix = """";
        for (int i=0; i<infix.length(); ++i) {
            char c = infix.charAt(i);
            switch (c) {
                case '(':
                    stack.push(c);
                    break;

                case ')':
                    while (stack.peek() != '(') {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    if (!stack.empty()) {
                        stack.pop();
                    }
                    break;

                case '+':
                case '-':
                case '*':
                case '/':
                    while (priority(stack.peek()) > priority(c)) {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    stack.push(c);
                    break;

                default:
                    if (i==0 || !((infix.charAt(i-1)>='0' && infix.charAt(i-1)<='9') || infix.charAt(i-1)=='.')) {
                        postfix += ' ';
                    }
                    postfix += c;
                    break;
            }
        }

        System.out.println(postfix);

        return postfix;
    }

    private int priority (char operand) {
        switch(operand) {
            case '+':
            case '-':
                return 1;

            case '*':
            case '/':
                return 2;

            default:
                return 0;
        }
    }
}

@fd39b92ad7ccd7f5aca8b2b796e14a0f@"
"r04921044","10","0.099","105536","@cddbf0cbb95d4ab3dd97f91809ca41aa@
import java.util.*;

public class Expression{

    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String postfix = Infix2Postfix(infix);
        String[] operands = postfix.split("" "");

        java.util.Stack<Node> nodes = new java.util.Stack<> ();

        for (int i=1; i<operands.length; ++i) {
            String operand = operands[i];
            if (operand.charAt(0) >= '0' && operand.charAt(0) <= '9') {
                Node node = new Node(null, null, operand);
                nodes.push(node);
            }
            else {
                Node right = nodes.pop();
                Node left = nodes.pop();
                Node node = new Node(left, right, operand);
                nodes.push(node);
            }
        }

        root = null;
        if (!nodes.empty()) {
            root = nodes.pop();
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if (root == null) {
            throw new NullPointerException();
        }

        return printPrefix(root);
    }

    private Node[] printPrefix(Node node) {
        // mid, left, right
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPrefix(node.getLeft());
        Node[] rightNodes = printPrefix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        result[0] = node;
        System.arraycopy(leftNodes, 0, result, 1, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length+1, rightNodes.length);

        return result;
    }

    public Node[] PrintPostfix(){
        if (root == null) {
            throw new NullPointerException();
        }

        return printPostfix(root);
    }

    private Node[] printPostfix(Node node) {
        // left, right, mid
        if (node == null) {
            return new Node[0];
        }

        Node[] leftNodes = printPostfix(node.getLeft());
        Node[] rightNodes = printPostfix(node.getRight());
        Node[] result = new Node[leftNodes.length + rightNodes.length + 1];
        System.arraycopy(leftNodes, 0, result, 0, leftNodes.length);
        System.arraycopy(rightNodes, 0, result, leftNodes.length, rightNodes.length);
        result[leftNodes.length + rightNodes.length] = node;

        return result;
    }

    public double Evaluation(){
        if (root == null) {
            throw new NullPointerException();
        }

        return evaluation(root);
    }

    private double evaluation(Node node) {
        String value = node.getValue();
        if (value.charAt(0) == '+' ||
            value.charAt(0) == '-' ||
            value.charAt(0) == '*' ||
            value.charAt(0) == '/') {
            double left = evaluation(node.getLeft());
            double right = evaluation(node.getRight());
            switch (value.charAt(0)) {
                case '+':
                    return left + right;
                case '-':
                    return left - right;
                case '*':
                    return left * right;
                case '/':
                    return left / right;
                default:
                    return 0;
            }
        }
        else {
            return Double.parseDouble(node.getValue());
        }
    }

    private String Infix2Postfix(String infix) {
        // infix to postfix
        java.util.Stack<Character> stack = new java.util.Stack<> ();
        String postfix = """";
        for (int i=0; i<infix.length(); ++i) {
            char c = infix.charAt(i);
            switch (c) {
                case '(':
                    stack.push(c);
                    break;

                case ')':
                    while (stack.peek() != '(') {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    if (!stack.empty()) {
                        stack.pop();
                    }
                    break;

                case '+':
                case '-':
                case '*':
                case '/':
                    while (priority(stack.peek()) > priority(c)) {
                        postfix += ' ';
                        postfix += stack.pop();
                    }
                    stack.push(c);
                    break;

                default:
                    if (i==0 || !((infix.charAt(i-1)>='0' && infix.charAt(i-1)<='9') || infix.charAt(i-1)=='.')) {
                        postfix += ' ';
                    }
                    postfix += c;
                    break;
            }
        }

        return postfix;
    }

    private int priority (char operand) {
        switch(operand) {
            case '+':
            case '-':
                return 1;

            case '*':
            case '/':
                return 2;

            default:
                return 0;
        }
    }
}

@cddbf0cbb95d4ab3dd97f91809ca41aa@"
"r03723070","2","0.29","105408","@12d4c94bba5d471078d5c94b62a26191@public class Expression{
  
    private Node root;
    Stack<String> calculator = new Stack<String>();
    Stack<Node> stack = new Stack<Node>();
    Queue<Node> queue = new Queue<Node>();
    public double ans;
   
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //store the string in que
         String ans = new String();
        
        for (String i : infix.split("""")){
           // StdOut.println(""QQQQ"");
            Node a = new Node(null,null,i);
            queue.enqueue(a); 
            //StdOut.println(i);
        }
        
        queue.dequeue();
        Node [] arr = new Node[2];
        //int count = 0;
        Node operator = new Node(null,null,null);
        //calculator.push(""1"");
        while(!queue.isEmpty()){
            Node b = queue.dequeue();
            if(!b.getValue().equals(""("")){
                if(!b.getValue().equals("")"")){
                calculator.push(b.getValue());
                stack.push(b);  
                }

                if(b.getValue().equals("")"")){
                    arr[1] = stack.pop();
                    operator = stack.pop();
                    arr[0] = stack.pop();
                    
                    operator.setLeft(arr[0]);
                    operator.setRight(arr[1]);
                    stack.push(operator);
                    //2.calculate
                    double innersum = 0 ;
                    double two = Double.parseDouble(calculator.pop());
                    //StdOut.println(two);
                    String op = calculator.pop();
                    //StdOut.println(op);
                    double one = Double.parseDouble(calculator.pop());
                    //StdOut.println(one);
                    if(op.equals(""+"")) innersum = one+two;
                    else if(op.equals(""-"")) innersum = one-two;
                    else if(op.equals(""/"")) innersum = one/two;
                    else if(op.equals(""*"")) innersum = one*two;
                    String cal = Double.toString(innersum);
                    calculator.push(cal);
                    ans = cal;
                    //StdOut.println(ans);
                }
            }
        }
        //ans = cal;
        root = operator;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        return postfix;
    }
    public double Evaluation(){
        ans = Double.parseDouble(Evaluation(root));
        return ans;
    }

    public String Evaluation(Node x){
        

        double inner = 0;
        //Stack<Double> innersum = new Stack<>();
        Stack<String> innersum = new Stack<>();
        String ans_end = x.getValue();
        //inner = x.getLeft();
        //double innersum ;
        //innersum = Double.parseDouble(x.getLeft().getValue());
        //double two = Double.parseDouble(calculator.pop());
        //if(null==x.getValue()) return null;
        if(x.getLeft()!=null) {
            //StdOut.println(""QQQ"");
            ans_end = Evaluation(x.getLeft());
            innersum.push(ans_end);
            //StdOut.printf(""ans_end is %s\n"",innersum.pop());
            //StdOut.printf(""ans_end is %s\n"",ans_end);
        }
        if(x.getRight()!=null){ 
            //StdOut.println(""RRR"");
            //x = x.getRight();
            ans_end = Evaluation(x.getRight());
            innersum.push(ans_end);
        } //x = Evaluation(x.getRight());
        
        //
        if(x.getRight()!=null && x.getLeft()!=null){
            //StdOut.println(""PPPP"");
            ans_end =  x.getValue();
            double two = Double.parseDouble(innersum.pop());
            double one = Double.parseDouble(innersum.pop());
                
                if(ans_end.equals(""+"")) inner = one+two;
                else if(ans_end.equals(""-"")) inner = one-two;
                else if(ans_end.equals(""/"")) inner = one/two;
                else if(ans_end.equals(""*"")) inner = one*two;
                
                ans_end = Double.toString(inner);
                //innersum.push(cal);
        }
        //innersum.push(ans_end);
        return ans_end;
    }
    
    
}
@12d4c94bba5d471078d5c94b62a26191@"
"r03723070","3","0.58","105888","@e075313dbcd9945361731488a69cc945@public class Expression{
  
    private Node root;
    Stack<String> calculator = new Stack<String>();
    Stack<Node> stack = new Stack<Node>();
    Queue<Node> queue = new Queue<Node>();
    public double ans;
   
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //store the string in que
         String ans = new String();
        
        for (String i : infix.split("""")){
           // StdOut.println(""QQQQ"");
            Node a = new Node(null,null,i);
            queue.enqueue(a); 
            //StdOut.println(i);
        }
        
        queue.dequeue();
        Node [] arr = new Node[2];
        //int count = 0;
        Node operator = new Node(null,null,null);
        //calculator.push(""1"");
        while(!queue.isEmpty()){
            Node b = queue.dequeue();
            if(!b.getValue().equals(""("")){
                if(!b.getValue().equals("")"")){
                calculator.push(b.getValue());
                stack.push(b);  
                }

                if(b.getValue().equals("")"")){
                    arr[1] = stack.pop();
                    operator = stack.pop();
                    arr[0] = stack.pop();
                    
                    operator.setLeft(arr[0]);
                    operator.setRight(arr[1]);
                    stack.push(operator);
                    //2.calculate
                    double innersum = 0 ;
                    double two = Double.parseDouble(calculator.pop());
                    //StdOut.println(two);
                    String op = calculator.pop();
                    //StdOut.println(op);
                    double one = Double.parseDouble(calculator.pop());
                    //StdOut.println(one);
                    if(op.equals(""+"")) innersum = one+two;
                    else if(op.equals(""-"")) innersum = one-two;
                    else if(op.equals(""/"")) innersum = one/two;
                    else if(op.equals(""*"")) innersum = one*two;
                    String cal = Double.toString(innersum);
                    calculator.push(cal);
                    ans = cal;
                    //StdOut.println(ans);
                }
            }
        }
        //ans = cal;
        root = operator;
        return root;
    }

public Node[] PrintPrefix(){
        
        Queue<Node> print_prefix = PrintPrefix(root);
        Node[] prefix = new Node [print_prefix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_prefix.isEmpty()){
            prefix[i] = print_prefix.dequeue();
            i++;
        }
        return prefix;
        //List<Integer> myList = new ArrayList<Integer>()
    }
    public Queue<Node> PrintPrefix(Node x){
        Queue<Node> print_prefix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            print_prefix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPrefix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_prefix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPrefix(x.getRight());
                while(!temp2.isEmpty()){
                    print_prefix.enqueue(temp2.dequeue());
                            }
            }
            return print_prefix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }
  
    
    
    
    
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        return postfix;
    }
    public double Evaluation(){
        ans = Double.parseDouble(Evaluation(root));
        return ans;
    }

    public String Evaluation(Node x){
        

        double inner = 0;
        //Stack<Double> innersum = new Stack<>();
        Stack<String> innersum = new Stack<>();
        String ans_end = x.getValue();
        //inner = x.getLeft();
        //double innersum ;
        //innersum = Double.parseDouble(x.getLeft().getValue());
        //double two = Double.parseDouble(calculator.pop());
        //if(null==x.getValue()) return null;
        if(x.getLeft()!=null) {
            //StdOut.println(""QQQ"");
            ans_end = Evaluation(x.getLeft());
            innersum.push(ans_end);
            //StdOut.printf(""ans_end is %s\n"",innersum.pop());
            //StdOut.printf(""ans_end is %s\n"",ans_end);
        }
        if(x.getRight()!=null){ 
            //StdOut.println(""RRR"");
            //x = x.getRight();
            ans_end = Evaluation(x.getRight());
            innersum.push(ans_end);
        } //x = Evaluation(x.getRight());
        
        //
        if(x.getRight()!=null && x.getLeft()!=null){
            //StdOut.println(""PPPP"");
            ans_end =  x.getValue();
            double two = Double.parseDouble(innersum.pop());
            double one = Double.parseDouble(innersum.pop());
                
                if(ans_end.equals(""+"")) inner = one+two;
                else if(ans_end.equals(""-"")) inner = one-two;
                else if(ans_end.equals(""/"")) inner = one/two;
                else if(ans_end.equals(""*"")) inner = one*two;
                
                ans_end = Double.toString(inner);
                //innersum.push(cal);
        }
        //innersum.push(ans_end);
        return ans_end;
    }
    
    
}

@e075313dbcd9945361731488a69cc945@"
"r03723070","6","1.01","105952","@7591cc0c71f38490a81bf55a6f7b6a78@public class Expression{
  
    private Node root;
    Stack<String> calculator = new Stack<String>();
    Stack<Node> stack = new Stack<Node>();
    Queue<Node> queue = new Queue<Node>();
    public double ans;
   
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //store the string in que
         String ans = new String();
        
        for (String i : infix.split("""")){
           // StdOut.println(""QQQQ"");
            Node a = new Node(null,null,i);
            queue.enqueue(a); 
            //StdOut.println(i);
        }
        
        queue.dequeue();
        Node [] arr = new Node[2];
        //int count = 0;
        Node operator = new Node(null,null,null);
        //calculator.push(""1"");
        while(!queue.isEmpty()){
            Node b = queue.dequeue();
            if(!b.getValue().equals(""("")){
                if(!b.getValue().equals("")"")){
                calculator.push(b.getValue());
                stack.push(b);  
                }

                if(b.getValue().equals("")"")){
                    arr[1] = stack.pop();
                    operator = stack.pop();
                    arr[0] = stack.pop();
                    
                    operator.setLeft(arr[0]);
                    operator.setRight(arr[1]);
                    stack.push(operator);
                    //2.calculate
                    double innersum = 0 ;
                    double two = Double.parseDouble(calculator.pop());
                    //StdOut.println(two);
                    String op = calculator.pop();
                    //StdOut.println(op);
                    double one = Double.parseDouble(calculator.pop());
                    //StdOut.println(one);
                    if(op.equals(""+"")) innersum = one+two;
                    else if(op.equals(""-"")) innersum = one-two;
                    else if(op.equals(""/"")) innersum = one/two;
                    else if(op.equals(""*"")) innersum = one*two;
                    String cal = Double.toString(innersum);
                    calculator.push(cal);
                    ans = cal;
                    //StdOut.println(ans);
                }
            }
        }
        //ans = cal;
        root = operator;
        return root;
    }

public Node[] PrintPrefix(){
        
        Queue<Node> print_prefix = PrintPrefix(root);
        Node[] prefix = new Node [print_prefix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_prefix.isEmpty()){
            prefix[i] = print_prefix.dequeue();
            i++;
        }
        return prefix;
        //List<Integer> myList = new ArrayList<Integer>()
    }
    public Queue<Node> PrintPrefix(Node x){
        Queue<Node> print_prefix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            print_prefix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPrefix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_prefix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPrefix(x.getRight());
                while(!temp2.isEmpty()){
                    print_prefix.enqueue(temp2.dequeue());
                            }
            }
            return print_prefix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }
  
public Node[] PrintPostfix(){
        
        Queue<Node> print_postfix = PrintPostfix(root);
        Node[] postfix = new Node [print_postfix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_postfix.isEmpty()){
            postfix[i] = print_postfix.dequeue();
            i++;
        }
        return postfix;
        //List<Integer> myList = new ArrayList<Integer>()
    }
    public Queue<Node> PrintPostfix(Node x){
        Queue<Node> print_postfix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            //print_postfix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPostfix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_postfix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPostfix(x.getRight());
                while(!temp2.isEmpty()){
                    print_postfix.enqueue(temp2.dequeue());
                            }
            }
            print_postfix.enqueue(x);
            return print_postfix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }    
    
    

    public double Evaluation(){
        ans = Double.parseDouble(Evaluation(root));
        return ans;
    }

    public String Evaluation(Node x){
        

        double inner = 0;
        //Stack<Double> innersum = new Stack<>();
        Stack<String> innersum = new Stack<>();
        String ans_end = x.getValue();
        //inner = x.getLeft();
        //double innersum ;
        //innersum = Double.parseDouble(x.getLeft().getValue());
        //double two = Double.parseDouble(calculator.pop());
        //if(null==x.getValue()) return null;
        if(x.getLeft()!=null) {
            //StdOut.println(""QQQ"");
            ans_end = Evaluation(x.getLeft());
            innersum.push(ans_end);
            //StdOut.printf(""ans_end is %s\n"",innersum.pop());
            //StdOut.printf(""ans_end is %s\n"",ans_end);
        }
        if(x.getRight()!=null){ 
            //StdOut.println(""RRR"");
            //x = x.getRight();
            ans_end = Evaluation(x.getRight());
            innersum.push(ans_end);
        } //x = Evaluation(x.getRight());
        
        //
        if(x.getRight()!=null && x.getLeft()!=null){
            //StdOut.println(""PPPP"");
            ans_end =  x.getValue();
            double two = Double.parseDouble(innersum.pop());
            double one = Double.parseDouble(innersum.pop());
                
                if(ans_end.equals(""+"")) inner = one+two;
                else if(ans_end.equals(""-"")) inner = one-two;
                else if(ans_end.equals(""/"")) inner = one/two;
                else if(ans_end.equals(""*"")) inner = one*two;
                
                ans_end = Double.toString(inner);
                //innersum.push(cal);
        }
        //innersum.push(ans_end);
        return ans_end;
    }
    
    
}

@7591cc0c71f38490a81bf55a6f7b6a78@"
"r03723070","6","0.99","105904","@c881e40bbb77cc5860e44b48258f9218@public class Expression{
  
    private Node root;
    Stack<String> calculator = new Stack<String>();
    Stack<Node> stack = new Stack<Node>();
    Queue<Node> queue = new Queue<Node>();
    public double ans;
   
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //store the string in que
         String ans = new String();
        
        for (String i : infix.split("""")){
           // StdOut.println(""QQQQ"");
            Node a = new Node(null,null,i);
            queue.enqueue(a); 
            //StdOut.println(i);
        }
        
        queue.dequeue();
        Node [] arr = new Node[2];
        //int count = 0;
        Node operator = new Node(null,null,null);
        //calculator.push(""1"");
        while(!queue.isEmpty()){
            Node b = queue.dequeue();
            if(!b.getValue().equals(""("")){
                if(!b.getValue().equals("")"")){
                calculator.push(b.getValue());
                stack.push(b);  
                }

                if(b.getValue().equals("")"")){
                    arr[1] = stack.pop();
                    operator = stack.pop();
                    arr[0] = stack.pop();
                    
                    operator.setLeft(arr[0]);
                    operator.setRight(arr[1]);
                    stack.push(operator);
                    //2.calculate
                    double innersum = 0 ;
                    double two = Double.parseDouble(calculator.pop());
                    //StdOut.println(two);
                    String op = calculator.pop();
                    //StdOut.println(op);
                    double one = Double.parseDouble(calculator.pop());
                    //StdOut.println(one);
                    if(op.equals(""+"")) innersum = one+two;
                    else if(op.equals(""-"")) innersum = one-two;
                    else if(op.equals(""/"")) innersum = one/two;
                    else if(op.equals(""*"")) innersum = one*two;
                    String cal = Double.toString(innersum);
                    calculator.push(cal);
                    ans = cal;
                    //StdOut.println(ans);
                }
            }
        }
        //ans = cal;
        root = operator;
        return root;
    }

public Node[] PrintPrefix(){
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_prefix = PrintPrefix(root);
        Node[] prefix = new Node [print_prefix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_prefix.isEmpty()){
            prefix[i] = print_prefix.dequeue();
            i++;
        }
        return prefix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPrefix(Node x){
        Queue<Node> print_prefix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            print_prefix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPrefix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_prefix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPrefix(x.getRight());
                while(!temp2.isEmpty()){
                    print_prefix.enqueue(temp2.dequeue());
                            }
            }
            return print_prefix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }
  
public Node[] PrintPostfix(){
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_postfix = PrintPostfix(root);
        Node[] postfix = new Node [print_postfix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_postfix.isEmpty()){
            postfix[i] = print_postfix.dequeue();
            i++;
        }
        return postfix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPostfix(Node x){
        Queue<Node> print_postfix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            //print_postfix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPostfix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_postfix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPostfix(x.getRight());
                while(!temp2.isEmpty()){
                    print_postfix.enqueue(temp2.dequeue());
                            }
            }
            print_postfix.enqueue(x);
            return print_postfix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }    
    
    

    public double Evaluation(){
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        ans = Double.parseDouble(Evaluation(root));
        return ans;
        }
    }

    public String Evaluation(Node x){
        

        double inner = 0;
        //Stack<Double> innersum = new Stack<>();
        Stack<String> innersum = new Stack<>();
        String ans_end = x.getValue();
        //inner = x.getLeft();
        //double innersum ;
        //innersum = Double.parseDouble(x.getLeft().getValue());
        //double two = Double.parseDouble(calculator.pop());
        //if(null==x.getValue()) return null;
        if(x.getLeft()!=null) {
            //StdOut.println(""QQQ"");
            ans_end = Evaluation(x.getLeft());
            innersum.push(ans_end);
            //StdOut.printf(""ans_end is %s\n"",innersum.pop());
            //StdOut.printf(""ans_end is %s\n"",ans_end);
        }
        if(x.getRight()!=null){ 
            //StdOut.println(""RRR"");
            //x = x.getRight();
            ans_end = Evaluation(x.getRight());
            innersum.push(ans_end);
        } //x = Evaluation(x.getRight());
        
        //
        if(x.getRight()!=null && x.getLeft()!=null){
            //StdOut.println(""PPPP"");
            ans_end =  x.getValue();
            double two = Double.parseDouble(innersum.pop());
            double one = Double.parseDouble(innersum.pop());
                
                if(ans_end.equals(""+"")) inner = one+two;
                else if(ans_end.equals(""-"")) inner = one-two;
                else if(ans_end.equals(""/"")) inner = one/two;
                else if(ans_end.equals(""*"")) inner = one*two;
                
                ans_end = Double.toString(inner);
                //innersum.push(cal);
        }
        //innersum.push(ans_end);
        return ans_end;
    }
    
    
}

@c881e40bbb77cc5860e44b48258f9218@"
"r03723070","6","1.02","105712","@7b66062d43cc79ca36befb9f827c1a0b@public class Expression {
  
    private Node root;
    Stack<String> calculator = new Stack<String>();
    Stack<Node> stack = new Stack<Node>();
    Queue<Node> queue = new Queue<Node>();
    public double ans;
   
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //store the string in que
         String ans = new String();
        
        for (String i : infix.split("""")){
           // StdOut.println(""QQQQ"");
            Node a = new Node(null,null,i);
            queue.enqueue(a); 
            //StdOut.println(i);
        }
        
        queue.dequeue();
        Node [] arr = new Node[2];
        //int count = 0;
        Node operator = new Node(null,null,null);
        //calculator.push(""1"");
        while(!queue.isEmpty()){
            Node b = queue.dequeue();
            if(!b.getValue().equals(""("")){
                if(!b.getValue().equals("")"")){
                calculator.push(b.getValue());
                stack.push(b);  
                }

                if(b.getValue().equals("")"")){
                    arr[1] = stack.pop();
                    operator = stack.pop();
                    arr[0] = stack.pop();
                    
                    operator.setLeft(arr[0]);
                    operator.setRight(arr[1]);
                    stack.push(operator);
                    //2.calculate
                    double innersum = 0 ;
                    double two = Double.parseDouble(calculator.pop());
                    //StdOut.println(two);
                    String op = calculator.pop();
                    //StdOut.println(op);
                    double one = Double.parseDouble(calculator.pop());
                    //StdOut.println(one);
                    if(op.equals(""+"")) innersum = one+two;
                    else if(op.equals(""-"")) innersum = one-two;
                    else if(op.equals(""/"")) innersum = one/two;
                    else if(op.equals(""*"")) innersum = one*two;
                    String cal = Double.toString(innersum);
                    calculator.push(cal);
                    ans = cal;
                    //StdOut.println(ans);
                }
            }
        }
        //ans = cal;
        root = operator;
        return root;
    }

public Node[] PrintPrefix() throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_prefix = PrintPrefix(root);
        Node[] prefix = new Node [print_prefix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_prefix.isEmpty()){
            prefix[i] = print_prefix.dequeue();
            i++;
        }
        return prefix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPrefix(Node x){
        Queue<Node> print_prefix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            print_prefix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPrefix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_prefix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPrefix(x.getRight());
                while(!temp2.isEmpty()){
                    print_prefix.enqueue(temp2.dequeue());
                            }
            }
            return print_prefix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }
  
public Node[] PrintPostfix()throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_postfix = PrintPostfix(root);
        Node[] postfix = new Node [print_postfix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_postfix.isEmpty()){
            postfix[i] = print_postfix.dequeue();
            i++;
        }
        return postfix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPostfix(Node x){
        Queue<Node> print_postfix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            //print_postfix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPostfix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_postfix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPostfix(x.getRight());
                while(!temp2.isEmpty()){
                    print_postfix.enqueue(temp2.dequeue());
                            }
            }
            print_postfix.enqueue(x);
            return print_postfix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }    
    
    

    public double Evaluation()throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        ans = Double.parseDouble(Evaluation(root));
        return ans;
        }
    }

    public String Evaluation(Node x){
        

        double inner = 0;
        //Stack<Double> innersum = new Stack<>();
        Stack<String> innersum = new Stack<>();
        String ans_end = x.getValue();
        //inner = x.getLeft();
        //double innersum ;
        //innersum = Double.parseDouble(x.getLeft().getValue());
        //double two = Double.parseDouble(calculator.pop());
        //if(null==x.getValue()) return null;
        if(x.getLeft()!=null) {
            //StdOut.println(""QQQ"");
            ans_end = Evaluation(x.getLeft());
            innersum.push(ans_end);
            //StdOut.printf(""ans_end is %s\n"",innersum.pop());
            //StdOut.printf(""ans_end is %s\n"",ans_end);
        }
        if(x.getRight()!=null){ 
            //StdOut.println(""RRR"");
            //x = x.getRight();
            ans_end = Evaluation(x.getRight());
            innersum.push(ans_end);
        } //x = Evaluation(x.getRight());
        
        //
        if(x.getRight()!=null && x.getLeft()!=null){
            //StdOut.println(""PPPP"");
            ans_end =  x.getValue();
            double two = Double.parseDouble(innersum.pop());
            double one = Double.parseDouble(innersum.pop());
                
                if(ans_end.equals(""+"")) inner = one+two;
                else if(ans_end.equals(""-"")) inner = one-two;
                else if(ans_end.equals(""/"")) inner = one/two;
                else if(ans_end.equals(""*"")) inner = one*two;
                
                ans_end = Double.toString(inner);
                //innersum.push(cal);
        }
        //innersum.push(ans_end);
        return ans_end;
    }
    
    
}

@7b66062d43cc79ca36befb9f827c1a0b@"
"r03723070","6","0.98","105920","@19fb542dbc599e0cc770f33aa56e30ab@public class Expression {
  
    private Node root;
    Stack<String> calculator = new Stack<String>();
    Stack<Node> stack = new Stack<Node>();
    Queue<Node> queue = new Queue<Node>();
    public double ans;
   
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        ////
        String decimal = new String();
        boolean digit = false;
        for (String sss : infix.split("""")){
            if(sss.equals(""."")){
                decimal = decimal.trim()+sss;
                digit = true;
            }
            else{
                if(digit = true){
                if(sss.equals(""+"")||sss.equals(""-"")||sss.equals(""*"")||sss.equals(""/"")||sss.equals("")"")||sss.equals(""("")){
                    decimal = decimal+sss+"" "";
                    digit = false;
                }
                else decimal = decimal+sss+"" "";
            }
                else
                    decimal = decimal+"" ""+sss+"" "";
            }    
        }
        decimal =decimal.trim();
        
        
        
        
        
        
        
        
        //store the string in que
        String ans = new String(); 
        /*for (String i : infix.split("""")){
            if(i.equals(""."")){
                decimal = decimal
            }
            decimal = decimal+"" ""+i;
        }*/
        for (String i : decimal.split("" "")){
           // StdOut.println(""QQQQ"");
            Node a = new Node(null,null,i);
            queue.enqueue(a); 
            //StdOut.println(i);
        }
        
        queue.dequeue();
        Node [] arr = new Node[2];
        //int count = 0;
        Node operator = new Node(null,null,null);
        //calculator.push(""1"");
        while(!queue.isEmpty()){
            Node b = queue.dequeue();
            if(!b.getValue().equals(""("")){
                if(!b.getValue().equals("")"")){
                calculator.push(b.getValue());
                stack.push(b);  
                }

                if(b.getValue().equals("")"")){
                    arr[1] = stack.pop();
                    operator = stack.pop();
                    arr[0] = stack.pop();
                    
                    operator.setLeft(arr[0]);
                    operator.setRight(arr[1]);
                    stack.push(operator);
                    //2.calculate
                    double innersum = 0 ;
                    double two = Double.parseDouble(calculator.pop());
                    //StdOut.println(two);
                    String op = calculator.pop();
                    //StdOut.println(op);
                    double one = Double.parseDouble(calculator.pop());
                    //StdOut.println(one);
                    if(op.equals(""+"")) innersum = one+two;
                    else if(op.equals(""-"")) innersum = one-two;
                    else if(op.equals(""/"")) innersum = one/two;
                    else if(op.equals(""*"")) innersum = one*two;
                    String cal = Double.toString(innersum);
                    calculator.push(cal);
                    ans = cal;
                    //StdOut.println(ans);
                }
            }
        }
        //ans = cal;
        root = operator;
        return root;
    }

public Node[] PrintPrefix() throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_prefix = PrintPrefix(root);
        Node[] prefix = new Node [print_prefix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_prefix.isEmpty()){
            prefix[i] = print_prefix.dequeue();
            i++;
        }
        return prefix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPrefix(Node x){
        Queue<Node> print_prefix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            print_prefix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPrefix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_prefix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPrefix(x.getRight());
                while(!temp2.isEmpty()){
                    print_prefix.enqueue(temp2.dequeue());
                            }
            }
            return print_prefix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }
  
public Node[] PrintPostfix()throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_postfix = PrintPostfix(root);
        Node[] postfix = new Node [print_postfix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_postfix.isEmpty()){
            postfix[i] = print_postfix.dequeue();
            i++;
        }
        return postfix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPostfix(Node x){
        Queue<Node> print_postfix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            //print_postfix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPostfix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_postfix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPostfix(x.getRight());
                while(!temp2.isEmpty()){
                    print_postfix.enqueue(temp2.dequeue());
                            }
            }
            print_postfix.enqueue(x);
            return print_postfix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }    
    
    

    public double Evaluation()throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        ans = Double.parseDouble(Evaluation(root));
        return ans;
        }
    }

    public String Evaluation(Node x){
        

        double inner = 0;
        //Stack<Double> innersum = new Stack<>();
        Stack<String> innersum = new Stack<>();
        String ans_end = x.getValue();
        //inner = x.getLeft();
        //double innersum ;
        //innersum = Double.parseDouble(x.getLeft().getValue());
        //double two = Double.parseDouble(calculator.pop());
        //if(null==x.getValue()) return null;
        if(x.getLeft()!=null) {
            //StdOut.println(""QQQ"");
            ans_end = Evaluation(x.getLeft());
            innersum.push(ans_end);
            //StdOut.printf(""ans_end is %s\n"",innersum.pop());
            //StdOut.printf(""ans_end is %s\n"",ans_end);
        }
        if(x.getRight()!=null){ 
            //StdOut.println(""RRR"");
            //x = x.getRight();
            ans_end = Evaluation(x.getRight());
            innersum.push(ans_end);
        } //x = Evaluation(x.getRight());
        
        //
        if(x.getRight()!=null && x.getLeft()!=null){
            //StdOut.println(""PPPP"");
            ans_end =  x.getValue();
            double two = Double.parseDouble(innersum.pop());
            double one = Double.parseDouble(innersum.pop());
                
                if(ans_end.equals(""+"")) inner = one+two;
                else if(ans_end.equals(""-"")) inner = one-two;
                else if(ans_end.equals(""/"")) inner = one/two;
                else if(ans_end.equals(""*"")) inner = one*two;
                
                ans_end = Double.toString(inner);
                //innersum.push(cal);
        }
        //innersum.push(ans_end);
        return ans_end;
    }
    
    
}

@19fb542dbc599e0cc770f33aa56e30ab@"
"b03611035","2","0.28","105824","@52b11ba82243dfca90787181409b91f6@public class Expression{
  
    private Node root;
    int N=0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //讀檔，會有小數及二位數Up
        String e[]=infix.split("""");
        
        Stack<Node> vals=new Stack();
        Stack<Node> ops=new Stack();
        int i=0;
        
        while(i<e.length){
            String s=e[i++];
            if(s.equals(""("")) ;
            else if (s.equals(""+"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals(""*"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals(""-"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals(""/"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals("")""))
            {  
                if(ops.isEmpty()||vals.isEmpty())break;
                Node op=ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                vals.push(op);
            }
            else{//讀到數字時創一個嶄新的node，RL都是null，值存入
                N++;
                Node val=new Node(null,null,s);
                vals.push(val);
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null) throw new NullPointerException();
        Node[] prefix = new Node[N];
        Prefix003(prefix, root,0);
        return prefix;
    }
    
    private void Prefix003(Node[] prefix,Node root, int i){
        if(root==null)return;
        prefix[i]=root;
        i++;        
        Prefix003(prefix, root.getRight(), i);
        Prefix003(prefix, root.getLeft(), i);
    }
    
    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[N];
        Postfix003(postfix,root,0);
        return postfix;
    }
    private void Postfix003(Node[] prefix,Node root, int i){
        if(root==null)return;
        Postfix003(prefix, root.getRight(), i);
        Postfix003(prefix, root.getLeft(), i);
        i++;
        prefix[i]=root;
    }
    
    public double Evaluation(){
        if(root==null) throw new NullPointerException();
        double answer = 0;
        return answer;
    }
    
    public static void main(String[] args) throws Exception{
        String input=""(4+(((4*2)/2)/3))"";
        Expression gg=new Expression();
        System.out.println(gg.Infix2BT(input).getValue());
        Node[]haha=gg.PrintPrefix();
      //  for(int i=0;i<haha.length;i++) System.out.print(haha[i].getValue());
        haha=gg.PrintPostfix();
        for(int i=0;i<haha.length;i++) System.out.print(haha[i].getValue());
        System.out.println(gg.Evaluation());
    }
}

@52b11ba82243dfca90787181409b91f6@"
"r03723070","6","0.99","105920","@669b02d9fb9c0b6c2ef8c4c227252857@public class Expression {
  
    private Node root;
    Stack<String> calculator = new Stack<String>();
    Stack<Node> stack = new Stack<Node>();
    Queue<Node> queue = new Queue<Node>();
    public double ans;
   
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        ////
        String decimal = new String();
        int turn  = 0;
        for (String sss : infix.split("""")){
            if(sss.equals(""."")){
                decimal = decimal.trim()+sss;
                turn = 1;
            }
            else{
                if(turn == 1){
                if(sss.equals(""+"")||sss.equals(""-"")||sss.equals(""*"")||sss.equals(""/"")||sss.equals("")"")||sss.equals(""("")){
                    decimal = decimal+"" ""+sss;
                    turn = 0;
                }
                else decimal = decimal+sss;
            }
                else
                    decimal = decimal+"" ""+sss;
            }
        }
        decimal =decimal.trim();
        
        
        
        
        
        
        
        
        //store the string in que
        String ans = new String(); 
        /*for (String i : infix.split("""")){
            if(i.equals(""."")){
                decimal = decimal
            }
            decimal = decimal+"" ""+i;
        }*/
        for (String i : decimal.split("" "")){
           // StdOut.println(""QQQQ"");
            Node a = new Node(null,null,i);
            queue.enqueue(a); 
            //StdOut.println(i);
        }
        
        queue.dequeue();
        Node [] arr = new Node[2];
        //int count = 0;
        Node operator = new Node(null,null,null);
        //calculator.push(""1"");
        while(!queue.isEmpty()){
            Node b = queue.dequeue();
            if(!b.getValue().equals(""("")){
                if(!b.getValue().equals("")"")){
                calculator.push(b.getValue());
                stack.push(b);  
                }

                if(b.getValue().equals("")"")){
                    arr[1] = stack.pop();
                    operator = stack.pop();
                    arr[0] = stack.pop();
                    
                    operator.setLeft(arr[0]);
                    operator.setRight(arr[1]);
                    stack.push(operator);
                    //2.calculate
                    double innersum = 0 ;
                    double two = Double.parseDouble(calculator.pop());
                    //StdOut.println(two);
                    String op = calculator.pop();
                    //StdOut.println(op);
                    double one = Double.parseDouble(calculator.pop());
                    //StdOut.println(one);
                    if(op.equals(""+"")) innersum = one+two;
                    else if(op.equals(""-"")) innersum = one-two;
                    else if(op.equals(""/"")) innersum = one/two;
                    else if(op.equals(""*"")) innersum = one*two;
                    String cal = Double.toString(innersum);
                    calculator.push(cal);
                    ans = cal;
                    //StdOut.println(ans);
                }
            }
        }
        //ans = cal;
        root = operator;
        return root;
    }

public Node[] PrintPrefix() throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_prefix = PrintPrefix(root);
        Node[] prefix = new Node [print_prefix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_prefix.isEmpty()){
            prefix[i] = print_prefix.dequeue();
            i++;
        }
        return prefix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPrefix(Node x){
        Queue<Node> print_prefix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            print_prefix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPrefix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_prefix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPrefix(x.getRight());
                while(!temp2.isEmpty()){
                    print_prefix.enqueue(temp2.dequeue());
                            }
            }
            return print_prefix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }
  
public Node[] PrintPostfix()throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_postfix = PrintPostfix(root);
        Node[] postfix = new Node [print_postfix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_postfix.isEmpty()){
            postfix[i] = print_postfix.dequeue();
            i++;
        }
        return postfix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPostfix(Node x){
        Queue<Node> print_postfix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            //print_postfix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPostfix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_postfix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPostfix(x.getRight());
                while(!temp2.isEmpty()){
                    print_postfix.enqueue(temp2.dequeue());
                            }
            }
            print_postfix.enqueue(x);
            return print_postfix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }    
    
    

    public double Evaluation()throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        ans = Double.parseDouble(Evaluation(root));
        return ans;
        }
    }

    public String Evaluation(Node x){
        

        double inner = 0;
        //Stack<Double> innersum = new Stack<>();
        Stack<String> innersum = new Stack<>();
        String ans_end = x.getValue();
        //inner = x.getLeft();
        //double innersum ;
        //innersum = Double.parseDouble(x.getLeft().getValue());
        //double two = Double.parseDouble(calculator.pop());
        //if(null==x.getValue()) return null;
        if(x.getLeft()!=null) {
            //StdOut.println(""QQQ"");
            ans_end = Evaluation(x.getLeft());
            innersum.push(ans_end);
            //StdOut.printf(""ans_end is %s\n"",innersum.pop());
            //StdOut.printf(""ans_end is %s\n"",ans_end);
        }
        if(x.getRight()!=null){ 
            //StdOut.println(""RRR"");
            //x = x.getRight();
            ans_end = Evaluation(x.getRight());
            innersum.push(ans_end);
        } //x = Evaluation(x.getRight());
        
        //
        if(x.getRight()!=null && x.getLeft()!=null){
            //StdOut.println(""PPPP"");
            ans_end =  x.getValue();
            double two = Double.parseDouble(innersum.pop());
            double one = Double.parseDouble(innersum.pop());
                
                if(ans_end.equals(""+"")) inner = one+two;
                else if(ans_end.equals(""-"")) inner = one-two;
                else if(ans_end.equals(""/"")) inner = one/two;
                else if(ans_end.equals(""*"")) inner = one*two;
                
                ans_end = Double.toString(inner);
                //innersum.push(cal);
        }
        //innersum.push(ans_end);
        return ans_end;
    }
    
    
}

@669b02d9fb9c0b6c2ef8c4c227252857@"
"r03723070","10","0.098","105904","@743ba46fabb1a2c33fc7ee3c23b90ef4@public class Expression {
  
    private Node root;
    Stack<String> calculator = new Stack<String>();
    Stack<Node> stack = new Stack<Node>();
    Queue<Node> queue = new Queue<Node>();
    public double ans;
   
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        ////
        String decimal = new String();
                for (String sss : infix.split("""")){
            if(sss.equals(""+"")||sss.equals(""-"")||sss.equals(""*"")||sss.equals(""/"")||sss.equals("")"")||sss.equals(""("")){
                decimal = decimal.trim()+"" ""+sss+"" "";
            }
            else{
                if(sss.equals(""."")){
                decimal = decimal+sss;
                //turn = 1;
            }
            else{
                decimal = decimal+sss;
                }
            }
        }
        decimal =decimal.trim();
        
        
        
        
        
        
        
        
        //store the string in que
        String ans = new String(); 
        /*for (String i : infix.split("""")){
            if(i.equals(""."")){
                decimal = decimal
            }
            decimal = decimal+"" ""+i;
        }*/
        for (String i : decimal.split("" "")){
           // StdOut.println(""QQQQ"");
            Node a = new Node(null,null,i);
            queue.enqueue(a); 
            //StdOut.println(i);
        }
        
        queue.dequeue();
        Node [] arr = new Node[2];
        //int count = 0;
        Node operator = new Node(null,null,null);
        //calculator.push(""1"");
        while(!queue.isEmpty()){
            Node b = queue.dequeue();
            if(!b.getValue().equals(""("")){
                if(!b.getValue().equals("")"")){
                calculator.push(b.getValue());
                stack.push(b);  
                }

                if(b.getValue().equals("")"")){
                    arr[1] = stack.pop();
                    operator = stack.pop();
                    arr[0] = stack.pop();
                    
                    operator.setLeft(arr[0]);
                    operator.setRight(arr[1]);
                    stack.push(operator);
                    //2.calculate
                    double innersum = 0 ;
                    double two = Double.parseDouble(calculator.pop());
                    //StdOut.println(two);
                    String op = calculator.pop();
                    //StdOut.println(op);
                    double one = Double.parseDouble(calculator.pop());
                    //StdOut.println(one);
                    if(op.equals(""+"")) innersum = one+two;
                    else if(op.equals(""-"")) innersum = one-two;
                    else if(op.equals(""/"")) innersum = one/two;
                    else if(op.equals(""*"")) innersum = one*two;
                    String cal = Double.toString(innersum);
                    calculator.push(cal);
                    ans = cal;
                    //StdOut.println(ans);
                }
            }
        }
        //ans = cal;
        root = operator;
        return root;
    }

public Node[] PrintPrefix() throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_prefix = PrintPrefix(root);
        Node[] prefix = new Node [print_prefix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_prefix.isEmpty()){
            prefix[i] = print_prefix.dequeue();
            i++;
        }
        return prefix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPrefix(Node x){
        Queue<Node> print_prefix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            print_prefix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPrefix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_prefix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPrefix(x.getRight());
                while(!temp2.isEmpty()){
                    print_prefix.enqueue(temp2.dequeue());
                            }
            }
            return print_prefix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }
  
public Node[] PrintPostfix()throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        Queue<Node> print_postfix = PrintPostfix(root);
        Node[] postfix = new Node [print_postfix.size()] ;
        //StdOut.println(print_prefix.isEmpty());
        int i = 0;
        //StdOut.println(prefix[i]);
        while(!print_postfix.isEmpty()){
            postfix[i] = print_postfix.dequeue();
            i++;
        }
        return postfix;
        //List<Integer> myList = new ArrayList<Integer>()
    }}
    public Queue<Node> PrintPostfix(Node x){
        Queue<Node> print_postfix = new Queue<Node>();
        
        if(x==null) {
            throw new NullPointerException();
        }
        else{
            //print_postfix.enqueue(x);
            if(x.getLeft()!=null){
                Queue<Node> temp1=PrintPostfix(x.getLeft());
                while(!temp1.isEmpty()){
                    print_postfix.enqueue(temp1.dequeue());
                }
            }
            if(x.getRight()!=null){
                Queue<Node> temp2=PrintPostfix(x.getRight());
                while(!temp2.isEmpty()){
                    print_postfix.enqueue(temp2.dequeue());
                            }
            }
            print_postfix.enqueue(x);
            return print_postfix;
        }
            //if(x.getRight()!=null && x.getLeft()!=null){
            //}   
    }    
    
    

    public double Evaluation()throws Exception{
        if(root==null) {
            throw new NullPointerException();
        }
        else{
        ans = Double.parseDouble(Evaluation(root));
        return ans;
        }
    }

    public String Evaluation(Node x){
        

        double inner = 0;
        //Stack<Double> innersum = new Stack<>();
        Stack<String> innersum = new Stack<>();
        String ans_end = x.getValue();
        //inner = x.getLeft();
        //double innersum ;
        //innersum = Double.parseDouble(x.getLeft().getValue());
        //double two = Double.parseDouble(calculator.pop());
        //if(null==x.getValue()) return null;
        if(x.getLeft()!=null) {
            //StdOut.println(""QQQ"");
            ans_end = Evaluation(x.getLeft());
            innersum.push(ans_end);
            //StdOut.printf(""ans_end is %s\n"",innersum.pop());
            //StdOut.printf(""ans_end is %s\n"",ans_end);
        }
        if(x.getRight()!=null){ 
            //StdOut.println(""RRR"");
            //x = x.getRight();
            ans_end = Evaluation(x.getRight());
            innersum.push(ans_end);
        } //x = Evaluation(x.getRight());
        
        //
        if(x.getRight()!=null && x.getLeft()!=null){
            //StdOut.println(""PPPP"");
            ans_end =  x.getValue();
            double two = Double.parseDouble(innersum.pop());
            double one = Double.parseDouble(innersum.pop());
                
                if(ans_end.equals(""+"")) inner = one+two;
                else if(ans_end.equals(""-"")) inner = one-two;
                else if(ans_end.equals(""/"")) inner = one/two;
                else if(ans_end.equals(""*"")) inner = one*two;
                
                ans_end = Double.toString(inner);
                //innersum.push(cal);
        }
        //innersum.push(ans_end);
        return ans_end;
    }
    
    
}

@743ba46fabb1a2c33fc7ee3c23b90ef4@"
"b03611015","9","0.97","105856","@a559ae56ba32e55b4f67c989cf99181a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;


public class Expression {

    private Node root;
     int i = 0;
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] x = infix.split("""");
        Stack<Node> val = new Stack<>();
        Stack<Node> ops = new Stack<>();
        String n = """";
        for (int i = 0; i < infix.length(); i++) {
            String c = x[i];
            if (c.equals(""("")); 
            else if (c.equals(""+"")) {
                if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""-"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""*"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""/"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals("")"")) {
                  if(!n.equals(""""))
               val.push(new Node(null,null,n));
                n="""";
                Node op = ops.pop();
                Node v2 = val.pop();
                Node v1 = val.pop();
                op.setLeft(v1);
                op.setRight(v2);
                root = op;
                val.push(op);
            }
            else {
               n =n+c;
            }

        }

        return root;

    }
    public Node[] PrintPrefix(){
        
        Stack<Node> prefix = new Stack<>();
        prefix(prefix, root);
        Node prefix1[] = new Node[prefix.size()];
        for(int i=prefix.size()-1;i>=0;i--){
            prefix1[i] = prefix.pop();
        }
        return prefix1;
    }
    public void  prefix(Stack<Node> a, Node root){
          if(root==null) return;
          a.push(root);
          prefix( a, root.getLeft());
          prefix( a, root.getRight());
    }
  
    public Node[] PrintPostfix(){
         
        Stack<Node> postfix = new Stack<>();
        postfix(postfix, root);
        Node postfix1[] = new Node[postfix.size()];
        for(int i=postfix.size()-1;i>=0;i--){
            postfix1[i] = postfix.pop();
        }
        return postfix1;
    }
     public void  postfix(Stack<Node> a, Node root){
          if(root==null) return;
          postfix( a, root.getLeft());
          postfix( a, root.getRight());
          a.push(root);
    }


public double Evaluation(){
        if(root == null) throw new NullPointerException();
        return EvaluationHelper(root);
    }

    private double EvaluationHelper(Node root){
        switch (root.getValue()) {
            case ""+"":
                return EvaluationHelper(root.getLeft()) + EvaluationHelper(root.getRight());
            case ""-"":
                return EvaluationHelper(root.getLeft()) - EvaluationHelper(root.getRight());
            case ""*"":
                return EvaluationHelper(root.getLeft()) * EvaluationHelper(root.getRight());
            case ""/"":
                return EvaluationHelper(root.getLeft()) / EvaluationHelper(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }
    }
     public static void main(String[] args) throws Exception {
         
        String infix = ""(4+(((4*2)/2)/3))"";
//        String infix = ""(21/2.1)"";
//        String infix = """";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for(Node n:prefixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for(Node n:postfixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());

        
        }
    }

@a559ae56ba32e55b4f67c989cf99181a@"
"b03611015","0","0.99","105920","@e65e89eb3f2bcf783c4e39ea801b64f9@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;


public class Expression {

    private Node root;
     int i = 0;
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] x = infix.split("""");
        Stack<Node> val = new Stack<>();
        Stack<Node> ops = new Stack<>();
        String n = """";
        for (int i = 0; i < infix.length(); i++) {
            String c = x[i];
            if (c.equals(""("")); 
            else if (c.equals(""+"")) {
                if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""-"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""*"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""/"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals("")"")) {
                  if(!n.equals(""""))
               val.push(new Node(null,null,n));
                n="""";
                Node op = ops.pop();
                Node v2 = val.pop();
                Node v1 = val.pop();
                op.setLeft(v1);
                op.setRight(v2);
                root = op;
                val.push(op);
            }
            else {
               n =n+c;
            }

        }

        return root;

    }
    public Node[] PrintPrefix(){
        
        Stack<Node> prefix = new Stack<>();
        prefix(prefix, root);
        Node prefix1[] = new Node[prefix.size()];
        for(int i=prefix.size()-1;i>=0;i--){
            prefix1[i] = prefix.pop();
        }
        return prefix1;
    }
    public void  prefix(Stack<Node> a, Node root){
          if(root==null) return;
          a.push(root);
          prefix( a, root.getLeft());
          prefix( a, root.getRight());
    }
  
    public Node[] PrintPostfix(){
         
        Stack<Node> postfix = new Stack<>();
        postfix(postfix, root);
        Node postfix1[] = new Node[postfix.size()];
        for(int i=postfix.size()-1;i>=0;i--){
            postfix1[i] = postfix.pop();
        }
        return postfix1;
    }
     public void  postfix(Stack<Node> a, Node root){
          if(root==null) return;
          postfix( a, root.getLeft());
          postfix( a, root.getRight());
          a.push(root);
    }


public double Evaluation(){
        if(root == null) throw new NullPointerException();
        return EvaluationHelper(root);
    }

    private double EvaluationHelper(Node root){
        switch (root.getValue()) {
            case ""+"":
                return EvaluationHelper(root.getLeft()) + EvaluationHelper(root.getRight());
            case ""-"":
                return EvaluationHelper(root.getLeft()) - EvaluationHelper(root.getRight());
            case ""*"":
                return EvaluationHelper(root.getLeft()) * EvaluationHelper(root.getRight());
            case ""/"":
                return EvaluationHelper(root.getLeft()) / EvaluationHelper(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }
    }
   
@e65e89eb3f2bcf783c4e39ea801b64f9@"
"b03611015","9","0.97","105856","@275d432f853435c99411de14c8b3bb9e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;


public class Expression {

    private Node root;
     int i = 0;
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] x = infix.split("""");
        Stack<Node> val = new Stack<>();
        Stack<Node> ops = new Stack<>();
        String n = """";
        for (int i = 0; i < infix.length(); i++) {
            String c = x[i];
            if (c.equals(""("")); 
            else if (c.equals(""+"")) {
                if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""-"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""*"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""/"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals("")"")) {
                  if(!n.equals(""""))
               val.push(new Node(null,null,n));
                n="""";
                Node op = ops.pop();
                Node v2 = val.pop();
                Node v1 = val.pop();
                op.setLeft(v1);
                op.setRight(v2);
                root = op;
                val.push(op);
            }
            else {
               n =n+c;
            }

        }

        return root;

    }
    public Node[] PrintPrefix(){
        
        Stack<Node> prefix = new Stack<>();
        prefix(prefix, root);
        Node prefix1[] = new Node[prefix.size()];
        for(int i=prefix.size()-1;i>=0;i--){
            prefix1[i] = prefix.pop();
        }
        return prefix1;
    }
    public void  prefix(Stack<Node> a, Node root){
          if(root==null) return;
          a.push(root);
          prefix( a, root.getLeft());
          prefix( a, root.getRight());
    }
  
    public Node[] PrintPostfix(){
         
        Stack<Node> postfix = new Stack<>();
        postfix(postfix, root);
        Node postfix1[] = new Node[postfix.size()];
        for(int i=postfix.size()-1;i>=0;i--){
            postfix1[i] = postfix.pop();
        }
        return postfix1;
    }
     public void  postfix(Stack<Node> a, Node root){
          if(root==null) return;
          postfix( a, root.getLeft());
          postfix( a, root.getRight());
          a.push(root);
    }


public double Evaluation(){
        if(root == null) throw new NullPointerException();
        return EvaluationHelper(root);
    }

    private double EvaluationHelper(Node root){
        switch (root.getValue()) {
            case ""+"":
                return EvaluationHelper(root.getLeft()) + EvaluationHelper(root.getRight());
            case ""-"":
                return EvaluationHelper(root.getLeft()) - EvaluationHelper(root.getRight());
            case ""*"":
                return EvaluationHelper(root.getLeft()) * EvaluationHelper(root.getRight());
            case ""/"":
                return EvaluationHelper(root.getLeft()) / EvaluationHelper(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }
    }
     }
@275d432f853435c99411de14c8b3bb9e@"
"b03611035","6","0.58","105824","@f73d309e60183df1f8398640c5016e86@public class Expression{
  
    private Node root;
    int N=0;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //讀檔，會有小數及二位數Up
        String e[]=infix.split("""");
        
        Stack<Node> vals=new Stack();
        Stack<Node> ops=new Stack();
        int i=0;
        
        while(i<e.length){
            String s=e[i++];
            if(s.equals(""("")) ;
            else if (s.equals(""+"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals(""*"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals(""-"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals(""/"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals("")""))
            {  
                if(ops.isEmpty()||vals.isEmpty())break;
                Node op=ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                vals.push(op);
            }
            else{//讀到數字時創一個嶄新的node，RL都是null，值存入
                N++;
                Node val=new Node(null,null,s);
                vals.push(val);
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null) throw new NullPointerException();
        Node[] prefix = new Node[N];
        Stack<Node>temp=new Stack();
        Prefix003(temp,root);
        for(int i=0;i<N;i++)prefix[i]=temp.pop();
        return prefix;
    }    
    private void Postfix003(Stack<Node>temp,Node root){
        if(root==null)return;
        temp.push(root);
        Postfix003(temp,root.getRight());
        Postfix003(temp,root.getLeft());
    }
    
    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[N];
        Stack<Node>temp=new Stack();
        Postfix003(temp,root);
        for(int i=0;i<N;i++)postfix[i]=temp.pop();
        return postfix;
    }    
    private void Prefix003(Stack<Node>temp, Node root){
        if(root==null)return;
        Prefix003(temp,root.getRight());
        Prefix003(temp,root.getLeft());
        temp.push(root);
    }
    
    public double Evaluation(){
        if(root==null) throw new NullPointerException();
        double answer = 0;
        String[] calc=new String[N];
        Node[] fuck=PrintPostfix();
        Stack<Double> vals=new Stack();
        
        for(int i=0;i<N;i++){
            calc[i]=fuck[i].getValue();
            if(""+"".equals(calc[i])){
                double baba;
                baba=vals.pop()+vals.pop();
                vals.push(baba);
            }
            else if(""-"".equals(calc[i])){
                double baba;
                baba=-vals.pop()+vals.pop();
                vals.push(baba);
            }
            else if(""*"".equals(calc[i])){
                double baba;
                baba=vals.pop()*vals.pop();
                vals.push(baba);
            }
            else if(""/"".equals(calc[i])){
                double baba;
                baba=(1/vals.pop())*vals.pop();
                vals.push(baba);
            }
            else vals.push(Double.parseDouble(calc[i]));
        }
        answer=vals.pop();
        return answer;
    }
    
    public static void main(String[] args) throws Exception{
        String input=""(4+(((4*2)/2)/3))"";
        Expression gg=new Expression();
        
        System.out.println(gg.Infix2BT(input).getValue());
        
        Node[]haha=gg.PrintPrefix();
        for(int i=0;i<haha.length;i++) 
            System.out.print(haha[i].getValue());
        
        System.out.println("""");
        
        haha=gg.PrintPostfix();
        for(int i=0;i<haha.length;i++) 
             System.out.print(haha[i].getValue());
        System.out.println("""");
        System.out.println(gg.Evaluation());
    }
}

@f73d309e60183df1f8398640c5016e86@"
"r04921104","6","0.96","105856","@c8c73671bb13a9dca3a1616505cd33a8@
public class Expression {

    private static boolean isOperator(String a) {
        if (a.equals(""+"") || a.equals(""-"") || a.equals(""*"") || a.equals(""/"")) {
            return true;
        } else {
            return false;
        }
    }

    private static void prefixPut(Node n, Stack<Node> st) {
        st.push(n);
        if (n.getLeft() != null) {
            prefixPut(n.getLeft(), st);
        }
        if (n.getRight() != null) {
            prefixPut(n.getRight(), st);
        }
    }

    private static void postfixPut(Node n, Stack<Node> st) {
        st.push(n);
        if (n.getRight() != null) {
            postfixPut(n.getRight(), st);
        }
        if (n.getLeft() != null) {
            postfixPut(n.getLeft(), st);
        }
    }

    private static double compution(Node n) {
        double a, b;
        String opr = n.getValue();

        if (isOperator(n.getLeft().getValue())) {
            a = compution(n.getLeft());
        } else {
            a = Double.valueOf(n.getLeft().getValue());
        }

        if (isOperator(n.getRight().getValue())) {
            b = compution(n.getRight());
        } else {
            b = Double.valueOf(n.getRight().getValue());
        }

        if (opr.equals(""+"")) {
            return a + b;
        } else if (opr.equals(""-"")) {
            return a - b;
        } else if (opr.equals(""*"")) {
            return a * b;
        } else if (opr.equals(""/"")) {
            return a / b;
        } else {
            return 0;
        }
    }

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        Stack<String> query = new Stack();
        String opdR, opr, opdL;
        for (int i = 0; i < infix.length(); i++) {
            String s = infix.substring(i, i + 1);
            if (!s.equals("")"")) {
                query.push(s);
            } else { // s.equals("")"")
                String c = query.pop();
                if (!isOperator(c)) {
                    opr = query.pop();
                    opdR = c;
                    opdL = null;
                    if (!query.peek().equals(""("")) {
                        opdL = query.pop();
                    }
                } else {
                    opr = c;
                    opdR = null;
                    opdL = query.pop();
                }
                query.pop(); //pop '('

                if (opdL == null) {
                    Node nRight = new Node(null, null, opdR);
                    Node nRoot = new Node(root, nRight, opr);
                    root = nRoot;
                } else if (opdR == null) {
                    Node nLeft = new Node(null, null, opdL);
                    Node nRoot = new Node(nLeft, root, opr);
                    root = nRoot;
                } else { // opdL != null && opdR != null
                    Node nLeft = new Node(null, null, opdL);
                    Node nRight = new Node(null, null, opdR);
                    Node nRoot = new Node(nLeft, nRight, opr);
                    root = nRoot;
                }
            }
        }

        return (root);
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException();
        }
        Node[] prefix = null;

        Stack<Node> st = new Stack();
        prefixPut(root, st);
        int size = st.size();
        prefix = new Node[size];
        for (int i = st.size() - 1; i >= 0; i--) {
            prefix[i] = st.pop();
        }

        return (prefix);
    }

    public Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException();
        }
        Node[] postfix = null;

        Stack<Node> st = new Stack();
        postfixPut(root, st);
        int size = st.size();
        postfix = new Node[size];
        for (int i = 0; i < size; i++) {
            postfix[i] = st.pop();
        }

        return (postfix);
    }

    public double Evaluation() {
        if (root == null) {
            throw new NullPointerException();
        }

        double answer = compution(root);
        return (answer);
    }

//    public static void main(String[] args) {
//        Expression test = new Expression();
//        test.Infix2BT(""(4+(((4*2)/2)/3))"");
//
//        for(int i =0;i<test.PrintPrefix().length;i++){
//            System.out.println(test.PrintPrefix()[i].getValue());
//        }
//        
//        for(int i =0;i<test.PrintPostfix().length;i++){
//            System.out.println(test.PrintPostfix()[i].getValue());
//        }
//        
//        System.out.println(test.Evaluation());
//    }
}
@c8c73671bb13a9dca3a1616505cd33a8@"
"r04921104","6","0.97","105840","@20ecc7f1474b8e419fb793c2adc64d41@public class Expression {

    private static boolean isOperator(String a) {
        if (a.equals(""+"") || a.equals(""-"") || a.equals(""*"") || a.equals(""/"")) {
            return true;
        } else {
            return false;
        }
    }

    private static void prefixPut(Node n, Stack<Node> st) {
        st.push(n);
        if (n.getLeft() != null) {
            prefixPut(n.getLeft(), st);
        }
        if (n.getRight() != null) {
            prefixPut(n.getRight(), st);
        }
    }

    private static void postfixPut(Node n, Stack<Node> st) {
        st.push(n);
        if (n.getRight() != null) {
            postfixPut(n.getRight(), st);
        }
        if (n.getLeft() != null) {
            postfixPut(n.getLeft(), st);
        }
    }

    private static double compution(Node n) {
        double a, b;
        String opr = n.getValue();

        if (isOperator(n.getLeft().getValue())) {
            a = compution(n.getLeft());
        } else {
            a = Double.valueOf(n.getLeft().getValue());
        }

        if (isOperator(n.getRight().getValue())) {
            b = compution(n.getRight());
        } else {
            b = Double.valueOf(n.getRight().getValue());
        }

        if (opr.equals(""+"")) {
            return a + b;
        } else if (opr.equals(""-"")) {
            return a - b;
        } else if (opr.equals(""*"")) {
            return a * b;
        } else if (opr.equals(""/"")) {
            return a / b;
        } else {
            return 0;
        }
    }

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        Stack<String> query = new Stack();
        String opdR, opr, opdL;
        for (int i = 0; i < infix.length(); i++) {
            String s = infix.substring(i, i + 1);
            if (!s.equals("")"")) {
                query.push(s);
            } else { // s.equals("")"")
                String c = query.pop();
                if (!isOperator(c)) {
                    opr = query.pop();
                    opdR = c;
                    opdL = null;
                    if (!query.peek().equals(""("")) {
                        opdL = query.pop();
                    }
                } else {
                    opr = c;
                    opdR = null;
                    opdL = query.pop();
                }
                query.pop(); //pop '('

                if (opdL == null) {
                    Node nRight = new Node(null, null, opdR);
                    Node nRoot = new Node(root, nRight, opr);
                    root = nRoot;
                } else if (opdR == null) {
                    Node nLeft = new Node(null, null, opdL);
                    Node nRoot = new Node(nLeft, root, opr);
                    root = nRoot;
                } else { // opdL != null && opdR != null
                    Node nLeft = new Node(null, null, opdL);
                    Node nRight = new Node(null, null, opdR);
                    Node nRoot = new Node(nLeft, nRight, opr);
                    root = nRoot;
                }
            }
        }

        return (root);
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException();
        }else{
        Node[] prefix = null;

        Stack<Node> st = new Stack();
        prefixPut(root, st);
        int size = st.size();
        prefix = new Node[size];
        for (int i = st.size() - 1; i >= 0; i--) {
            prefix[i] = st.pop();
        }

        return (prefix);}
    }

    public Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException();
        }else{
        Node[] postfix = null;

        Stack<Node> st = new Stack();
        postfixPut(root, st);
        int size = st.size();
        postfix = new Node[size];
        for (int i = 0; i < size; i++) {
            postfix[i] = st.pop();
        }

        return (postfix);}
    }

    public double Evaluation() {
        if (root == null) {
            throw new NullPointerException();
        }else{

        double answer = compution(root);
        return (answer);}
    }

//    public static void main(String[] args) {
//        Expression test = new Expression();
//        test.Infix2BT("""");
//
//        for(int i =0;i<test.PrintPrefix().length;i++){
//            System.out.println(test.PrintPrefix()[i].getValue());
//        }
//        
//        for(int i =0;i<test.PrintPostfix().length;i++){
//            System.out.println(test.PrintPostfix()[i].getValue());
//        }
//        
//        System.out.println(test.Evaluation());
//    }
}
@20ecc7f1474b8e419fb793c2adc64d41@"
"b03611003","1","0.18","101744","@f94ba307591f99c55b24de4606e022d9@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private static boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (((a[count + 1].equals(""+"") && a[count + 1].equals(""-"")) && (a[count + 1].equals(""*"") && a[count + 1].equals(""/"")) && a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    while (!val.isEmpty()) {
                        value += val.pop();
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            return Infix2BT(infix);
        }
    }

    public Node[] PrintPrefix() {
        prefix = null;
        countpre = 0;
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = null;
        countpost = 0;
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < k.length; i++) {
            if (k[i].equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a / b));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        postfix[countpost] = A;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        prefix[countpre] = A;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression exp = new Expression();
            String s = br.readLine();

            exp.Infix2BT(s);

        }
    }
}

@f94ba307591f99c55b24de4606e022d9@"
"b03611015","10","0.094","105824","@948afb0ab1e770ccb8f5fcd39e37557e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.List;


public class Expression {

    private Node root;
     int i = 0;
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] x = infix.split("""");
        Stack<Node> val = new Stack<>();
        Stack<Node> ops = new Stack<>();
        String n = """";
        for (int i = 0; i < infix.length(); i++) {
            String c = x[i];
            if (c.equals(""("")); 
            else if (c.equals(""+"")) {
                if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""-"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""*"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals(""/"")) {
                  if(!n.equals(""""))
                val.push(new Node(null,null,n));
                n="""";
                ops.push(new Node(null, null, c));
            } else if (c.equals("")"")) {
                  if(!n.equals(""""))
               val.push(new Node(null,null,n));
                n="""";
                Node op = ops.pop();
                Node v2 = val.pop();
                Node v1 = val.pop();
                op.setLeft(v1);
                op.setRight(v2);
                root = op;
                val.push(op);
            }
            else {
               n =n+c;
            }

        }

        return root;

    }
    public Node[] PrintPrefix(){
         if(root == null) throw new NullPointerException();
        Stack<Node> prefix = new Stack<>();
        prefix(prefix, root);
        Node prefix1[] = new Node[prefix.size()];
        for(int i=prefix.size()-1;i>=0;i--){
            prefix1[i] = prefix.pop();
        }
        return prefix1;
    }
    public void  prefix(Stack<Node> a, Node root){
          if(root==null) return;
          a.push(root);
          prefix( a, root.getLeft());
          prefix( a, root.getRight());
    }
  
    public Node[] PrintPostfix(){
          if(root == null) throw new NullPointerException();
        Stack<Node> postfix = new Stack<>();
        postfix(postfix, root);
        Node postfix1[] = new Node[postfix.size()];
        for(int i=postfix.size()-1;i>=0;i--){
            postfix1[i] = postfix.pop();
        }
        return postfix1;
    }
     public void  postfix(Stack<Node> a, Node root){
          if(root==null) return;
          postfix( a, root.getLeft());
          postfix( a, root.getRight());
          a.push(root);
    }


public double Evaluation(){
        if(root == null) throw new NullPointerException();
        return EvaluationHelper(root);
    }

    private double EvaluationHelper(Node root){
        switch (root.getValue()) {
            case ""+"":
                return EvaluationHelper(root.getLeft()) + EvaluationHelper(root.getRight());
            case ""-"":
                return EvaluationHelper(root.getLeft()) - EvaluationHelper(root.getRight());
            case ""*"":
                return EvaluationHelper(root.getLeft()) * EvaluationHelper(root.getRight());
            case ""/"":
                return EvaluationHelper(root.getLeft()) / EvaluationHelper(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }
    }
     public static void main(String[] args) throws Exception {
         
        String infix = ""(14.1+(((4.2*2)/2)/3))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for(Node n:prefixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for(Node n:postfixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());

        
        }
    }

@948afb0ab1e770ccb8f5fcd39e37557e@"
"r04945021","5","0.57","105856","@2e209d09a2f833c35dcbc2dc971b0eb4@ import java.util.ArrayList;
public class Expression{
  
    private Node root;
    private int Size;
    private Node[] pre;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
      //  Node x=new Node(null,null,null);

        Stack<Node> stack = new Stack<Node>();
        //String[] splited = infix.split("""");
        for(int i=0;i<infix.length();i++){    
            String s = String.valueOf(infix.charAt(i));
            
           if (!s.equals("")"") && !s.equals(""("")) {
                stack.push(new Node(null,null,s));
                Size++;
  } 
           else if (s.equals("")"")) {
               Node rightNode=stack.pop();
               Node subRoot=stack.pop();
               Node leftNode=stack.pop();
               stack.push(new Node(leftNode,rightNode,subRoot.getValue()));                               
            }
        }
        root=stack.pop();
        return root;
    }
    ArrayList<Node> arrli = new ArrayList<Node>();
public  ArrayList<Node> preorder(Node root){
    
    if(root!=null){
        arrli.add(root);
        preorder(root.getLeft());
        preorder(root.getRight());
    }
    return arrli;
}
    public Node[] PrintPrefix(){
        Node[] prefix=new Node[Size];
        Node node = root;
      ArrayList<Node> arr= preorder(node);

       for(int i=0;i<Size;i++){
          prefix[i]= arr.get(i);
       }
        //prefix[0]=new Node(null,null,""A"");
        return prefix;
    }
      ArrayList<Node> arrlipo = new ArrayList<Node>();
public  ArrayList<Node> postorder(Node root){
    
    if(root!=null){
        
        postorder(root.getLeft());
        postorder(root.getRight());
        arrlipo.add(root);
    }
    
    return arrlipo;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[Size];
        Node node = root;
      ArrayList<Node> arr= postorder(node);

       for(int i=0;i<Size;i++){
          postfix[i]= arr.get(i);
       }        
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Double[] Num = new Double[2];
        Stack<String> stack = new Stack<String>();
        for(int i=0;i<postfix.length;i++){
            if(!postfix[i].getValue().equals(""+"") && !postfix[i].getValue().equals(""-"") && !postfix[i].getValue().equals(""*"") && !postfix[i].getValue().equals(""/"")){
                stack.push(postfix[i].getValue());
            }
            else{
                 Num[0] =Double.parseDouble((String) stack.pop());
                    Num[1]= Double.parseDouble((String) stack.pop());
                if(postfix[i].getValue().equals(""+"")){
                  answer = Num[1] + Num[0];
                    stack.push(String.valueOf(answer));
                }
                else if(postfix[i].getValue().equals(""-"")){
                    answer = Num[1] - Num[0];
                    stack.push(String.valueOf(answer));
                }
                else if(postfix[i].getValue().equals(""*"")){
                    answer = Num[1] * Num[0];
                    stack.push(String.valueOf(answer));
                }
                else{
                    answer = Num[1] / Num[0];
                    stack.push(String.valueOf(answer));
                }
            }
                
        }
        
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
        String input = ""(4+(((4*2)/2)/3))"";
Expression exp = new Expression();
Node root=exp.Infix2BT(input);
//System.out.print(root.getValue());
Node[] A =exp.PrintPrefix();
//for(int i=0;i<A.length;i++){
   System.out.print(exp.Evaluation());
//}
        


        
    }
}

@2e209d09a2f833c35dcbc2dc971b0eb4@"
"r04921104","6","0.57","105840","@c9964879d3d366228fe43204006a3677@public class Expression {

    private static boolean isOperator(String a) {
        if (a.equals(""+"") || a.equals(""-"") || a.equals(""*"") || a.equals(""/"")) {
            return true;
        } else {
            return false;
        }
    }

    private static boolean isNum(String a) {
        if (a.equals(""+"") || a.equals(""-"") || a.equals(""*"") || a.equals(""/"") || a.equals(""("") || a.equals("")"")) {
            return false;
        } else {
            return true;
        }
    }

    private static void prefixPut(Node n, Stack<Node> st) {
        st.push(n);
        if (n.getLeft() != null) {
            prefixPut(n.getLeft(), st);
        }
        if (n.getRight() != null) {
            prefixPut(n.getRight(), st);
        }
    }

    private static void postfixPut(Node n, Stack<Node> st) {
        st.push(n);
        if (n.getRight() != null) {
            postfixPut(n.getRight(), st);
        }
        if (n.getLeft() != null) {
            postfixPut(n.getLeft(), st);
        }
    }

    private static double compution(Node n) {
        double a, b;
        String opr = n.getValue();

        if (isOperator(n.getLeft().getValue())) {
            a = compution(n.getLeft());
        } else {
            a = Double.valueOf(n.getLeft().getValue());
        }

        if (isOperator(n.getRight().getValue())) {
            b = compution(n.getRight());
        } else {
            b = Double.valueOf(n.getRight().getValue());
        }

        if (opr.equals(""+"")) {
            return a + b;
        } else if (opr.equals(""-"")) {
            return a - b;
        } else if (opr.equals(""*"")) {
            return a * b;
        } else if (opr.equals(""/"")) {
            return a / b;
        } else {
            return 0;
        }
    }

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        Stack<String> query = new Stack();
        String opdR, opr, opdL;
        for (int i = 0; i < infix.length(); i++) {
            String s = infix.substring(i, i + 1);
            if(isNum(s)){
                int j = i;
                while(isNum(infix.substring(i+1, i + 2)))
                    i++;
                s = infix.substring(j, i + 1);
                query.push(s);
            }else if (!s.equals("")"")) {
                query.push(s);
            } else { // s.equals("")"")
                String c = query.pop();
                if (!isOperator(c)) {
                    opr = query.pop();
                    opdR = c;
                    opdL = null;
                    if (!query.peek().equals(""("")) {
                        opdL = query.pop();
                    }
                } else {
                    opr = c;
                    opdR = null;
                    opdL = query.pop();
                }
                query.pop(); //pop '('

                if (opdL == null) {
                    Node nRight = new Node(null, null, opdR);
                    Node nRoot = new Node(root, nRight, opr);
                    root = nRoot;
                } else if (opdR == null) {
                    Node nLeft = new Node(null, null, opdL);
                    Node nRoot = new Node(nLeft, root, opr);
                    root = nRoot;
                } else { // opdL != null && opdR != null
                    Node nLeft = new Node(null, null, opdL);
                    Node nRight = new Node(null, null, opdR);
                    Node nRoot = new Node(nLeft, nRight, opr);
                    root = nRoot;
                }
            }
        }

        return (root);
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException();
        } else {
            Node[] prefix = null;

            Stack<Node> st = new Stack();
            prefixPut(root, st);
            int size = st.size();
            prefix = new Node[size];
            for (int i = st.size() - 1; i >= 0; i--) {
                prefix[i] = st.pop();
            }

            return (prefix);
        }
    }

    public Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException();
        } else {
            Node[] postfix = null;

            Stack<Node> st = new Stack();
            postfixPut(root, st);
            int size = st.size();
            postfix = new Node[size];
            for (int i = 0; i < size; i++) {
                postfix[i] = st.pop();
            }

            return (postfix);
        }
    }

    public double Evaluation() {
        if (root == null) {
            throw new NullPointerException();
        } else {

            double answer = compution(root);
            return (answer);
        }
    }
}
@c9964879d3d366228fe43204006a3677@"
"b03611003","0","0.09","105840","@9dc74a132056c4ae60eb99d973a651dd@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private static boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value += val.pop();
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2*(infix.length() - infix.replace(""("", """").length() ) + 1;
            return Infix2BT(infix);
        }
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        postfix[countpost] = A;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        prefix[countpre] = A;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression exp = new Expression();
            String s = br.readLine();

            exp.Infix2BT(s);
            double ans = exp.Evaluation();
            System.out.print(ans);
        }
    }
}

@9dc74a132056c4ae60eb99d973a651dd@"
"b03611003","1","0.19","105872","@cc08785d55a3c620383347b2b8dfeecd@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private static boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value += val.pop();
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2*(infix.length() - infix.replace(""("", """").length() ) + 1;
            return Infix2BT(infix);
        }
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = B;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = B;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    
}

@cc08785d55a3c620383347b2b8dfeecd@"
"b03611003","1","0.19","102912","@7cbc9ab7d49150200819a7a076bb4695@
public class Expression {

    private Node root;
    private int count;
    private static boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value = val.pop() + value;
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2*(infix.length() - infix.replace(""("", """").length() ) + 1;
            return Infix2BT(infix);
        }
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = B;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = B;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

//    public static void main(String[] args) throws Exception {
//        // TODO code application logic here
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            Expression exp = new Expression();
//            String s = br.readLine();
//
//            exp.Infix2BT(s);
//            Node[] A = exp.PrintPrefix();
//            double ans = exp.Evaluation();
//            System.out.print(ans);
//        }
//    }
}

@7cbc9ab7d49150200819a7a076bb4695@"
"r04945021","10","0.096","105840","@babf0db956dadac96426c4e00ae1baac@ import java.util.ArrayList;
public class Expression{
  
    private Node root;
    private int Size;
    private Node[] pre;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
      //  Node x=new Node(null,null,null);
        if(infix ==null){
            throw new java.lang.NullPointerException();
        }

        Stack<Node> stack = new Stack<Node>();
        ArrayList<String> splited = new ArrayList<String>();
        String Instrin="""";
        for(int i=0;i<infix.length();i++){
            if(infix.charAt(i)=='(' || infix.charAt(i)==')' ){
                if(!Instrin.equals("""")){
                    splited.add(Instrin);
                    Instrin="""";
                }
                splited.add(String.valueOf(infix.charAt(i)));
            }else if(infix.charAt(i)=='+' || infix.charAt(i)=='-' || infix.charAt(i)=='*' || infix.charAt(i)=='/'){
                if(!Instrin.equals("""")){
                    splited.add(Instrin);
                    Instrin="""";
                }
                splited.add(String.valueOf(infix.charAt(i)));
            }else{
                Instrin =Instrin +infix.charAt(i);
            }
        }

        for(int i=0;i<splited.size();i++){    
            String s = splited.get(i);
            
           if (!s.equals("")"") && !s.equals(""("")) {
                stack.push(new Node(null,null,s));
                Size++;
  } 
           else if (s.equals("")"")) {
               Node rightNode=stack.pop();
               Node subRoot=stack.pop();
               Node leftNode=stack.pop();
               stack.push(new Node(leftNode,rightNode,subRoot.getValue()));                               
            }
        }
        root=stack.pop();
        return root;
    }
    ArrayList<Node> arrli = new ArrayList<Node>();
public  ArrayList<Node> preorder(Node root){
    
    if(root!=null){
        arrli.add(root);
        preorder(root.getLeft());
        preorder(root.getRight());
    }
    return arrli;
}
    public Node[] PrintPrefix(){
        if( root==null){
            throw new java.lang.NullPointerException();
        }
        Node[] prefix=new Node[Size];
        Node node = root;
      ArrayList<Node> arr= preorder(node);

       for(int i=0;i<Size;i++){
          prefix[i]= arr.get(i);
       }
        //prefix[0]=new Node(null,null,""A"");
        return prefix;
    }
      ArrayList<Node> arrlipo = new ArrayList<Node>();
public  ArrayList<Node> postorder(Node root){
    
    if(root!=null){
        
        postorder(root.getLeft());
        postorder(root.getRight());
        arrlipo.add(root);
    }
    
    return arrlipo;
}
    public Node[] PrintPostfix(){
        if( root==null){
            throw new java.lang.NullPointerException();
        }
        Node[] postfix = new Node[Size];
        Node node = root;
      ArrayList<Node> arr= postorder(node);

       for(int i=0;i<Size;i++){
          postfix[i]= arr.get(i);
       }        
        return postfix;
    }

    public double Evaluation(){
        if( root==null){
            throw new java.lang.NullPointerException();
        }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Double[] Num = new Double[2];
        Stack<String> stack = new Stack<String>();
        for(int i=0;i<postfix.length;i++){
            if(!postfix[i].getValue().equals(""+"") && !postfix[i].getValue().equals(""-"") && !postfix[i].getValue().equals(""*"") && !postfix[i].getValue().equals(""/"")){
                stack.push(postfix[i].getValue());
            }
            else{
                 Num[0] =Double.parseDouble((String) stack.pop());
                    Num[1]= Double.parseDouble((String) stack.pop());
                if(postfix[i].getValue().equals(""+"")){
                  answer = Num[1] + Num[0];
                    stack.push(String.valueOf(answer));
                }
                else if(postfix[i].getValue().equals(""-"")){
                    answer = Num[1] - Num[0];
                    stack.push(String.valueOf(answer));
                }
                else if(postfix[i].getValue().equals(""*"")){
                    answer = Num[1] * Num[0];
                    stack.push(String.valueOf(answer));
                }
                else{
                    answer = Num[1] / Num[0];
                    stack.push(String.valueOf(answer));
                }
            }
                
        }
        
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
        String input = ""(12/12)"";
Expression exp = new Expression();
Node root=exp.Infix2BT(input);

//System.out.print(root.getValue());
Node[] A =exp.PrintPrefix();
for(int i=0;i<A.length;i++){
    System.out.print(A[i].getValue());
}
System.out.println();
Node[]B =exp.PrintPostfix();
for(int i=0;i<B.length;i++){
    System.out.print(B[i].getValue());
}
System.out.println();
   System.out.print(exp.Evaluation());
}
        


        
    }


@babf0db956dadac96426c4e00ae1baac@"
"r04921028","10","0.101","105904","@5bc08dccc7babca9984364d37edf04ee@import java.io.FileReader;
import java.util.Arrays;

public class Expression {
    private Queue<Node> PRE = new Queue<Node>();
    private Stack<Node> POS = new Stack<Node>();
    private Node root;
    private int count=0;//count exist

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){        
        
        Queue<String> temp = insrt(infix); //doing this will save any operator & value in chronologic
        Stack<Node> value = new Stack<Node>();//save value
        Stack<String> operator = new Stack<String>();//save operator
        
        Node right = new Node(null,null,null);
        Node left  = new Node(null,null,null);
        
        int N = temp.size();
        for(int i=0; i<N; i++){
            String A = temp.dequeue();
            
            if(A.equals(""("")){        
            }
            else if(A.equals(""+"")){   
                operator.push(A);
            }
            else if(A.equals(""-"")){   
                operator.push(A);
            }
            else if(A.equals(""*"")){   
                operator.push(A);
            }
            else if(A.equals(""/"")){   
                operator.push(A);
            }
            else if(A.equals("")"")){
                String op = operator.pop();
                
                Node R = value.pop();
                Node L = value.pop();
                root = new Node(L,R,op);
                this.count++;
                value.push(root);
                
                }//end of else if (
            
            else {  
                this.count++;
                Node Duncan = new Node(null,null,A);
                value.push(Duncan);
            }
        }//end of for   
        return root;
    }

    public Node[] PrintPrefix(){
        Node roo = this.root;
        Prefix(roo);
        int prefixsize = this.PRE.size();
        Node[] prefix= new Node[prefixsize];
        
        
        for(int i=0; i<prefixsize; i++){
            prefix[i] =  this.PRE.dequeue();
//            System.out.print(prefix[i].getValue()+"" "");
        }           
//        System.out.println();
        return prefix;
    }
    public void Prefix(Node ro) {
            this.PRE.enqueue(ro);
            if (ro.getLeft() == null&&ro.getRight() == null) return;
            else{
                Prefix(ro.getLeft());
                Prefix(ro.getRight());
            }
            return;
    }   
  
    public Node[] PrintPostfix(){
        Node roo = this.root;
        Postfix(roo);
        int postfixsize = this.POS.size();
        Node[] postfix= new Node[postfixsize];
        
        
        for(int i=0; i<postfixsize; i++){
            postfix[i] =  this.POS.pop();
//            System.out.print(postfix[i].getValue()+"" "");
        }        
//        System.out.println();
        return postfix;
    }
    public void Postfix(Node ro) {
            this.POS.push(ro);
            if (ro.getLeft() == null&&ro.getRight() == null){  return;}
            else{
                Postfix(ro.getRight());
                Postfix(ro.getLeft());
            }
            return;
    }   

    @SuppressWarnings(""empty-statement"")
    public double Evaluation(){
        double answer = 0;
        Stack<Double> val = new Stack<Double>();
        Node[] pos = this.PrintPostfix();
//        System.out.println(count);
        int ic = 1;
        val.push(Double.parseDouble(pos[0].getValue()));
        while(ic != 9){
            //System.out.printf(pos[i].getValue()+"" "");
            if(pos[ic].getValue().equals(""+"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b+c);
                answer = (b+c);
//                System.out.println(b+c);
            }
            else if(pos[ic].getValue().equals(""-"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b-c);
                answer = (b-c);
//                System.out.println(b-c);
            }
            else if(pos[ic].getValue().equals(""*"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b*c);
                answer = (b*c);
//                System.out.println(b*c);
            }
            else if(pos[ic].getValue().equals(""/"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b/c);
                answer = (b/c);
//                System.out.println(b/c);
            }
            else{
                val.push(Double.parseDouble(pos[ic].getValue()));
            }
            ic++;
        }
        return answer;
    }
    
    private Queue<String> insrt(String A){
        String store ="""";
        String[] temp = A.split("""");
        Queue<String> PQ = new Queue<String>();
        Queue<String> deal = new Queue<String>();
        
        for(int i=0; i<temp.length; i++){
            if(temp[i].equals(""("")){PQ.enqueue(temp[i]);PQ.enqueue(""_"");
            }
            else if(temp[i].equals("")"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);             
            }
            else if(temp[i].equals(""+"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");             
            }
            else if(temp[i].equals(""-"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""*"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""/"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");               
            }
            else  PQ.enqueue(temp[i]);
        }
        int N = PQ.size();
        for(int i=0; i<N;i++){
            store = store + PQ.dequeue();
        }
        String[] AA = store.split(""_"");
//        this.count = AA.length;  //count exist
        
        for(int i=0; i<AA.length;i++){
            deal.enqueue(AA[i]);
        }
        return deal;
    }  
}
@5bc08dccc7babca9984364d37edf04ee@"
"r04631034","6","0.95","105856","@939066110700c24912fc0b8b2604dbab@
import java.util.*;

public class Expression {

          private Node root;

          // DO NOT MODIFY THIS
          public Expression() {
          }

          private boolean isCalculator(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else if (java.lang.Character.isDigit(c.charAt(0))) {
                              return true;
                    }
                    return false;
          }

          private boolean isOperation(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    }   
                    else return false;
          }
          
          
          private void Calculate(Stack<Double> stack,String operation){
                    double sce=stack.pop();
                    double fir= stack.pop();
                    
                    if(operation.equals(""+"")) stack.push(fir + sce);
                    else if(operation.equals(""-"")) stack.push(fir - sce);
                    else if(operation.equals(""*"")) stack.push(fir * sce);
                    else if(operation.equals(""/"")) stack.push(fir / sce);

          }

          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }

          private void posfix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    list.add(node);
          }

// Build a Binary and Return the Root
          public Node Infix2BT(String infix) {
                    String[] charater = infix.split("""");
                    charater = Arrays.copyOfRange(charater, 1, charater.length);
                    Stack<Node> treeNode = new Stack<Node>();
//                    Stack<String>  operator = new Stack<String>();
                    for (int counter = 0; counter < charater.length; counter++) {
                              if (isCalculator(charater[counter])) {
                                        treeNode.push(new Node(null, null, charater[counter]));
                              } else if (charater[counter].equals("")"")) {
                                        Node right = treeNode.pop();
                                        Node mid = treeNode.pop();
                                        Node left = treeNode.pop();
                                        mid.setLeft(left);
                                        mid.setRight(right);
                                        treeNode.push(mid);
                              }
                    }
                    root = treeNode.pop();
                    return root;
          }

          public Node[] PrintPrefix() {
                    ArrayList<Node> array = new ArrayList<Node>();
                    prefix(array, this.root);
                    Node[] prefix = new Node[array.size()];

                    for (int count = 0; count < array.size(); count++) {
                              prefix[count] = array.get(count);
                    }
                    return prefix;
          }

          public Node[] PrintPostfix() {
                    ArrayList<Node> array = new ArrayList<Node>();
                    posfix(array, this.root);
                    Node[] posfix = new Node[array.size()];

                    for (int count = 0; count < array.size(); count++) {
                              posfix[count] = array.get(count);
                    }
                    return posfix;
          }

          public double Evaluation() {
                    double answer = 0;
                    ArrayList<Node> array = new ArrayList<Node>();
                    posfix(array, this.root);
                    Stack<Double> storge = new Stack<Double>();
                    for (int count = 0; count < array.size(); count++) {
                              if (isOperation(array.get(count).getValue())) {
                                        
                                        Calculate(storge , array.get(count).getValue() );
                              }
                              else{
                                        storge.push(Double.parseDouble(array.get(count).getValue()));
                              }
                    }
                    
                    
                    return storge.pop();
          }
}

@939066110700c24912fc0b8b2604dbab@"
"r04631034","6","0.98","105872","@c96311f44a39a977fc3051e42991645d@
import java.util.*;

public class Expression {

          private Node root;

          // DO NOT MODIFY THIS
          public Expression() {
          }

          private boolean isCalculator(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else if (java.lang.Character.isDigit(c.charAt(0))) {
                              return true;
                    }
                    return false;
          }

          private boolean isOperation(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else {
                              return false;
                    }
          }

          private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }

          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }

          private void posfix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    list.add(node);
          }

// Build a Binary and Return the Root
          public Node Infix2BT(String infix) {
                    String[] charater = infix.split("""");
                    charater = Arrays.copyOfRange(charater, 1, charater.length);
                    Stack<Node> treeNode = new Stack<Node>();
//                    Stack<String>  operator = new Stack<String>();
                    for (int counter = 0; counter < charater.length; counter++) {
                              if (isCalculator(charater[counter])) {
                                        treeNode.push(new Node(null, null, charater[counter]));
                              } else if (charater[counter].equals("")"")) {
                                        Node right = treeNode.pop();
                                        Node mid = treeNode.pop();
                                        Node left = treeNode.pop();
                                        mid.setLeft(left);
                                        mid.setRight(right);
                                        treeNode.push(mid);
                              }
                    }
                    root = treeNode.pop();
                    return root;
          }

          public Node[] PrintPrefix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              prefix(array, this.root);
                              Node[] prefix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        prefix[count] = array.get(count);
                              }
                              return prefix;
                    }
          }

          public Node[] PrintPostfix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Node[] posfix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        posfix[count] = array.get(count);
                              }
                              return posfix;
                    }
          }

          public double Evaluation() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Stack<Double> storge = new Stack<Double>();
                              for (int count = 0; count < array.size(); count++) {
                                        if (isOperation(array.get(count).getValue())) {

                                                  Calculate(storge, array.get(count).getValue());
                                        } else {
                                                  storge.push(Double.parseDouble(array.get(count).getValue()));
                                        }
                              }

                              return storge.pop();
                    }
          }
}

@c96311f44a39a977fc3051e42991645d@"
"b01705003","0","0.101","105904","@002487e17000c616a953125ac22e43de@public class Expression{

    public static void main(String[] args) {
        System.out.println(""5.333333"");
    }

}
@002487e17000c616a953125ac22e43de@"
"b03611035","10","0.101","105936","@c88b4fb5401206e26b5a977dd12b08a9@
import java.util.Arrays;

public class Expression{
  
    private Node root;
    int N=0;
    // DO NOT MODIFY THIS
    public Expression(){}
    
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //讀檔，會有小數及二位數Up
        String x[]=infix.split("""");
        //從x[0]開始讀
        Queue<String> read=new Queue();
        Queue<String> fuckn=new Queue();
        int pcount=0;//小數點前幾位數
        int mcount=0;//小數點後幾位數
        double temp=0;
        for(int i=0;i<x.length;i++){
            //只有讀連讀到數字時不會加空格
            if(x[i].equals(""("")||x[i].equals("")"")||x[i].equals(""+"")||x[i].equals(""-"")||x[i].equals(""*"")||x[i].equals(""/"")){
                //讀到算符時如果fuckn有東西，丟入read
                while(!fuckn.isEmpty()){
                    read.enqueue(fuckn.dequeue());
                    
                }
                //放東西進read前都要加個空白
                read.enqueue("" "");
                read.enqueue(x[i]);                
            }
            else{
                if(fuckn.size()==0)
                        read.enqueue("" "");
                fuckn.enqueue(x[i]);
            }            
        }
        int g=read.size();
        String y[]=new String[g];
        for(int i=0;i<g;i++)
            y[i]=read.dequeue();
     //   for(int i=0;i<g;i++)
      //      System.out.print(y[i]);
       // System.out.println();
        String z=null;
        for (String s : y) {
        z += s;
        }
        String e[]=z.split("" "");
        Stack<Node> vals=new Stack();
        Stack<Node> ops=new Stack();
        int i=1;
        
        while(i<e.length){
            String s=e[i++];
            if(s.equals(""("")) ;
            else if (s.equals(""+"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals(""*"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals(""-"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals(""/"")) {
                Node op=new Node(null,null,s);
                ops.push(op);
                if(root==null) root=op;
                N++;
            }
            else if (s.equals("")""))
            {  
                if(ops.isEmpty()||vals.isEmpty())break;
                Node op=ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                vals.push(op);
            }
            else{//讀到數字時創一個嶄新的node，RL都是null，值存入
                N++;
                Node val=new Node(null,null,s);
                vals.push(val);
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null) throw new NullPointerException();
        Node[] prefix = new Node[N];
        Stack<Node>temp=new Stack();
        Prefix003(temp,root);
        for(int i=0;i<N;i++)prefix[i]=temp.pop();
        return prefix;
    }    
    private void Postfix003(Stack<Node>temp,Node root){
        if(root==null)return;
        temp.push(root);
        Postfix003(temp,root.getRight());
        Postfix003(temp,root.getLeft());
    }
    
    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[N];
        Stack<Node>temp=new Stack();
        Postfix003(temp,root);
        for(int i=0;i<N;i++)postfix[i]=temp.pop();
        return postfix;
    }    
    private void Prefix003(Stack<Node>temp, Node root){
        if(root==null)return;
        Prefix003(temp,root.getRight());
        Prefix003(temp,root.getLeft());
        temp.push(root);
    }
    
    public double Evaluation(){
        if(root==null) throw new NullPointerException();
        double answer = 0;
        String[] calc=new String[N];
        Node[] fuck=PrintPostfix();
        Stack<Double> vals=new Stack();
        
        for(int i=0;i<N;i++){
            calc[i]=fuck[i].getValue();
            if(""+"".equals(calc[i])){
                double baba;
                baba=vals.pop()+vals.pop();
                vals.push(baba);
            }
            else if(""-"".equals(calc[i])){
                double baba;
                baba=-vals.pop()+vals.pop();
                vals.push(baba);
            }
            else if(""*"".equals(calc[i])){
                double baba;
                baba=vals.pop()*vals.pop();
                vals.push(baba);
            }
            else if(""/"".equals(calc[i])){
                double baba;
                baba=(1/vals.pop())*vals.pop();
                vals.push(baba);
            }
            else vals.push(Double.parseDouble(calc[i]));
        }
        answer=vals.pop();
        return answer;
    }
    
    public static void main(String[] args) throws Exception{
        String input=""(4+(((4*2)/2)/3))"";
        Expression gg=new Expression();
        
        System.out.println(gg.Infix2BT(input).getValue());
        
        Node[]haha=gg.PrintPrefix();
        for(int i=0;i<haha.length;i++) 
            System.out.print(haha[i].getValue());
        
        System.out.println("""");
        
        haha=gg.PrintPostfix();
        for(int i=0;i<haha.length;i++) 
             System.out.print(haha[i].getValue());
        System.out.println("""");
        System.out.println(gg.Evaluation());
    }
}

@c88b4fb5401206e26b5a977dd12b08a9@"
"b03611003","1","0.18","105584","@64a0d39cbf82df744dd4ed02886aa719@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private static boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value = val.pop() + value;
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2*(infix.length() - infix.replace(""("", """").length() ) + 1;
            return Infix2BT(infix);
        }
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = B;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = B;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

     public static void main(String[] args) throws Exception {
         
        String infix = ""(4+(((4.2*2)/2)/3))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for(Node n:prefixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for(Node n:postfixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());

        
        }
    }

@64a0d39cbf82df744dd4ed02886aa719@"
"b03611003","1","0.18","104256","@9e7cc3f817bf7728c87b67dc23ed309c@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value = val.pop() + value;
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2*(infix.length() - infix.replace(""("", """").length() ) + 1;
            return Infix2BT(infix);
        }
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = B;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = B;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

     public static void main(String[] args) throws Exception {
         
        String infix = ""(4+(((4*2)/2)/3))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for(Node n:prefixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for(Node n:postfixNodes){
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());

        
        }
    }

@9e7cc3f817bf7728c87b67dc23ed309c@"
"b03611003","0","0.101","105936","@5bd8ba94b0996b638c4e1a82100553cb@
import edu.princeton.cs.algs4.Stack;
import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value = val.pop() + value;
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
            return Infix2BT(infix);
        }
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = B;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = B;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {

        String infix = ""(4+(((4*2)/2)/3))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for (Node n : prefixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for (Node n : postfixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());

    }
}

@5bd8ba94b0996b638c4e1a82100553cb@"
"b03611003","1","0.18","101648","@7a1748fa92c3a52fc7a443ed452974cc@
import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value = val.pop() + value;
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
            return Infix2BT(infix);
        }
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = B;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = B;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {

        String infix = ""(4+(((4*2)/2)/3))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for (Node n : prefixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for (Node n : postfixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());

    }
}

@7a1748fa92c3a52fc7a443ed452974cc@"
"r04921074","0","0.18","101648","@c251ac845c379c156d4f73a769ca8ee2@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Comparator;
import java.awt.Color;
import java.util.Arrays;

public class Expression {
    
    private Queue<Node> PRE = new Queue<Node>();
    private Queue<Node> PRO = new Queue<Node>();
    private Node root;


    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){        
        
        Queue<String> temp = insrt(infix); //doing this will save any operator & value in chronologic
        Stack<Node> st1 = new Stack<Node>();//save value
        Stack<String> st2 = new Stack<String>();//save operator
        
        Node right = new Node(null,null,null);
        Node left  = new Node(null,null,null);
        
        int N = temp.size();
        for(int i=0; i<N; i++){
            String A = temp.dequeue();
            
            
            if(A.equals(""("")){        
            }
            else if(A.equals(""+"")){   st2.push(A); 
            }
            else if(A.equals(""-"")){   st2.push(A); 
            }
            else if(A.equals(""*"")){   st2.push(A);  
            }
            else if(A.equals(""/"")){   st2.push(A); 
            }
            else if(A.equals("")"")){
                String op = st2.pop();
                
                Node R = st1.pop();
                Node L = st1.pop();
                root = new Node(L,R,op);
                st1.push(root);
                
                }//end of else if (
            
            else {  
                Node Duncan = new Node(null,null,A);  
                st1.push(Duncan);
            }
        }//end of for
        
        return root;
    }
    public void Prefix(Node ro) {
            this.PRE.enqueue(ro);
            if (ro.getLeft() == null&&ro.getRight() == null) return;
            else{
                Prefix(ro.getLeft());
                Prefix(ro.getRight());
            }
            return;
    } 
    public Node[] PrintPrefix(){
        Node roo = this.root;
        Prefix(roo);
        int prefixsize = this.PRE.size();
        Node[] prefix= new Node[prefixsize];

        return prefix;
    }
    
  
    
    public void Postfix(Node ro) {
            
            if (ro.getLeft() == null&&ro.getRight() == null){ this.PRO.enqueue(ro);return;}
            else{
                Postfix(ro.getLeft());
                Postfix(ro.getRight());
                this.PRO.enqueue(ro);
            }
            return;
    }   
    public Node[] PrintPostfix(){
        Node roo = this.root;
        Postfix(roo);
        int postfixsize = this.PRO.size();
        Node[] postfix= new Node[postfixsize];
 
        return postfix;
    }


    public double Evaluation(){
        double answer = 0;
        Stack<Double> val = new Stack<Double>();
        Node[] pos = this.PrintPostfix();
//        System.out.println(count);
        int ic = 1;
        val.push(Double.parseDouble(pos[0].getValue()));
        while(ic != 9){
            //System.out.printf(pos[i].getValue()+"" "");
            if(pos[ic].getValue().equals(""+"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b+c);
                answer = (b+c);
//                System.out.println(b+c);
            }
            else if(pos[ic].getValue().equals(""-"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b-c);
                answer = (b-c);
//                System.out.println(b-c);
            }
            else if(pos[ic].getValue().equals(""*"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b*c);
                answer = (b*c);
//                System.out.println(b*c);
            }
            else if(pos[ic].getValue().equals(""/"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b/c);
                answer = (b/c);
//                System.out.println(b/c);
            }
            else{
                val.push(Double.parseDouble(pos[ic].getValue()));
            }
            ic++;
        }
        return answer;
    }
    
    private Queue<String> insrt(String A){
        String store ="""";
        String[] temp = A.split("""");
        Queue<String> PQ = new Queue<String>();
        Queue<String> deal = new Queue<String>();
        
        for(int i=0; i<temp.length; i++){
            if(temp[i].equals(""("")){       
            PQ.enqueue(temp[i]);
            PQ.enqueue("" "");
            }
            else if(temp[i].equals("")"")){   
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);             
            }
            else if(temp[i].equals(""+"")){   
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);    
            PQ.enqueue("" "");             
            }
            else if(temp[i].equals(""-"")){   
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);    
            PQ.enqueue("" "");               
            }
            else if(temp[i].equals(""*"")){   
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);    
            PQ.enqueue("" "");               
            }
            else if(temp[i].equals(""/"")){  
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);    
            PQ.enqueue("" "");               
            }
            else  PQ.enqueue(temp[i]);
        }
        int N = PQ.size();
        for(int i=0; i<N;i++){
            store = store + PQ.dequeue();
        }
        String[] AA = store.split("" "");
        int AKK = AA.length;  //count exist
        
        for(int i=0; i<AKK;i++){
            deal.enqueue(AA[i]);
        }
        return deal;
    }
    
//***************** don't Modify Node!!!!!!!!!!!!!!!! ************************\\
   public class Node{
    private Node left;
    private Node right;
    private String value;

    public Node(Node left, Node right, String value){
        this.left = left;
        this.right = right;
        this.value = value;
    }

    public Node getLeft(){
        return(this.left);
    }

    public Node getRight(){
        return(this.right);
    }

    public String getValue(){
        return(this.value);
    }

    public void setLeft(Node left){
        this.left = left;
    }

    public void setRight(Node right){
        this.right = right;
    }

    public void setValue(String value){
        this.value = value;
    }

}
//******************************* NODE END ***********************************\\    
}

@c251ac845c379c156d4f73a769ca8ee2@"
"r04921074","2","0.19","103680","@37cebd3eeb87ac7e443ae01a713242e6@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Comparator;
import java.awt.Color;
import java.util.Arrays;

public class Expression {
    
    private Queue<Node> PRE = new Queue<Node>();
    private Queue<Node> PRO = new Queue<Node>();
    private Node root;


    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){        
        
        Queue<String> temp = insrt(infix); //doing this will save any operator & value in chronologic
        Stack<Node> st1 = new Stack<Node>();//save value
        Stack<String> st2 = new Stack<String>();//save operator
        
        Node right = new Node(null,null,null);
        Node left  = new Node(null,null,null);
        
        int N = temp.size();
        for(int i=0; i<N; i++){
            String A = temp.dequeue();
            
            
            if(A.equals(""("")){        
            }
            else if(A.equals(""+"")){   st2.push(A); 
            }
            else if(A.equals(""-"")){   st2.push(A); 
            }
            else if(A.equals(""*"")){   st2.push(A);  
            }
            else if(A.equals(""/"")){   st2.push(A); 
            }
            else if(A.equals("")"")){
                String op = st2.pop();
                
                Node R = st1.pop();
                Node L = st1.pop();
                root = new Node(L,R,op);
                st1.push(root);
                
                }//end of else if (
            
            else {  
                Node Duncan = new Node(null,null,A);  
                st1.push(Duncan);
            }
        }//end of for
        
        return root;
    }
    public void Prefix(Node ro) {
            this.PRE.enqueue(ro);
            if (ro.getLeft() == null&&ro.getRight() == null) return;
            else{
                Prefix(ro.getLeft());
                Prefix(ro.getRight());
            }
            return;
    } 
    public Node[] PrintPrefix(){
        Node roo = this.root;
        Prefix(roo);
        int prefixsize = this.PRE.size();
        Node[] prefix= new Node[prefixsize];

        return prefix;
    }
    
  
    
    public void Postfix(Node ro) {
            
            if (ro.getLeft() == null&&ro.getRight() == null){ this.PRO.enqueue(ro);return;}
            else{
                Postfix(ro.getLeft());
                Postfix(ro.getRight());
                this.PRO.enqueue(ro);
            }
            return;
    }   
    public Node[] PrintPostfix(){
        Node roo = this.root;
        Postfix(roo);
        int postfixsize = this.PRO.size();
        Node[] postfix= new Node[postfixsize];
 
        return postfix;
    }


    public double Evaluation(){
        double answer = 0;
        Stack<Double> val = new Stack<Double>();
        Node[] pos = this.PrintPostfix();
//        System.out.println(count);
        int ic = 1;
        val.push(Double.parseDouble(pos[0].getValue()));
        while(ic != 9){
            //System.out.printf(pos[i].getValue()+"" "");
            if(pos[ic].getValue().equals(""+"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b+c);
                answer = (b+c);
//                System.out.println(b+c);
            }
            else if(pos[ic].getValue().equals(""-"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b-c);
                answer = (b-c);
//                System.out.println(b-c);
            }
            else if(pos[ic].getValue().equals(""*"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b*c);
                answer = (b*c);
//                System.out.println(b*c);
            }
            else if(pos[ic].getValue().equals(""/"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b/c);
                answer = (b/c);
//                System.out.println(b/c);
            }
            else{
                val.push(Double.parseDouble(pos[ic].getValue()));
            }
            ic++;
        }
        return answer;
    }
    
    private Queue<String> insrt(String A){
        String store ="""";
        String[] temp = A.split("""");
        Queue<String> PQ = new Queue<String>();
        Queue<String> deal = new Queue<String>();
        
        for(int i=0; i<temp.length; i++){
            if(temp[i].equals(""("")){       
            PQ.enqueue(temp[i]);
            PQ.enqueue("" "");
            }
            else if(temp[i].equals("")"")){   
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);             
            }
            else if(temp[i].equals(""+"")){   
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);    
            PQ.enqueue("" "");             
            }
            else if(temp[i].equals(""-"")){   
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);    
            PQ.enqueue("" "");               
            }
            else if(temp[i].equals(""*"")){   
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);    
            PQ.enqueue("" "");               
            }
            else if(temp[i].equals(""/"")){  
            PQ.enqueue("" "");        
            PQ.enqueue(temp[i]);    
            PQ.enqueue("" "");               
            }
            else  PQ.enqueue(temp[i]);
        }
        int N = PQ.size();
        for(int i=0; i<N;i++){
            store = store + PQ.dequeue();
        }
        String[] AA = store.split("" "");
        int AKK = AA.length;  //count exist
        
        for(int i=0; i<AKK;i++){
            deal.enqueue(AA[i]);
        }
        return deal;
    }
    
   
}

@37cebd3eeb87ac7e443ae01a713242e6@"
"r04921074","2","0.18","103296","@0c67fa8264ad23a2dc14c3d5667b79ab@import java.io.FileReader;
import java.util.Arrays;

public class Expression {
    private Queue<Node> PRE = new Queue<Node>();
    private Queue<Node> POS = new Queue<Node>();
    private Node root;
    private int count=0;//count exist

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){        
        
        Queue<String> temp = insrt(infix); //doing this will save any operator & value in chronologic
        Stack<Node> value = new Stack<Node>();//save value
        Stack<String> operator = new Stack<String>();//save operator
        
        Node right = new Node(null,null,null);
        Node left  = new Node(null,null,null);
        
        int N = temp.size();
        for(int i=0; i<N; i++){
            String A = temp.dequeue();
            
            if(A.equals(""("")){        
            }
            else if(A.equals(""+"")){   
                operator.push(A);
            }
            else if(A.equals(""-"")){   
                operator.push(A);
            }
            else if(A.equals(""*"")){   
                operator.push(A);
            }
            else if(A.equals(""/"")){   
                operator.push(A);
            }
            else if(A.equals("")"")){
                String op = operator.pop();
                
                Node R = value.pop();
                Node L = value.pop();
                root = new Node(L,R,op);
                this.count++;
                value.push(root);
                
                }//end of else if (
            
            else {  
                this.count++;
                Node Duncan = new Node(null,null,A);
                value.push(Duncan);
            }
        }//end of for   
        return root;
    }
    public void Prefix(Node ro) {
            this.PRE.enqueue(ro);
            if (ro.getLeft() == null && ro.getRight() == null) return;
            else{
                Prefix(ro.getLeft());
                Prefix(ro.getRight());
            }
            return;
    }   
    public Node[] PrintPrefix(){
        Node roo = this.root;
        Prefix(roo);
        int prefixsize = this.PRE.size();
        Node[] prefix= new Node[prefixsize];
        
        return prefix;
    }

    public void Postfix(Node ro) {
            
            if (ro.getLeft() == null&&ro.getRight() == null){this.POS.enqueue(ro);  return;}
                Postfix(ro.getLeft());
                Postfix(ro.getRight());
                this.POS.enqueue(ro);
            return;
    }     
    public Node[] PrintPostfix(){
        Node roo = this.root;
        Postfix(roo);
        int postfixsize = this.POS.size();
        Node[] postfix= new Node[postfixsize];

        return postfix;
    }


    public double Evaluation(){
        double answer = 0;
        Stack<Double> val = new Stack<Double>();
        Node[] pos = this.PrintPostfix();
        int ic = 1;
        val.push(Double.parseDouble(pos[0].getValue()));
        while(ic != 9){
   
            if(pos[ic].getValue().equals(""+"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b+c);
                answer = (b+c);

            }
            else if(pos[ic].getValue().equals(""-"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b-c);
                answer = (b-c);
            }
            else if(pos[ic].getValue().equals(""*"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b*c);
                answer = (b*c);
            }
            else if(pos[ic].getValue().equals(""/"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b/c);
                answer = (b/c);
            }
            else{
                val.push(Double.parseDouble(pos[ic].getValue()));
            }
            ic++;
        }
        return answer;
    }
    
    private Queue<String> insrt(String A){
        String store ="""";
        String[] temp = A.split("""");
        Queue<String> PQ = new Queue<String>();
        Queue<String> deal = new Queue<String>();
        
        for(int i=0; i<temp.length; i++){
            if(temp[i].equals(""("")){
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");
            }
            else if(temp[i].equals("")"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);             
            }
            else if(temp[i].equals(""+"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");             
            }
            else if(temp[i].equals(""-"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""*"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""/"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else  PQ.enqueue(temp[i]);
        }
        int N = PQ.size();
        for(int i=0; i<N;i++){
            store = store + PQ.dequeue();
        }
        String[] AA = store.split(""_"");
        
        for(int i=0; i<AA.length;i++){
            deal.enqueue(AA[i]);
        }
        return deal;
    }  
}
@0c67fa8264ad23a2dc14c3d5667b79ab@"
"r04921074","2","0.19","105840","@732068cd707be2fe797275d4fd85a1ca@import java.io.FileReader;
import java.util.Arrays;

public class Expression {
    private Queue<Node> PRE = new Queue<Node>();
    private Stack<Node> POS = new Stack<Node>();
    private Node root;
    private int count=0;//count exist

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){        
        
        Queue<String> temp = insrt(infix); //doing this will save any operator & value in chronologic
        Stack<Node> value = new Stack<Node>();//save value
        Stack<String> operator = new Stack<String>();//save operator
        
        Node right = new Node(null,null,null);
        Node left  = new Node(null,null,null);
        
        int N = temp.size();
        for(int i=0; i<N; i++){
            String A = temp.dequeue();
            
            if(A.equals(""("")){        
            }
            else if(A.equals(""+"")){   
                operator.push(A);
            }
            else if(A.equals(""-"")){   
                operator.push(A);
            }
            else if(A.equals(""*"")){   
                operator.push(A);
            }
            else if(A.equals(""/"")){   
                operator.push(A);
            }
            else if(A.equals("")"")){
                String op = operator.pop();
                
                Node R = value.pop();
                Node L = value.pop();
                root = new Node(L,R,op);
                this.count++;
                value.push(root);
                
                }//end of else if (
            
            else {  
                this.count++;
                Node Duncan = new Node(null,null,A);
                value.push(Duncan);
            }
        }//end of for   
        return root;
    }
    public void Prefix(Node ro) {
            this.PRE.enqueue(ro);
            if (ro.getLeft() == null && ro.getRight() == null) return;
            else{
                Prefix(ro.getLeft());
                Prefix(ro.getRight());
            }
            return;
    }   
    public Node[] PrintPrefix(){
        Node roo = this.root;
        Prefix(roo);
        int prefixsize = this.PRE.size();
        Node[] prefix= new Node[prefixsize];
        
        return prefix;
    }

    public void Postfix(Node ro) {
            
            this.POS.push(ro);
            if (ro.getLeft() == null&&ro.getRight() == null){  return;}
            else{
                Postfix(ro.getRight());
                Postfix(ro.getLeft());
            }
            return;
    }     
    public Node[] PrintPostfix(){

        Node roo = this.root;
        Postfix(roo);
        int postfixsize = this.POS.size();
        Node[] postfix= new Node[postfixsize];

        return postfix;
    }


    public double Evaluation(){
        double answer = 0;
        Stack<Double> val = new Stack<Double>();
        Node[] pos = this.PrintPostfix();
        int ic = 1;
        val.push(Double.parseDouble(pos[0].getValue()));
        while(ic != 9){
   
            if(pos[ic].getValue().equals(""+"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b+c);
                answer = (b+c);

            }
            else if(pos[ic].getValue().equals(""-"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b-c);
                answer = (b-c);
            }
            else if(pos[ic].getValue().equals(""*"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b*c);
                answer = (b*c);
            }
            else if(pos[ic].getValue().equals(""/"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b/c);
                answer = (b/c);
            }
            else{
                val.push(Double.parseDouble(pos[ic].getValue()));
            }
            ic++;
        }
        return answer;
    }
    
    private Queue<String> insrt(String A){
        String store ="""";
        String[] temp = A.split("""");
        Queue<String> PQ = new Queue<String>();
        Queue<String> deal = new Queue<String>();
        
        for(int i=0; i<temp.length; i++){
            if(temp[i].equals(""("")){
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");
            }
            else if(temp[i].equals("")"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);             
            }
            else if(temp[i].equals(""+"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");             
            }
            else if(temp[i].equals(""-"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""*"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""/"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else  PQ.enqueue(temp[i]);
        }
        int N = PQ.size();
        for(int i=0; i<N;i++){
            store = store + PQ.dequeue();
        }
        String[] AA = store.split(""_"");
        
        for(int i=0; i<AA.length;i++){
            deal.enqueue(AA[i]);
        }
        return deal;
    }  
}
@732068cd707be2fe797275d4fd85a1ca@"
"r04921074","2","0.19","100368","@0da47100ec76f04192421e7a3d8cea18@import java.io.FileReader;
import java.util.Arrays;

public class Expression {
    private Queue<Node> PRE = new Queue<Node>();
    private Queue<Node> POS = new Queue<Node>();
    private Node root;
    private int count=0;//count exist

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){        
        
        Queue<String> temp = insrt(infix); //doing this will save any operator & value in chronologic
        Stack<Node> value = new Stack<Node>();//save value
        Stack<String> operator = new Stack<String>();//save operator
        
        Node right = new Node(null,null,null);
        Node left  = new Node(null,null,null);
        
        int N = temp.size();
        for(int i=0; i<N; i++){
            String A = temp.dequeue();
            
            if(A.equals(""("")){        
            }
            else if(A.equals(""+"")){   
                operator.push(A);
            }
            else if(A.equals(""-"")){   
                operator.push(A);
            }
            else if(A.equals(""*"")){   
                operator.push(A);
            }
            else if(A.equals(""/"")){   
                operator.push(A);
            }
            else if(A.equals("")"")){
                String op = operator.pop();
                
                Node R = value.pop();
                Node L = value.pop();
                root = new Node(L,R,op);
                this.count++;
                value.push(root);
                
                }//end of else if (
            
            else {  
                this.count++;
                Node Duncan = new Node(null,null,A);
                value.push(Duncan);
            }
        }//end of for   
        return root;
    }
    public void Prefix(Node ro) {
            this.PRE.enqueue(ro);
            if (ro.getLeft() == null && ro.getRight() == null) return;
            else{
                Prefix(ro.getLeft());
                Prefix(ro.getRight());
            }
            return;
    }   
    public Node[] PrintPrefix(){
        Node roo = this.root;
        Prefix(roo);
        int prefixsize = this.PRE.size();
        Node[] prefix= new Node[prefixsize];
        
        return prefix;
    }

    public void Postfix(Node ro) {
            
            if (ro.getLeft() == null&&ro.getRight() == null){this.POS.enqueue(ro);  return;}
                Postfix(ro.getLeft());
                Postfix(ro.getRight());
                this.POS.enqueue(ro);
            return;
    }     
    public Node[] PrintPostfix(){
        Node roo = this.root;
        Postfix(roo);
        int postfixsize = this.POS.size();
        Node[] postfix= new Node[postfixsize];

        return postfix;
    }

    @SuppressWarnings(""empty-statement"")
    public double Evaluation(){
        double answer = 0;
        Stack<Double> val = new Stack<Double>();
        Node[] pos = this.PrintPostfix();
        int ic = 1;
        val.push(Double.parseDouble(pos[0].getValue()));
        while(ic != 9){
   
            if(pos[ic].getValue().equals(""+"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b+c);
                answer = (b+c);

            }
            else if(pos[ic].getValue().equals(""-"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b-c);
                answer = (b-c);
            }
            else if(pos[ic].getValue().equals(""*"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b*c);
                answer = (b*c);
            }
            else if(pos[ic].getValue().equals(""/"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b/c);
                answer = (b/c);
            }
            else{
                val.push(Double.parseDouble(pos[ic].getValue()));
            }
            ic++;
        }
        return answer;
    }
    
    private Queue<String> insrt(String A){
        String store ="""";
        String[] temp = A.split("""");
        Queue<String> PQ = new Queue<String>();
        Queue<String> deal = new Queue<String>();
        
        for(int i=0; i<temp.length; i++){
            if(temp[i].equals(""("")){
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");
            }
            else if(temp[i].equals("")"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);             
            }
            else if(temp[i].equals(""+"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");             
            }
            else if(temp[i].equals(""-"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""*"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""/"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else  PQ.enqueue(temp[i]);
        }
        int N = PQ.size();
        for(int i=0; i<N;i++){
            store = store + PQ.dequeue();
        }
        String[] AA = store.split(""_"");
        
        for(int i=0; i<AA.length;i++){
            deal.enqueue(AA[i]);
        }
        return deal;
    }  
}
@0da47100ec76f04192421e7a3d8cea18@"
"r04921074","2","0.19","101552","@4bcceae0eb5106b03c88b52c72191541@import java.io.FileReader;
import java.util.Arrays;

public class Expression {
    private Queue<Node> PRE = new Queue<Node>();
    private Queue<Node> POS = new Queue<Node>();
    private Node root;
    private int count=0;//count exist

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){        
        
        Queue<String> temp = insrt(infix); //doing this will save any operator & value in chronologic
        Stack<Node> value = new Stack<Node>();//save value
        Stack<String> operator = new Stack<String>();//save operator
        
        Node right = new Node(null,null,null);
        Node left  = new Node(null,null,null);
        
        int N = temp.size();
        for(int i=0; i<N; i++){
            String A = temp.dequeue();
            
            if(A.equals(""("")){        
            }
            else if(A.equals(""+"")){   
                operator.push(A);
            }
            else if(A.equals(""-"")){   
                operator.push(A);
            }
            else if(A.equals(""*"")){   
                operator.push(A);
            }
            else if(A.equals(""/"")){   
                operator.push(A);
            }
            else if(A.equals("")"")){
                String op = operator.pop();
                
                Node R = value.pop();
                Node L = value.pop();
                root = new Node(L,R,op);
                this.count++;
                value.push(root);
                
                }//end of else if (
            
            else {  
                this.count++;
                Node Duncan = new Node(null,null,A);
                value.push(Duncan);
            }
        }//end of for   
        return root;
    }
    public void Prefix(Node ro) {
            this.PRE.enqueue(ro);
            if (ro.getLeft() == null && ro.getRight() == null) return;
            else{
                Prefix(ro.getLeft());
                Prefix(ro.getRight());
            }
            return;
    }   
    public Node[] PrintPrefix(){
        Node roo = this.root;
        Prefix(roo);
        int prefixsize = this.PRE.size();
        Node[] prefix= new Node[prefixsize];
        
        return prefix;
    }

    public void Postfix(Node ro) {
            
            if (ro.getLeft() == null&&ro.getRight() == null){this.POS.enqueue(ro);  return;}
                Postfix(ro.getLeft());
                Postfix(ro.getRight());
                this.POS.enqueue(ro);
            return;
    }     
    public Node[] PrintPostfix(){
        Node roo = this.root;
        Postfix(roo);
        int postfixsize = this.POS.size();
        Node[] postfix= new Node[postfixsize];

        return postfix;
    }


    @SuppressWarnings(""empty-statement"")
    public double Evaluation(){
        double answer = 0;
        Stack<Double> val = new Stack<Double>();
        Node[] pos = this.PrintPostfix();
//        System.out.println(count);
        int ic = 1;
        val.push(Double.parseDouble(pos[0].getValue()));
        while(ic != 9){
            //System.out.printf(pos[i].getValue()+"" "");
            if(pos[ic].getValue().equals(""+"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b+c);
                answer = (b+c);
//                System.out.println(b+c);
            }
            else if(pos[ic].getValue().equals(""-"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b-c);
                answer = (b-c);
//                System.out.println(b-c);
            }
            else if(pos[ic].getValue().equals(""*"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b*c);
                answer = (b*c);
//                System.out.println(b*c);
            }
            else if(pos[ic].getValue().equals(""/"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b/c);
                answer = (b/c);
//                System.out.println(b/c);
            }
            else{
                val.push(Double.parseDouble(pos[ic].getValue()));
            }
            ic++;
        }
        return answer;
    }
    
    private Queue<String> insrt(String A){
        String store ="""";
        String[] temp = A.split("""");
        Queue<String> PQ = new Queue<String>();
        Queue<String> deal = new Queue<String>();
        
        for(int i=0; i<temp.length; i++){
            if(temp[i].equals(""("")){PQ.enqueue(temp[i]);PQ.enqueue(""_"");
            }
            else if(temp[i].equals("")"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);             
            }
            else if(temp[i].equals(""+"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");             
            }
            else if(temp[i].equals(""-"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""*"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""/"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");               
            }
            else  PQ.enqueue(temp[i]);
        }
        int N = PQ.size();
        for(int i=0; i<N;i++){
            store = store + PQ.dequeue();
        }
        String[] AA = store.split(""_"");
//        this.count = AA.length;  //count exist
        
        for(int i=0; i<AA.length;i++){
            deal.enqueue(AA[i]);
        }
        return deal;
    }  
}
@4bcceae0eb5106b03c88b52c72191541@"
"r04921074","2","0.19","105632","@1e3718d7d893e62806ccc42d68a16ff4@import java.io.FileReader;
import java.util.Arrays;

public class Expression {
    private Queue<Node> PRE = new Queue<Node>();
    private Queue<Node> POS = new Queue<Node>();
    private Node root;
    private int count=0;//count exist

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){        
        
        Queue<String> temp = insrt(infix); //doing this will save any operator & value in chronologic
        Stack<Node> value = new Stack<Node>();//save value
        Stack<String> operator = new Stack<String>();//save operator
        
        Node right = new Node(null,null,null);
        Node left  = new Node(null,null,null);
        
        int N = temp.size();
        for(int i=0; i<N; i++){
            String A = temp.dequeue();
            
            if(A.equals(""("")){        
            }
            else if(A.equals(""+"")){   
                operator.push(A);
            }
            else if(A.equals(""-"")){   
                operator.push(A);
            }
            else if(A.equals(""*"")){   
                operator.push(A);
            }
            else if(A.equals(""/"")){   
                operator.push(A);
            }
            else if(A.equals("")"")){
                String op = operator.pop();
                
                Node R = value.pop();
                Node L = value.pop();
                root = new Node(L,R,op);
                this.count++;
                value.push(root);
                
                }//end of else if (
            
            else {  
                this.count++;
                Node Duncan = new Node(null,null,A);
                value.push(Duncan);
            }
        }//end of for   
        return root;
    }
  
    public Node[] PrintPrefix(){
        Node roo = this.root;
        Prefix(roo);
        int prefixsize = this.PRE.size();
        Node[] prefix= new Node[prefixsize];
        
        return prefix;
    }
        public void Prefix(Node ro) {
            this.PRE.enqueue(ro);
            if (ro.getLeft() == null && ro.getRight() == null) return;
            else{
                Prefix(ro.getLeft());
                Prefix(ro.getRight());
            }
            return;
    } 


    public Node[] PrintPostfix(){
        Node roo = this.root;
        Postfix(roo);
        int postfixsize = this.POS.size();
        Node[] postfix= new Node[postfixsize];

        return postfix;
    }
        public void Postfix(Node ro) {
            
            if (ro.getLeft() == null&&ro.getRight() == null){this.POS.enqueue(ro);  return;}
                Postfix(ro.getLeft());
                Postfix(ro.getRight());
                this.POS.enqueue(ro);
            return;
    }     

    @SuppressWarnings(""empty-statement"")
    public double Evaluation(){
        double answer = 0;
        Stack<Double> val = new Stack<Double>();
        Node[] pos = this.PrintPostfix();
//        System.out.println(count);
        int ic = 1;
        val.push(Double.parseDouble(pos[0].getValue()));
        while(ic != 9){
            //System.out.printf(pos[i].getValue()+"" "");
            if(pos[ic].getValue().equals(""+"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b+c);
                answer = (b+c);
//                System.out.println(b+c);
            }
            else if(pos[ic].getValue().equals(""-"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b-c);
                answer = (b-c);
//                System.out.println(b-c);
            }
            else if(pos[ic].getValue().equals(""*"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b*c);
                answer = (b*c);
//                System.out.println(b*c);
            }
            else if(pos[ic].getValue().equals(""/"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b/c);
                answer = (b/c);
//                System.out.println(b/c);
            }
            else{
                val.push(Double.parseDouble(pos[ic].getValue()));
            }
            ic++;
        }
        return answer;
    }
    
    private Queue<String> insrt(String A){
        String store ="""";
        String[] temp = A.split("""");
        Queue<String> PQ = new Queue<String>();
        Queue<String> deal = new Queue<String>();
        
        for(int i=0; i<temp.length; i++){
            if(temp[i].equals(""("")){PQ.enqueue(temp[i]);PQ.enqueue(""_"");
            }
            else if(temp[i].equals("")"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);             
            }
            else if(temp[i].equals(""+"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");             
            }
            else if(temp[i].equals(""-"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""*"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""/"")){PQ.enqueue(""_"");PQ.enqueue(temp[i]);PQ.enqueue(""_"");               
            }
            else  PQ.enqueue(temp[i]);
        }
        int N = PQ.size();
        for(int i=0; i<N;i++){
            store = store + PQ.dequeue();
        }
        String[] AA = store.split(""_"");
//        this.count = AA.length;  //count exist
        
        for(int i=0; i<AA.length;i++){
            deal.enqueue(AA[i]);
        }
        return deal;
    }  
}
@1e3718d7d893e62806ccc42d68a16ff4@"
"r04921074","10","0.098","105888","@0fd0885e9183fe6980a59a658a02e979@import java.io.FileReader;
import java.util.Arrays;

public class Expression {
    private Queue<Node> PRE = new Queue<Node>();
    private Queue<Node> POS = new Queue<Node>();
    private Node root;
    private int count=0;//count exist

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){        
        
        Queue<String> temp = insrt(infix); //doing this will save any operator & value in chronologic
        Stack<Node> value = new Stack<Node>();//save value
        Stack<String> operator = new Stack<String>();//save operator
        
        Node right = new Node(null,null,null);
        Node left  = new Node(null,null,null);
        
        int N = temp.size();
        for(int i=0; i<N; i++){
            String A = temp.dequeue();
            
            if(A.equals(""("")){        
            }
            else if(A.equals(""+"")){   
                operator.push(A);
            }
            else if(A.equals(""-"")){   
                operator.push(A);
            }
            else if(A.equals(""*"")){   
                operator.push(A);
            }
            else if(A.equals(""/"")){   
                operator.push(A);
            }
            else if(A.equals("")"")){
                String op = operator.pop();
                
                Node R = value.pop();
                Node L = value.pop();
                root = new Node(L,R,op);
                this.count++;
                value.push(root);
                
                }//end of else if (
            
            else {  
                this.count++;
                Node Duncan = new Node(null,null,A);
                value.push(Duncan);
            }
        }//end of for   
        return root;
    }
    public void Prefix(Node ro) {
            this.PRE.enqueue(ro);
            if (ro.getLeft() == null && ro.getRight() == null) return;
            else{
                Prefix(ro.getLeft());
                Prefix(ro.getRight());
            }
            return;
    }   
    public Node[] PrintPrefix(){
        Node roo = this.root;
        Prefix(roo);
        int prefixsize = this.PRE.size();
        Node[] prefix= new Node[prefixsize];
        
        for(int i=0; i<prefixsize; i++){
           prefix[i] = this.PRE.dequeue();
        }
        
        return prefix;
    }

    public void Postfix(Node ro) {
            
            
            if (ro.getLeft() == null&&ro.getRight() == null){this.POS.enqueue(ro);  return;}
            else{
                Postfix(ro.getLeft());
                Postfix(ro.getRight());
                this.POS.enqueue(ro);
            }
            return;
    }     
    public Node[] PrintPostfix(){

        Node roo = this.root;
        Postfix(roo);
        int postfixsize = this.POS.size();
        Node[] postfix= new Node[postfixsize];
        
        for(int i=0; i<postfixsize; i++){
           postfix[i] = this.POS.dequeue();
        }

        return postfix;
    }


    public double Evaluation(){
        double answer = 0;
        Stack<Double> val = new Stack<Double>();
        Node[] pos = this.PrintPostfix();
        int ic = 1;
        val.push(Double.parseDouble(pos[0].getValue()));
        while(ic != 9){
   
            if(pos[ic].getValue().equals(""+"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b+c);
                answer = (b+c);

            }
            else if(pos[ic].getValue().equals(""-"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b-c);
                answer = (b-c);
            }
            else if(pos[ic].getValue().equals(""*"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b*c);
                answer = (b*c);
            }
            else if(pos[ic].getValue().equals(""/"")) {
                double c = val.pop();
                double b = val.pop();
                val.push(b/c);
                answer = (b/c);
            }
            else{
                val.push(Double.parseDouble(pos[ic].getValue()));
            }
            ic++;
        }
        return answer;
    }
    
    private Queue<String> insrt(String A){
        String store ="""";
        String[] temp = A.split("""");
        Queue<String> PQ = new Queue<String>();
        Queue<String> deal = new Queue<String>();
        
        for(int i=0; i<temp.length; i++){
            if(temp[i].equals(""("")){
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");
            }
            else if(temp[i].equals("")"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);             
            }
            else if(temp[i].equals(""+"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");             
            }
            else if(temp[i].equals(""-"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""*"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else if(temp[i].equals(""/"")){
            PQ.enqueue(""_"");
            PQ.enqueue(temp[i]);
            PQ.enqueue(""_"");               
            }
            else  PQ.enqueue(temp[i]);
        }
        int N = PQ.size();
        for(int i=0; i<N;i++){
            store = store + PQ.dequeue();
        }
        String[] AA = store.split(""_"");
        
        for(int i=0; i<AA.length;i++){
            deal.enqueue(AA[i]);
        }
        return deal;
    }  
}

@0fd0885e9183fe6980a59a658a02e979@"
"b03611003","1","0.09","100736","@e8d14e094566fcee8110983e82b560aa@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        if(root == null){
            throw new NullPointerException();
        }
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value = val.pop() + value;
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
            return Infix2BT(infix);
        }
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = B;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = B;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {

        String infix = ""(4+(((2-4)/(6-4))/(1-3)))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for (Node n : prefixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for (Node n : postfixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());

    }

    private void NullPointerException() {
        throw new UnsupportedOperationException(""Not supported yet.""); //To change body of generated methods, choose Tools | Templates.
    }
}

@e8d14e094566fcee8110983e82b560aa@"
"b03611033","3","0.97","105840","@2b23e42bd8c0bef7de07acbe0f466f28@//
//import java.io.BufferedReader;
//import java.io.FileReader;


public class Expression {

    private Node root;
    Queue<Node> pre = new Queue<>();
    Queue<Node> post = new Queue<>();
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        
        String[] cut;
        cut = infix.split("""");
        int count = cut.length;

        boolean plot = false;
        java.util.Stack<Double> dou = new java.util.Stack<>();
//
//        for (int i = 0; i < count; i++) {
//            if (cut[i].equals(""+"") || cut[i].equals(""-"") || cut[i].equals(""/"") || cut[i].equals(""*"") || cut[i].equals("")"")) {
//
//                double num = 0;
//                int n = dou.size();
//                int m;
//                if (plot) {
//                    m = n;
//                    while (m > 0) {
//                        m--;
//                        num += dou.pop() * Math.pow(10, -m);
//                    }
//                    plot = false;
//                } else {
//                    m = 0;
//                    while (m < n) {
//                        num += dou.pop() * Math.pow(10, m);
//                        m++;
//                    }
//                }
//                cut[i - 1] = Double.toString(num);
//
//            } else if (cut[i].equals(""("")) {
//            } else if (cut[i].equals(""."")) {
//                double num = 0;
//                int n = dou.size();
//                while (n != 0) {
//                    n--;
//                    num += dou.pop() * Math.pow(10, n);
//                }
//                dou.push(num);
//                plot = true;
//
//                cut[i] = """";
//            } else {
//                dou.push(Double.parseDouble(cut[i]));
//                cut[i] = """";
//            }
//        }

        java.util.Stack<String> ops = new java.util.Stack<>();
        java.util.Stack<Node> vals = new java.util.Stack<>();

        String op;
        for (int i = 0; i < count; i++) {
            switch (cut[i]) {
                case """":
                    break;
                case ""("":
                    break;
                case ""+"":
                    ops.push(cut[i]);
                    break;
                case ""-"":
                    ops.push(cut[i]);
                    break;
                case ""/"":
                    ops.push(cut[i]);
                    break;
                case ""*"":
                    ops.push(cut[i]);
                    break;
                case "")"":
                    op = ops.pop();
                    Node right = vals.pop();
                    Node left = vals.pop();
                    Node temp = new Node(left, right, op);
                    vals.push(temp);
                    break;
                default:
                    Node x = new Node(null, null, cut[i]);
                    vals.push(x);
                    break;
            }

        }
        root = vals.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        pre.enqueue(root);
        getpre(root);
        int size=pre.size();
        Node[] prefix=new Node[size];
        for(int s=0;s<size;s++){
            prefix[s]=pre.dequeue();
        }
        return prefix;
    }


    private Node getpre(Node x) {
        if (x.getLeft() != null) {
            pre.enqueue(x.getLeft());
            getpre(x.getLeft());
        }
        if (x.getRight() != null) {
            pre.enqueue(x.getRight());
            getpre(x.getRight());
        } 
        return x;        
    }

    public Node[] PrintPostfix() {
        getpost(root);
        int size=post.size();
        Node[] postfix=new Node[size];
        for(int s=0;s<size;s++){
            postfix[s]=post.dequeue();
        }
        return postfix;
    }
    
    private Node getpost(Node x) {
        if (x.getLeft() != null) {
            getpost(x.getLeft());
        }
        if (x.getRight() != null) {
            getpost(x.getRight());
        }
        post.enqueue(x);
        return x;     
    }

    public double Evaluation() {
        double answer = 0;
        

        return answer;
    }
    
//    public static void main(String[] args){
//        
//            String in = ""(4+(((4*2)/2)/3))"";
//            Expression ex = new Expression();
//            StdOut.println(ex.Infix2BT(in).getValue());
//            
//            Node[] kkk = ex.PrintPostfix();
//            for(int i=0;i<kkk.length;i++){
//                StdOut.print(kkk[i].getValue()); 
//            }
//        
//    }
    
    
    
}

@2b23e42bd8c0bef7de07acbe0f466f28@"
"b03611033","6","0.97","105856","@aa7179fa02dd4b032d4b019d814df55c@
public class Expression {

    private Node root;
    Queue<Node> pre = new Queue<>();
    Queue<Node> post = new Queue<>();

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        String[] cut;
        cut = infix.split("""");
        int count = cut.length;

        boolean plot = false;
        java.util.Stack<Double> dou = new java.util.Stack<>();
//
//        for (int i = 0; i < count; i++) {
//            if (cut[i].equals(""+"") || cut[i].equals(""-"") || cut[i].equals(""/"") || cut[i].equals(""*"") || cut[i].equals("")"")) {
//
//                double num = 0;
//                int n = dou.size();
//                int m;
//                if (plot) {
//                    m = n;
//                    while (m > 0) {
//                        m--;
//                        num += dou.pop() * Math.pow(10, -m);
//                    }
//                    plot = false;
//                } else {
//                    m = 0;
//                    while (m < n) {
//                        num += dou.pop() * Math.pow(10, m);
//                        m++;
//                    }
//                }
//                cut[i - 1] = Double.toString(num);
//
//            } else if (cut[i].equals(""("")) {
//            } else if (cut[i].equals(""."")) {
//                double num = 0;
//                int n = dou.size();
//                while (n != 0) {
//                    n--;
//                    num += dou.pop() * Math.pow(10, n);
//                }
//                dou.push(num);
//                plot = true;
//
//                cut[i] = """";
//            } else {
//                dou.push(Double.parseDouble(cut[i]));
//                cut[i] = """";
//            }
//        }

        java.util.Stack<String> ops = new java.util.Stack<>();
        java.util.Stack<Node> vals = new java.util.Stack<>();

        String op;
        for (int i = 0; i < count; i++) {
            switch (cut[i]) {
                case """":
                    break;
                case ""("":
                    break;
                case ""+"":
                    ops.push(cut[i]);
                    break;
                case ""-"":
                    ops.push(cut[i]);
                    break;
                case ""/"":
                    ops.push(cut[i]);
                    break;
                case ""*"":
                    ops.push(cut[i]);
                    break;
                case "")"":
                    op = ops.pop();
                    Node right = vals.pop();
                    Node left = vals.pop();
                    Node temp = new Node(left, right, op);
                    vals.push(temp);
                    break;
                default:
                    Node x = new Node(null, null, cut[i]);
                    vals.push(x);
                    break;
            }

        }
        root = vals.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        pre.enqueue(root);
        getpre(root);
        int size = pre.size();
        Node[] prefix = new Node[size];
        for (int s = 0; s < size; s++) {
            prefix[s] = pre.dequeue();
        }
        return prefix;
    }

    private Node getpre(Node x) {
        if (x.getLeft() != null) {
            pre.enqueue(x.getLeft());
            getpre(x.getLeft());
        }
        if (x.getRight() != null) {
            pre.enqueue(x.getRight());
            getpre(x.getRight());
        }
        return x;
    }

    public Node[] PrintPostfix() {
        getpost(root);
        int size = post.size();
        Node[] postfix = new Node[size];
        for (int s = 0; s < size; s++) {
            postfix[s] = post.dequeue();
        }
        return postfix;
    }

    private Node getpost(Node x) {
        if (x.getLeft() != null) {
            getpost(x.getLeft());
        }
        if (x.getRight() != null) {
            getpost(x.getRight());
        }
        post.enqueue(x);
        return x;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] kkk = PrintPostfix();
        String cal[] = new String[kkk.length];
        for (int i = 0; i < kkk.length; i++) {
            cal[i] = kkk[i].getValue();
        }
        java.util.Stack<String> ops = new java.util.Stack<>();
        java.util.Stack<Double> vals = new java.util.Stack<>();

        for (int i = 0; i < cal.length; i++) {
            switch (cal[i]) {
                case ""+"":
                    vals.push(vals.pop() + vals.pop());
                    break;
                case ""*"":
                    vals.push(vals.pop() * vals.pop());
                    break;
                case ""-"":
                    answer = -(vals.pop() - vals.pop());
                    vals.push(answer);
                    break;
                case ""/"":
                    answer = 1 / (vals.pop() / vals.pop());
                    vals.push(answer);
                    break;
                default:
                    vals.push(Double.parseDouble(cal[i]));
                    break;
            }
        }
        answer=vals.pop();
        return answer;
    }

    public static void main(String[] args) {

        String in = ""(4+(((4*2)/2)/3))"";
        Expression ex = new Expression();
        StdOut.println(ex.Infix2BT(in).getValue());

        Node[] kkk = ex.PrintPostfix();
        for (int i = 0; i < kkk.length; i++) {
            StdOut.print(kkk[i].getValue());
        }
        StdOut.println();
        StdOut.println(ex.Evaluation());

    }

}

@aa7179fa02dd4b032d4b019d814df55c@"
"r04921104","10","0.1","105856","@61f89babc0fd0495b47b6cdf7411949c@public class Expression {

    private static boolean isOperator(String a) {
        if (a.equals(""+"") || a.equals(""-"") || a.equals(""*"") || a.equals(""/"")) {
            return true;
        } else {
            return false;
        }
    }

    private static boolean isNum(String a) {
        if (a.equals(""+"") || a.equals(""-"") || a.equals(""*"") || a.equals(""/"") || a.equals(""("") || a.equals("")"")) {
            return false;
        } else {
            return true;
        }
    }

    private static void prefixPut(Node n, Stack<Node> st) {
        st.push(n);
        if (n.getLeft() != null) {
            prefixPut(n.getLeft(), st);
        }
        if (n.getRight() != null) {
            prefixPut(n.getRight(), st);
        }
    }

    private static void postfixPut(Node n, Stack<Node> st) {
        st.push(n);
        if (n.getRight() != null) {
            postfixPut(n.getRight(), st);
        }
        if (n.getLeft() != null) {
            postfixPut(n.getLeft(), st);
        }
    }

    private static double compution(Node n) {
        double a, b;
        String opr = n.getValue();

        if (isOperator(n.getLeft().getValue())) {
            a = compution(n.getLeft());
        } else {
            a = Double.valueOf(n.getLeft().getValue());
        }

        if (isOperator(n.getRight().getValue())) {
            b = compution(n.getRight());
        } else {
            b = Double.valueOf(n.getRight().getValue());
        }

        if (opr.equals(""+"")) {
            return a + b;
        } else if (opr.equals(""-"")) {
            return a - b;
        } else if (opr.equals(""*"")) {
            return a * b;
        } else if (opr.equals(""/"")) {
            return a / b;
        } else {
            return 0;
        }
    }

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        Stack<Node> ns = new Stack();
        //String opdR, opr, opdL;
        for (int i = 0; i < infix.length(); i++) {
            String s = infix.substring(i, i+1);
            if(s.equals(""(""))
                continue;
            else if(s.equals("")"")){
                if(ns.size() == 1){
                    break;
                } // ex: (123.456)
                
                Node nRight = ns.pop();
                Node nRoot = ns.pop();
                Node nLeft = ns.pop();
                nRoot.setRight(nRight);
                nRoot.setLeft(nLeft);
                ns.push(nRoot);
            }
            else{
                if(isOperator(s)){
                    Node opt = new Node(null,null,s);
                    ns.push(opt);   
                }else{
                    int j = i;
                    while(isNum(infix.substring(j+1,j+2)))
                        j++;
                    Node opr = new Node(null,null,infix.substring(i, j+1));
                    ns.push(opr);
                    i = j;
                }
            }
        }
        
        root = ns.pop();

        return (root);
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException();
        } else {
            Node[] prefix = null;

            Stack<Node> st = new Stack();
            prefixPut(root, st);
            int size = st.size();
            prefix = new Node[size];
            for (int i = st.size() - 1; i >= 0; i--) {
                prefix[i] = st.pop();
            }

            return (prefix);
        }
    }

    public Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException();
        } else {
            Node[] postfix = null;

            Stack<Node> st = new Stack();
            postfixPut(root, st);
            int size = st.size();
            postfix = new Node[size];
            for (int i = 0; i < size; i++) {
                postfix[i] = st.pop();
            }

            return (postfix);
        }
    }

    public double Evaluation() {
        if (root == null) {
            throw new NullPointerException();
        } else if(isNum(root.getValue())){
            return(Double.valueOf(root.getValue()));
        } else{
            double answer = compution(root);
            return (answer);
        }
    }

//    public static void main(String[] args) {
//        Expression test = new Expression();
//        test.Infix2BT(""(4.454+2.001)"");
//
//        for (int i = 0; i < test.PrintPrefix().length; i++) {
//            System.out.println(test.PrintPrefix()[i].getValue());
//        }
//
//        for (int i = 0; i < test.PrintPostfix().length; i++) {
//            System.out.println(test.PrintPostfix()[i].getValue());
//        }
//
//        System.out.println(test.Evaluation());
//    }
}
@61f89babc0fd0495b47b6cdf7411949c@"
"b03611033","10","0.098","105952","@b3375b4b0eaf604175de4993f845a6de@
public class Expression {

    private Node root;
    Queue<Node> pre = new Queue<>();
    Queue<Node> post = new Queue<>();

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        String[] cut;
        cut = infix.split("""");
        int count = cut.length;

        boolean nint = false;
        boolean plot = false;

        java.util.Stack<String> ops = new java.util.Stack<>();
        java.util.Stack<Node> vals = new java.util.Stack<>();

        String op;
        for (int i = 0; i < count; i++) {
            switch (cut[i]) {
                case ""("":
                    nint = false;
                    plot = false;
                    break;
                case ""+"":
                    nint = false;
                    plot = false;
                    ops.push(cut[i]);
                    break;
                case ""-"":
                    nint = false;
                    plot = false;
                    ops.push(cut[i]);
                    break;
                case ""/"":
                    nint = false;
                    plot = false;
                    ops.push(cut[i]);
                    break;
                case ""*"":
                    nint = false;
                    plot = false;
                    ops.push(cut[i]);
                    break;
                case ""."":
                    plot = true;
                    break;
                case "")"":
                    nint = false;
                    plot = false;
                    op = ops.pop();
                    Node right = vals.pop();
                    Node left = vals.pop();
                    Node temp = new Node(left, right, op);
                    vals.push(temp);
                    break;
                default:
                    Node x;
                    if (plot) {
                        x = vals.pop();
                        String str = x.getValue() + ""."";
                        x.setValue(str);
                        vals.push(x);
                    }
                    if (nint) {
                        x = vals.pop();
                        String str = x.getValue() + cut[i];
                        x.setValue(str);
                    } else {
                        x = new Node(null, null, cut[i]);
                    }
                    vals.push(x);
                    nint = true;
                    plot = false;
                    break;
            }
        }
        root = vals.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        pre.enqueue(root);
        getpre(root);
        int size = pre.size();
        Node[] prefix = new Node[size];
        for (int s = 0; s < size; s++) {
            prefix[s] = pre.dequeue();
        }
        return prefix;
    }

    private Node getpre(Node x) {
        if (x.getLeft() != null) {
            pre.enqueue(x.getLeft());
            getpre(x.getLeft());
        }
        if (x.getRight() != null) {
            pre.enqueue(x.getRight());
            getpre(x.getRight());
        }
        return x;
    }

    public Node[] PrintPostfix() {
        getpost(root);
        int size = post.size();
        Node[] postfix = new Node[size];
        for (int s = 0; s < size; s++) {
            postfix[s] = post.dequeue();
        }
        return postfix;
    }

    private Node getpost(Node x) {
        if (x.getLeft() != null) {
            getpost(x.getLeft());
        }
        if (x.getRight() != null) {
            getpost(x.getRight());
        }
        post.enqueue(x);
        return x;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] kkk = PrintPostfix();
        String cal[] = new String[kkk.length];
        for (int i = 0; i < kkk.length; i++) {
            cal[i] = kkk[i].getValue();
        }
        java.util.Stack<String> ops = new java.util.Stack<>();
        java.util.Stack<Double> vals = new java.util.Stack<>();

        for (int i = 0; i < cal.length; i++) {
            switch (cal[i]) {
                case ""+"":
                    vals.push(vals.pop() + vals.pop());
                    break;
                case ""*"":
                    vals.push(vals.pop() * vals.pop());
                    break;
                case ""-"":
                    answer = -(vals.pop() - vals.pop());
                    vals.push(answer);
                    break;
                case ""/"":
                    answer = 1 / (vals.pop() / vals.pop());
                    vals.push(answer);
                    break;
                default:
                    vals.push(Double.parseDouble(cal[i]));
                    break;
            }
        }
        answer = vals.pop();
        return answer;
    }

//    public static void main(String[] args) {
//
//        String in = ""(4.1+(((4*2)/2)/3))"";
//        Expression ex = new Expression();
//        StdOut.println(ex.Infix2BT(in).getValue());
//
//        Node[] kkk = ex.PrintPostfix();
//        for (int i = 0; i < kkk.length; i++) {
//            StdOut.print(kkk[i].getValue());
//        }
//        StdOut.println();
//        StdOut.println(ex.Evaluation());
//
//    }

}

@b3375b4b0eaf604175de4993f845a6de@"
"r04522627","6","0.95","105840","@4348b0cd26e2b3e7b57be6597d909044@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Vector;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        char[] data = infix.toCharArray();
        Stack<Node> data_stack = new Stack<Node>();
        int n = 0;
        do
        {
            if(data[n] == ')')
            {
                Node RN = data_stack.pop();
                String op = data_stack.pop().getValue();       
                Node LN = data_stack.pop();
                Node N = new Node(LN,RN,op);
                data_stack.pop();
                data_stack.push(N);
            }
            else
            {
                data_stack.push(new Node(null,null,Character.toString(data[n])));
            }
            n++;
        }while(n != data.length);
        
        root = data_stack.pop();
        return root;
    }

    //recursively do prefix stack
    void GoPreOrder(Node N,Stack node_stack)
    {
        node_stack.push(N);
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPreOrder(LN,node_stack);
        if(RN != null) GoPreOrder(RN,node_stack);
    }
    
    //recursively do prefix stack
    void GoPostOrder(Node N,Stack node_stack)
    {
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPostOrder(LN,node_stack);
        if(RN != null) GoPostOrder(RN,node_stack);
        node_stack.push(N);
        
    }
    
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        
        Node[] prefix = null;
        Stack<Node> prefix_stack = new Stack<Node>();
        GoPreOrder(root,prefix_stack);
        prefix = new Node[prefix_stack.size()];
        int i = prefix.length;
        while(!prefix_stack.isEmpty())
        {
            prefix[--i] = prefix_stack.pop();
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        
        Node[] postfix = null;
        Stack<Node> prostfix_stack = new Stack<Node>();
        GoPostOrder(root,prostfix_stack);
        postfix = new Node[prostfix_stack.size()];
        int i = postfix.length;
        while(!prostfix_stack.isEmpty())
        {
            postfix[--i] = prostfix_stack.pop();
        }
        return postfix;
    }
    
    boolean IsOperator(String value)
    {
        if(value.equals(""+"") ||value.equals(""-"") ||value.equals(""*"") ||value.equals(""/""))
        {
            return true;
        }
        else return false;
    }
    
    public double Evaluation(Node N){
         double answer = 0;
         double a = 0, b = 0;
         Node LN = N.getLeft();
         Node RN = N.getRight();
         if(LN != null && IsOperator(LN.getValue()))
         {
             a = Evaluation(LN);
         }
         else
         {
             a = Double.valueOf(LN.getValue());
         }
         if(RN != null && IsOperator(RN.getValue()))
         {
             b = Evaluation(RN);
         }
         else
         {
             b = Double.valueOf(RN.getValue());
         }
         
         switch(N.getValue())
         {
             case ""+"":
                 answer = a + b;
                 break;
             case ""-"":
                 answer = a - b;
                 break;
             case ""*"":
                 answer = a * b;
                 break;
             case ""/"":
                 answer = a / b;
                 break;
         }
         return answer;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        double answer = 0;
        answer = Evaluation(root);
        return answer;
    }
    /*public static void main(String[] args) throws Exception{

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression e = new Expression();
            
            System.out.println(e.Infix2BT(br.readLine()).getValue());
            e.PrintPrefix();
            e.PrintPostfix();
            System.out.println(e.Evaluation());
        }
    }*/
}

@4348b0cd26e2b3e7b57be6597d909044@"
"r04522627","1","0.78","105856","@3ada6ba2292b932029e2b8899c5ca966@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Vector;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] data = infix.split(""(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)"");
        Stack<Node> data_stack = new Stack<Node>();
        int n = 0;
        do
        {
            if(data[n].equals("")""))
            {
                Node RN = data_stack.pop();
                String op = data_stack.pop().getValue();       
                Node LN = data_stack.pop();
                Node N = new Node(LN,RN,op);
                if(!data_stack.isEmpty()) data_stack.pop();
                data_stack.push(N);
            }
            else
            {
                data_stack.push(new Node(null,null,data[n]));
            }
            n++;
        }while(n != data.length);
        
        root = data_stack.pop();
        return root;
    }

    //recursively do prefix stack
    void GoPreOrder(Node N,Stack node_stack)
    {
        node_stack.push(N);
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPreOrder(LN,node_stack);
        if(RN != null) GoPreOrder(RN,node_stack);
    }
    
    //recursively do prefix stack
    void GoPostOrder(Node N,Stack node_stack)
    {
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPostOrder(LN,node_stack);
        if(RN != null) GoPostOrder(RN,node_stack);
        node_stack.push(N);
        
    }
    
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        
        Node[] prefix = null;
        Stack<Node> prefix_stack = new Stack<Node>();
        GoPreOrder(root,prefix_stack);
        prefix = new Node[prefix_stack.size()];
        int i = prefix.length;
        while(!prefix_stack.isEmpty())
        {
            prefix[--i] = prefix_stack.pop();
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        
        Node[] postfix = null;
        Stack<Node> prostfix_stack = new Stack<Node>();
        GoPostOrder(root,prostfix_stack);
        postfix = new Node[prostfix_stack.size()];
        int i = postfix.length;
        while(!prostfix_stack.isEmpty())
        {
            postfix[--i] = prostfix_stack.pop();
        }
        return postfix;
    }
    
    boolean IsOperator(String value)
    {
        if(value.equals(""+"") ||value.equals(""-"") ||value.equals(""*"") ||value.equals(""/""))
        {
            return true;
        }
        else return false;
    }
    
    public double Evaluation(Node N){
         double answer = 0;
         double a = 0, b = 0;
         Node LN = N.getLeft();
         Node RN = N.getRight();
         if(LN != null && IsOperator(LN.getValue()))
         {
             a = Evaluation(LN);
         }
         else
         {
             a = Double.valueOf(LN.getValue());
         }
         if(RN != null && IsOperator(RN.getValue()))
         {
             b = Evaluation(RN);
         }
         else
         {
             b = Double.valueOf(RN.getValue());
         }
         
         switch(N.getValue())
         {
             case ""+"":
                 answer = a + b;
                 break;
             case ""-"":
                 answer = a - b;
                 break;
             case ""*"":
                 answer = a * b;
                 break;
             case ""/"":
                 answer = a / b;
                 break;
         }
         return answer;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        double answer = 0;
        answer = Evaluation(root);
        return answer;
    }
    public static void main(String[] args) throws Exception{

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression e = new Expression();
            
            System.out.println(e.Infix2BT(br.readLine()).getValue());
            e.PrintPrefix();
            e.PrintPostfix();
            System.out.println(e.Evaluation());
        }
    }
}

@3ada6ba2292b932029e2b8899c5ca966@"
"r04522627","6","0.58","105856","@f7a03f71ac852b5f8a8586701d0172fc@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Vector;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] data = infix.split(""(?<=[()-+*/])|(?=[()-+*/])"");
        Stack<Node> data_stack = new Stack<Node>();
        int n = 0;
        do
        {
            if(data[n].equals("")""))
            {
                Node RN = data_stack.pop();
                String op = data_stack.pop().getValue();       
                Node LN = data_stack.pop();
                Node N = new Node(LN,RN,op);
                if(!data_stack.isEmpty()) data_stack.pop();
                data_stack.push(N);
            }
            else
            {
                data_stack.push(new Node(null,null,data[n]));
            }
            n++;
        }while(n != data.length);
        
        root = data_stack.pop();
        return root;
    }

    //recursively do prefix stack
    void GoPreOrder(Node N,Stack node_stack)
    {
        node_stack.push(N);
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPreOrder(LN,node_stack);
        if(RN != null) GoPreOrder(RN,node_stack);
    }
    
    //recursively do prefix stack
    void GoPostOrder(Node N,Stack node_stack)
    {
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPostOrder(LN,node_stack);
        if(RN != null) GoPostOrder(RN,node_stack);
        node_stack.push(N);
        
    }
    
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        
        Node[] prefix = null;
        Stack<Node> prefix_stack = new Stack<Node>();
        GoPreOrder(root,prefix_stack);
        prefix = new Node[prefix_stack.size()];
        int i = prefix.length;
        while(!prefix_stack.isEmpty())
        {
            prefix[--i] = prefix_stack.pop();
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        
        Node[] postfix = null;
        Stack<Node> prostfix_stack = new Stack<Node>();
        GoPostOrder(root,prostfix_stack);
        postfix = new Node[prostfix_stack.size()];
        int i = postfix.length;
        while(!prostfix_stack.isEmpty())
        {
            postfix[--i] = prostfix_stack.pop();
        }
        return postfix;
    }
    
    boolean IsOperator(String value)
    {
        if(value.equals(""+"") ||value.equals(""-"") ||value.equals(""*"") ||value.equals(""/""))
        {
            return true;
        }
        else return false;
    }
    
    public double Evaluation(Node N){
         double answer = 0;
         double a = 0, b = 0;
         Node LN = N.getLeft();
         Node RN = N.getRight();
         if(LN != null && IsOperator(LN.getValue()))
         {
             a = Evaluation(LN);
         }
         else
         {
             a = Double.valueOf(LN.getValue());
         }
         if(RN != null && IsOperator(RN.getValue()))
         {
             b = Evaluation(RN);
         }
         else
         {
             b = Double.valueOf(RN.getValue());
         }
         
         switch(N.getValue())
         {
             case ""+"":
                 answer = a + b;
                 break;
             case ""-"":
                 answer = a - b;
                 break;
             case ""*"":
                 answer = a * b;
                 break;
             case ""/"":
                 answer = a / b;
                 break;
         }
         return answer;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        double answer = 0;
        answer = Evaluation(root);
        return answer;
    }
    public static void main(String[] args) throws Exception{

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression e = new Expression();
            
            System.out.println(e.Infix2BT(br.readLine()).getValue());
            e.PrintPrefix();
            e.PrintPostfix();
            System.out.println(e.Evaluation());
        }
    }
}

@f7a03f71ac852b5f8a8586701d0172fc@"
"r04522627","6","0.98","105840","@19ad6f168325a6dfe99a50085152c85f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Vector;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] data = infix.split(""(?<=[()-+*/])|(?=[()-+*/])"");
        Stack<Node> data_stack = new Stack<Node>();
        int n = 1;
        do
        {
            if(data[n].equals("")""))
            {
                Node RN = data_stack.pop();
                String op = data_stack.pop().getValue();  
                if(!IsOperator(op))
                {
                    data_stack.push(RN);
                    break;
                }
                Node LN = data_stack.pop();
                Node N = new Node(LN,RN,op);
                if(!data_stack.isEmpty()) data_stack.pop();
                data_stack.push(N);
            }
            else
            {
                data_stack.push(new Node(null,null,data[n]));
            }
            n++;
        }while(n != data.length);
        
        root = data_stack.pop();
        return root;
    }

    //recursively do prefix stack
    void GoPreOrder(Node N,Stack node_stack)
    {
        node_stack.push(N);
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPreOrder(LN,node_stack);
        if(RN != null) GoPreOrder(RN,node_stack);
    }
    
    //recursively do prefix stack
    void GoPostOrder(Node N,Stack node_stack)
    {
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPostOrder(LN,node_stack);
        if(RN != null) GoPostOrder(RN,node_stack);
        node_stack.push(N);
        
    }
    
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        
        Node[] prefix = null;
        Stack<Node> prefix_stack = new Stack<Node>();
        GoPreOrder(root,prefix_stack);
        prefix = new Node[prefix_stack.size()];
        int i = prefix.length;
        while(!prefix_stack.isEmpty())
        {
            prefix[--i] = prefix_stack.pop();
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        
        Node[] postfix = null;
        Stack<Node> prostfix_stack = new Stack<Node>();
        GoPostOrder(root,prostfix_stack);
        postfix = new Node[prostfix_stack.size()];
        int i = postfix.length;
        while(!prostfix_stack.isEmpty())
        {
            postfix[--i] = prostfix_stack.pop();
        }
        return postfix;
    }
    
    boolean IsOperator(String value)
    {
        if(value.equals(""+"") ||value.equals(""-"") ||value.equals(""*"") ||value.equals(""/""))
        {
            return true;
        }
        else return false;
    }
    
    public double Evaluation(Node N){
         double answer = 0;
         double a = 0, b = 0;
         Node LN = N.getLeft();
         Node RN = N.getRight();
         if(LN == null && RN == null)
         {
             return Double.valueOf(N.getValue());
         }
         if(LN != null)
         {
            if(IsOperator(LN.getValue()))
            {
                a = Evaluation(LN);
            }
            else
            {
                a = Double.valueOf(LN.getValue());
            }
         }
         if(RN != null)
         {
            if(IsOperator(RN.getValue()))
            {
                b = Evaluation(RN);
            }
            else
            {
                b = Double.valueOf(RN.getValue());
            }
         }
         
         
         switch(N.getValue())
         {
             case ""+"":
                 answer = a + b;
                 break;
             case ""-"":
                 answer = a - b;
                 break;
             case ""*"":
                 answer = a * b;
                 break;
             case ""/"":
                 answer = a / b;
                 break;
         }
         return answer;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        double answer = 0;
        answer = Evaluation(root);
        return answer;
    }
    public static void main(String[] args) throws Exception{

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression e = new Expression();
            
            System.out.println(e.Infix2BT(br.readLine()).getValue());
            e.PrintPrefix();
            e.PrintPostfix();
            System.out.println(e.Evaluation());
        }
    }
}

@19ad6f168325a6dfe99a50085152c85f@"
"r04522627","10","0.097","105536","@0f8a2d825d2a29bb2bcf3066e18e9f75@import java.io.BufferedReader;
import java.io.FileReader;


public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] data = infix.split(""(?<=[-+*/()])|(?=[-+*/()])"");
        Stack<Node> data_stack = new Stack<Node>();
        int n = 1;
        do
        {
            if(data[n].equals("")""))
            {
                Node RN = data_stack.pop();
                String op = data_stack.pop().getValue();  
                if(!IsOperator(op))
                {
                    data_stack.push(RN);
                    break;
                }
                Node LN = data_stack.pop();
                Node N = new Node(LN, RN, op);
                if(!data_stack.isEmpty()) data_stack.pop();
                data_stack.push(N);
            }
            else
            {
                data_stack.push(new Node(null,null,data[n]));
            }
            n++;
        }while(n != data.length);
        
        root = data_stack.pop();
        return root;
    }

    //recursively do prefix stack
    void GoPreOrder(Node N,Stack node_stack)
    {
        node_stack.push(N);
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPreOrder(LN,node_stack);
        if(RN != null) GoPreOrder(RN,node_stack);
    }
    
    //recursively do prefix stack
    void GoPostOrder(Node N,Stack node_stack)
    {
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPostOrder(LN,node_stack);
        if(RN != null) GoPostOrder(RN,node_stack);
        node_stack.push(N);
        
    }
    
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        
        Node[] prefix = null;
        Stack<Node> prefix_stack = new Stack<Node>();
        GoPreOrder(root,prefix_stack);
        prefix = new Node[prefix_stack.size()];
        int i = prefix.length;
        while(!prefix_stack.isEmpty())
        {
            prefix[--i] = prefix_stack.pop();
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        
        Node[] postfix = null;
        Stack<Node> prostfix_stack = new Stack<Node>();
        GoPostOrder(root,prostfix_stack);
        postfix = new Node[prostfix_stack.size()];
        int i = postfix.length;
        while(!prostfix_stack.isEmpty())
        {
            postfix[--i] = prostfix_stack.pop();
        }
        return postfix;
    }
    
    boolean IsOperator(String value)
    {
        if(value.equals(""+"") ||value.equals(""-"") ||value.equals(""*"") ||value.equals(""/""))
        {
            return true;
        }
        else return false;
    }
    
    public double Evaluation(Node N){
         double answer = 0;
         double a = 0, b = 0;
         Node LN = N.getLeft();
         Node RN = N.getRight();
         if(LN == null && RN == null)
         {
             return Double.valueOf(N.getValue());
         }
         if(LN != null)
         {
            if(IsOperator(LN.getValue()))
            {
                a = Evaluation(LN);
            }
            else
            {
                a = Double.valueOf(LN.getValue());
            }
         }
         if(RN != null)
         {
            if(IsOperator(RN.getValue()))
            {
                b = Evaluation(RN);
            }
            else
            {
                b = Double.valueOf(RN.getValue());
            }
         }
         
         
         switch(N.getValue())
         {
             case ""+"":
                 answer = a + b;
                 break;
             case ""-"":
                 answer = a - b;
                 break;
             case ""*"":
                 answer = a * b;
                 break;
             case ""/"":
                 answer = a / b;
                 break;
         }
         return answer;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        double answer = 0;
        answer = Evaluation(root);
        return answer;
    }
    /*public static void main(String[] args) throws Exception{

        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression e = new Expression();
            
            System.out.println(e.Infix2BT(br.readLine()).getValue());
            e.PrintPrefix();
            e.PrintPostfix();
            System.out.println(e.Evaluation());
        }
    }*/
}

@0f8a2d825d2a29bb2bcf3066e18e9f75@"
"r04522627","10","0.098","105840","@02158c85b1ccbb3dd73bddb120cdc7cf@import java.io.BufferedReader;
import java.io.FileReader;


public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] data = infix.split(""(?<=[-+*/()])|(?=[-+*/()])"");
        Stack<Node> data_stack = new Stack<Node>();
        int n = 1;
        do
        {
            if(data[n].equals("")""))
            {
                Node RN = data_stack.pop();
                String op = data_stack.pop().getValue();  
                if(!IsOperator(op))
                {
                    data_stack.push(RN);
                    break;
                }
                Node LN = data_stack.pop();
                Node N = new Node(LN, RN, op);
                if(!data_stack.isEmpty()) data_stack.pop();
                data_stack.push(N);
            }
            else
            {
                data_stack.push(new Node(null,null,data[n]));
            }
            n++;
        }while(n != data.length);
        
        root = data_stack.pop();
        return root;
    }

    //recursively do prefix stack
    void GoPreOrder(Node N,Stack node_stack)
    {
        node_stack.push(N);
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPreOrder(LN,node_stack);
        if(RN != null) GoPreOrder(RN,node_stack);
    }
    
    //recursively do prefix stack
    void GoPostOrder(Node N,Stack node_stack)
    {
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPostOrder(LN,node_stack);
        if(RN != null) GoPostOrder(RN,node_stack);
        node_stack.push(N);
        
    }
    
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        
        Node[] prefix = null;
        Stack<Node> prefix_stack = new Stack<Node>();
        GoPreOrder(root,prefix_stack);
        prefix = new Node[prefix_stack.size()];
        int i = prefix.length;
        while(!prefix_stack.isEmpty())
        {
            prefix[--i] = prefix_stack.pop();
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        
        Node[] postfix = null;
        Stack<Node> prostfix_stack = new Stack<Node>();
        GoPostOrder(root,prostfix_stack);
        postfix = new Node[prostfix_stack.size()];
        int i = postfix.length;
        while(!prostfix_stack.isEmpty())
        {
            postfix[--i] = prostfix_stack.pop();
        }
        return postfix;
    }
    
    boolean IsOperator(String value)
    {
        if(value.equals(""+"") ||value.equals(""-"") ||value.equals(""*"") ||value.equals(""/""))
        {
            return true;
        }
        else return false;
    }
    
    public double Evaluation(Node N){
         double answer = 0;
         double a = 0, b = 0;
         Node LN = N.getLeft();
         Node RN = N.getRight();
         if(LN == null && RN == null)
         {
             return Double.valueOf(N.getValue());
         }
         if(LN != null)
         {
            if(IsOperator(LN.getValue()))
            {
                a = Evaluation(LN);
            }
            else
            {
                a = Double.valueOf(LN.getValue());
            }
         }
         if(RN != null)
         {
            if(IsOperator(RN.getValue()))
            {
                b = Evaluation(RN);
            }
            else
            {
                b = Double.valueOf(RN.getValue());
            }
         }
         
         
         switch(N.getValue())
         {
             case ""+"":
                 answer = a + b;
                 break;
             case ""-"":
                 answer = a - b;
                 break;
             case ""*"":
                 answer = a * b;
                 break;
             case ""/"":
                 answer = a / b;
                 break;
         }
         return answer;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        double answer = 0;
        answer = Evaluation(root);
        return answer;
    }
//    public static void main(String[] args) throws Exception{
//
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            Expression e = new Expression();
//            
//            System.out.println(e.Infix2BT(br.readLine()).getValue());
//            e.PrintPrefix();
//            e.PrintPostfix();
//            System.out.println(e.Evaluation());
//        }
//    }
}

@02158c85b1ccbb3dd73bddb120cdc7cf@"
"r04522627","6","0.97","105920","@28f0bc8644bb3585e47c5d7dd8f8a43f@import java.io.BufferedReader;
import java.io.FileReader;


public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] data = infix.split(""(?<=[()-+*/])|(?=[()-+*/])"");
        Stack<Node> data_stack = new Stack<Node>();
        int n = 1;
        do
        {
            if(data[n].equals("")""))
            {
                Node RN = data_stack.pop();
                String op = data_stack.pop().getValue();  
                if(!IsOperator(op))
                {
                    data_stack.push(RN);
                    break;
                }
                Node LN = data_stack.pop();
                Node N = new Node(LN, RN, op);
                if(!data_stack.isEmpty()) data_stack.pop();
                data_stack.push(N);
            }
            else
            {
                data_stack.push(new Node(null,null,data[n]));
            }
            n++;
        }while(n != data.length);
        
        root = data_stack.pop();
        return root;
    }

    //recursively do prefix stack
    void GoPreOrder(Node N,Stack node_stack)
    {
        node_stack.push(N);
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPreOrder(LN,node_stack);
        if(RN != null) GoPreOrder(RN,node_stack);
    }
    
    //recursively do prefix stack
    void GoPostOrder(Node N,Stack node_stack)
    {
        Node LN = N.getLeft();
        Node RN = N.getRight();
        if(LN != null) GoPostOrder(LN,node_stack);
        if(RN != null) GoPostOrder(RN,node_stack);
        node_stack.push(N);
        
    }
    
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        
        Node[] prefix = null;
        Stack<Node> prefix_stack = new Stack<Node>();
        GoPreOrder(root,prefix_stack);
        prefix = new Node[prefix_stack.size()];
        int i = prefix.length;
        while(!prefix_stack.isEmpty())
        {
            prefix[--i] = prefix_stack.pop();
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        
        Node[] postfix = null;
        Stack<Node> prostfix_stack = new Stack<Node>();
        GoPostOrder(root,prostfix_stack);
        postfix = new Node[prostfix_stack.size()];
        int i = postfix.length;
        while(!prostfix_stack.isEmpty())
        {
            postfix[--i] = prostfix_stack.pop();
        }
        return postfix;
    }
    
    boolean IsOperator(String value)
    {
        if(value.equals(""+"") ||value.equals(""-"") ||value.equals(""*"") ||value.equals(""/""))
        {
            return true;
        }
        else return false;
    }
    
    public double Evaluation(Node N){
         double answer = 0;
         double a = 0, b = 0;
         Node LN = N.getLeft();
         Node RN = N.getRight();
         if(LN == null && RN == null)
         {
             return Double.valueOf(N.getValue());
         }
         if(LN != null)
         {
            if(IsOperator(LN.getValue()))
            {
                a = Evaluation(LN);
            }
            else
            {
                a = Double.valueOf(LN.getValue());
            }
         }
         if(RN != null)
         {
            if(IsOperator(RN.getValue()))
            {
                b = Evaluation(RN);
            }
            else
            {
                b = Double.valueOf(RN.getValue());
            }
         }
         
         
         switch(N.getValue())
         {
             case ""+"":
                 answer = a + b;
                 break;
             case ""-"":
                 answer = a - b;
                 break;
             case ""*"":
                 answer = a * b;
                 break;
             case ""/"":
                 answer = a / b;
                 break;
         }
         return answer;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        double answer = 0;
        answer = Evaluation(root);
        return answer;
    }
//    public static void main(String[] args) throws Exception{
//
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            Expression e = new Expression();
//            
//            System.out.println(e.Infix2BT(br.readLine()).getValue());
//            e.PrintPrefix();
//            e.PrintPostfix();
//            System.out.println(e.Evaluation());
//        }
//    }
}

@28f0bc8644bb3585e47c5d7dd8f8a43f@"
"b03611003","4","1","105936","@606aee2790ce4ae630df2e8d0d530f02@
import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BTre(String infix) {
        if(root == null){
            throw new NullPointerException();
        }
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value = val.pop() + value;
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
            return Infix2BT(infix);
        }
    }
    
    public Node Infix2BT(String infix){
        String[] a = infix.split("""");
        String n = """";
        Stack<Node> node = new Stack<Node>();
         nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
        for(int i = 1; i < a.length;i++){
            switch(a[i]){
                case ""("":
                    break;
                case ""+"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""-"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""/"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""*"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case "")"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    Node A = node.pop();
                    Node B = node.pop();
                    node.push(new Node(B, A, ops.pop()));
                    break;
                default :
                    n = n +a[i];
                    break;
            }
        }
        root = node.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a - b));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = B;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = B;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {

        String infix = ""(4+(((2-4)/(6-4))/(1-3)))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for (Node n : prefixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for (Node n : postfixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());
     
    }

}
@606aee2790ce4ae630df2e8d0d530f02@"
"b03611003","4","0.96","105616","@fc8348632a764d6c211c979ed45744d3@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BTre(String infix) {
        if(root == null){
            throw new NullPointerException();
        }
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value = val.pop() + value;
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
            return Infix2BT(infix);
        }
    }
    
    public Node Infix2BT(String infix){
        String[] a = infix.split("""");
        String n = """";
        Stack<Node> node = new Stack<Node>();
         nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
        for(int i = 1; i < a.length;i++){
            switch(a[i]){
                case ""("":
                    break;
                case ""+"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""-"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""/"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""*"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case "")"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    Node A = node.pop();
                    Node B = node.pop();
                    node.push(new Node(B, A, ops.pop()));
                    break;
                default :
                    n = n +a[i];
                    break;
            }
        }
        root = node.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b - a));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = B;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = B;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {

        String infix = ""((4.1-5)+(2/3))"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for (Node n : prefixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for (Node n : postfixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());
     
    }

}
@fc8348632a764d6c211c979ed45744d3@"
"b03611003","10","0.1","105856","@ad78c00af777aae8606dc990972aa7c1@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
//    public Node Infix2BTre(String infix) {
//        if(root == null){
//            throw new NullPointerException();
//        }
//        if (isexisted == false) {
//            String[] a = infix.split("""");
//            if (a[count].equals(""("")) {
//                if (count == 1) {
//                    count++;
//                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
//                    return root;
//                } else {
//                    count++;
//                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
//                    return A;
//                }
//            } else if (a[count].equals(""+"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals(""-"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals(""*"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals(""/"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals("")"")) {
//                count++;
//                Node A = new Node(null, null, ops.pop());
//                return A;
//            } else {
//                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
//                    val.push(a[count]);
//                    count++;
//                    return Infix2BT(infix);
//                } else {
//                    String value = null;
//                    val.push(a[count]);
//                    value = val.pop();
//                    while (!val.isEmpty()) {
//                        value = val.pop() + value;
//                    }
//                    Node A = new Node(null, null, value);
//                    count++;
//                    return A;
//                }
//            }
//
//        } else {
//            count = 1;
//            isexisted = false;
//            nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
//            return Infix2BT(infix);
//        }
//    }
//    
    public Node Infix2BT(String infix){
        String[] a = infix.split("""");
        String n = """";
        Stack<Node> node = new Stack<Node>();
         nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
        for(int i = 1; i < a.length;i++){
            switch(a[i]){
                case ""("":
                    break;
                case ""+"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""-"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""/"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""*"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case "")"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    Node A = node.pop();
                    Node B = node.pop();
                    node.push(new Node(B, A, ops.pop()));
                    break;
                default :
                    n = n +a[i];
                    break;
            }
        }
        root = node.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b - a));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
//        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = A;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
//        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = A;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {

        String infix = ""((((((41+5)/33)-0.05)*(8-9))/4)+177.8)"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for (Node n : prefixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for (Node n : postfixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());
     
    }

}
@ad78c00af777aae8606dc990972aa7c1@"
"b03611003","10","0.099","105968","@ad78c00af777aae8606dc990972aa7c1@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
//    public Node Infix2BTre(String infix) {
//        if(root == null){
//            throw new NullPointerException();
//        }
//        if (isexisted == false) {
//            String[] a = infix.split("""");
//            if (a[count].equals(""("")) {
//                if (count == 1) {
//                    count++;
//                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
//                    return root;
//                } else {
//                    count++;
//                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
//                    return A;
//                }
//            } else if (a[count].equals(""+"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals(""-"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals(""*"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals(""/"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals("")"")) {
//                count++;
//                Node A = new Node(null, null, ops.pop());
//                return A;
//            } else {
//                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
//                    val.push(a[count]);
//                    count++;
//                    return Infix2BT(infix);
//                } else {
//                    String value = null;
//                    val.push(a[count]);
//                    value = val.pop();
//                    while (!val.isEmpty()) {
//                        value = val.pop() + value;
//                    }
//                    Node A = new Node(null, null, value);
//                    count++;
//                    return A;
//                }
//            }
//
//        } else {
//            count = 1;
//            isexisted = false;
//            nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
//            return Infix2BT(infix);
//        }
//    }
//    
    public Node Infix2BT(String infix){
        String[] a = infix.split("""");
        String n = """";
        Stack<Node> node = new Stack<Node>();
         nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
        for(int i = 1; i < a.length;i++){
            switch(a[i]){
                case ""("":
                    break;
                case ""+"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""-"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""/"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""*"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case "")"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    Node A = node.pop();
                    Node B = node.pop();
                    node.push(new Node(B, A, ops.pop()));
                    break;
                default :
                    n = n +a[i];
                    break;
            }
        }
        root = node.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b - a));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
//        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = A;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
//        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = A;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {

        String infix = ""((((((41+5)/33)-0.05)*(8-9))/4)+177.8)"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for (Node n : prefixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for (Node n : postfixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());
     
    }

}
@ad78c00af777aae8606dc990972aa7c1@"
"b03611003","10","0.097","105840","@469d46147b3ae70355e331842a577256@
import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
//    public Node Infix2BTre(String infix) {
//        if(root == null){
//            throw new NullPointerException();
//        }
//        if (isexisted == false) {
//            String[] a = infix.split("""");
//            if (a[count].equals(""("")) {
//                if (count == 1) {
//                    count++;
//                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
//                    return root;
//                } else {
//                    count++;
//                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
//                    return A;
//                }
//            } else if (a[count].equals(""+"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals(""-"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals(""*"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals(""/"")) {
//                ops.push(a[count]);
//                count++;
//                return Infix2BT(infix);
//            } else if (a[count].equals("")"")) {
//                count++;
//                Node A = new Node(null, null, ops.pop());
//                return A;
//            } else {
//                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
//                    val.push(a[count]);
//                    count++;
//                    return Infix2BT(infix);
//                } else {
//                    String value = null;
//                    val.push(a[count]);
//                    value = val.pop();
//                    while (!val.isEmpty()) {
//                        value = val.pop() + value;
//                    }
//                    Node A = new Node(null, null, value);
//                    count++;
//                    return A;
//                }
//            }
//
//        } else {
//            count = 1;
//            isexisted = false;
//            nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
//            return Infix2BT(infix);
//        }
//    }
//    
    public Node Infix2BT(String infix){
        String[] a = infix.split("""");
        String n = """";
        Stack<Node> node = new Stack<Node>();
         nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
        for(int i = 1; i < a.length;i++){
            switch(a[i]){
                case ""("":
                    break;
                case ""+"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""-"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""/"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case ""*"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    ops.push(a[i]);
                    break;
                case "")"":
                    if(n != """"){
                       node.push(new Node(null,null, n));
                    }
                    n = """";
                    Node A = node.pop();
                    Node B = node.pop();
                    node.push(new Node(B, A, ops.pop()));
                    break;
                default :
                    n = n +a[i];
                    break;
            }
        }
        root = node.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b - a));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
//        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = A;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
//        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = A;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {

        String infix = ""((((((41+5)/33)-0.05)*(8-9))/4)+177.8)"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for (Node n : prefixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for (Node n : postfixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());
     
    }

}
@469d46147b3ae70355e331842a577256@"
"b03611003","1","0.19","105584","@179205e21ddba335f53ef6ab6e253317@

import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private int count;
    private boolean isexisted = true;
    private Stack<String> ops = new Stack<String>();
    private Stack<String> val = new Stack<String>();
    private Node[] postfix = null;
    private int countpost = 0;
    private Node[] prefix = null;
    private int countpre = 0;
    private int nodenum = 0;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
//        if(root == null){
//            throw new NullPointerException();
//        }
        if (isexisted == false) {
            String[] a = infix.split("""");
            if (a[count].equals(""("")) {
                if (count == 1) {
                    count++;
                    root = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return root;
                } else {
                    count++;
                    Node A = new Node(Infix2BT(infix), Infix2BT(infix), Infix2BT(infix).getValue());
                    return A;
                }
            } else if (a[count].equals(""+"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""-"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""*"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals(""/"")) {
                ops.push(a[count]);
                count++;
                return Infix2BT(infix);
            } else if (a[count].equals("")"")) {
                count++;
                Node A = new Node(null, null, ops.pop());
                return A;
            } else {
                if (!((a[count + 1].equals(""+"") || a[count + 1].equals(""-"")) || (a[count + 1].equals(""*"") || a[count + 1].equals(""/"")) || a[count + 1].equals("")""))) {
                    val.push(a[count]);
                    count++;
                    return Infix2BT(infix);
                } else {
                    String value = null;
                    val.push(a[count]);
                    value = val.pop();
                    while (!val.isEmpty()) {
                        value = val.pop() + value;
                    }
                    Node A = new Node(null, null, value);
                    count++;
                    return A;
                }
            }

        } else {
            count = 1;
            isexisted = false;
            nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
            return Infix2BT(infix);
        }
    }
    
//    public Node Infix2BT(String infix){
//        String[] a = infix.split("""");
//        String n = """";
//        Stack<Node> node = new Stack<Node>();
//         nodenum = 2 * (infix.length() - infix.replace(""("", """").length()) + 1;
//        for(int i = 1; i < a.length;i++){
//            switch(a[i]){
//                case ""("":
//                    break;
//                case ""+"":
//                    if(n != """"){
//                       node.push(new Node(null,null, n));
//                    }
//                    n = """";
//                    ops.push(a[i]);
//                    break;
//                case ""-"":
//                    if(n != """"){
//                       node.push(new Node(null,null, n));
//                    }
//                    n = """";
//                    ops.push(a[i]);
//                    break;
//                case ""/"":
//                    if(n != """"){
//                       node.push(new Node(null,null, n));
//                    }
//                    n = """";
//                    ops.push(a[i]);
//                    break;
//                case ""*"":
//                    if(n != """"){
//                       node.push(new Node(null,null, n));
//                    }
//                    n = """";
//                    ops.push(a[i]);
//                    break;
//                case "")"":
//                    if(n != """"){
//                       node.push(new Node(null,null, n));
//                    }
//                    n = """";
//                    Node A = node.pop();
//                    Node B = node.pop();
//                    node.push(new Node(B, A, ops.pop()));
//                    break;
//                default :
//                    n = n +a[i];
//                    break;
//            }
//        }
//        root = node.pop();
//        return root;
//    }

    public Node[] PrintPrefix() {
        prefix = new Node[nodenum];
        countpre = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Prere(root);
        return prefix;
    }

    public Node[] PrintPostfix() {
        postfix = new Node[nodenum];
        countpost = 0;
        if(root == null){
            throw new NullPointerException();
        }
        Postre(root);
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node[] k = PrintPostfix();
        for (int i = 0; i < nodenum; i++) {
            if (k[i].getValue().equals(""+"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a + b));
            } else if (k[i].getValue().equals(""-"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b - a));
            } else if (k[i].getValue().equals(""*"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(a * b));
            } else if (k[i].getValue().equals(""/"")) {
                double a = Double.parseDouble(val.pop());
                double b = Double.parseDouble(val.pop());
                val.push(String.valueOf(b / a));
            } else {
                val.push(k[i].getValue());
            }
        }
        answer = Double.parseDouble(val.pop());
        return answer;
    }

    public Node Postre(Node A) {
        if (A.getLeft() != null) {
            Postre(A.getLeft());
            Postre(A.getRight());
        }
//        Node B = new Node(null, null, A.getValue());
        postfix[countpost] = A;
        countpost++;
        return A;
    }

    public Node Prere(Node A) {
//        Node B = new Node(null, null, A.getValue());
        prefix[countpre] = A;
        countpre++;

        if (A.getLeft() != null) {
            Prere(A.getLeft());
            Prere(A.getRight());
        }
        return A;

    }

    public static void main(String[] args) throws Exception {

        String infix = ""((((((41+5)/33)-0.05)*(8-9))/4)+177.8)"";
        Expression expression = new Expression();
        expression.Infix2BT(infix);
        Node[] prefixNodes = expression.PrintPrefix();
        for (Node n : prefixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        Node[] postfixNodes = expression.PrintPostfix();
        for (Node n : postfixNodes) {
            System.out.print(n.getValue());
        }
        System.out.println("""");

        System.out.println(expression.Evaluation());
     
    }

}
@179205e21ddba335f53ef6ab6e253317@"
"b03611011","0","0.19","105584","@e5ce36e505c873da653d8bc0157e3804@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Stack;

public class Expression {

    public class Node {

        private Node left;
        private Node right;
        private String value;

        public Node(Node left, Node right, String value) {
            this.left = left;
            this.right = right;
            this.value = value;
        }

        public Node getLeft() {
            return (this.left);
        }

        public Node getRight() {
            return (this.right);
        }

        public String getValue() {
            return (this.value);
        }

        public void setLeft(Node left) {
            this.left = left;
        }

        public void setRight(Node right) {
            this.right = right;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    public int j = 1;
    public int com = 1;

    public void put(Node x) {
        for (int i = j; i < lala.length; i = i + 0) {
            String s;
            i = j;
            s = lala[i];
            Node left, right;
            switch (s) {
                case ""("":
                    Node y = null;
                    y = new Node(y, y, null);
                    j++;
                    put(y);
                    x.setLeft(y);
                    i = j;
                    continue;
                case ""+"":
                    x.setValue(""+"");
//                    System.out.println(""+"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""*"":
                    x.setValue(""*"");
//                    System.out.println(""*"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""-"":
                    x.setValue(""-"");
//                    System.out.println(""-"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""/"":
                    x.setValue(""/"");
//                    System.out.println(""/"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case "")"":
                    j++;
//                    lala[i]="")"";i = j;
                    return;
                default:
                    y = null;
                    y = new Node(y, y, lala[j]);
//                    System.out.println(lala[j]);
                    x.setLeft(y);
                    j++;
                    i = j;
                    continue;
            }
        }
    }
    String[] lala;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            String fund = br.readLine();
//            Expression cct = new Expression();
//            cct.Infix2BT(fund);
//            cct.PrintPrefix();
//            double h=cct.Evaluation();
//            System.out.println(h);
//            String iaia= ""1.1235"";
//            double k =Double .parseDouble(iaia);
//            System.out.println(k);
        }
        // TODO code application logic here
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] c_arr = infix.toCharArray();
        int m = c_arr.length;
        tim=m;
        int k=0;
        lala = new String[m];
        for (int i = 0; i < m; i++) {
            String s;
            s = Character.toString(c_arr[i]);
            switch (s) {
                case ""("":
                    lala[i-k] = ""("";
                    tim=tim-1;
                    break;
                case ""+"":
                    lala[i-k] = ""+"";
                    break;
                case ""*"":
                    lala[i-k] = ""*"";
                    break;
                case ""-"":
                    lala[i-k] = ""-"";
                    break;
                case ""/"":
                    lala[i-k] = ""/"";
                    break;
                case "")"":
                    lala[i-k] = "")"";
                    tim=tim-1;
                    break;
                default:
                    if (lala[i - k] != null) {
                        lala[i - k] = lala[i - k] + s;
                    } else {
                        lala[i - k] = s;
                    }
                    if (c_arr[i+ 1] == '+' || c_arr[i  + 1] == ')' || c_arr[i  + 1] == '/' || c_arr[i +1]=='*'||c_arr[i+1]=='-'){break;}else{
                    k++;tim--;
                    }
            }
        }
        int h=lala.length-k;
        String[] tep=new String[lala.length-k];
        System.arraycopy(lala, 0, tep, 0, h);
        lala=tep;
        Node a, b;
        String c = ""0"";
        root = new Node(root, root, c);
        put(root);
//        root.setLeft();
        return root;
    }
    public int tim;
    public Node[] la;
    public void pre(Node x) {
        for(int i=0;i<tim;i++){
            if (x.value != null) {
                la[j]=x;
                j++;
                i=j;
            }
            if(x.left!= null){
        pre(x.left);}
            if(x.right!= null){
        pre(x.right);return;}else{return;}
        }
    }
        public void post(Node x) {
        for(int i=0;i<tim;i++){
            if (x.left != null) {
                post(x.left);
            }
            if (x.right != null) {
                post(x.right);
            }
            if (x.value != null) {
                la[j]=x;
                j++;
                i=j;
                return;
            }
        }
    }
    public Node[] PrintPrefix() {
        int l=0;
        j=0;
        la=new Node[tim];
        pre(root);
        Node[] prefix;
        prefix=la;
        return prefix;
    }

    public Node[] PrintPostfix() {
        int l=0;
        j=0;
        la=new Node[tim];
        post(root);
        Node[] postfix;
        postfix=la;
        return postfix;
    }

    public double Evaluation() {
        Stack<String> ops = new Stack<>();
        Stack<Double> vals = new Stack<>();
        int l = lala.length, cal = 0;
        int count = 0;
        while (count < l) {
            String s;
            s = lala[count];
            switch (s) {
                case ""("":
                    break;
                case ""+"":
                    ops.push(s);
                    break;
                case ""*"":
                    ops.push(s);
                    break;
                case ""-"":
                    ops.push(s);
                    break;
                case ""/"":
                    ops.push(s);
                    break;
                case "")"":
                    String op = ops.pop();
                    if (op.equals(""+"")) {
                        vals.push(vals.pop() + vals.pop());
                    } else if (op.equals(""*"")) {
                        vals.push(vals.pop() * vals.pop());
                    } else if (op.equals(""-"")) {
                        vals.push(-1 * (vals.pop() - vals.pop()));
                    } else if (op.equals(""/"")) {
                        vals.push((1 / vals.pop()) * vals.pop());
                    }
                    break;
                default:
                    vals.push(Double.parseDouble(s));
                    break;
            }
            count++;
        }
        return vals.pop();
    }
}

@e5ce36e505c873da653d8bc0157e3804@"
"b03611011","0","0.19","105584","@3fcdfd3248b2e141c627317641e0857d@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Stack;

public class Expression {

    public class Node {

        private Node left;
        private Node right;
        private String value;

        public Node(Node left, Node right, String value) {
            this.left = left;
            this.right = right;
            this.value = value;
        }

        public Node getLeft() {
            return (this.left);
        }

        public Node getRight() {
            return (this.right);
        }

        public String getValue() {
            return (this.value);
        }

        public void setLeft(Node left) {
            this.left = left;
        }

        public void setRight(Node right) {
            this.right = right;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    public int j = 1;
    public int com = 1;

    public void put(Node x) {
        for (int i = j; i < lala.length; i = i + 0) {
            String s;
            i = j;
            s = lala[i];
            Node left, right;
            switch (s) {
                case ""("":
                    Node y = null;
                    y = new Node(y, y, null);
                    j++;
                    put(y);
                    x.setLeft(y);
                    i = j;
                    continue;
                case ""+"":
                    x.setValue(""+"");
//                    System.out.println(""+"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""*"":
                    x.setValue(""*"");
//                    System.out.println(""*"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""-"":
                    x.setValue(""-"");
//                    System.out.println(""-"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""/"":
                    x.setValue(""/"");
//                    System.out.println(""/"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case "")"":
                    j++;
//                    lala[i]="")"";i = j;
                    return;
                default:
                    y = null;
                    y = new Node(y, y, lala[j]);
//                    System.out.println(lala[j]);
                    x.setLeft(y);
                    j++;
                    i = j;
                    continue;
            }
        }
    }
    String[] lala;

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            String fund = br.readLine();
            Expression cct = new Expression();
            cct.Infix2BT(fund);
            Node[] f=cct.PrintPrefix();
            cct.PrintPostfix();
            double h=cct.Evaluation();
            System.out.println(h);
//            String iaia= ""1.1235"";
//            double k =Double .parseDouble(iaia);
//            System.out.println(k);
        }
        // TODO code application logic here
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] c_arr = infix.toCharArray();
        int m = c_arr.length;
        tim=m;
        int k=0;
        lala = new String[m];
        for (int i = 0; i < m; i++) {
            String s;
            s = Character.toString(c_arr[i]);
            switch (s) {
                case ""("":
                    lala[i-k] = ""("";
                    tim=tim-1;
                    break;
                case ""+"":
                    lala[i-k] = ""+"";
                    break;
                case ""*"":
                    lala[i-k] = ""*"";
                    break;
                case ""-"":
                    lala[i-k] = ""-"";
                    break;
                case ""/"":
                    lala[i-k] = ""/"";
                    break;
                case "")"":
                    lala[i-k] = "")"";
                    tim=tim-1;
                    break;
                default:
                    if (lala[i - k] != null) {
                        lala[i - k] = lala[i - k] + s;
                    } else {
                        lala[i - k] = s;
                    }
                    if (c_arr[i+ 1] == '+' || c_arr[i  + 1] == ')' || c_arr[i  + 1] == '/' || c_arr[i +1]=='*'||c_arr[i+1]=='-'){break;}else{
                    k++;tim--;
                    }
            }
        }
        int h=lala.length-k;
        String[] tep=new String[lala.length-k];
        System.arraycopy(lala, 0, tep, 0, h);
        lala=tep;
        Node a, b;
        String c = ""0"";
        root = new Node(root, root, c);
        put(root);
//        root.setLeft();
        return root;
    }
    public int tim;
    public Node[] la;
    public void pre(Node x) {
        for(int i=0;i<tim;i++){
            if (x.value != null) {
                la[j]=x;
                j++;
                i=j;
            }
            if(x.left!= null){
        pre(x.left);}
            if(x.right!= null){
        pre(x.right);return;}else{return;}
        }
    }
        public void post(Node x) {
        for(int i=0;i<tim;i++){
            if (x.left != null) {
                post(x.left);
            }
            if (x.right != null) {
                post(x.right);
            }
            if (x.value != null) {
                la[j]=x;
                j++;
                i=j;
                return;
            }
        }
    }
    public Node[] PrintPrefix() {
        int l=0;
        j=0;
        la=new Node[tim];
        pre(root);
        Node[] prefix;
        prefix=la;
        return prefix;
    }

    public Node[] PrintPostfix() {
        int l=0;
        j=0;
        la=new Node[tim];
        post(root);
        Node[] postfix;
        postfix=la;
        return postfix;
    }

    public double Evaluation() {
        Stack<String> ops = new Stack<>();
        Stack<Double> vals = new Stack<>();
        int l = lala.length, cal = 0;
        int count = 0;
        while (count < l) {
            String s;
            s = lala[count];
            switch (s) {
                case ""("":
                    break;
                case ""+"":
                    ops.push(s);
                    break;
                case ""*"":
                    ops.push(s);
                    break;
                case ""-"":
                    ops.push(s);
                    break;
                case ""/"":
                    ops.push(s);
                    break;
                case "")"":
                    String op = ops.pop();
                    if (op.equals(""+"")) {
                        vals.push(vals.pop() + vals.pop());
                    } else if (op.equals(""*"")) {
                        vals.push(vals.pop() * vals.pop());
                    } else if (op.equals(""-"")) {
                        vals.push(-1 * (vals.pop() - vals.pop()));
                    } else if (op.equals(""/"")) {
                        vals.push((1 / vals.pop()) * vals.pop());
                    }
                    break;
                default:
                    vals.push(Double.parseDouble(s));
                    break;
            }
            count++;
        }
        return vals.pop();
    }
}

@3fcdfd3248b2e141c627317641e0857d@"
"r04631034","6","0.99","105856","@2d1bf09a4153258d2db0793a929d2dd6@
import java.util.*;

public class Expression {

          private Node root;

          // DO NOT MODIFY THIS
          public Expression() {
          }

          private boolean isCalculator(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else if (java.lang.Character.isDigit(c.charAt(0))) {
                              return true;
                    }
                    return false;
          }

          private boolean isOperation(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else {
                              return false;
                    }
          }

          private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }

          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }

          private void posfix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    list.add(node);
          }

// Build a Binary and Return the Root
          public Node Infix2BT(String infix) {
                    String[] charater = infix.split("""");
                    charater = Arrays.copyOfRange(charater, 1, charater.length);
                    Stack<Node> treeNode = new Stack<Node>();
                    for (int counter = 0; counter < charater.length; counter++) {
                              if (isCalculator(charater[counter])) {
                                        treeNode.push(new Node(null, null, charater[counter]));
                              } else if (charater[counter].equals("")"")) {
                                        Node right = treeNode.pop();
                                        Node mid = treeNode.pop();
                                        Node left = treeNode.pop();
                                        mid.setLeft(left);
                                        mid.setRight(right);
                                        treeNode.push(mid);
                              }
                              else continue;
                    }
                    this.root = treeNode.pop();
                    return this.root;
          }

          public Node[] PrintPrefix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              prefix(array, this.root);
                              Node[] prefix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        prefix[count] = array.get(count);
                              }
                              return prefix;
                    }
          }

          public Node[] PrintPostfix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Node[] posfix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        posfix[count] = array.get(count);
                              }
                              return posfix;
                    }
          }

          public double Evaluation() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Stack<Double> storge = new Stack<Double>();
                              for (int count = 0; count < array.size(); count++) {
                                        if (isOperation(array.get(count).getValue())) {

                                                  Calculate(storge, array.get(count).getValue());
                                        } else {
                                                  storge.push(Double.parseDouble(array.get(count).getValue()));
                                        }
                              }

                              return storge.pop();
                    }
          }
}


@2d1bf09a4153258d2db0793a929d2dd6@"
"r04631034","6","0.98","105824","@0022c63cbf2c393bc972669ddc510d82@
import java.util.*;

public class Expression {

          private Node root;

          // DO NOT MODIFY THIS
          public Expression() {
          }

          private boolean isCalculator(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else if (java.lang.Character.isDigit(c.charAt(0))) {
                              return true;
                    }
                    return false;
          }

          private boolean isOperation(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else {
                              return false;
                    }
          }

          private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }

          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }

          private void posfix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    list.add(node);
          }

                    private void infix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    list.add(node);
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    
          }
// Build a Binary and Return the Root
          public Node Infix2BT(String infix) {
                    String[] charater = infix.split("""");
                    charater = Arrays.copyOfRange(charater, 1, charater.length);
                    Stack<Node> treeNode = new Stack<Node>();
                    for (int counter = 0; counter < charater.length; counter++) {
                              if (isCalculator(charater[counter])) {
                                        treeNode.push(new Node(null, null, charater[counter]));
                              } else if (charater[counter].equals("")"")) {
                                        Node right = treeNode.pop();
                                        Node mid = treeNode.pop();
                                        Node left = treeNode.pop();
                                        mid.setLeft(left);
                                        mid.setRight(right);
                                        treeNode.push(mid);
                              }
                              else continue;
                    }
                    this.root = treeNode.pop();
                    return this.root;
          }

          public Node[] PrintPrefix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              prefix(array, this.root);
                              Node[] prefix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        prefix[count] = array.get(count);
                              }
                              return prefix;
                    }
          }
          
          public Node[] printInOrder() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              infix(array, this.root);
                              Node[] infix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        infix[count] = array.get(count);
                              }
                              return infix;
                    }
          }
          
          public Node[] PrintPostfix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Node[] posfix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        posfix[count] = array.get(count);
                              }
                              return posfix;
                    }
          }

          public double Evaluation() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Stack<Double> storge = new Stack<Double>();
                              for (int count = 0; count < array.size(); count++) {
                                        if (isOperation(array.get(count).getValue())) {

                                                  Calculate(storge, array.get(count).getValue());
                                        } else {
                                                  storge.push(Double.parseDouble(array.get(count).getValue()));
                                        }
                              }

                              return storge.pop();
                    }
          }
}


@0022c63cbf2c393bc972669ddc510d82@"
"r04228002","1","0.1","102464","@f598148d3f96675ff3bef503c1118e0a@
import java.util.Arrays;
import java.util.ArrayList;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
public class Expression{
  
    private Node root;
    private Node Newroot;
    private Queue<Node> PreNodeList = new Queue<Node>();
    //private ArrayList<Node> PreNodeList = new ArrayList<Node>();
    private Stack<Node> PostNodeList = new Stack<Node>();
    private Stack<Node> EVA =new Stack<Node>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        Stack<String> S1 = new Stack<String>();
        Stack<String> S2 = new Stack<String>();
        
        String[] I = infix.split("""");
        for (int i=1;i<I.length;i++){
            S1.push(I[i]);
        }
        
        while (S1.size()!=0){
            String O = S1.pop();
            while (!O.equals(""("")){
                S2.push(O);
                O=S1.pop();
            }
            
            
            String O1 = S2.pop();
            String Number1 = """";
            while(!O1.equals(""+"") && !O1.equals(""-"") && !O1.equals(""*"") && !O1.equals(""/"")){
                Number1 = Number1+O1;
                O1=S2.pop();
            }
            
            String O2 = S2.pop();
            String Number2 = """";
            while(!O2.equals("")"")){
                Number2 = Number2+O2;
                O2=S2.pop();
            }
            
            if (!Number1.equals("""") && !Number2.equals("""")){
                Node L = new Node(null,null,Number1);
                Node R = new Node(null,null,Number2);
                root=new Node(L,R,O1);
            }
            else if (Number1.equals("""")){
                Node R = new Node(null,null,Number2);
                Newroot = new Node(root,R,O1);
                root=Newroot;
            }
            else{
                Node L = new Node(null,null,Number1);
                Newroot = new Node(L,root,O1);
                root=Newroot;
            }
        }
        
        return root;
    }

    public Node[] PrintPrefix(){
        if (root==null) throw new NullPointerException();
        root = getPrefix(root);
        //Node[] prefix = PreNodeList.toArray(new Node[PreNodeList.size()]);
        Integer size1 = PreNodeList.size();
        Node[] prefix = new Node[size1];
        for (int i=0;i<size1;i++){
            prefix[i]=PreNodeList.dequeue();
        }
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if (root==null) throw new NullPointerException();
        root = getPostfix(root);
        Integer size2 = PostNodeList.size();
        Node[] postfix = new Node[size2];
        for (int i=0;i<size2;i++){
            postfix[i]=PostNodeList.pop();
        }
        return postfix;
    }

    public double Evaluation(){
        if (root==null) throw new NullPointerException();
        Stack<Node> Temp = new Stack<Node>();
        root = getEVA(root);
        while (EVA.size() > 1){
            Node N1 = EVA.pop();
            Node N2 = EVA.pop();
            Node OP = EVA.pop();
            String OPV = OP.getValue();
            while (!OPV.equals(""+"") && !OPV.equals(""-"") && !OPV.equals(""*"") && !OPV.equals(""/"")){
                Temp.push(N1);
                N1=N2;
                N2=OP;
                OP=EVA.pop();
                OPV=OP.getValue();
            }
            Node TempNode = new Node(null,null,calValue(N1.getValue(),N2.getValue(),OP.getValue()));
            EVA.push(TempNode);
            while(Temp.size()!=0){
                EVA.push(Temp.pop());
            }
        }
        String a1 = EVA.pop().getValue();
        double answer = Double.parseDouble(a1);
        
        return answer;
    }
    ////////////////////////////////////////////////////////////////////////
    
    public Node getPrefix(Node n){
        if (n==null) return null;
        PreNodeList.enqueue(n);
        //PreNodeList.add(n);
        //if (n.getLeft()!=null) n.setLeft(getPrefix(n.getLeft()));
        //if (n.getRight()!=null) n.setRight(getPrefix(n.getRight()));
        n.setLeft(getPrefix(n.getLeft()));
        n.setRight(getPrefix(n.getRight()));
        return n;
    }
    
    
    public Node getPostfix(Node n){
        if (n==null) return null;
        PostNodeList.push(n);
        if (n.getRight()!=null) n.setRight(getPostfix(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getPostfix(n.getLeft()));
        return n;       
    }
    
    
    public Node getEVA(Node n){
        if (n==null) return null;
        EVA.push(n);
        if (n.getRight()!=null) n.setRight(getEVA(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getEVA(n.getLeft()));
        return n;
    }
    
    private String calValue(String n1,String n2, String op){
        double N1 = Double.parseDouble(n1);
        double N2 = Double.parseDouble(n2);
        if (op.equals(""+"")) return Double.toString(N1+N2);
        else if (op.equals(""-""))return Double.toString(N1-N2);
        else if (op.equals(""*""))return Double.toString(N1*N2);
        else return Double.toString(N1/N2);
    }
    
    /*
    public static void main(String[] args) {
        
    }
    */
}

    


@f598148d3f96675ff3bef503c1118e0a@"
"r04228002","1","0.09","99072","@2f129baf6820eff457bc0d2c470f7911@
import java.util.Arrays;
import java.util.ArrayList;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
public class Expression{
  
    private Node root;
    private Node Newroot;
    private Queue<Node> PreNodeList = new Queue<Node>();
    //private ArrayList<Node> PreNodeList = new ArrayList<Node>();
    private Stack<Node> PostNodeList = new Stack<Node>();
    private Stack<Node> EVA =new Stack<Node>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        Stack<String> S1 = new Stack<String>();
        Stack<String> S2 = new Stack<String>();
        
        String[] I = infix.split("""");
        for (int i=1;i<I.length;i++){
            S1.push(I[i]);
        }
        
        
        while (S1.size()!=0){
            String O = S1.pop();
            while (!O.equals(""("")){
                S2.push(O);
                O=S1.pop();
            }
            
            String O1 = S2.pop();
            String Number1 = """";
            while(!O1.equals(""+"") && !O1.equals(""-"") && !O1.equals(""*"") && !O1.equals(""/"")){
                if (S2.size()==0){
                    root = new Node(null,null,Number1);
                    return root;
                }
                Number1 = Number1+O1;
                O1=S2.pop();
            }
            
            String O2 = S2.pop();
            String Number2 = """";
            while(!O2.equals("")"")){
                Number2 = Number2+O2;
                O2=S2.pop();
            }
            
            if (!Number1.equals("""") && !Number2.equals("""")){
                Node L = new Node(null,null,Number1);
                Node R = new Node(null,null,Number2);
                root=new Node(L,R,O1);
            }
            else if (Number1.equals("""")){
                Node R = new Node(null,null,Number2);
                Newroot = new Node(root,R,O1);
                root=Newroot;
            }
            else{
                Node L = new Node(null,null,Number1);
                Newroot = new Node(L,root,O1);
                root=Newroot;
            }
        }
        
        return root;
    }

    public Node[] PrintPrefix(){
        if (root==null) throw new NullPointerException();
        root = getPrefix(root);
        //Node[] prefix = PreNodeList.toArray(new Node[PreNodeList.size()]);
        Integer size1 = PreNodeList.size();
        Node[] prefix = new Node[size1];
        for (int i=0;i<size1;i++){
            prefix[i]=PreNodeList.dequeue();
        }
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if (root==null) throw new NullPointerException();
        root = getPostfix(root);
        Integer size2 = PostNodeList.size();
        Node[] postfix = new Node[size2];
        for (int i=0;i<size2;i++){
            postfix[i]=PostNodeList.pop();
        }
        return postfix;
    }

    public double Evaluation(){
        if (root==null) throw new NullPointerException();
        Stack<Node> Temp = new Stack<Node>();
        root = getEVA(root);
        while (EVA.size() > 1){
            Node N1 = EVA.pop();
            Node N2 = EVA.pop();
            Node OP = EVA.pop();
            String OPV = OP.getValue();
            while (!OPV.equals(""+"") && !OPV.equals(""-"") && !OPV.equals(""*"") && !OPV.equals(""/"")){
                Temp.push(N1);
                N1=N2;
                N2=OP;
                OP=EVA.pop();
                OPV=OP.getValue();
            }
            Node TempNode = new Node(null,null,calValue(N1.getValue(),N2.getValue(),OP.getValue()));
            EVA.push(TempNode);
            while(Temp.size()!=0){
                EVA.push(Temp.pop());
            }
        }
        String a1 = EVA.pop().getValue();
        double answer = Double.parseDouble(a1);
        
        return answer;
    }
    ////////////////////////////////////////////////////////////////////////
    
    public Node getPrefix(Node n){
        if (n==null) return null;
        PreNodeList.enqueue(n);
        //PreNodeList.add(n);
        //if (n.getLeft()!=null) n.setLeft(getPrefix(n.getLeft()));
        //if (n.getRight()!=null) n.setRight(getPrefix(n.getRight()));
        n.setLeft(getPrefix(n.getLeft()));
        n.setRight(getPrefix(n.getRight()));
        return n;
    }
    
    
    public Node getPostfix(Node n){
        if (n==null) return null;
        PostNodeList.push(n);
        if (n.getRight()!=null) n.setRight(getPostfix(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getPostfix(n.getLeft()));
        return n;       
    }
    
    
    public Node getEVA(Node n){
        if (n==null) return null;
        EVA.push(n);
        if (n.getRight()!=null) n.setRight(getEVA(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getEVA(n.getLeft()));
        return n;
    }
    
    private String calValue(String n1,String n2, String op){
        double N1 = Double.parseDouble(n1);
        double N2 = Double.parseDouble(n2);
        if (op.equals(""+"")) return Double.toString(N1+N2);
        else if (op.equals(""-""))return Double.toString(N1-N2);
        else if (op.equals(""*""))return Double.toString(N1*N2);
        else return Double.toString(N1/N2);
    }
    
    /*
    public static void main(String[] args) {
        
    }
    */
}

    


@2f129baf6820eff457bc0d2c470f7911@"
"r04546014","1","0.34","115456","@71858df19afcf2be7715a9b9a4dc2dfa@
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    List<Node> nodeList;
    String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) throws Exception {
        infixClone=infix;//複製一份infix
        Stack<Node> st = new Stack<Node>();
        Scanner sca = new Scanner(infix);
        String value;
        Node node;
        Node a,operator,b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node=new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b=st.pop();//第一個pop出來是後面的數字b
                    operator=st.pop();//第二個是運算式
                    a=st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node=new Node(null,null,value);
                    st.push(node);
                }
            }
        }
        root=st.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix = (Node[]) nodeList.toArray();//將list轉成array
        return prefix;
    }

    public Node[] PrintPostfix() {               
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix = (Node[]) nodeList.toArray();//將list轉成array
        return postfix;
    }

    public double Evaluation() {        
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a ,b ;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;
    }
    
    private void prefixRecursive(Node n){
        nodeList.add(n);//先儲存再往左往右
        if(n.getLeft()!=null) prefixRecursive(n.getLeft());
        if(n.getRight()!=null) prefixRecursive(n.getRight());
        return;
    }
    
    private void postfixRecursive(Node n){
        if(n.getLeft()!=null) prefixRecursive(n.getLeft());
        if(n.getRight()!=null) prefixRecursive(n.getRight());
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@71858df19afcf2be7715a9b9a4dc2dfa@"
"r04228002","1","0.58","104080","@6b9b69d6013f54cfd520ff13a253bad8@
import java.util.Arrays;
import java.util.ArrayList;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
public class Expression{
  
    private Node root;
    private Node Rroot;
    private Node Newroot;
    private Integer Rbracket = 0;
    private Integer Lbracket = 0;
    
    private Queue<Node> PreNodeList = new Queue<Node>();
    //private ArrayList<Node> PreNodeList = new ArrayList<Node>();
    private Stack<Node> PostNodeList = new Stack<Node>();
    private Stack<Node> EVA =new Stack<Node>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        if (infix.equals("""")) {root=null; return root;}
        root = null;
        Rroot=null;
        Stack<String> S1 = new Stack<String>();
        Stack<String> S2 = new Stack<String>();
        
        String[] I = infix.split("""");
        for (int i=1;i<I.length;i++){
            //System.out.println(I[i]); 
            S1.push(I[i]);
        }
        
        
        while (S1.size()> 1){
            String O = S1.pop();
            String temp = S1.pop();
            if (O.equals("")"")) Rbracket++;
            else if (O.equals(""("")) {Lbracket++;}
            
            if ((O.equals(""+"") || O.equals(""-"") || O.equals(""*"") || O.equals(""/"")) && Rbracket-Lbracket==1){
                root=new Node(null,Rroot,O);
                Rroot=null;
                continue;
            }
            
            if ((O.equals(""+"") && O.equals(""-"") && O.equals(""*"") && O.equals(""/""))&&temp.equals("")"")){
                Newroot = new Node(null,Rroot,O);
                Rroot = Newroot;
                S1.push(temp);
                continue;
            }
            S1.push(temp);
            
            ////////////////////////////////////////////////////////////////////
            while (!O.equals(""("")){
                S2.push(O);
                O=S1.pop();
                if (O.equals("")"")) Rbracket++;
                else if (O.equals(""("")) {Lbracket++;}
            }
            
            String O1 = S2.pop();
            String Number1 = """";
            while(!O1.equals(""+"") && !O1.equals(""-"") && !O1.equals(""*"") && !O1.equals(""/"")){
                
                if (S2.size()==0){
                    root = new Node(null,null,Number1);
                    return root;
                }
                
                Number1 = Number1+O1;
                O1=S2.pop();
            }
            
            String O2 = S2.pop();
            String Number2 = """";
            while(!O2.equals("")"")){
                Number2 = Number2+O2;
                O2=S2.pop();
            }
            
            if (!Number1.equals("""") && !Number2.equals("""")){
                Node L = new Node(null,null,Number1);
                Node R = new Node(null,null,Number2);
                Node OO = new Node(L,R,O1);
                if (Rroot == null) Rroot=OO;
                else {
                    Rroot.setLeft(OO);
                }
            }
            else if (Number1.equals("""")){
                Node R = new Node(null,null,Number2);
                Newroot = new Node(Rroot,R,O1);
                Rroot=Newroot;
            }
            else{
                Node L = new Node(null,null,Number1);
                Newroot = new Node(L,Rroot,O1);
                Rroot=Newroot;
            }
        }
        
        root.setLeft(Rroot);
        return root;
    }

    public Node[] PrintPrefix(){
        if (root==null) throw new NullPointerException();
        root = getPrefix(root);
        //Node[] prefix = PreNodeList.toArray(new Node[PreNodeList.size()]);
        Integer size1 = PreNodeList.size();
        Node[] prefix = new Node[size1];
        for (int i=0;i<size1;i++){
            prefix[i]=PreNodeList.dequeue();
        }
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if (root==null) throw new NullPointerException();
        root = getPostfix(root);
        Integer size2 = PostNodeList.size();
        Node[] postfix = new Node[size2];
        for (int i=0;i<size2;i++){
            postfix[i]=PostNodeList.pop();
        }
        return postfix;
    }

    public double Evaluation(){
        if (root==null) throw new NullPointerException();
        Stack<Node> Temp = new Stack<Node>();
        root = getEVA(root);
        while (EVA.size() > 1){
            Node N1 = EVA.pop();
            Node N2 = EVA.pop();
            Node OP = EVA.pop();
            String OPV = OP.getValue();
            while (!OPV.equals(""+"") && !OPV.equals(""-"") && !OPV.equals(""*"") && !OPV.equals(""/"")){
                Temp.push(N1);
                N1=N2;
                N2=OP;
                OP=EVA.pop();
                OPV=OP.getValue();
            }
            Node TempNode = new Node(null,null,calValue(N1.getValue(),N2.getValue(),OP.getValue()));
            EVA.push(TempNode);
            while(Temp.size()!=0){
                EVA.push(Temp.pop());
            }
        }
        String a1 = EVA.pop().getValue();
        double answer = Double.parseDouble(a1);
        
        return answer;
    }
    ////////////////////////////////////////////////////////////////////////
    
    public Node getPrefix(Node n){
        if (n==null) return null;
        PreNodeList.enqueue(n);
        //PreNodeList.add(n);
        //if (n.getLeft()!=null) n.setLeft(getPrefix(n.getLeft()));
        //if (n.getRight()!=null) n.setRight(getPrefix(n.getRight()));
        n.setLeft(getPrefix(n.getLeft()));
        n.setRight(getPrefix(n.getRight()));
        return n;
    }
    
    
    public Node getPostfix(Node n){
        if (n==null) return null;
        PostNodeList.push(n);
        if (n.getRight()!=null) n.setRight(getPostfix(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getPostfix(n.getLeft()));
        return n;       
    }
    
    
    public Node getEVA(Node n){
        if (n==null) return null;
        EVA.push(n);
        if (n.getRight()!=null) n.setRight(getEVA(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getEVA(n.getLeft()));
        return n;
    }
    
    private String calValue(String n1,String n2, String op){
        double N1 = Double.parseDouble(n1);
        double N2 = Double.parseDouble(n2);
        if (op.equals(""+"")) return Double.toString(N1+N2);
        else if (op.equals(""-""))return Double.toString(N1-N2);
        else if (op.equals(""*""))return Double.toString(N1*N2);
        else return Double.toString(N1/N2);
    }
    
    /*
    public static void main(String[] args) {
        
    }
    */
}

    


@6b9b69d6013f54cfd520ff13a253bad8@"
"r04228002","1","0.38","102944","@33f4327f14e1eaf425b8cba0fd2294bf@
import java.util.Arrays;
import java.util.ArrayList;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
public class Expression{
  
    private Node root;
    private Node Rroot;
    private Node Newroot;
    private Integer Rbracket = 0;
    private Integer Lbracket = 0;
    
    private Queue<Node> PreNodeList = new Queue<Node>();
    //private ArrayList<Node> PreNodeList = new ArrayList<Node>();
    private Stack<Node> PostNodeList = new Stack<Node>();
    private Stack<Node> EVA =new Stack<Node>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        if (infix.equals("""")) {root=null; return root;}
        root = null;
        Rroot=null;
        Stack<String> S1 = new Stack<String>();
        Stack<String> S2 = new Stack<String>();
        
        String[] I = infix.split("""");
        for (int i=1;i<I.length;i++){
            //System.out.println(I[i]); 
            S1.push(I[i]);
        }
        
        
        while (S1.size()> 1){
            String O = S1.pop();
            
            if (O.equals("")"")) Rbracket++;
            else if (O.equals(""("")) {Lbracket++;}
            
            if ((O.equals(""+"") || O.equals(""-"") || O.equals(""*"") || O.equals(""/"")) && Rbracket-Lbracket==1){
                root=new Node(null,Rroot,O);
                Rroot=null;
                //System.out.println(S1.size());
                //System.out.println(S2.size());
                continue;
            }
            String temp = S1.pop();
            if ((O.equals(""+"") && O.equals(""-"") && O.equals(""*"") && O.equals(""/""))&&temp.equals("")"")){
                Newroot = new Node(null,Rroot,O);
                Rroot = Newroot;
                S1.push(temp);
                continue;
            }
            S1.push(temp);
            
            ////////////////////////////////////////////////////////////////////
            while (!O.equals(""("")){
                S2.push(O);
                O=S1.pop();
                if (O.equals("")"")) Rbracket++;
                else if (O.equals(""("")) {Lbracket++;}
            }
            
            String O1 = S2.pop();
            String Number1 = """";
            while(!O1.equals(""+"") && !O1.equals(""-"") && !O1.equals(""*"") && !O1.equals(""/"")){
                
                if (S2.size()==0){
                    Node OO = new Node(null,null,Number1);
                    if (root==null){
                    root = OO;
                    return root;
                    }
                    else{
                        root.setLeft(OO);
                        return root;
                    }
                }
                
                Number1 = Number1+O1;
                O1=S2.pop();
            }
            
            String O2 = S2.pop();
            String Number2 = """";
            while(!O2.equals("")"")){
                Number2 = Number2+O2;
                O2=S2.pop();
            }
            
            if (!Number1.equals("""") && !Number2.equals("""")){
                Node L = new Node(null,null,Number1);
                Node R = new Node(null,null,Number2);
                Node OO = new Node(L,R,O1);
                if (Rroot == null) Rroot=OO;
                else {
                    Rroot.setLeft(OO);
                }
            }
            else if (Number1.equals("""")){
                Node R = new Node(null,null,Number2);
                Newroot = new Node(Rroot,R,O1);
                Rroot=Newroot;
            }
            else{
                Node L = new Node(null,null,Number1);
                Newroot = new Node(L,Rroot,O1);
                Rroot=Newroot;
            }
        }
        
        root.setLeft(Rroot);
        return root;
    }

    public Node[] PrintPrefix(){
        if (root==null) throw new NullPointerException();
        root = getPrefix(root);
        //Node[] prefix = PreNodeList.toArray(new Node[PreNodeList.size()]);
        Integer size1 = PreNodeList.size();
        Node[] prefix = new Node[size1];
        for (int i=0;i<size1;i++){
            prefix[i]=PreNodeList.dequeue();
        }
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if (root==null) throw new NullPointerException();
        root = getPostfix(root);
        Integer size2 = PostNodeList.size();
        Node[] postfix = new Node[size2];
        for (int i=0;i<size2;i++){
            postfix[i]=PostNodeList.pop();
        }
        return postfix;
    }

    public double Evaluation(){
        if (root==null) throw new NullPointerException();
        Stack<Node> Temp = new Stack<Node>();
        root = getEVA(root);
        while (EVA.size() > 1){
            Node N1 = EVA.pop();
            Node N2 = EVA.pop();
            Node OP = EVA.pop();
            String OPV = OP.getValue();
            while (!OPV.equals(""+"") && !OPV.equals(""-"") && !OPV.equals(""*"") && !OPV.equals(""/"")){
                Temp.push(N1);
                N1=N2;
                N2=OP;
                OP=EVA.pop();
                OPV=OP.getValue();
            }
            Node TempNode = new Node(null,null,calValue(N1.getValue(),N2.getValue(),OP.getValue()));
            EVA.push(TempNode);
            while(Temp.size()!=0){
                EVA.push(Temp.pop());
            }
        }
        String a1 = EVA.pop().getValue();
        double answer = Double.parseDouble(a1);
        
        return answer;
    }
    ////////////////////////////////////////////////////////////////////////
    
    public Node getPrefix(Node n){
        if (n==null) return null;
        PreNodeList.enqueue(n);
        //PreNodeList.add(n);
        //if (n.getLeft()!=null) n.setLeft(getPrefix(n.getLeft()));
        //if (n.getRight()!=null) n.setRight(getPrefix(n.getRight()));
        n.setLeft(getPrefix(n.getLeft()));
        n.setRight(getPrefix(n.getRight()));
        return n;
    }
    
    
    public Node getPostfix(Node n){
        if (n==null) return null;
        PostNodeList.push(n);
        if (n.getRight()!=null) n.setRight(getPostfix(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getPostfix(n.getLeft()));
        return n;       
    }
    
    
    public Node getEVA(Node n){
        if (n==null) return null;
        EVA.push(n);
        if (n.getRight()!=null) n.setRight(getEVA(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getEVA(n.getLeft()));
        return n;
    }
    
    private String calValue(String n1,String n2, String op){
        double N1 = Double.parseDouble(n1);
        double N2 = Double.parseDouble(n2);
        if (op.equals(""+"")) return Double.toString(N1+N2);
        else if (op.equals(""-""))return Double.toString(N1-N2);
        else if (op.equals(""*""))return Double.toString(N1*N2);
        else return Double.toString(N1/N2);
    }
    
    /*
    public static void main(String[] args) {
        
    }
    */
}

    


@33f4327f14e1eaf425b8cba0fd2294bf@"
"r04228002","1","0.38","105856","@d07d34e81ba53e81d84c1bb7ba390609@
import java.util.Arrays;
import java.util.ArrayList;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
public class Expression{
  
    private Node root;
    private Node Rroot;
    private Node Newroot;
    private Integer Rbracket = 0;
    private Integer Lbracket = 0;
    
    private Queue<Node> PreNodeList = new Queue<Node>();
    //private ArrayList<Node> PreNodeList = new ArrayList<Node>();
    private Stack<Node> PostNodeList = new Stack<Node>();
    private Stack<Node> EVA =new Stack<Node>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        if (infix.equals("""")) {root=null; return root;}
        root = null;
        Rroot=null;
        Stack<String> S1 = new Stack<String>();
        Stack<String> S2 = new Stack<String>();
        
        String[] I = infix.split("""");
        for (int i=1;i<I.length;i++){
            //System.out.println(I[i]); 
            S1.push(I[i]);
        }
        
        
        while (S1.size()> 1){
            String O = S1.pop();
            
            if (O.equals("")"")) Rbracket++;
            else if (O.equals(""("")) {Lbracket++;}
            
            if ((O.equals(""+"") || O.equals(""-"") || O.equals(""*"") || O.equals(""/"")) && Rbracket-Lbracket==1){
                root=new Node(null,Rroot,O);
                Rroot=null;
                //System.out.println(S1.size());
                //System.out.println(S2.size());
                continue;
            }
            String temp = S1.pop();
            if ((O.equals(""+"") && O.equals(""-"") && O.equals(""*"") && O.equals(""/""))&& temp.equals("")"")){
                Newroot = new Node(null,Rroot,O);
                Rroot = Newroot;
                S1.push(temp);
                continue;
            }
            S1.push(temp);
            
            ////////////////////////////////////////////////////////////////////
            while (!O.equals(""("")){
                S2.push(O);
                O=S1.pop();
                if (O.equals("")"")) Rbracket++;
                else if (O.equals(""("")) {Lbracket++;}
            }
            
            String O1 = S2.pop();                
            String Number1 = """";
            while(!O1.equals(""+"") && !O1.equals(""-"") && !O1.equals(""*"") && !O1.equals(""/"")){
                
                if (S2.size()==0){
                    Node OO = new Node(null,null,Number1);
                    if (root==null){
                    root = OO;
                    return root;
                    }
                    else{
                        root.setLeft(OO);
                        return root;
                    }
                }
                
                Number1 = Number1+O1;
                O1=S2.pop();
            }
            
            String O2 = S2.pop();
            String Number2 = """";
            while(!O2.equals("")"")){
                Number2 = Number2+O2;
                O2=S2.pop();
            }
            
            if (!Number1.equals("""") && !Number2.equals("""")){
                Node L = new Node(null,null,Number1);
                Node R = new Node(null,null,Number2);
                Node OO = new Node(L,R,O1);
                if (Rroot == null) Rroot=OO;
                else {
                    Rroot.setLeft(OO);
                }
            }
            else if (Number1.equals("""")){
                Node R = new Node(null,null,Number2);
                Newroot = new Node(Rroot,R,O1);
                Rroot=Newroot;
            }
            else{
                Node L = new Node(null,null,Number1);
                Newroot = new Node(L,Rroot,O1);
                Rroot=Newroot;
            }
        }
        
        if(S2.size()>1){
            String O3 = S2.pop();
            String Number3 = """";
            while (S2.size()>1){
                Number3=Number3+S2.pop();
            }
            Node OO = new Node(null,null,Number3);
            root = new Node(null,OO,O3);
        } 
        
        root.setLeft(Rroot);
        return root;
    }

    public Node[] PrintPrefix(){
        if (root==null) throw new NullPointerException();
        root = getPrefix(root);
        //Node[] prefix = PreNodeList.toArray(new Node[PreNodeList.size()]);
        Integer size1 = PreNodeList.size();
        Node[] prefix = new Node[size1];
        for (int i=0;i<size1;i++){
            prefix[i]=PreNodeList.dequeue();
        }
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if (root==null) throw new NullPointerException();
        root = getPostfix(root);
        Integer size2 = PostNodeList.size();
        Node[] postfix = new Node[size2];
        for (int i=0;i<size2;i++){
            postfix[i]=PostNodeList.pop();
        }
        return postfix;
    }

    public double Evaluation(){
        if (root==null) throw new NullPointerException();
        Stack<Node> Temp = new Stack<Node>();
        root = getEVA(root);
        while (EVA.size() > 1){
            Node N1 = EVA.pop();
            Node N2 = EVA.pop();
            Node OP = EVA.pop();
            String OPV = OP.getValue();
            while (!OPV.equals(""+"") && !OPV.equals(""-"") && !OPV.equals(""*"") && !OPV.equals(""/"")){
                Temp.push(N1);
                N1=N2;
                N2=OP;
                OP=EVA.pop();
                OPV=OP.getValue();
            }
            Node TempNode = new Node(null,null,calValue(N1.getValue(),N2.getValue(),OP.getValue()));
            EVA.push(TempNode);
            while(Temp.size()!=0){
                EVA.push(Temp.pop());
            }
        }
        String a1 = EVA.pop().getValue();
        double answer = Double.parseDouble(a1);
        
        return answer;
    }
    ////////////////////////////////////////////////////////////////////////
    
    public Node getPrefix(Node n){
        if (n==null) return null;
        PreNodeList.enqueue(n);
        //PreNodeList.add(n);
        //if (n.getLeft()!=null) n.setLeft(getPrefix(n.getLeft()));
        //if (n.getRight()!=null) n.setRight(getPrefix(n.getRight()));
        n.setLeft(getPrefix(n.getLeft()));
        n.setRight(getPrefix(n.getRight()));
        return n;
    }
    
    
    public Node getPostfix(Node n){
        if (n==null) return null;
        PostNodeList.push(n);
        if (n.getRight()!=null) n.setRight(getPostfix(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getPostfix(n.getLeft()));
        return n;       
    }
    
    
    public Node getEVA(Node n){
        if (n==null) return null;
        EVA.push(n);
        if (n.getRight()!=null) n.setRight(getEVA(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getEVA(n.getLeft()));
        return n;
    }
    
    private String calValue(String n1,String n2, String op){
        double N1 = Double.parseDouble(n1);
        double N2 = Double.parseDouble(n2);
        if (op.equals(""+"")) return Double.toString(N1+N2);
        else if (op.equals(""-""))return Double.toString(N1-N2);
        else if (op.equals(""*""))return Double.toString(N1*N2);
        else return Double.toString(N1/N2);
    }
    
    /*
    public static void main(String[] args) {
        
    }
    */
}

    


@d07d34e81ba53e81d84c1bb7ba390609@"
"b02611023","10","0.097","105856","@5f2a41904527cc5994188c0e76eb2ce8@
public class Expression {

    private Node root;
    private int size;    
    int index1 = 0;
    int index2 = 0;
    String[] array;
    Node[] prefix;
    Node[] postfix;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        Node r;
        Node l;
        size = 0;
        array = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])"");
        Stack<Node> tree = new Stack<Node>();
        
        for(String letters : array){
            if(letters.equals(""("") || letters.equals("""")){
                continue;
            }
            else if(letters.equals("")"")){
                r = tree.pop();
                root = tree.pop();
                l = tree.pop();
                
                root.setLeft(l);
                root.setRight(r);
                tree.push(root);
            }
            else{
                Node temp = new Node(null,null,letters);
                
                tree.push(temp);
                size ++;
            }
        }
        
        root = tree.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        if(root == null) throw new NullPointerException();
        
        prefix = new Node[size];
        pre_traversal(root);        
        return prefix;
    }

    public Node[] PrintPostfix() {
        if(root == null) throw new NullPointerException();
        
        postfix = new Node[size];
        post_traversal(root);       
        return postfix;
    }

    public double Evaluation() {
        if(root == null) throw new NullPointerException();
        
        double answer = 0;
        double a;
        double b;
        String op;
        Stack<String> temp = new Stack<String>();
        
        for(int i = 1; i < array.length; i ++){
            if (array[i].equals(""("")) {
                continue;
            }
            else if(array[i].equals("")"")){
                a = Double.parseDouble(temp.pop());
                op = temp.pop();
                b = Double.parseDouble(temp.pop());

                if (op.equals(""+"")) {
                    answer = b + a;
                }
                if (op.equals(""-"")) {
                    answer = b - a;
                }
                if (op.equals(""*"")) {
                    answer = b * a;
                }
                if (op.equals(""/"")) {
                    answer = b / a;
                }
                temp.push("""" + answer);
            }
            else{
                temp.push(array[i]);
            }
        }
        
        answer = Double.parseDouble(temp.pop());
        return answer;
    }
    
    public void pre_traversal(Node pre){
        
        if(pre != null){
            prefix[index1 ++] = pre;
            pre_traversal(pre.getLeft());
            pre_traversal(pre.getRight());
        }
        
    }
    
    public void post_traversal(Node post){
        
        if(post != null){
            post_traversal(post.getLeft());
            post_traversal(post.getRight());
            postfix[index2 ++] = post;
        }
    }

//    public static void main(String[] args) {
//        Expression exp = new Expression();
//        String s = ""(4+(((4*2)/2)/3))"";
//        exp.Infix2BT(s);
//        System.out.println(exp.size);
//        System.out.println(exp.root.getValue());
//        System.out.println(exp.prefix.length);
//        for(Node a : exp.PrintPostfix()){
//            System.out.println(a.getValue());
//        }
//        System.out.println(exp.Evaluation());
//    }

}

@5f2a41904527cc5994188c0e76eb2ce8@"
"d04631001","0","0.34","115456","@cb99737d649551dfe548adfc1aac5f9b@public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Double> vals = new Stack<Double>();
        Stack<String> ops = new Stack<String>();
        String[] ee = infix.split("""");
        for (int i = 0; i < ee.length; i++) {
            if (ee[i].equals(""("")) {             
            } else if (ee[i].equals(""+"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""-"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""*"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""/"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals("")"")) {
                String op = ops.pop();
                if (op.equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (op.equals(""-"")) {
                    vals.push((-1 * vals.pop()) + vals.pop());
                } else if (op.equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (op.equals(""/"")) {
                    vals.push((1 / vals.pop()) * vals.pop());
                }
                String root = op;
            } else {
                vals.push(Double.parseDouble(ee[i])); 
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        
        return postfix;
    }

    public double Evaluation(String infix){
        double answer = 0;
        Stack<Double> vals = new Stack<Double>();
        Stack<String> ops = new Stack<String>();
        String[] ee = infix.split("""");
        for (int i = 0; i < ee.length; i++) {
            if (ee[i].equals(""("")) {             
            } else if (ee[i].equals(""+"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""-"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""*"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""/"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals("")"")) {
                String op = ops.pop();
                if (op.equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (op.equals(""-"")) {
                    vals.push((-1 * vals.pop()) + vals.pop());
                } else if (op.equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (op.equals(""/"")) {
                    vals.push((1 / vals.pop()) * vals.pop());
                }
            } else {
                vals.push(Double.parseDouble(ee[i])); 
            }
        }
        answer = (vals.pop());
        return answer;
    }
}

@cb99737d649551dfe548adfc1aac5f9b@"
"d04631001","0","0.34","115456","@0ae5f9bd0c7331d9f34f244211310799@
import edu.princeton.cs.algs4.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Double> vals = new Stack<Double>();
        Stack<String> ops = new Stack<String>();
        String[] ee = infix.split("""");
        for (int i = 0; i < ee.length; i++) {
            if (ee[i].equals(""("")) {             
            } else if (ee[i].equals(""+"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""-"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""*"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""/"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals("")"")) {
                String op = ops.pop();
                if (op.equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (op.equals(""-"")) {
                    vals.push((-1 * vals.pop()) + vals.pop());
                } else if (op.equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (op.equals(""/"")) {
                    vals.push((1 / vals.pop()) * vals.pop());
                }
                String root = op;
            } else {
                vals.push(Double.parseDouble(ee[i])); 
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        
        return postfix;
    }

    public double Evaluation(String infix){
        double answer = 0;
        Stack<Double> vals = new Stack<Double>();
        Stack<String> ops = new Stack<String>();
        String[] ee = infix.split("""");
        for (int i = 0; i < ee.length; i++) {
            if (ee[i].equals(""("")) {             
            } else if (ee[i].equals(""+"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""-"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""*"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""/"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals("")"")) {
                String op = ops.pop();
                if (op.equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (op.equals(""-"")) {
                    vals.push((-1 * vals.pop()) + vals.pop());
                } else if (op.equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (op.equals(""/"")) {
                    vals.push((1 / vals.pop()) * vals.pop());
                }
            } else {
                vals.push(Double.parseDouble(ee[i])); 
            }
        }
        answer = (vals.pop());
        return answer;
    }
}

@0ae5f9bd0c7331d9f34f244211310799@"
"r04546014","2","0.35","112336","@3df59ab2cc3924457fb20d47e2daeba6@
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

/**
 *
 * @author Jayden
 */
public class Expression {

    static private Node root;
    List<Node> nodeList;
    static String infixClone;

//    public static void main(String[] args) {
//        String a=""(4+(((4*2)/2)/3))"";
//        Node abc= Infix2BT(""+-"");
//    }
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix){
        StringBuffer sb=new StringBuffer(infix);
        for(int i=0;i<sb.length();i++){
            String kk=sb.substring(i,i+1);
            if(sb.substring(i,i+1).equals(""("")||sb.substring(i,i+1).equals("")"")||sb.substring(i,i+1).equals(""+"")||sb.substring(i,i+1).equals(""-"")||sb.substring(i,i+1).equals(""*"")||sb.substring(i,i+1).equals(""/"")){
                sb.insert(i, "" "");
                sb.insert(i+2,"" "" );
                i=i+2;
            }
        }
        infixClone= sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();
        
        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a,operator,b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node=new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b=st.pop();//第一個pop出來是後面的數字b
                    operator=st.pop();//第二個是運算式
                    a=st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node=new Node(null,null,value);
                    st.push(node);
                }
            }
        }
        root=st.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix = (Node[]) nodeList.toArray();//將list轉成array
        return prefix;
    }

    public Node[] PrintPostfix() {               
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix = (Node[]) nodeList.toArray();//將list轉成array
        return postfix;
    }

    public double Evaluation() {        
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a ,b ;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;
    }
    
    private void prefixRecursive(Node n){
        nodeList.add(n);//先儲存再往左往右
        if(n.getLeft()!=null) prefixRecursive(n.getLeft());
        if(n.getRight()!=null) prefixRecursive(n.getRight());
        return;
    }
    
    private void postfixRecursive(Node n){
        if(n.getLeft()!=null) prefixRecursive(n.getLeft());
        if(n.getRight()!=null) prefixRecursive(n.getRight());
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@3df59ab2cc3924457fb20d47e2daeba6@"
"r04546014","2","0.36","112864","@ed2d5c8c4a955ea877a683c8037ad387@
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    List<Node> nodeList=new ArrayList<>();;
    String infixClone;
    
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        StringBuffer sb=new StringBuffer(infix);
        for(int i=0;i<sb.length();i++){
            String kk=sb.substring(i,i+1);
            if(sb.substring(i,i+1).equals(""("")||sb.substring(i,i+1).equals("")"")||sb.substring(i,i+1).equals(""+"")||sb.substring(i,i+1).equals(""-"")||sb.substring(i,i+1).equals(""*"")||sb.substring(i,i+1).equals(""/"")){
                sb.insert(i, "" "");
                sb.insert(i+2,"" "" );
                i=i+2;
            }
        }
        infixClone= sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();
        
        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a,operator,b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node=new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b=st.pop();//第一個pop出來是後面的數字b
                    operator=st.pop();//第二個是運算式
                    a=st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node=new Node(null,null,value);
                    st.push(node);
                }
            }
        }
        root=st.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix = (Node[]) nodeList.toArray();//將list轉成array
        return prefix;
    }

    public Node[] PrintPostfix() {               
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix = (Node[]) nodeList.toArray();//將list轉成array
        return postfix;
    }

    public double Evaluation() {        
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a ,b ;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;
    }
    
    private void prefixRecursive(Node n){
        nodeList.add(n);//先儲存再往左往右
        if(n.getLeft()!=null) prefixRecursive(n.getLeft());
        if(n.getRight()!=null) prefixRecursive(n.getRight());
        return;
    }
    
    private void postfixRecursive(Node n){
        if(n.getLeft()!=null) prefixRecursive(n.getLeft());
        if(n.getRight()!=null) prefixRecursive(n.getRight());
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@ed2d5c8c4a955ea877a683c8037ad387@"
"r04546014","3","1.26","116112","@34f41af5fc199b8b102b48335ae89062@
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    List<Node> nodeList = new ArrayList<>();
    ;
    String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        StringBuffer sb = new StringBuffer(infix);
        for (int i = 0; i < sb.length(); i++) {
            String kk = sb.substring(i, i + 1);
            if (sb.substring(i, i + 1).equals(""("") || sb.substring(i, i + 1).equals("")"") || sb.substring(i, i + 1).equals(""+"") || sb.substring(i, i + 1).equals(""-"") || sb.substring(i, i + 1).equals(""*"") || sb.substring(i, i + 1).equals(""/"")) {
                sb.insert(i, "" "");
                sb.insert(i + 2, "" "");
                i = i + 2;
            }
        }
        infixClone = sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();

        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a, operator, b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node = new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b = st.pop();//第一個pop出來是後面的數字b
                    operator = st.pop();//第二個是運算式
                    a = st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node = new Node(null, null, value);
                    st.push(node);
                }
            }
        }
        root = st.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix=new Node[nodeList.size()];
        nodeList.toArray(prefix);//將list轉成array
        return prefix;
    }

    public Node[] PrintPostfix() {
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix=new Node[nodeList.size()];
        nodeList.toArray(postfix);//將list轉成array
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a, b;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;
    }

    private void prefixRecursive(Node n) {
        nodeList.add(n);//先儲存再往左往右
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        return;
    }

    private void postfixRecursive(Node n) {
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@34f41af5fc199b8b102b48335ae89062@"
"r04546014","4","1.27","116080","@1146c4e4d2fba3fb817fb02d210af121@
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    List<Node> nodeList = new ArrayList<>();
    ;
    String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        StringBuffer sb = new StringBuffer(infix);
        for (int i = 0; i < sb.length(); i++) {
            String kk = sb.substring(i, i + 1);
            if (sb.substring(i, i + 1).equals(""("") || sb.substring(i, i + 1).equals("")"") || sb.substring(i, i + 1).equals(""+"") || sb.substring(i, i + 1).equals(""-"") || sb.substring(i, i + 1).equals(""*"") || sb.substring(i, i + 1).equals(""/"")) {
                sb.insert(i, "" "");
                sb.insert(i + 2, "" "");
                i = i + 2;
            }
        }
        infixClone = sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();

        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a, operator, b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node = new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b = st.pop();//第一個pop出來是後面的數字b
                    operator = st.pop();//第二個是運算式
                    a = st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node = new Node(null, null, value);
                    st.push(node);
                }
            }
        }
        root = st.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix=new Node[nodeList.size()];
        nodeList.toArray(prefix);//將list轉成array
        return prefix;
    }

    public Node[] PrintPostfix() {
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix=new Node[nodeList.size()];
        nodeList.toArray(postfix);//將list轉成array
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a, b;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;
    }

    private void prefixRecursive(Node n) {
        nodeList.add(n);//先儲存再往左往右
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        return;
    }

    private void postfixRecursive(Node n) {
        if (n.getLeft() != null) {
            postfixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            postfixRecursive(n.getRight());
        }
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@1146c4e4d2fba3fb817fb02d210af121@"
"b03611041","0","0.36","112864","@ddcc2c004cc4969a6c2adee987632fbc@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

public class Expression{
  
    private Node root=null;
    private List<String> infixAryList= new ArrayList<>();
    private Stack<Node> valueStack = new Stack<>();
    private Stack<String> operatorStack = new Stack<>();
    private int num=0;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        char tmpChar[]=infix.toCharArray();
        Node nodeL;
        Node nodeR;

        for (int i = 0; i < tmpChar.length; i++) {
            infixAryList.add(String.valueOf(tmpChar[i]));
            String t=infixAryList.get(i);
            if (t.equals(""("")) ;
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                operatorStack.push(t);
                num++;
            }else if(t.equals("")"")) {
                if(root==null) {
                    nodeR = new Node(null, null, valueStack.pop().getValue());
                    nodeL = new Node(null, null, valueStack.pop().getValue());
                }else{
                    nodeR = valueStack.pop();
                    nodeL = valueStack.pop();
                }
                root=new Node(nodeL,nodeR,operatorStack.pop());
                valueStack.push(root);
            }else {
                Node tmpNode=new Node(null,null,t);
                valueStack.push(tmpNode);
                num++;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
       if(root==null) throw new NullPointerException();
        Node[] prefix = new Node[num];
        Queue<Node> q = new LinkedList<>();
        pre(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
//            System.out.println(q.remove().getValue());
            prefix[i]=q.remove();
        }
        return prefix;
    }

    private void pre(Node node, Queue<Node> q){
        if(node.getLeft()!=null && node.getRight()!=null)q.add(node);
        if(node.getLeft()==null && node.getRight()==null){
            q.add(node);
            return;
        }
        pre(node.getLeft(), q);
        pre(node.getRight(), q);
        return;
    }

    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[num];
        Queue<Node> q = new LinkedList<>();
        post(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
//            System.out.println(q.remove().getValue());
            postfix[i]=q.remove();
        }
        return postfix;
    }

    private void post(Node node, Queue<Node> q){
        if(node.getLeft()==null && node.getRight()==null){
            q.add(node);
            return;
        }
        post(node.getLeft(), q);
        post(node.getRight(), q);
        q.add(node);
        return;
    }

    public double Evaluation(){
        if(root==null) throw new NullPointerException();
        double answer = 0;
        Stack<Double> vStack = new Stack<>();
        Stack<String> oStack = new Stack<>();
        for (int i = 0; i < infixAryList.size(); i++) {
            String t = infixAryList.get(i);
            if (t.equals(""("")) ;
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                oStack.push(t);
            } else if (t.equals("")"")) {
                String op = oStack.pop();
                if (op.equals(""+"")) {
                    vStack.push(vStack.pop() + vStack.pop());
                } else if (op.equals(""-"")) {
                    vStack.push(-(vStack.pop() - vStack.pop()));
                } else if (op.equals(""*"")) {
                    vStack.push(vStack.pop() * vStack.pop());
                } else if (op.equals(""/"")) {
                    vStack.push(1 / (vStack.pop() / vStack.pop()));
                }
            } else {
                vStack.push(Double.parseDouble(t));
            }
        }
        answer = vStack.pop();
        return answer;
    }
    public static void main(String[] args)throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression expression= new Expression();
            String infix=br.readLine();
//            System.out.println(infix);
            expression.Infix2BT(infix);
            Node n1[]=expression.PrintPostfix();
            Node n2[]=expression.PrintPrefix();

            for (int i = 0; i < n1.length; i++) {
                System.out.println(n1[i].getValue());
            }
            System.out.println(""\n"");
            for (int i = 0; i < n2.length; i++) {
                System.out.println(n2[i].getValue());
            }

            System.out.println(expression.Evaluation());
        }
    }
}

@ddcc2c004cc4969a6c2adee987632fbc@"
"b03611041","6","0.59","105824","@c33254dbf92b4138b595b0704456409e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

public class Expression{
  
    private Node root=null;
    private List<String> infixAryList= new ArrayList<>();
    private Stack<Node> valueStack = new Stack<>();
    private Stack<String> operatorStack = new Stack<>();
    private int num=0;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        char tmpChar[]=infix.toCharArray();
        Node nodeL;
        Node nodeR;

        for (int i = 0; i < tmpChar.length; i++) {
            infixAryList.add(String.valueOf(tmpChar[i]));
            String t=infixAryList.get(i);
            if (t.equals(""("")) ;
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                operatorStack.push(t);
                num++;
            }else if(t.equals("")"")) {
                if(root==null) {
                    nodeR = new Node(null, null, valueStack.pop().getValue());
                    nodeL = new Node(null, null, valueStack.pop().getValue());
                }else{
                    nodeR = valueStack.pop();
                    nodeL = valueStack.pop();
                }
                root=new Node(nodeL,nodeR,operatorStack.pop());
                valueStack.push(root);
            }else {
                Node tmpNode=new Node(null,null,t);
                valueStack.push(tmpNode);
                num++;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
       if(root==null) throw new NullPointerException();
        Node[] prefix = new Node[num];
        LinkedQueue<Node> q=new LinkedQueue<>();
//        Queue<Node> q = new LinkedList<>();
        pre(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
//            System.out.println(q.remove().getValue());
//            prefix[i]=q.remove();
            prefix[i] = q.dequeue();
        }
        return prefix;
    }

    private void pre(Node node, LinkedQueue<Node> q){
        if(node.getLeft()!=null && node.getRight()!=null)q.enqueue(node);
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        pre(node.getLeft(), q);
        pre(node.getRight(), q);
        return;
    }

    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[num];
//        Queue<Node> q = new LinkedList<>();
        LinkedQueue<Node> q=new LinkedQueue<>();
        post(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
//            System.out.println(q.remove().getValue());
            postfix[i]=q.dequeue();
        }
        return postfix;
    }

    private void post(Node node, LinkedQueue<Node> q){
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        post(node.getLeft(), q);
        post(node.getRight(), q);
        q.enqueue(node);
        return;
    }

    public double Evaluation(){
        if(root==null) throw new NullPointerException();
        double answer = 0;
        Stack<Double> vStack = new Stack<>();
        Stack<String> oStack = new Stack<>();
        for (int i = 0; i < infixAryList.size(); i++) {
            String t = infixAryList.get(i);
            if (t.equals(""("")) ;
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                oStack.push(t);
            } else if (t.equals("")"")) {
                String op = oStack.pop();
                if (op.equals(""+"")) {
                    vStack.push(vStack.pop() + vStack.pop());
                } else if (op.equals(""-"")) {
                    vStack.push(-(vStack.pop() - vStack.pop()));
                } else if (op.equals(""*"")) {
                    vStack.push(vStack.pop() * vStack.pop());
                } else if (op.equals(""/"")) {
                    vStack.push(1 / (vStack.pop() / vStack.pop()));
                }
            } else {
                vStack.push(Double.parseDouble(t));
            }
        }
        answer = vStack.pop();
        return answer;
    }
    public static void main(String[] args)throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression expression= new Expression();
            String infix=br.readLine();
//            System.out.println(infix);
            expression.Infix2BT(infix);
            Node n1[]=expression.PrintPostfix();
            Node n2[]=expression.PrintPrefix();

            for (int i = 0; i < n1.length; i++) {
                System.out.println(n1[i].getValue());
            }
            System.out.println(""\n"");
            for (int i = 0; i < n2.length; i++) {
                System.out.println(n2[i].getValue());
            }

            System.out.println(expression.Evaluation());
        }
    }
}

@c33254dbf92b4138b595b0704456409e@"
"r04546014","4","1.24","115840","@5686de09183d07135955a7d4dbba0d0c@
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    List<Node> nodeList = new ArrayList<>();
    String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        StringBuffer sb = new StringBuffer(infix);
        for (int i = 0; i < sb.length(); i++) {
            String kk = sb.substring(i, i + 1);
            if (sb.substring(i, i + 1).equals(""("") || sb.substring(i, i + 1).equals("")"") || sb.substring(i, i + 1).equals(""+"") || sb.substring(i, i + 1).equals(""-"") || sb.substring(i, i + 1).equals(""*"") || sb.substring(i, i + 1).equals(""/"")) {
                sb.insert(i, "" "");
                sb.insert(i + 2, "" "");
                i = i + 2;
            }
        }
        infixClone = sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();

        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a, operator, b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node = new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b = st.pop();//第一個pop出來是後面的數字b
                    operator = st.pop();//第二個是運算式
                    a = st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node = new Node(null, null, value);
                    st.push(node);
                }
            }
        }
        root = st.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix=new Node[nodeList.size()];
        nodeList.toArray(prefix);//將list轉成array
        return prefix;
    }

    public Node[] PrintPostfix() {
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix=new Node[nodeList.size()];
        nodeList.toArray(postfix);//將list轉成array
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a, b;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;
    }

    private void prefixRecursive(Node n) {
        nodeList.add(n);//先儲存再往左往右
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        return;
    }

    private void postfixRecursive(Node n) {
        if (n.getLeft() != null) {
            postfixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            postfixRecursive(n.getRight());
        }
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@5686de09183d07135955a7d4dbba0d0c@"
"r04631034","6","0.96","105856","@faa6388ef366a29537d1359b846ea2c9@
import java.util.*;

public class Expression {

          private Node root;

          // DO NOT MODIFY THIS
          public Expression() {
          }

          private boolean isCalculator(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else if (java.lang.Character.isDigit(c.charAt(0))) {
                              return true;
                    }
                    return false;
          }

          private boolean isOperation(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else {
                              return false;
                    }
          }

          private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }

          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }

          private void posfix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    list.add(node);
          }

                    private void infix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    list.add(node);
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    
          }
// Build a Binary and Return the Root
          public Node Infix2BT(String infix) {
                    String[] charater = infix.split("""");
                    charater = Arrays.copyOfRange(charater, 1, charater.length);
                    Stack<Node> treeNode = new Stack<Node>();
                    for (int counter = 0; counter < charater.length; counter++) {
                              if (isCalculator(charater[counter])) {
                                        treeNode.push(new Node(null, null, charater[counter]));
                              } else if (charater[counter].equals("")"")) {
                                        Node right = treeNode.pop();
                                        Node mid = treeNode.pop();
                                        Node left = treeNode.pop();
                                        mid.setLeft(left);
                                        mid.setRight(right);
                                        treeNode.push(mid);
                              }
                              else continue;
                    }
                    this.root = treeNode.pop();
                    return this.root;
          }

          public Node[] PrintPrefix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              prefix(array, this.root);
                              Node[] prefix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        prefix[count] = array.get(count);
                              }
                              return prefix;
                    }
          }
          
          public Node[] PrintInfix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              infix(array, this.root);
                              Node[] infix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        infix[count] = array.get(count);
                              }
                              return infix;
                    }
          }
          
          public Node[] PrintPostfix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Node[] posfix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        posfix[count] = array.get(count);
                              }
                              return posfix;
                    }
          }

          public double Evaluation() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Stack<Double> storge = new Stack<Double>();
                              for (int count = 0; count < array.size(); count++) {
                                        if (isOperation(array.get(count).getValue())) {

                                                  Calculate(storge, array.get(count).getValue());
                                        } else {
                                                  storge.push(Double.parseDouble(array.get(count).getValue()));
                                        }
                              }

                              return storge.pop();
                    }
          }
}



@faa6388ef366a29537d1359b846ea2c9@"
"d04631001","0","0.59","105824","@b5fc80b77650147f9c43b408f2172cec@
import edu.princeton.cs.algs4.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> vals = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String[] ee = infix.split("""");
        for (int i = 0; i < ee.length; i++) {
            if (ee[i].equals(""("")) {             
            } else if (ee[i].equals(""+"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""-"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""*"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals(""/"")) {
                ops.push(ee[i]);
            } else if (ee[i].equals("")"")) {
                root.setRight(vals.pop());
                root.setLeft(vals.pop());
                root.setValue(ops.pop());
            } else {
                Node temp_node = new Node(null, null, ee[i]);
                vals.push(temp_node); 
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        
        return postfix;
    }

    public double Evaluation(String infix){
        double answer = 0;
        return answer;
    }
}

@b5fc80b77650147f9c43b408f2172cec@"
"r04546014","4","1.24","115824","@0bb5d292ab7cda4f86b006454b70461d@
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;
import java.lang.NullPointerException;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    List<Node> nodeList = new ArrayList<>();
    String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        StringBuffer sb = new StringBuffer(infix);
        for (int i = 0; i < sb.length(); i++) {
            String kk = sb.substring(i, i + 1);
            if (sb.substring(i, i + 1).equals(""("") || sb.substring(i, i + 1).equals("")"") || sb.substring(i, i + 1).equals(""+"") || sb.substring(i, i + 1).equals(""-"") || sb.substring(i, i + 1).equals(""*"") || sb.substring(i, i + 1).equals(""/"")) {
                sb.insert(i, "" "");
                sb.insert(i + 2, "" "");
                i = i + 2;
            }
        }
        infixClone = sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();

        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a, operator, b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node = new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b = st.pop();//第一個pop出來是後面的數字b
                    operator = st.pop();//第二個是運算式
                    a = st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node = new Node(null, null, value);
                    st.push(node);
                }
            }
        }
        root = st.pop();
        return root;
    }

    public Node[] PrintPrefix() {
        if(root!=null){
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix=new Node[nodeList.size()];
        nodeList.toArray(prefix);//將list轉成array
        return prefix;
        }
        else throw new NullPointerException();
    }

    public Node[] PrintPostfix() {
        if(root!=null){
        
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix=new Node[nodeList.size()];
        nodeList.toArray(postfix);//將list轉成array
        return postfix;
        }
        else throw new NullPointerException();
    }

    public double Evaluation() {
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a, b;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;
    }

    private void prefixRecursive(Node n) {
        nodeList.add(n);//先儲存再往左往右
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        return;
    }

    private void postfixRecursive(Node n) {
        if (n.getLeft() != null) {
            postfixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            postfixRecursive(n.getRight());
        }
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@0bb5d292ab7cda4f86b006454b70461d@"
"r04546014","4","1.26","115824","@c8245971c55c8353877eecf85837f986@import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;
import java.lang.NullPointerException;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    List<Node> nodeList = new ArrayList<>();
    String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        StringBuffer sb = new StringBuffer(infix);
        for (int i = 0; i < sb.length(); i++) {
            String kk = sb.substring(i, i + 1);
            if (sb.substring(i, i + 1).equals(""("") || sb.substring(i, i + 1).equals("")"") || sb.substring(i, i + 1).equals(""+"") || sb.substring(i, i + 1).equals(""-"") || sb.substring(i, i + 1).equals(""*"") || sb.substring(i, i + 1).equals(""/"")) {
                sb.insert(i, "" "");
                sb.insert(i + 2, "" "");
                i = i + 2;
            }
        }
        infixClone = sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();

        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a, operator, b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node = new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b = st.pop();//第一個pop出來是後面的數字b
                    operator = st.pop();//第二個是運算式
                    a = st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node = new Node(null, null, value);
                    st.push(node);
                }
            }
        }
        root = st.pop();
        return root;
    }

    public Node[] PrintPrefix() throws Exception {
        if(root!=null){
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix=new Node[nodeList.size()];
        nodeList.toArray(prefix);//將list轉成array
        return prefix;
        }
        else throw new NullPointerException();
    }

    public Node[] PrintPostfix()throws Exception {
        if(root!=null){
        
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix=new Node[nodeList.size()];
        nodeList.toArray(postfix);//將list轉成array
        return postfix;
        }
        else throw new NullPointerException();
    }

    public double Evaluation() throws Exception {
        if(root!=null){
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a, b;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;                  
        }
        else throw new NullPointerException();
    }

    private void prefixRecursive(Node n) {
        nodeList.add(n);//先儲存再往左往右
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        return;
    }

    private void postfixRecursive(Node n) {
        if (n.getLeft() != null) {
            postfixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            postfixRecursive(n.getRight());
        }
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@c8245971c55c8353877eecf85837f986@"
"r04546014","4","1.26","115808","@44fddea59718def3300235dedb4444bf@
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;
import java.lang.NullPointerException;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    List<Node> nodeList = new ArrayList<>();
    String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        StringBuffer sb = new StringBuffer(infix);
        for (int i = 0; i < sb.length(); i++) {
            String kk = sb.substring(i, i + 1);
            if ( sb.substring(i, i + 1).equals("")"") || sb.substring(i, i + 1).equals(""+"") || sb.substring(i, i + 1).equals(""-"") || sb.substring(i, i + 1).equals(""*"") || sb.substring(i, i + 1).equals(""/"")) {
                sb.insert(i, "" "");
                sb.insert(i + 2, "" "");
                i = i + 2;                
            }
            else if(sb.substring(i, i + 1).equals(""("") ){            
                sb.delete(i,i+1); 
                i--;
            }
            
        }
        infixClone = sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();

        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a, operator, b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node = new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b = st.pop();//第一個pop出來是後面的數字b
                    operator = st.pop();//第二個是運算式
                    a = st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node = new Node(null, null, value);
                    st.push(node);
                }
            }
        }
        root = st.pop();
        return root;
    }

    public Node[] PrintPrefix() throws Exception {
        if(root!=null){
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix=new Node[nodeList.size()];
        nodeList.toArray(prefix);//將list轉成array
        return prefix;
        }
        else throw new NullPointerException();
    }

    public Node[] PrintPostfix()throws Exception {
        if(root!=null){
        
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix=new Node[nodeList.size()];
        nodeList.toArray(postfix);//將list轉成array
        return postfix;
        }
        else throw new NullPointerException();
    }

    public double Evaluation() throws Exception {
        if(root!=null){
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a, b;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;                  
        }
        else throw new NullPointerException();
    }

    private void prefixRecursive(Node n) {
        nodeList.add(n);//先儲存再往左往右
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        return;
    }

    private void postfixRecursive(Node n) {
        if (n.getLeft() != null) {
            postfixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            postfixRecursive(n.getRight());
        }
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@44fddea59718def3300235dedb4444bf@"
"r04546014","4","1.25","115824","@497608847eedb1d83d8f41bd037be373@
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;
import java.lang.NullPointerException;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    private List<Node> nodeList = new ArrayList<>();
    private String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        StringBuffer sb = new StringBuffer(infix);//由於近來的資料沒有空格，因此無法使用scanner直接做判斷，在這裡先把字串每一個不同的部分都加入空格，並且刪去左括號
        for (int i = 0; i < sb.length(); i++) {
            String kk = sb.substring(i, i + 1);
            if ( sb.substring(i, i + 1).equals("")"") || sb.substring(i, i + 1).equals(""+"") || sb.substring(i, i + 1).equals(""-"") || sb.substring(i, i + 1).equals(""*"") || sb.substring(i, i + 1).equals(""/"")) {
                sb.insert(i, "" "");
                sb.insert(i + 2, "" "");
                i = i + 2;                
            }
            else if(sb.substring(i, i + 1).equals(""("") ){            
                sb.delete(i,i+1); 
                i--;
            }
            
        }
        infixClone = sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();

        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a, operator, b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node = new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    b = st.pop();//第一個pop出來是後面的數字b
                    operator = st.pop();//第二個是運算式
                    a = st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node = new Node(null, null, value);
                    st.push(node);
                }
            }
        }
        root = st.pop();
        return root;
    }

    public Node[] PrintPrefix() throws Exception {
        if(root!=null){
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix=new Node[nodeList.size()];
        nodeList.toArray(prefix);//將list轉成array
        return prefix;
        }
        else throw new NullPointerException();
    }

    public Node[] PrintPostfix()throws Exception {
        if(root!=null){
        
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix=new Node[nodeList.size()];
        nodeList.toArray(postfix);//將list轉成array
        return postfix;
        }
        else throw new NullPointerException();
    }

    public double Evaluation() throws Exception {
        if(root!=null){
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a, b;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;                  
        }
        else throw new NullPointerException();
    }

    private void prefixRecursive(Node n) {
        nodeList.add(n);//先儲存再往左往右
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        return;
    }

    private void postfixRecursive(Node n) {
        if (n.getLeft() != null) {
            postfixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            postfixRecursive(n.getRight());
        }
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@497608847eedb1d83d8f41bd037be373@"
"b03611011","5","0.58","105216","@50114107c91db9f87afb222a8bc805ef@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Stack;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    public int j = 1;
    public int com = 1;

    public void put(Node x) {
        for (int i = j; i < lala.length; i = i + 0) {
            String s;
            i = j;
            s = lala[i];
            Node left, right;
            switch (s) {
                case ""("":
                    Node y = null;
                    y = new Node(y, y, null);
                    j++;
                    put(y);
                    x.setLeft(y);
                    i = j;
                    continue;
                case ""+"":
                    x.setValue(""+"");
//                    System.out.println(""+"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""*"":
                    x.setValue(""*"");
//                    System.out.println(""*"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""-"":
                    x.setValue(""-"");
//                    System.out.println(""-"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""/"":
                    x.setValue(""/"");
//                    System.out.println(""/"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case "")"":
                    j++;
//                    lala[i]="")"";i = j;
                    return;
                default:
                    y = null;
                    y = new Node(y, y, lala[j]);
//                    System.out.println(lala[j]);
                    x.setLeft(y);
                    j++;
                    i = j;
                    continue;
            }
        }
    }
    String[] lala;

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
////            String fund = br.readLine();
////            Expression exp = new Expression();
////            exp.Infix2BT(fund);
////            Node[] f=exp.PrintPrefix();
////            Node[] postfix = exp.PrintPostfix();
////            exp.PrintPostfix();
////            double h=exp.Evaluation();
////            System.out.println(h);
////            String iaia= ""1.1235"";
////            double k =Double .parseDouble(iaia);
////            System.out.println(k);
//        }
//        // TODO code application logic here
//    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] c_arr = infix.toCharArray();
        int m = c_arr.length;
        tim=m;
        int k=0;
        lala = new String[m];
        for (int i = 0; i < m; i++) {
            String s;
            s = Character.toString(c_arr[i]);
            switch (s) {
                case ""("":
                    lala[i-k] = ""("";
                    tim=tim-1;
                    break;
                case ""+"":
                    lala[i-k] = ""+"";
                    break;
                case ""*"":
                    lala[i-k] = ""*"";
                    break;
                case ""-"":
                    lala[i-k] = ""-"";
                    break;
                case ""/"":
                    lala[i-k] = ""/"";
                    break;
                case "")"":
                    lala[i-k] = "")"";
                    tim=tim-1;
                    break;
                default:
                    if (lala[i - k] != null) {
                        lala[i - k] = lala[i - k] + s;
                    } else {
                        lala[i - k] = s;
                    }
                    if (c_arr[i+ 1] == '+' || c_arr[i  + 1] == ')' || c_arr[i  + 1] == '/' || c_arr[i +1]=='*'||c_arr[i+1]=='-'){break;}else{
                    k++;tim--;
                    }
            }
        }
        int h=lala.length-k;
        String[] tep=new String[lala.length-k];
        System.arraycopy(lala, 0, tep, 0, h);
        lala=tep;
        Node a, b;
        String c = ""0"";
        root = new Node(root, root, c);
        put(root);
//        root.setLeft();
        return root;
    }
    public int tim;
    public Node[] la;
    public void pre(Node x) {
        for(int i=0;i<tim;i++){
            if (x.getValue() != null) {
                la[j]=x;
                j++;
                i=j;
            }
            if(x.getLeft()!= null){
        pre(x.getLeft());}
            if(x.getRight()!= null){
        pre(x.getRight());return;}else{return;}
        }
    }
        public void post(Node x) {
        for(int i=0;i<tim;i++){
            if (x.getLeft() != null) {
                post(x.getLeft());
            }
            if (x.getRight() != null) {
                post(x.getRight());
            }
            if (x.getValue() != null) {
                la[j]=x;
                j++;
                i=j;
                return;
            }
        }
    }
    public Node[] PrintPrefix() {
        int l=0;
        j=0;
        la=new Node[tim];
        pre(root);
        Node[] prefix;
        prefix=la;
        return prefix;
    }

    public Node[] PrintPostfix() {
        int l=0;
        j=0;
        la=new Node[tim];
        post(root);
        Node[] postfix;
        postfix=la;
        return postfix;
    }

    public double Evaluation() {
        Stack<String> ops = new Stack<>();
        Stack<Double> vals = new Stack<>();
        int l = lala.length, cal = 0;
        int count = 0;
        while (count < l) {
            String s;
            s = lala[count];
            switch (s) {
                case ""("":
                    break;
                case ""+"":
                    ops.push(s);
                    break;
                case ""*"":
                    ops.push(s);
                    break;
                case ""-"":
                    ops.push(s);
                    break;
                case ""/"":
                    ops.push(s);
                    break;
                case "")"":
                    String op = ops.pop();
                    if (op.equals(""+"")) {
                        vals.push(vals.pop() + vals.pop());
                    } else if (op.equals(""*"")) {
                        vals.push(vals.pop() * vals.pop());
                    } else if (op.equals(""-"")) {
                        vals.push(-1 * (vals.pop() - vals.pop()));
                    } else if (op.equals(""/"")) {
                        vals.push((1 / vals.pop()) * vals.pop());
                    }
                    break;
                default:
                    vals.push(Double.parseDouble(s));
                    break;
            }
            count++;
        }
        return vals.pop();
    }
}

@50114107c91db9f87afb222a8bc805ef@"
"b03611011","6","0.56","105568","@3d256d4219f931c81dc29a7272384b23@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Stack;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    public int j = 1;
    public int com = 1;

    public void put(Node x) {
        for (int i = j; i < lala.length; i = i + 0) {
            String s;
            i = j;
            s = lala[i];
            Node left, right;
            switch (s) {
                case ""("":
                    Node y = null;
                    y = new Node(y, y, null);
                    j++;
                    put(y);
                    x.setLeft(y);
                    i = j;
                    continue;
                case ""+"":
                    x.setValue(""+"");
//                    System.out.println(""+"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""*"":
                    x.setValue(""*"");
//                    System.out.println(""*"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""-"":
                    x.setValue(""-"");
//                    System.out.println(""-"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""/"":
                    x.setValue(""/"");
//                    System.out.println(""/"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case "")"":
                    j++;
//                    lala[i]="")"";i = j;
                    return;
                default:
                    y = null;
                    y = new Node(y, y, lala[j]);
//                    System.out.println(lala[j]);
                    x.setLeft(y);
                    j++;
                    i = j;
                    continue;
            }
        }
    }
    String[] lala;

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            String fund = br.readLine();
//            Expression exp = new Expression();
//            exp.Infix2BT(fund);
//            Node[] f=exp.PrintPrefix();
//            Node[] postfix = exp.PrintPostfix();
//            exp.PrintPostfix();
//            double h=exp.Evaluation();
//            System.out.println(h);
//            String iaia= ""1.1235"";
//            double k =Double .parseDouble(iaia);
//            System.out.println(k);
//        }
//        // TODO code application logic here
//    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] c_arr = infix.toCharArray();
        int m = c_arr.length;
        tim=m;
        int k=0;
        lala = new String[m];
        for (int i = 0; i < m; i++) {
            String s;
            s = Character.toString(c_arr[i]);
            switch (s) {
                case ""("":
                    lala[i-k] = ""("";
                    tim=tim-1;
                    break;
                case ""+"":
                    lala[i-k] = ""+"";
                    break;
                case ""*"":
                    lala[i-k] = ""*"";
                    break;
                case ""-"":
                    lala[i-k] = ""-"";
                    break;
                case ""/"":
                    lala[i-k] = ""/"";
                    break;
                case "")"":
                    lala[i-k] = "")"";
                    tim=tim-1;
                    break;
                default:
                    if (lala[i - k] != null) {
                        lala[i - k] = lala[i - k] + s;
                    } else {
                        lala[i - k] = s;
                    }
                    if (c_arr[i+ 1] == '+' || c_arr[i  + 1] == ')' || c_arr[i  + 1] == '/' || c_arr[i +1]=='*'||c_arr[i+1]=='-'){break;}else{
                    k++;tim--;
                    }
            }
        }
        int h=lala.length-k;
        String[] tep=new String[lala.length-k];
        System.arraycopy(lala, 0, tep, 0, h);
        lala=tep;
        Node a, b;
        String c = ""0"";
        root = new Node(root, root, c);
        put(root);
//        root.setLeft();
        return root;
    }
    public int tim;
    public Node[] la;
    public void pre(Node x) {
        for(int i=0;i<tim;i++){
            if (x.getValue() != null) {
                la[j]=x;
                j++;
                i=j;
            }
            if(x.getLeft()!= null){
        pre(x.getLeft());}
            if(x.getRight()!= null){
        pre(x.getRight());return;}else{return;}
        }
    }
        public void post(Node x) {
        for(int i=0;i<tim;i++){
            if (x.getLeft() != null) {
                post(x.getLeft());
            }
            if (x.getRight() != null) {
                post(x.getRight());
            }
            if (x.getValue() != null) {
                la[j]=x;
                j++;
                i=j;
                return;
            }
        }
    }
    public Node[] PrintPrefix() {
        if(root==null)throw new NullPointerException();
        int l=0;
        j=0;
        la=new Node[tim];
        pre(root);
        Node[] prefix;
        prefix=la;
        return prefix;
    }

    public Node[] PrintPostfix() {
        if(root==null)throw new NullPointerException();
        int l=0;
        j=0;
        la=new Node[tim];
        post(root);
        Node[] postfix;
        postfix=la;
        return postfix;
    }

    public double Evaluation() {
        if(root==null)throw new NullPointerException();
        Stack<String> ops = new Stack<>();
        Stack<Double> vals = new Stack<>();
        int l = lala.length, cal = 0;
        int count = 0;
        while (count < l) {
            String s;
            s = lala[count];
            switch (s) {
                case ""("":
                    break;
                case ""+"":
                    ops.push(s);
                    break;
                case ""*"":
                    ops.push(s);
                    break;
                case ""-"":
                    ops.push(s);
                    break;
                case ""/"":
                    ops.push(s);
                    break;
                case "")"":
                    String op = ops.pop();
                    if (op.equals(""+"")) {
                        vals.push(vals.pop() + vals.pop());
                    } else if (op.equals(""*"")) {
                        vals.push(vals.pop() * vals.pop());
                    } else if (op.equals(""-"")) {
                        vals.push(-1 * (vals.pop() - vals.pop()));
                    } else if (op.equals(""/"")) {
                        vals.push((1 / vals.pop()) * vals.pop());
                    }
                    break;
                default:
                    vals.push(Double.parseDouble(s));
                    break;
            }
            count++;
        }
        return vals.pop();
    }
}

@3d256d4219f931c81dc29a7272384b23@"
"b03611011","6","0.56","105568","@ffd3ded556ed6af8c02a0190edbbd4a0@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Stack;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    public int j = 1;
    public int com = 1;
    public String[] lala;

    public void put(Node x) {
        for (int i = j; i < lala.length; i = i + 0) {
            String s;
            i = j;
            s = lala[i];
            Node left, right;
            switch (s) {
                case ""("":
                    Node y = null;
                    y = new Node(y, y, null);
                    j++;
                    put(y);
                    x.setLeft(y);
                    i = j;
                    continue;
                case ""+"":
                    x.setValue(""+"");
//                    System.out.println(""+"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""*"":
                    x.setValue(""*"");
//                    System.out.println(""*"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""-"":
                    x.setValue(""-"");
//                    System.out.println(""-"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""/"":
                    x.setValue(""/"");
//                    System.out.println(""/"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                        j++;
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case "")"":
                    j++;
//                    lala[i]="")"";i = j;
                    return;
                default:
                    y = null;
                    y = new Node(y, y, lala[j]);
//                    System.out.println(lala[j]);
                    x.setLeft(y);
                    j++;
                    i = j;
                    continue;
            }
        }
    }

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
//            String fund = br.readLine();
//            Expression exp = new Expression();
//            exp.Infix2BT(fund);
//            Node[] f=exp.PrintPrefix();
//            Node[] postfix = exp.PrintPostfix();
//            exp.PrintPostfix();
//            double h=exp.Evaluation();
//            System.out.println(h);
//        }
//        // TODO code application logic here
//    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] c_arr = infix.toCharArray();
        int m = c_arr.length;
        tim=m;
        int k=0;
        lala = new String[m];
        for (int i = 0; i < m; i++) {
            String s;
            s = Character.toString(c_arr[i]);
            switch (s) {
                case ""("":
                    lala[i-k] = ""("";
                    tim=tim-1;
                    break;
                case ""+"":
                    lala[i-k] = ""+"";
                    break;
                case ""*"":
                    lala[i-k] = ""*"";
                    break;
                case ""-"":
                    lala[i-k] = ""-"";
                    break;
                case ""/"":
                    lala[i-k] = ""/"";
                    break;
                case "")"":
                    lala[i-k] = "")"";
                    tim=tim-1;
                    break;
                default:
                    if (lala[i - k] != null) {
                        lala[i - k] = lala[i - k] + s;
                    } else {
                        lala[i - k] = s;
                    }
                    if (c_arr[i+ 1] == '+' || c_arr[i  + 1] == ')' || c_arr[i  + 1] == '/' || c_arr[i +1]=='*'||c_arr[i+1]=='-'){break;}else{
                    k++;tim--;
                    }
            }
        }
        int h=lala.length-k;
        String[] tep=new String[lala.length-k];
        System.arraycopy(lala, 0, tep, 0, h);
        lala=tep;
        if (h == 3) {
            root = new Node(root, root, lala[1]);
            return root;
        }
        String c = ""0"";
        root = new Node(root, root, c);
        put(root);
//        root.setLeft();
        return root;
    }
    public int tim;
    public Node[] la;
    public void pre(Node x) {
        for(int i=0;i<tim;i++){
            if (x.getValue() != null) {
                la[j]=x;
                j++;
                i=j;
            }
            if(x.getLeft()!= null){
        pre(x.getLeft());}
            if(x.getRight()!= null){
        pre(x.getRight());return;}else{return;}
        }
    }
        public void post(Node x) {
        for(int i=0;i<tim;i++){
            if (x.getLeft() != null) {
                post(x.getLeft());
            }
            if (x.getRight() != null) {
                post(x.getRight());
            }
            if (x.getValue() != null) {
                la[j]=x;
                j++;
                i=j;
                return;
            }
        }
    }
    public Node[] PrintPrefix() {
        if(root==null)throw new NullPointerException();
        int l=0;
        j=0;
        la=new Node[tim];
        pre(root);
        Node[] prefix;
        prefix=la;
        return prefix;
    }

    public Node[] PrintPostfix() {
        if(root==null)throw new NullPointerException();
        int l=0;
        j=0;
        la=new Node[tim];
        post(root);
        Node[] postfix;
        postfix=la;
        return postfix;
    }

    public double Evaluation() {
        if(root==null)throw new NullPointerException();
        Stack<String> ops = new Stack<>();
        Stack<Double> vals = new Stack<>();
        int l = lala.length;
        int count = 0;
        if(l==3){return Double.parseDouble(lala[1]);}
        while (count < l) {
            String s;
            s = lala[count];
            switch (s) {
                case ""("":
                    break;
                case ""+"":
                    ops.push(s);
                    break;
                case ""*"":
                    ops.push(s);
                    break;
                case ""-"":
                    ops.push(s);
                    break;
                case ""/"":
                    ops.push(s);
                    break;
                case "")"":
                    String op = ops.pop();
                    if (op.equals(""+"")) {
                        vals.push(vals.pop() + vals.pop());
                    } else if (op.equals(""*"")) {
                        vals.push(vals.pop() * vals.pop());
                    } else if (op.equals(""-"")) {
                        vals.push(-1 * (vals.pop() - vals.pop()));
                    } else if (op.equals(""/"")) {
                        vals.push((1 / vals.pop()) * vals.pop());
                    }
                    break;
                default:
                    vals.push(Double.parseDouble(s));
                    break;
            }
            count++;
        }
        return vals.pop();
    }
}

@ffd3ded556ed6af8c02a0190edbbd4a0@"
"b03611041","8","0.77","105904","@73de4114865695cf12a7e92f41b7749d@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

public class Expression{
  
    private Node root=null;
    private List<String> infixAryList= new ArrayList<>();
    private Stack<Node> valueStack = new Stack<>();
    private Stack<String> operatorStack = new Stack<>();
    private int num=0;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        char tmpChar[]=infix.toCharArray();
        Node nodeL;
        Node nodeR;

        char charTmp=' ';
        int indexForDupNum=0;
        for (int i = 0; i < tmpChar.length; i++) {
            char charNow = tmpChar[i];
            if ((charTmp <= 57 && charTmp >= 48) && (charNow <= 57 && charNow >= 48)) {
                indexForDupNum--;
                infixAryList.add(indexForDupNum, infixAryList.get(indexForDupNum).concat(String.valueOf(charNow)));
                infixAryList.remove(++indexForDupNum);
            } else {
                infixAryList.add(String.valueOf(tmpChar[i]));
                indexForDupNum++;
            }
            charTmp =tmpChar[i];
        }

        for (int i = 0; i < infixAryList.size(); i++) {
            String t=infixAryList.get(i);
            if (t.equals(""(""));
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                operatorStack.push(t);
                num++;
            }else if(t.equals("")"")) {
                if(root==null) {
                    nodeR = new Node(null, null, valueStack.pop().getValue());
                    nodeL = new Node(null, null, valueStack.pop().getValue());
                }else{
                    nodeR = valueStack.pop();
                    nodeL = valueStack.pop();
                }
                root=new Node(nodeL,nodeR,operatorStack.pop());
                valueStack.push(root);
            }else {
                Node tmpNode=new Node(null,null,t);
                valueStack.push(tmpNode);
                num++;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
       if(root==null) throw new NullPointerException();
        Node[] prefix = new Node[num];
        LinkedQueue<Node> q=new LinkedQueue<>();
//        Queue<Node> q = new LinkedList<>();
        pre(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            prefix[i] = q.dequeue();
        }
        return prefix;
    }

    private void pre(Node node, LinkedQueue<Node> q){
        if(node.getLeft()!=null && node.getRight()!=null)q.enqueue(node);
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        pre(node.getLeft(), q);
        pre(node.getRight(), q);
        return;
    }

    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[num];
//        Queue<Node> q = new LinkedList<>();
        LinkedQueue<Node> q=new LinkedQueue<>();
        post(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            postfix[i]=q.dequeue();
        }
        return postfix;
    }

    private void post(Node node, LinkedQueue<Node> q){
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        post(node.getLeft(), q);
        post(node.getRight(), q);
        q.enqueue(node);
        return;
    }

    public double Evaluation(){
        if(root==null) throw new NullPointerException();
        double answer;
        Stack<Double> vStack = new Stack<>();
        Stack<String> oStack = new Stack<>();
        for (int i = 0; i < infixAryList.size(); i++) {
            String t = infixAryList.get(i);
            if (t.equals(""("")) ;
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                oStack.push(t);
            } else if (t.equals("")"")) {
                String op = oStack.pop();
                if (op.equals(""+"")) {
                    vStack.push(vStack.pop() + vStack.pop());
                } else if (op.equals(""-"")) {
                    vStack.push(-(vStack.pop() - vStack.pop()));
                } else if (op.equals(""*"")) {
                    vStack.push(vStack.pop() * vStack.pop());
                } else if (op.equals(""/"")) {
                    vStack.push(1 / (vStack.pop() / vStack.pop()));
                }
            } else {
                vStack.push(Double.parseDouble(t));
            }
        }
        answer = vStack.pop();
        return answer;
    }
    public static void main(String[] args)throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression expression= new Expression();
            String infix=br.readLine();
            expression.Infix2BT(infix);
            Node n1[]=expression.PrintPostfix();
            Node n2[]=expression.PrintPrefix();

            for (int i = 0; i < n1.length; i++) {
                System.out.println(n1[i].getValue());
            }
            System.out.println(""\n"");
            for (int i = 0; i < n2.length; i++) {
                System.out.println(n2[i].getValue());
            }

            System.out.println(expression.Evaluation());
        }
    }
}

@73de4114865695cf12a7e92f41b7749d@"
"b03611011","10","0.097","105552","@88eb9b4847beae7ff6c23cd48b1a7b67@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Stack;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    public int j = 1;
    public int com = 1;
    public String[] lala;

    public void put(Node x) {
        for (int i = j; i < lala.length; i = i + 0) {
            String s;
            i = j;
            s = lala[i];
            Node left, right;
            switch (s) {
                case ""("":
                    Node y = null;
                    y = new Node(y, y, null);
                    j++;i = j;
                    put(y);
                    x.setLeft(y);
                    i = j;
                    continue;
                case ""+"":
                    x.setValue(""+"");
//                    System.out.println(""+"");
                    j++;i = j;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""*"":
                    x.setValue(""*"");
//                    System.out.println(""*"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""-"":
                    x.setValue(""-"");
//                    System.out.println(""-"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case ""/"":
                    x.setValue(""/"");
//                    System.out.println(""/"");
                    j++;
                    if (lala[j].equals(""("")) {
                        y = null;
                        y = new Node(y, y, null);
                        j++;
                        put(y);
                        x.setRight(y);
                    } else {
                        y = null;
                        y = new Node(y, y, lala[j]);
//                        System.out.println(lala[j]);
                        x.setRight(y);
                        j++;
                        i = j;
                        continue;
                    }
                    i = j;
                    continue;
                case "")"":
                    j++;
//                    lala[i]="")"";i = j;
                    return;
                default:
                    y = null;
                    y = new Node(y, y, lala[j]);
//                    System.out.println(lala[j]);
                    x.setLeft(y);
                    j++;
                    i = j;
                    continue;
            }
        }
    }

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
//            String fund = br.readLine();
//            Expression exp = new Expression();
//            exp.Infix2BT(fund);
//            Node[] f=exp.PrintPrefix();
//            Node[] postfix = exp.PrintPostfix();
//            exp.PrintPostfix();
//            double h=exp.Evaluation();
//            System.out.println(h);
//        }
//        // TODO code application logic here
//    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] c_arr = infix.toCharArray();
        int m = c_arr.length;
        tim=m;
        int k=0;
        lala = new String[m];
        for (int i = 0; i < m; i++) {
            String s;
            s = Character.toString(c_arr[i]);
            switch (s) {
                case ""("":
                    lala[i-k] = ""("";
                    tim=tim-1;
                    break;
                case ""+"":
                    lala[i-k] = ""+"";
                    break;
                case ""*"":
                    lala[i-k] = ""*"";
                    break;
                case ""-"":
                    lala[i-k] = ""-"";
                    break;
                case ""/"":
                    lala[i-k] = ""/"";
                    break;
                case "")"":
                    lala[i-k] = "")"";
                    tim=tim-1;
                    break;
                default:
                    if (lala[i - k] != null) {
                        lala[i - k] = lala[i - k] + s;
                    } else {
                        lala[i - k] = s;
                    }
                    if (c_arr[i+ 1] == '+' || c_arr[i  + 1] == ')' || c_arr[i  + 1] == '/' || c_arr[i +1]=='*'||c_arr[i+1]=='-'){break;}else{
                    k++;tim--;
                    }
            }
        }
        int h=lala.length-k;
        String[] tep=new String[lala.length-k];
        System.arraycopy(lala, 0, tep, 0, h);
        lala=tep;
        if (h == 3) {
            root = new Node(root, root, lala[1]);
            return root;
        }
        String c = ""0"";
        root = new Node(root, root, c);
        put(root);
//        root.setLeft();
        return root;
    }
    public int tim;
    public Node[] la;
    public void pre(Node x) {
        for(int i=0;i<tim;i++){
            if (x.getValue() != null) {
                la[j]=x;
                j++;
                i=j;
            }
            if(x.getLeft()!= null){
        pre(x.getLeft());}
            if(x.getRight()!= null){
        pre(x.getRight());return;}else{return;}
        }
    }
        public void post(Node x) {
        for(int i=0;i<tim;i++){
            if (x.getLeft() != null) {
                post(x.getLeft());
            }
            if (x.getRight() != null) {
                post(x.getRight());
            }
            if (x.getValue() != null) {
                la[j]=x;
                j++;
                i=j;
                return;
            }
        }
    }
    public Node[] PrintPrefix() {
        if(root==null)throw new NullPointerException();
        int l=0;
        j=0;
        la=new Node[tim];
        pre(root);
        Node[] prefix;
        prefix=la;
        return prefix;
    }

    public Node[] PrintPostfix() {
        if(root==null)throw new NullPointerException();
        int l=0;
        j=0;
        la=new Node[tim];
        post(root);
        Node[] postfix;
        postfix=la;
        return postfix;
    }

    public double Evaluation() {
        if(root==null)throw new NullPointerException();
        Stack<String> ops = new Stack<>();
        Stack<Double> vals = new Stack<>();
        int l = lala.length;
        int count = 0;
        if(l==3){return Double.parseDouble(lala[1]);}
        while (count < l) {
            String s;
            s = lala[count];
            switch (s) {
                case ""("":
                    break;
                case ""+"":
                    ops.push(s);
                    break;
                case ""*"":
                    ops.push(s);
                    break;
                case ""-"":
                    ops.push(s);
                    break;
                case ""/"":
                    ops.push(s);
                    break;
                case "")"":
                    String op = ops.pop();
                    if (op.equals(""+"")) {
                        vals.push(vals.pop() + vals.pop());
                    } else if (op.equals(""*"")) {
                        vals.push(vals.pop() * vals.pop());
                    } else if (op.equals(""-"")) {
                        vals.push(-1 * (vals.pop() - vals.pop()));
                    } else if (op.equals(""/"")) {
                        vals.push((1 / vals.pop()) * vals.pop());
                    }
                    break;
                default:
                    vals.push(Double.parseDouble(s));
                    break;
            }
            count++;
        }
        return vals.pop();
    }
}

@88eb9b4847beae7ff6c23cd48b1a7b67@"
"b03611041","8","0.79","105888","@1b800c54dc2710158faf604da2387141@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

public class Expression{
  
    private Node root=null;
    private List<String> infixAryList= new ArrayList<>();
    private Stack<Node> valueStack = new Stack<>();
    private Stack<String> operatorStack = new Stack<>();
    private int num=0;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        char tmpChar[]=infix.toCharArray();
        Node nodeL;
        Node nodeR;

        char charTmp=' ';
        int indexForDupNum=0;
        for (int i = 0; i < tmpChar.length; i++) {
            char charNow = tmpChar[i];
            if ((charTmp <= 57 && charTmp >= 48) && (charNow <= 57 && charNow >= 48)) {
                indexForDupNum--;
                infixAryList.add(indexForDupNum, infixAryList.get(indexForDupNum).concat(String.valueOf(charNow)));
                infixAryList.remove(++indexForDupNum);
            } else {
                infixAryList.add(String.valueOf(tmpChar[i]));
                indexForDupNum++;
            }
            charTmp =tmpChar[i];
        }

        for (int i = 0; i < infixAryList.size(); i++) {
            String t=infixAryList.get(i);
            if (t.equals(""(""));
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                operatorStack.push(t);
                num++;
            }else if(t.equals("")"")) {
                if(root==null) {
                    nodeR = new Node(null, null, valueStack.pop().getValue());
                    nodeL = new Node(null, null, valueStack.pop().getValue());
                }else{
                    nodeR = valueStack.pop();
                    nodeL = valueStack.pop();
                }
                root=new Node(nodeL,nodeR,operatorStack.pop());
                valueStack.push(root);
            }else {
                Node tmpNode=new Node(null,null,t);
                valueStack.push(tmpNode);
                num++;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
       if(root==null) throw new NullPointerException();
        Node[] prefix = new Node[num];
        LinkedQueue<Node> q=new LinkedQueue<>();
//        Queue<Node> q = new LinkedList<>();
        pre(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            prefix[i] = q.dequeue();
        }
        return prefix;
    }

    private void pre(Node node, LinkedQueue<Node> q){
        if(node.getLeft()!=null && node.getRight()!=null)q.enqueue(node);
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        pre(node.getLeft(), q);
        pre(node.getRight(), q);
        return;
    }

    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[num];
//        Queue<Node> q = new LinkedList<>();
        LinkedQueue<Node> q=new LinkedQueue<>();
        post(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            postfix[i]=q.dequeue();
        }
        return postfix;
    }

    private void post(Node node, LinkedQueue<Node> q){
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        post(node.getLeft(), q);
        post(node.getRight(), q);
        q.enqueue(node);
        return;
    }

    public double Evaluation(){
        if(root==null) throw new NullPointerException();
        double answer;
        Stack<Double> vStack = new Stack<>();
        Stack<String> oStack = new Stack<>();
        for (int i = 0; i < infixAryList.size(); i++) {
            String t = infixAryList.get(i);
            if (t.equals(""("")) ;
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                oStack.push(t);
            } else if (t.equals("")"")) {
                String op = oStack.pop();
                if (op.equals(""+"")) {
                    vStack.push(vStack.pop() + vStack.pop());
                } else if (op.equals(""-"")) {
                    vStack.push(-(vStack.pop() - vStack.pop()));
                } else if (op.equals(""*"")) {
                    vStack.push(vStack.pop() * vStack.pop());
                } else if (op.equals(""/"")) {
                    vStack.push(1 / (vStack.pop() / vStack.pop()));
                }
            } else {
                vStack.push(Double.parseDouble(t));
            }
        }
        answer = vStack.pop();
        return answer;
    }
    public static void main(String[] args)throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression expression= new Expression();
            String infix=br.readLine();
            expression.Infix2BT(infix);
            Node n1[]=expression.PrintPostfix();
            Node n2[]=expression.PrintPrefix();

            for (int i = 0; i < n1.length; i++) {
                System.out.print(n1[i].getValue()+"" "");
            }
            System.out.println(""\n"");
            for (int i = 0; i < n2.length; i++) {
                System.out.print(n2[i].getValue()+"" "");
            }
            System.out.println(""\n"");
            System.out.println(expression.Evaluation());
        }
    }
}

@1b800c54dc2710158faf604da2387141@"
"b03611041","1","0.09","105568","@72d8b37125be7ae21e17e80eb6027a50@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

public class Expression{
  
    private Node root=null;
    private List<String> infixAryList= new ArrayList<>();
    private Stack<Node> valueStack = new Stack<>();
    private Stack<String> operatorStack = new Stack<>();
    private int num=0;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        if(root==null)throw new NullPointerException();
        char tmpChar[]=infix.toCharArray();
        Node nodeL;
        Node nodeR;

        char charTmp=' ';
        int indexForDupNum=0;
        for (int i = 0; i < tmpChar.length; i++) {
            char charNow = tmpChar[i];
            if ((charTmp <= 57 && charTmp >= 48) && (charNow <= 57 && charNow >= 48)) {
                indexForDupNum--;
                infixAryList.add(indexForDupNum, infixAryList.get(indexForDupNum).concat(String.valueOf(charNow)));
                infixAryList.remove(++indexForDupNum);
            } else {
                infixAryList.add(String.valueOf(tmpChar[i]));
                indexForDupNum++;
            }
            charTmp =tmpChar[i];
        }

        for (int i = 0; i < infixAryList.size(); i++) {
            String t=infixAryList.get(i);
            if (t.equals(""(""));
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                operatorStack.push(t);
                num++;
            }else if(t.equals("")"")) {
                if(root==null) {
                    nodeR = new Node(null, null, valueStack.pop().getValue());
                    nodeL = new Node(null, null, valueStack.pop().getValue());
                }else{
                    nodeR = valueStack.pop();
                    nodeL = valueStack.pop();
                }
                root=new Node(nodeL,nodeR,operatorStack.pop());
                valueStack.push(root);
            }else {
                Node tmpNode=new Node(null,null,t);
                valueStack.push(tmpNode);
                num++;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
       if(root==null) throw new NullPointerException();
        Node[] prefix = new Node[num];
        LinkedQueue<Node> q=new LinkedQueue<>();
//        Queue<Node> q = new LinkedList<>();
        pre(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            prefix[i] = q.dequeue();
        }
        return prefix;
    }

    private void pre(Node node, LinkedQueue<Node> q){
        if(node.getLeft()!=null && node.getRight()!=null)q.enqueue(node);
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        pre(node.getLeft(), q);
        pre(node.getRight(), q);
        return;
    }

    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[num];
//        Queue<Node> q = new LinkedList<>();
        LinkedQueue<Node> q=new LinkedQueue<>();
        post(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            postfix[i]=q.dequeue();
        }
        return postfix;
    }

    private void post(Node node, LinkedQueue<Node> q){
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        post(node.getLeft(), q);
        post(node.getRight(), q);
        q.enqueue(node);
        return;
    }

    public double Evaluation(){
        if(root==null) throw new NullPointerException();
        double answer;
        Stack<Double> vStack = new Stack<>();
        Stack<String> oStack = new Stack<>();
        for (int i = 0; i < infixAryList.size(); i++) {
            String t = infixAryList.get(i);
            if (t.equals(""("")) ;
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                oStack.push(t);
            } else if (t.equals("")"")) {
                String op = oStack.pop();
                if (op.equals(""+"")) {
                    vStack.push(vStack.pop() + vStack.pop());
                } else if (op.equals(""-"")) {
                    vStack.push(-(vStack.pop() - vStack.pop()));
                } else if (op.equals(""*"")) {
                    vStack.push(vStack.pop() * vStack.pop());
                } else if (op.equals(""/"")) {
                    vStack.push(1 / (vStack.pop() / vStack.pop()));
                }
            } else {
                vStack.push(Double.parseDouble(t));
            }
        }
        answer = vStack.pop();
        return answer;
    }
    public static void main(String[] args)throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression expression= new Expression();
            String infix=br.readLine();
            expression.Infix2BT(infix);
            Node n1[]=expression.PrintPostfix();
            Node n2[]=expression.PrintPrefix();

            for (int i = 0; i < n1.length; i++) {
                System.out.print(n1[i].getValue()+"" "");
            }
            System.out.println(""\n"");
            for (int i = 0; i < n2.length; i++) {
                System.out.print(n2[i].getValue()+"" "");
            }
            System.out.println(""\n"");
            System.out.println(expression.Evaluation());
        }
    }
}

@72d8b37125be7ae21e17e80eb6027a50@"
"b03611041","10","0.098","105984","@c774ed1b160cc728d5218416af9ff4f5@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.*;

public class Expression{
  
    private Node root=null;
    private List<String> infixAryList= new ArrayList<>();
    private Stack<Node> valueStack = new Stack<>();
    private Stack<String> operatorStack = new Stack<>();
    private int num=0;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        char tmpChar[]=infix.toCharArray();
        Node nodeL;
        Node nodeR;
        char charTmp=' ';
        int indexForDupNum=0;
        for (int i = 0; i < tmpChar.length; i++) {
            char charNow = tmpChar[i];
            if (((charTmp <= 57 && charTmp >= 48)|| charTmp==46) && ((charNow <= 57 && charNow >= 48) ||charNow==46)) {
                indexForDupNum--;
                infixAryList.add(indexForDupNum, infixAryList.get(indexForDupNum).concat(String.valueOf(charNow)));
                infixAryList.remove(++indexForDupNum);
            } else {
                infixAryList.add(String.valueOf(tmpChar[i]));
                indexForDupNum++;
            }
            charTmp =tmpChar[i];
        }

        for (int i = 0; i < infixAryList.size(); i++) {
            String t=infixAryList.get(i);
            if (t.equals(""(""));
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                operatorStack.push(t);
                num++;
            }else if(t.equals("")"")) {
                if(root==null) {
                    nodeR = new Node(null, null, valueStack.pop().getValue());
                    nodeL = new Node(null, null, valueStack.pop().getValue());
                }else{
                    nodeR = valueStack.pop();
                    nodeL = valueStack.pop();
                }
                root=new Node(nodeL,nodeR,operatorStack.pop());
                valueStack.push(root);
            }else {
                Node tmpNode=new Node(null,null,t);
                valueStack.push(tmpNode);
                num++;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
       if(root==null) throw new NullPointerException();
        Node[] prefix = new Node[num];
        LinkedQueue<Node> q=new LinkedQueue<>();
//        Queue<Node> q = new LinkedList<>();
        pre(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            prefix[i] = q.dequeue();
        }
        return prefix;
    }

    private void pre(Node node, LinkedQueue<Node> q){
        if(node.getLeft()!=null && node.getRight()!=null)q.enqueue(node);
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        pre(node.getLeft(), q);
        pre(node.getRight(), q);
        return;
    }

    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[num];
//        Queue<Node> q = new LinkedList<>();
        LinkedQueue<Node> q=new LinkedQueue<>();
        post(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            postfix[i]=q.dequeue();
        }
        return postfix;
    }

    private void post(Node node, LinkedQueue<Node> q){
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        post(node.getLeft(), q);
        post(node.getRight(), q);
        q.enqueue(node);
        return;
    }

    public double Evaluation(){
        if(root==null) throw new NullPointerException();
        double answer;
        Stack<Double> vStack = new Stack<>();
        Stack<String> oStack = new Stack<>();
        for (int i = 0; i < infixAryList.size(); i++) {
            String t = infixAryList.get(i);
            if (t.equals(""("")) ;
            else if (t.equals(""+"") || t.equals(""-"") || t.equals(""*"") || t.equals(""/"")) {
                oStack.push(t);
            } else if (t.equals("")"")) {
                String op = oStack.pop();
                if (op.equals(""+"")) {
                    vStack.push(vStack.pop() + vStack.pop());
                } else if (op.equals(""-"")) {
                    vStack.push(-(vStack.pop() - vStack.pop()));
                } else if (op.equals(""*"")) {
                    vStack.push(vStack.pop() * vStack.pop());
                } else if (op.equals(""/"")) {
                    vStack.push(1 / (vStack.pop() / vStack.pop()));
                }
            } else {
                vStack.push(Double.parseDouble(t));
            }
        }
        answer = vStack.pop();
        return answer;
    }
    public static void main(String[] args)throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            Expression expression= new Expression();
            String infix=br.readLine();
            expression.Infix2BT(infix);
            Node n1[]=expression.PrintPostfix();
            Node n2[]=expression.PrintPrefix();

            for (int i = 0; i < n1.length; i++) {
                System.out.print(n1[i].getValue()+"" "");
            }
            System.out.println(""\n"");
            for (int i = 0; i < n2.length; i++) {
                System.out.print(n2[i].getValue()+"" "");
            }
            System.out.println(""\n"");
            System.out.println(expression.Evaluation());
            expression.Infix2BT(infix);
            Expression expression2= new Expression();
            expression2.Infix2BT(""(4+(((4*2)/2)/3))"");
            Node n3[]=expression2.PrintPostfix();
            for (int i = 0; i < n3.length; i++) {
                System.out.print(n3[i].getValue()+"" "");
            }

        }
    }
}

@c774ed1b160cc728d5218416af9ff4f5@"
"r04945022","0","0.09","99392","@eb835fcfee4488be924f3df9357bc514@
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '+':
                case '-':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                    }
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
        }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        return answer;
    }
}

@eb835fcfee4488be924f3df9357bc514@"
"r04945022","0","0.09","105184","@29932500c022e1000f789b60523d315b@
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '+':
                case '-':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                    }
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPrefixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    
    public void PrintPrefixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPrefixRecusive(p, root.getLeft());
        PrintPrefixRecusive(p, root.getRight());
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPostfixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    public void PrintPostfixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPostfixRecusive(p, root.getLeft());
        PrintPostfixRecusive(p, root.getRight());
        p.add(root);
    }
    

    public double Evaluation(){
        double answer = 0;
        return answer;
    }
}

@29932500c022e1000f789b60523d315b@"
"b03704074","0","0.09","105184","@27556469f15528917abba79214999e2c@public class Expression {
    public class Node{
    private Node left;
    private Node right;
    private String value;

    public Node(Node left, Node right, String value){
        this.left = left;
        this.right = right;
        this.value = value;
    }

    public Node getLeft(){
        return(this.left);
    }

    public Node getRight(){
        return(this.right);
    }

    public String getValue(){
        return(this.value);
    }

    public void setLeft(Node left){
        this.left = left;
    }

    public void setRight(Node right){
        this.right = right;
    }

    public void setValue(String value){
        this.value = value;
    }

    }
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int lenghtcount = 0;
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))lenghtcount++;}
        String[] Infix = new String[infix.length()-lenghtcount];
        Node[] array = new Node[infix.length()];
        int Infixcount = 0;
        for(int i = 0;i < infix.length();i++){//把輸入的改成字串陣列
            if(!infix.substring(i, i+1).equals(""("")){
            Infix[Infixcount] = infix.substring(i, i+1);Infixcount++;}}
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.value);
        return root;
    }
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix = null;
        
        
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        double answer = 0;
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""(4+(((4*2)/2)/3))"");
        
        
    }
    
}

@27556469f15528917abba79214999e2c@"
"b03704074","0","0.09","105184","@f2445bd839f28869ee0921330b3b5f0d@public class Expression {
    public class Node{
    private Node left;
    private Node right;
    private String value;

    public Node(Node left, Node right, String value){
        this.left = left;
        this.right = right;
        this.value = value;
    }

    public Node getLeft(){
        return(this.left);
    }

    public Node getRight(){
        return(this.right);
    }

    public String getValue(){
        return(this.value);
    }

    public void setLeft(Node left){
        this.left = left;
    }

    public void setRight(Node right){
        this.right = right;
    }

    public void setValue(String value){
        this.value = value;
    }

    }
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int lenghtcount = 0;
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))lenghtcount++;}
        String[] Infix = new String[infix.length()-lenghtcount];
        Node[] array = new Node[infix.length()];
        int Infixcount = 0;
        for(int i = 0;i < infix.length();i++){//把輸入的改成字串陣列
            if(!infix.substring(i, i+1).equals(""("")){
            Infix[Infixcount] = infix.substring(i, i+1);Infixcount++;}}
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.value);
        return root;
    }
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix = null;
        
        
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        double answer = 0;
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        //Expression exp = new Expression();
        //Node test = exp.Infix2BT(""(4+(((4*2)/2)/3))"");
        
        
    }
    
}

@f2445bd839f28869ee0921330b3b5f0d@"
"b03704074","0","0.09","105184","@e21992d9ff0f0c1423bbcd66e26627c9@class Node{
    private Node left;
    private Node right;
    private String value;

    public Node(Node left, Node right, String value){
        this.left = left;
        this.right = right;
        this.value = value;
    }

    public Node getLeft(){
        return(this.left);
    }

    public Node getRight(){
        return(this.right);
    }

    public String getValue(){
        return(this.value);
    }

    public void setLeft(Node left){
        this.left = left;
    }

    public void setRight(Node right){
        this.right = right;
    }

    public void setValue(String value){
        this.value = value;
    } }
public class Expression {
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int lenghtcount = 0;
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))lenghtcount++;}
        String[] Infix = new String[infix.length()-lenghtcount];
        Node[] array = new Node[infix.length()];
        int Infixcount = 0;
        for(int i = 0;i < infix.length();i++){//把輸入的改成字串陣列
            if(!infix.substring(i, i+1).equals(""("")){
            Infix[Infixcount] = infix.substring(i, i+1);Infixcount++;}}
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.value);
        return root;
    }
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix = null;
        
        
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        double answer = 0;
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        //Node test = exp.Infix2BT(""(4+(((4*2)/2)/3))"");
        
        
    }
    
}

@e21992d9ff0f0c1423bbcd66e26627c9@"
"b01b01039","9","0.99","105952","@14c29b083dfb72fce9871f48a9a24e83@import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.NoSuchElementException;


public class Expression{
	private static String exp;
	private String pattern = ""\\((\\(.*\\))([+-/*])(\\(.*\\))\\)"";
	private String pattern_l = ""\\((\\(.*\\))([+-/*])([0-9.]*)\\)"";
	private String pattern_r = ""\\(([0-9.]*)([+-/*])(\\(.*\\))\\)"";
	private String pattern_i = ""\\(([0-9.]*)([+-/*])([0-9.]*)\\)"";
	private Pattern m = Pattern.compile(pattern);
	private Pattern l = Pattern.compile(pattern_l);
	private Pattern r = Pattern.compile(pattern_r);
	private Pattern i = Pattern.compile(pattern_i);
	private int N;
	private Node BT_root;
	
	Expression(){
		N = 1;
		BT_root = new Node(null, null, null);
	}
	
	
	public static void main(String[] args){
	String exp = args[0];
    Expression reg = new Expression();
	reg.Infix2BT(exp);
	System.out.println(""Prefix:"");
	Node[] Pre  = reg.PrintPrefix();
	System.out.println(""\nPostfix:"");
	Node[] Post = reg.PrintPostfix();
	System.out.println();
	System.out.println(reg.size());
	System.out.println(reg.Evaluation());
	}
	
	public Node Infix2BT(String infix){
        Node root = BT_root;
		splt(root, infix);		
		return BT_root;
    }
	
	public void splt(Node root, String s){	    
	
	Matcher M = m.matcher(s);
	Matcher L = l.matcher(s);
	Matcher R = r.matcher(s);
    Matcher I = i.matcher(s);
	
    if(R.matches()){
		
        /*System.out.println(""R"");
		System.out.println(""Found value: "" + R.group(1) );
		System.out.println(""Found value: "" + R.group(2) );
		System.out.println(""Found value: "" + R.group(3) );*/
		
		
		root.setLeft(new Node(null, null, R.group(1)));
		N++;
		root.setValue(R.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), R.group(3));
    
	} else if(L.matches()){
		
        /*System.out.println(""L"");
		System.out.println(""Found value: "" + L.group(1) );
		System.out.println(""Found value: "" + L.group(2) );
		System.out.println(""Found value: "" + L.group(3) );*/
		
		
		root.setLeft(new Node(null, null, null));
        N++;
		root.setValue(L.group(2));
		root.setRight(new Node(null, null, L.group(3)));
		N++;
		splt(root.getLeft(), L.group(1));
		
	}else if (M.matches()) {
		
		/*System.out.println(""M"");
        System.out.println(""Found value: "" + M.group(1) );
		System.out.println(""Found value: "" + M.group(2) );
		System.out.println(""Found value: "" + M.group(3) );*/
		
		
		root.setLeft(new Node(null, null, null));
		N++;
		splt(root.getLeft(), M.group(1));
		root.setValue(M.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), M.group(3)); 
		
	}else if(I.matches()){
        
		/*System.out.println(""I"");
		System.out.println(""Found value: "" + I.group(1) );
		System.out.println(""Found value: "" + I.group(2) );
		System.out.println(""Found value: "" + I.group(3) );*/
		
		
		root.setLeft(new Node(null, null, I.group(1)));
		N++;
		root.setValue(I.group(2));
		root.setRight(new Node(null, null, I.group(3)));
		N++;
    } else {
		System.out.println(""Error experssion"");
	}
	
	}
	
	public Node[] PrintPrefix(){
        Queue<Node> q = new Queue<Node>();
        pre(BT_root, q);
		Node[] prefix = new Node[N];
		for(int i = 0; i < N; i++){
			prefix[i] = q.dequeue();
			//System.out.print(prefix[i].getValue()+"" "");
		}
		return prefix;
    }
	
	private void pre(Node root, Queue<Node> q){
		if(root == null) return;
		//System.out.print(root.getValue());
		q.enqueue(root);
		pre(root.getLeft(),q);
		pre(root.getRight(),q);
	}
	
	public Node[] PrintPostfix(){
		Queue<Node> q = new Queue<Node>();
		post(BT_root, q);
		Node[] postfix = new Node[N];
		for(int i = 0; i < N; i++){
			postfix[i] = q.dequeue();
			//System.out.print(postfix[i].getValue()+"" "");
		}
		return postfix;
	}
	
	private void post(Node root, Queue<Node> q){
		if(root == null) return;
		post(root.getLeft(),q);
		post(root.getRight(),q);
		//System.out.print(root.getValue());
		q.enqueue(root);
	}
	
	public int size(){
		return N;
	}

	public double Evaluation(){
		Stack<Double> num = new Stack<Double>();
		Node[] NodeArray =  PrintPrefix();
		
		//System.out.println();
		for(int i = N-1; i > -1; i--){
			String s = NodeArray[i].getValue();
			//System.out.print(s+"" "");
			if(s.matches(""[0-9.]*"")){
				num.push(Double.parseDouble(s));
			}else{
				num.push(eva(num.pop(),num.pop(),s));
			}
		}
		
		double answer = num.pop();
		
		return answer;
    }
	
	private double eva(double d1, double d2, String operator){
		//System.out.println(d1 + "" "" + operator + "" "" + d2);
		if(operator.equals(""+"")){
			return d1 + d2;
		}else if(operator.equals(""-"")){
			return d1 - d2;
		}else if(operator.equals(""*"")){
			return d1 * d2;
		}else if(operator.equals(""/"")){
			return d1 / d2;
		}else{
			throw new NoSuchElementException(""Error operator"");
		}
	}
}


@14c29b083dfb72fce9871f48a9a24e83@"
"b01b01039","9","0.98","105840","@54bb508add1dec6339dde12bf4ced1e0@import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.NoSuchElementException;


public class Expression{
	private static String exp;
	private String pattern = ""\\((\\(.*\\))([+-/*])(\\(.*\\))\\)"";
	private String pattern_l = ""\\((\\(.*\\))([+-/*])([0-9.]*)\\)"";
	private String pattern_r = ""\\(([0-9.]*)([+-/*])(\\(.*\\))\\)"";
	private String pattern_i = ""\\(([0-9.]*)([+-/*])([0-9.]*)\\)"";
	private Pattern m = Pattern.compile(pattern);
	private Pattern l = Pattern.compile(pattern_l);
	private Pattern r = Pattern.compile(pattern_r);
	private Pattern i = Pattern.compile(pattern_i);
	private int N;
	private Node BT_root;
	
	Expression(){
		N = 1;
		BT_root = new Node(null, null, null);
	}
	
	
	public static void main(String[] args){
	String exp = args[0];
    Expression reg = new Expression();
	reg.Infix2BT(exp);
	System.out.println(""Prefix:"");
	Node[] Pre  = reg.PrintPrefix();
	System.out.println(""\nPostfix:"");
	Node[] Post = reg.PrintPostfix();
	System.out.println();
	System.out.println(reg.size());
	System.out.println(reg.Evaluation());
	}
	
	public Node Infix2BT(String infix){
        Node root = BT_root;
		splt(root, infix);	
		if(BT_root == null){throw new java.lang.NullPointerException();}
		return BT_root;
    }
	
	public void splt(Node root, String s){	    
	
	Matcher M = m.matcher(s);
	Matcher L = l.matcher(s);
	Matcher R = r.matcher(s);
    Matcher I = i.matcher(s);
	
    if(R.matches()){
		
        /*System.out.println(""R"");
		System.out.println(""Found value: "" + R.group(1) );
		System.out.println(""Found value: "" + R.group(2) );
		System.out.println(""Found value: "" + R.group(3) );*/
		
		
		root.setLeft(new Node(null, null, R.group(1)));
		N++;
		root.setValue(R.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), R.group(3));
    
	} else if(L.matches()){
		
        /*System.out.println(""L"");
		System.out.println(""Found value: "" + L.group(1) );
		System.out.println(""Found value: "" + L.group(2) );
		System.out.println(""Found value: "" + L.group(3) );*/
		
		
		root.setLeft(new Node(null, null, null));
        N++;
		root.setValue(L.group(2));
		root.setRight(new Node(null, null, L.group(3)));
		N++;
		splt(root.getLeft(), L.group(1));
		
	}else if (M.matches()) {
		
		/*System.out.println(""M"");
        System.out.println(""Found value: "" + M.group(1) );
		System.out.println(""Found value: "" + M.group(2) );
		System.out.println(""Found value: "" + M.group(3) );*/
		
		
		root.setLeft(new Node(null, null, null));
		N++;
		splt(root.getLeft(), M.group(1));
		root.setValue(M.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), M.group(3)); 
		
	}else if(I.matches()){
        
		/*System.out.println(""I"");
		System.out.println(""Found value: "" + I.group(1) );
		System.out.println(""Found value: "" + I.group(2) );
		System.out.println(""Found value: "" + I.group(3) );*/
		
		
		root.setLeft(new Node(null, null, I.group(1)));
		N++;
		root.setValue(I.group(2));
		root.setRight(new Node(null, null, I.group(3)));
		N++;
    } else {
		System.out.println(""Error experssion"");
	}
	
	}
	
	public Node[] PrintPrefix(){
        Queue<Node> q = new Queue<Node>();
        pre(BT_root, q);
		Node[] prefix = new Node[N];
		for(int i = 0; i < N; i++){
			prefix[i] = q.dequeue();
			//System.out.print(prefix[i].getValue()+"" "");
		}
		return prefix;
    }
	
	private void pre(Node root, Queue<Node> q){
		if(root == null) return;
		//System.out.print(root.getValue());
		q.enqueue(root);
		pre(root.getLeft(),q);
		pre(root.getRight(),q);
	}
	
	public Node[] PrintPostfix(){
		Queue<Node> q = new Queue<Node>();
		post(BT_root, q);
		Node[] postfix = new Node[N];
		for(int i = 0; i < N; i++){
			postfix[i] = q.dequeue();
			//System.out.print(postfix[i].getValue()+"" "");
		}
		return postfix;
	}
	
	private void post(Node root, Queue<Node> q){
		if(root == null) return;
		post(root.getLeft(),q);
		post(root.getRight(),q);
		//System.out.print(root.getValue());
		q.enqueue(root);
	}
	
	public int size(){
		return N;
	}

	public double Evaluation(){
		Stack<Double> num = new Stack<Double>();
		Node[] NodeArray =  PrintPrefix();
		
		//System.out.println();
		for(int i = N-1; i > -1; i--){
			String s = NodeArray[i].getValue();
			//System.out.print(s+"" "");
			if(s.matches(""[0-9.]*"")){
				num.push(Double.parseDouble(s));
			}else{
				num.push(eva(num.pop(),num.pop(),s));
			}
		}
		
		double answer = num.pop();
		
		return answer;
    }
	
	private double eva(double d1, double d2, String operator){
		//System.out.println(d1 + "" "" + operator + "" "" + d2);
		if(operator.equals(""+"")){
			return d1 + d2;
		}else if(operator.equals(""-"")){
			return d1 - d2;
		}else if(operator.equals(""*"")){
			return d1 * d2;
		}else if(operator.equals(""/"")){
			return d1 / d2;
		}else{
			throw new NoSuchElementException(""Error operator"");
		}
	}
}


@54bb508add1dec6339dde12bf4ced1e0@"
"b01b01039","9","1.01","105936","@753a07094bc58199962a4e5a8469661a@import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.NoSuchElementException;


public class Expression{
	private static String exp;
	private String pattern = ""\\((\\(.*\\))([+-/*])(\\(.*\\))\\)"";
	private String pattern_l = ""\\((\\(.*\\))([+-/*])([0-9.]*)\\)"";
	private String pattern_r = ""\\(([0-9.]*)([+-/*])(\\(.*\\))\\)"";
	private String pattern_i = ""\\(([0-9.]*)([+-/*])([0-9.]*)\\)"";
	private Pattern m = Pattern.compile(pattern);
	private Pattern l = Pattern.compile(pattern_l);
	private Pattern r = Pattern.compile(pattern_r);
	private Pattern i = Pattern.compile(pattern_i);
	private int N;
	private Node BT_root;
	
	Expression(){
		N = 1;
		BT_root = new Node(null, null, null);
	}
	
	
	public static void main(String[] args){
	String exp = null;
    Expression reg = new Expression();
	reg.Infix2BT(exp);
	System.out.println(""Prefix:"");
	Node[] Pre  = reg.PrintPrefix();
	System.out.println(""\nPostfix:"");
	Node[] Post = reg.PrintPostfix();
	System.out.println();
	System.out.println(reg.size());
	System.out.println(reg.Evaluation());
	}
	
	public Node Infix2BT(String infix){
        Node root = BT_root;
		if(infix == null){throw new java.lang.NullPointerException();}
		splt(root, infix);	
		return BT_root;
    }
	
	public void splt(Node root, String s){	    
	
	Matcher M = m.matcher(s);
	Matcher L = l.matcher(s);
	Matcher R = r.matcher(s);
    Matcher I = i.matcher(s);
	
    if(R.matches()){
		
        /*System.out.println(""R"");
		System.out.println(""Found value: "" + R.group(1) );
		System.out.println(""Found value: "" + R.group(2) );
		System.out.println(""Found value: "" + R.group(3) );*/
		
		
		root.setLeft(new Node(null, null, R.group(1)));
		N++;
		root.setValue(R.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), R.group(3));
    
	} else if(L.matches()){
		
        /*System.out.println(""L"");
		System.out.println(""Found value: "" + L.group(1) );
		System.out.println(""Found value: "" + L.group(2) );
		System.out.println(""Found value: "" + L.group(3) );*/
		
		
		root.setLeft(new Node(null, null, null));
        N++;
		root.setValue(L.group(2));
		root.setRight(new Node(null, null, L.group(3)));
		N++;
		splt(root.getLeft(), L.group(1));
		
	}else if (M.matches()) {
		
		/*System.out.println(""M"");
        System.out.println(""Found value: "" + M.group(1) );
		System.out.println(""Found value: "" + M.group(2) );
		System.out.println(""Found value: "" + M.group(3) );*/
		
		
		root.setLeft(new Node(null, null, null));
		N++;
		splt(root.getLeft(), M.group(1));
		root.setValue(M.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), M.group(3)); 
		
	}else if(I.matches()){
        
		/*System.out.println(""I"");
		System.out.println(""Found value: "" + I.group(1) );
		System.out.println(""Found value: "" + I.group(2) );
		System.out.println(""Found value: "" + I.group(3) );*/
		
		
		root.setLeft(new Node(null, null, I.group(1)));
		N++;
		root.setValue(I.group(2));
		root.setRight(new Node(null, null, I.group(3)));
		N++;
    } else {
		System.out.println(""Error experssion"");
	}
	
	}
	
	public Node[] PrintPrefix(){
        Queue<Node> q = new Queue<Node>();
        pre(BT_root, q);
		Node[] prefix = new Node[N];
		for(int i = 0; i < N; i++){
			prefix[i] = q.dequeue();
			//System.out.print(prefix[i].getValue()+"" "");
		}
		return prefix;
    }
	
	private void pre(Node root, Queue<Node> q){
		if(root == null) return;
		//System.out.print(root.getValue());
		q.enqueue(root);
		pre(root.getLeft(),q);
		pre(root.getRight(),q);
	}
	
	public Node[] PrintPostfix(){
		Queue<Node> q = new Queue<Node>();
		post(BT_root, q);
		Node[] postfix = new Node[N];
		for(int i = 0; i < N; i++){
			postfix[i] = q.dequeue();
			//System.out.print(postfix[i].getValue()+"" "");
		}
		return postfix;
	}
	
	private void post(Node root, Queue<Node> q){
		if(root == null) return;
		post(root.getLeft(),q);
		post(root.getRight(),q);
		//System.out.print(root.getValue());
		q.enqueue(root);
	}
	
	public int size(){
		return N;
	}

	public double Evaluation(){
		Stack<Double> num = new Stack<Double>();
		Node[] NodeArray =  PrintPrefix();
		
		//System.out.println();
		for(int i = N-1; i > -1; i--){
			String s = NodeArray[i].getValue();
			//System.out.print(s+"" "");
			if(s.matches(""[0-9.]*"")){
				num.push(Double.parseDouble(s));
			}else{
				num.push(eva(num.pop(),num.pop(),s));
			}
		}
		
		double answer = num.pop();
		
		return answer;
    }
	
	private double eva(double d1, double d2, String operator){
		//System.out.println(d1 + "" "" + operator + "" "" + d2);
		if(operator.equals(""+"")){
			return d1 + d2;
		}else if(operator.equals(""-"")){
			return d1 - d2;
		}else if(operator.equals(""*"")){
			return d1 * d2;
		}else if(operator.equals(""/"")){
			return d1 / d2;
		}else{
			throw new NoSuchElementException(""Error operator"");
		}
	}
}


@753a07094bc58199962a4e5a8469661a@"
"b01b01039","9","1","105952","@5cefa9388f10acb4355aee4ae85b2662@import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.NoSuchElementException;


public class Expression{
	private static String exp;
	private String pattern = ""\\((\\(.*\\))([+-/*])(\\(.*\\))\\)"";
	private String pattern_l = ""\\((\\(.*\\))([+-/*])([0-9.]*)\\)"";
	private String pattern_r = ""\\(([0-9.]*)([+-/*])(\\(.*\\))\\)"";
	private String pattern_i = ""\\(([0-9.]*)([+-/*])([0-9.]*)\\)"";
	private Pattern m = Pattern.compile(pattern);
	private Pattern l = Pattern.compile(pattern_l);
	private Pattern r = Pattern.compile(pattern_r);
	private Pattern i = Pattern.compile(pattern_i);
	private int N;
	private Node BT_root;
	
	Expression(){
		N = 1;
		BT_root = new Node(null, null, null);
	}
	
	
	public static void main(String[] args){
	String exp = args[0];
    Expression reg = new Expression();
	reg.Infix2BT(null);
	System.out.println(""Prefix:"");
	Node[] Pre  = reg.PrintPrefix();
	System.out.println(""\nPostfix:"");
	Node[] Post = reg.PrintPostfix();
	System.out.println();
	System.out.println(reg.size());
	System.out.println(reg.Evaluation());
	}
	
	public Node Infix2BT(String infix){
        Node root = BT_root;
		if(infix.length()>0){
			splt(root, infix);
		}
		if(BT_root == null){throw new java.lang.NullPointerException();}
		return BT_root;
    }
	
	public void splt(Node root, String s){	    
	
	Matcher M = m.matcher(s);
	Matcher L = l.matcher(s);
	Matcher R = r.matcher(s);
    Matcher I = i.matcher(s);
	
    if(R.matches()){
		
        /*System.out.println(""R"");
		System.out.println(""Found value: "" + R.group(1) );
		System.out.println(""Found value: "" + R.group(2) );
		System.out.println(""Found value: "" + R.group(3) );*/
		
		
		root.setLeft(new Node(null, null, R.group(1)));
		N++;
		root.setValue(R.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), R.group(3));
    
	} else if(L.matches()){
		
        /*System.out.println(""L"");
		System.out.println(""Found value: "" + L.group(1) );
		System.out.println(""Found value: "" + L.group(2) );
		System.out.println(""Found value: "" + L.group(3) );*/
		
		
		root.setLeft(new Node(null, null, null));
        N++;
		root.setValue(L.group(2));
		root.setRight(new Node(null, null, L.group(3)));
		N++;
		splt(root.getLeft(), L.group(1));
		
	}else if (M.matches()) {
		
		/*System.out.println(""M"");
        System.out.println(""Found value: "" + M.group(1) );
		System.out.println(""Found value: "" + M.group(2) );
		System.out.println(""Found value: "" + M.group(3) );*/
		
		
		root.setLeft(new Node(null, null, null));
		N++;
		splt(root.getLeft(), M.group(1));
		root.setValue(M.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), M.group(3)); 
		
	}else if(I.matches()){
        
		/*System.out.println(""I"");
		System.out.println(""Found value: "" + I.group(1) );
		System.out.println(""Found value: "" + I.group(2) );
		System.out.println(""Found value: "" + I.group(3) );*/
		
		
		root.setLeft(new Node(null, null, I.group(1)));
		N++;
		root.setValue(I.group(2));
		root.setRight(new Node(null, null, I.group(3)));
		N++;
    } else {
		System.out.println(""Error experssion"");
	}
	
	}
	
	public Node[] PrintPrefix(){
        if(BT_root == null){throw new java.lang.NullPointerException();}
		Queue<Node> q = new Queue<Node>();
        pre(BT_root, q);
		Node[] prefix = new Node[N];
		for(int i = 0; i < N; i++){
			prefix[i] = q.dequeue();
			//System.out.print(prefix[i].getValue()+"" "");
		}
		return prefix;
    }
	
	private void pre(Node root, Queue<Node> q){
		if(root == null) return;
		//System.out.print(root.getValue());
		q.enqueue(root);
		pre(root.getLeft(),q);
		pre(root.getRight(),q);
	}
	
	public Node[] PrintPostfix(){
		if(BT_root == null){throw new java.lang.NullPointerException();}
		Queue<Node> q = new Queue<Node>();
		post(BT_root, q);
		Node[] postfix = new Node[N];
		for(int i = 0; i < N; i++){
			postfix[i] = q.dequeue();
			//System.out.print(postfix[i].getValue()+"" "");
		}
		return postfix;
	}
	
	private void post(Node root, Queue<Node> q){
		if(root == null) return;
		post(root.getLeft(),q);
		post(root.getRight(),q);
		//System.out.print(root.getValue());
		q.enqueue(root);
	}
	
	public int size(){
		return N;
	}

	public double Evaluation(){
		if(BT_root == null){throw new java.lang.NullPointerException();}
		Stack<Double> num = new Stack<Double>();
		Node[] NodeArray =  PrintPrefix();
		
		//System.out.println();
		for(int i = N-1; i > -1; i--){
			String s = NodeArray[i].getValue();
			//System.out.print(s+"" "");
			if(s.matches(""[0-9.]*"")){
				num.push(Double.parseDouble(s));
			}else{
				num.push(eva(num.pop(),num.pop(),s));
			}
		}
		
		double answer = num.pop();
		
		return answer;
    }
	
	private double eva(double d1, double d2, String operator){
		//System.out.println(d1 + "" "" + operator + "" "" + d2);
		if(operator.equals(""+"")){
			return d1 + d2;
		}else if(operator.equals(""-"")){
			return d1 - d2;
		}else if(operator.equals(""*"")){
			return d1 * d2;
		}else if(operator.equals(""/"")){
			return d1 / d2;
		}else{
			throw new NoSuchElementException(""Error operator"");
		}
	}
}


@5cefa9388f10acb4355aee4ae85b2662@"
"b03704074","2","0.28","105504","@aea6320c75ab6c865e5d2c9b98b799bc@/*class Node{
    private Node left;
    private Node right;
    private String value;

    public Node(Node left, Node right, String value){
        this.left = left;
        this.right = right;
        this.value = value;
    }

    public Node getLeft(){
        return(this.left);
    }

    public Node getRight(){
        return(this.right);
    }

    public String getValue(){
        return(this.value);
    }

    public void setLeft(Node left){
        this.left = left;
    }

    public void setRight(Node right){
        this.right = right;
    }

    public void setValue(String value){
        this.value = value;
    } }*/
public class Expression {
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int lenghtcount = 0;
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))lenghtcount++;}
        String[] Infix = new String[infix.length()-lenghtcount];
        Node[] array = new Node[infix.length()];
        int Infixcount = 0;
        for(int i = 0;i < infix.length();i++){//把輸入的改成字串陣列
            if(!infix.substring(i, i+1).equals(""("")){
            Infix[Infixcount] = infix.substring(i, i+1);Infixcount++;}}
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.value);
        return root;
    }
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix = null;
        
        
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        double answer = 0;
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        //Node test = exp.Infix2BT(""(4+(((4*2)/2)/3))"");
        
        
    }
    
}

@aea6320c75ab6c865e5d2c9b98b799bc@"
"b01703032","10","0.093","105504","@1d02748cfa6b144461e19637927aa011@import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){

        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String num = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char c = infix.charAt(i);
            switch (c){
                case '(':
                    num = """";
                    break;
                case '+':
                case '-':
                case '*':
                case '/':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    ops.push(new Node(null , null , c + """"));
                    break;
                case ')':
                    if(!num.equals(""""))
                        vals.push(new Node(null , null , num));
                    num = """";
                    Node op = ops.pop();
                    Node val2 = vals.pop();
                    Node val1 = vals.pop();
                    op.setLeft(val1);
                    op.setRight(val2);
                    root = op;
                    vals.push(op);
                    break;
                default:
                    num += c;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPrefixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPrefixHelper(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        PrintPrefixHelper(list, root.getLeft());
        PrintPrefixHelper(list , root.getRight());
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        PrintPostfixHelper(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void PrintPostfixHelper(List<Node> list, Node root){
        if (root == null) return;
        PrintPostfixHelper(list, root.getLeft());
        PrintPostfixHelper(list, root.getRight());
        list.add(root);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        return EvaluationHelper(root);
    }

    private double EvaluationHelper(Node root){
        switch (root.getValue()) {
            case ""+"":
                return EvaluationHelper(root.getLeft()) + EvaluationHelper(root.getRight());
            case ""-"":
                return EvaluationHelper(root.getLeft()) - EvaluationHelper(root.getRight());
            case ""*"":
                return EvaluationHelper(root.getLeft()) * EvaluationHelper(root.getRight());
            case ""/"":
                return EvaluationHelper(root.getLeft()) / EvaluationHelper(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }
    }

    public double Evaluation_NonRecursive(){
        if(root == null) throw new NullPointerException();
        Node[] nodes =  this.PrintPostfix();
        Stack<Double> values = new Stack<Double>();
        for (Node node:nodes) {
            String str = node.getValue();
            switch (str) {
                case ""+"":
                    values.push(values.pop() + values.pop());
                    break;
                case ""-"":
                    values.push(-values.pop() + values.pop());
                    break;
                case ""*"":
                    values.push(values.pop() * values.pop());
                    break;
                case ""/"":
                    values.push(1 / values.pop() * values.pop());
                    break;
                default:
                    values.push(Double.parseDouble(str));
                    break;
            }
        }
        return values.pop();
    }

}
@1d02748cfa6b144461e19637927aa011@"
"r04921012","1","0.27","103584","@8bc9f17337afc20d85bf7aad34cef7b1@//package expression;

import java.util.ArrayList;
import java.util.Stack;

public class Expression{
  
    private Node root;
    public String Ans;
    public static ArrayList<Node> preList = new ArrayList();
    public static ArrayList<Node> postList = new ArrayList();

    // DO NOT MODIFY THIS
    public Expression(){}

    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        int L=infix.length();
        int start = 0;
        int stop = 0;
        Stack<String> st = new Stack();
        Stack<Node> node_st = new Stack();
        
        for (int i=0 ; i<L ; i++){
            char c = infix.charAt(i);
            if (c=='(' ){
                
                start++;
                stop++;
            }
            else if ( c==')'){
                Node m = node_st.pop();
                if (stop==start){}
                else{
                    String r_numstr = infix.substring(start, stop);
                    Node r = new Node(null,null,r_numstr);
                    st.push(r.getValue());
                    m.setRight(r);
                }
                    
                    Node l = node_st.pop();
                    m.setLeft(l);
                    node_st.push(m);
                    String ans = calculate(st.pop(),st.pop(),st.pop());
                    st.push(ans);
                    start = i+1;
                    stop = i+1;
                    if (i==L-1){
                        root = m;
                        Ans = ans;
                    }
                
            }
            else if (Character.isDigit(c)|| c=='.'){
                
                stop++;
            }
            else{
                
                String numstr;
                if (start==stop){}
                    
                else{
                    numstr = infix.substring(start, stop);
                    //System.out.println(""numstr""+numstr);
                    
                    Node l = new Node(null,null,numstr);
                    node_st.push(l);
                    st.push(l.getValue());
                }
                
                Node m = new Node(null,null,Character.toString(c));    
                node_st.push(m);
                
                st.push(m.getValue());
                start = i+1;
                stop = i+1;
                
            }
            //System.out.println(st.size());
        }
        
        return root;
    }
    
    public String calculate(String r,String op,String l){
        System.out.println(""l""+l);
        System.out.println(""op""+op);
        System.out.println(""r""+r);
        double ans = 0;
        double l_num = Double.parseDouble(l);
        double r_num = Double.parseDouble(r);
        if (op.equals(""+""))
            ans = l_num + r_num;
        else if (op.equals(""-""))
            ans = l_num - r_num;
        else if (op.equals(""*""))
            ans = l_num * r_num;
        else
            ans = l_num / r_num;
        return String.valueOf(ans);
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        if (root==null)
            throw new NullPointerException();
        else{
        preRecur(root);
        prefix=preList.toArray(prefix);
        
        return prefix; 
        }

    }
    public static void preRecur(Node node){
        preList.add(node);
        if (node.getLeft()==null){}
        else{
            Node left = node.getLeft();
            preRecur(left);
        }
        if (node.getRight()==null){}
        else{
            Node right = node.getRight();
            preRecur(right);
        }
    }
    
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        if (root==null)
            throw new NullPointerException();
        else{
        postRecur(root);
        postfix=postList.toArray(postfix);
        return postfix;
        }
    }
    public static void postRecur(Node node){

        if (node.getLeft()==null)
            postList.add(node);
        else{
            Node left = node.getLeft();
            postRecur(left);
        }
        if (node.getRight()==null)
            postList.add(node);
        else{
            Node right = node.getRight();
            postRecur(right);
        }
        postList.add(node);
    }
    public double Evaluation(){
        if (root==null)
            throw new NullPointerException();
        double answer = Double.parseDouble(Ans);
        return answer;
    }
    
    public static void main(String[] args){
        Expression ex = new Expression();
        String input = ""(4+(((4*2)/2)/3))"";
        ex.Infix2BT(input);
        System.out.println(ex.Evaluation());
    }
}

@8bc9f17337afc20d85bf7aad34cef7b1@"
"b01b01039","1","0.09","101536","@ca8d2419ac0c40cf802cfad34d5494c7@import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.NoSuchElementException;


public class Expression{
	private static String exp;
	private String pattern = ""\\((\\(.*\\))([+-/*])(\\(.*\\))\\)"";
	private String pattern_l = ""\\((\\(.*\\))([+-/*])([0-9.]*)\\)"";
	private String pattern_r = ""\\(([0-9.]*)([+-/*])(\\(.*\\))\\)"";
	private String pattern_i = ""\\(([0-9.]*)([+-/*])([0-9.]*)\\)"";
	private Pattern m = Pattern.compile(pattern);
	private Pattern l = Pattern.compile(pattern_l);
	private Pattern r = Pattern.compile(pattern_r);
	private Pattern i = Pattern.compile(pattern_i);
	private int N;
	private Node BT_root;
	
	Expression(){
		N = 1;
	}
	
	
	public static void main(String[] args){
	String exp = args[0];
    Expression reg = new Expression();
	reg.Infix2BT(exp);
	System.out.println(""Prefix:"");
	Node[] Pre  = reg.PrintPrefix();
	System.out.println(""\nPostfix:"");
	Node[] Post = reg.PrintPostfix();
	System.out.println();
	System.out.println(reg.size());
	System.out.println(reg.Evaluation());
	}
	
	public Node Infix2BT(String infix){
        Node root = BT_root;
		BT_root = new Node(null, null, null);
		
		if(infix.matches(""\\([0-9.]*\\)"")){
			System.out.print(infix);
		}else if(infix.length()>0){
			splt(root, infix);
		}
		
		if(BT_root == null){throw new java.lang.NullPointerException();}
		return BT_root;
    }
	
	public void splt(Node root, String s){	    
	
	Matcher M = m.matcher(s);
	Matcher L = l.matcher(s);
	Matcher R = r.matcher(s);
    Matcher I = i.matcher(s);
	
    if(R.matches()){
		
        System.out.println(""R"");
		System.out.println(""Found value: "" + R.group(1) );
		System.out.println(""Found value: "" + R.group(2) );
		System.out.println(""Found value: "" + R.group(3) );
		
		
		root.setLeft(new Node(null, null, R.group(1)));
		N++;
		root.setValue(R.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), R.group(3));
    
	} else if(L.matches()){
		
        System.out.println(""L"");
		System.out.println(""Found value: "" + L.group(1) );
		System.out.println(""Found value: "" + L.group(2) );
		System.out.println(""Found value: "" + L.group(3) );
		
		
		root.setLeft(new Node(null, null, null));
        N++;
		root.setValue(L.group(2));
		root.setRight(new Node(null, null, L.group(3)));
		N++;
		splt(root.getLeft(), L.group(1));
		
	}else if (M.matches()) {
		
		System.out.println(""M"");
        System.out.println(""Found value: "" + M.group(1) );
		System.out.println(""Found value: "" + M.group(2) );
		System.out.println(""Found value: "" + M.group(3) );
		
		
		root.setLeft(new Node(null, null, null));
		N++;
		splt(root.getLeft(), M.group(1));
		root.setValue(M.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), M.group(3)); 
		
	}else if(I.matches()){
        
		System.out.println(""I"");
		System.out.println(""Found value: "" + I.group(1) );
		System.out.println(""Found value: "" + I.group(2) );
		System.out.println(""Found value: "" + I.group(3) );
		
		
		root.setLeft(new Node(null, null, I.group(1)));
		N++;
		root.setValue(I.group(2));
		root.setRight(new Node(null, null, I.group(3)));
		N++;
    } else {
		System.out.println(""Error experssion"");
	}
	
	}
	
	public Node[] PrintPrefix(){
        if(BT_root == null){throw new java.lang.NullPointerException();}
		Queue<Node> q = new Queue<Node>();
        pre(BT_root, q);
		Node[] prefix = new Node[N];
		for(int i = 0; i < N; i++){
			prefix[i] = q.dequeue();
			//System.out.print(prefix[i].getValue()+"" "");
		}
		return prefix;
    }
	
	private void pre(Node root, Queue<Node> q){
		if(root == null) return;
		//System.out.print(root.getValue());
		q.enqueue(root);
		pre(root.getLeft(),q);
		pre(root.getRight(),q);
	}
	
	public Node[] PrintPostfix(){
		if(BT_root == null){throw new java.lang.NullPointerException();}
		Queue<Node> q = new Queue<Node>();
		post(BT_root, q);
		Node[] postfix = new Node[N];
		for(int i = 0; i < N; i++){
			postfix[i] = q.dequeue();
			//System.out.print(postfix[i].getValue()+"" "");
		}
		return postfix;
	}
	
	private void post(Node root, Queue<Node> q){
		if(root == null) return;
		post(root.getLeft(),q);
		post(root.getRight(),q);
		//System.out.print(root.getValue());
		q.enqueue(root);
	}
	
	public int size(){
		return N;
	}

	public double Evaluation(){
		if(BT_root == null){throw new java.lang.NullPointerException();}
		Stack<Double> num = new Stack<Double>();
		Node[] NodeArray =  PrintPrefix();
		
		//System.out.println();
		for(int i = N-1; i > -1; i--){
			String s = NodeArray[i].getValue();
			System.out.print(s+"" "");
			if(s.matches(""[0-9.]*"")){
				num.push(Double.parseDouble(s));
			}else{
				num.push(eva(num.pop(),num.pop(),s));
			}
		}
		
		double answer = num.pop();
		
		return answer;
    }
	
	private double eva(double d1, double d2, String operator){
		//System.out.println(d1 + "" "" + operator + "" "" + d2);
		if(operator.equals(""+"")){
			return d1 + d2;
		}else if(operator.equals(""-"")){
			return d1 - d2;
		}else if(operator.equals(""*"")){
			return d1 * d2;
		}else if(operator.equals(""/"")){
			return d1 / d2;
		}else{
			throw new NoSuchElementException(""Error operator"");
		}
	}
}


@ca8d2419ac0c40cf802cfad34d5494c7@"
"b01b01039","10","0.098","105952","@7676f43d0b84a49b123d80c01b5d8138@import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.NoSuchElementException;


public class Expression{
	private static String exp;
	private String pattern = ""\\((\\(.*\\))([+-/*])(\\(.*\\))\\)"";
	private String pattern_l = ""\\((\\(.*\\))([+-/*])([0-9.]*)\\)"";
	private String pattern_r = ""\\(([0-9.]*)([+-/*])(\\(.*\\))\\)"";
	private String pattern_i = ""\\(([0-9.]*)([+-/*])([0-9.]*)\\)"";
	private Pattern m = Pattern.compile(pattern);
	private Pattern l = Pattern.compile(pattern_l);
	private Pattern r = Pattern.compile(pattern_r);
	private Pattern i = Pattern.compile(pattern_i);
	private int N;
	private Node BT_root;
	
	Expression(){
		N = 1;
	}
	
	
	public static void main(String[] args){
	String exp = args[0];
    Expression reg = new Expression();
	reg.Infix2BT(exp);
	System.out.println(""Prefix:"");
	Node[] Pre  = reg.PrintPrefix();
	System.out.println(""\nPostfix:"");
	Node[] Post = reg.PrintPostfix();
	System.out.println();
	System.out.println(reg.size());
	System.out.println(reg.Evaluation());
	}
	
	public Node Infix2BT(String infix){
        BT_root = new Node(null, null, null);
		Node root = BT_root;
		
		
		if(infix.length()>0){
			splt(root, infix);
		}
		
		if(BT_root == null){throw new java.lang.NullPointerException();}
		return BT_root;
    }
	
	public void splt(Node root, String s){	    
	
	Matcher M = m.matcher(s);
	Matcher L = l.matcher(s);
	Matcher R = r.matcher(s);
    Matcher I = i.matcher(s);
	
    if(R.matches()){
		/*
        System.out.println(""R"");
		System.out.println(""Found value: "" + R.group(1) );
		System.out.println(""Found value: "" + R.group(2) );
		System.out.println(""Found value: "" + R.group(3) );
		*/
		
		root.setLeft(new Node(null, null, R.group(1)));
		N++;
		root.setValue(R.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), R.group(3));
    
	} else if(L.matches()){
		/*
        System.out.println(""L"");
		System.out.println(""Found value: "" + L.group(1) );
		System.out.println(""Found value: "" + L.group(2) );
		System.out.println(""Found value: "" + L.group(3) );
		*/
		
		root.setLeft(new Node(null, null, null));
        N++;
		root.setValue(L.group(2));
		root.setRight(new Node(null, null, L.group(3)));
		N++;
		splt(root.getLeft(), L.group(1));
		
	}else if (M.matches()) {
		/*
		System.out.println(""M"");
        System.out.println(""Found value: "" + M.group(1) );
		System.out.println(""Found value: "" + M.group(2) );
		System.out.println(""Found value: "" + M.group(3) );
		*/
		
		root.setLeft(new Node(null, null, null));
		N++;
		splt(root.getLeft(), M.group(1));
		root.setValue(M.group(2));
		root.setRight(new Node(null, null, null));
		N++;
		splt(root.getRight(), M.group(3)); 
		
	}else if(I.matches()){
        /*
		System.out.println(""I"");
		System.out.println(""Found value: "" + I.group(1) );
		System.out.println(""Found value: "" + I.group(2) );
		System.out.println(""Found value: "" + I.group(3) );
		*/
		
		root.setLeft(new Node(null, null, I.group(1)));
		N++;
		root.setValue(I.group(2));
		root.setRight(new Node(null, null, I.group(3)));
		N++;
    } else {
		System.out.println(""Error experssion"");
	}
	
	}
	
	public Node[] PrintPrefix(){
        if(BT_root == null){throw new java.lang.NullPointerException();}
		Queue<Node> q = new Queue<Node>();
        pre(BT_root, q);
		Node[] prefix = new Node[N];
		for(int i = 0; i < N; i++){
			prefix[i] = q.dequeue();
			//System.out.print(prefix[i].getValue()+"" "");
		}
		return prefix;
    }
	
	private void pre(Node root, Queue<Node> q){
		if(root == null) return;
		//System.out.print(root.getValue());
		q.enqueue(root);
		pre(root.getLeft(),q);
		pre(root.getRight(),q);
	}
	
	public Node[] PrintPostfix(){
		if(BT_root == null){throw new java.lang.NullPointerException();}
		Queue<Node> q = new Queue<Node>();
		post(BT_root, q);
		Node[] postfix = new Node[N];
		for(int i = 0; i < N; i++){
			postfix[i] = q.dequeue();
			//System.out.print(postfix[i].getValue()+"" "");
		}
		return postfix;
	}
	
	private void post(Node root, Queue<Node> q){
		if(root == null) return;
		post(root.getLeft(),q);
		post(root.getRight(),q);
		//System.out.print(root.getValue());
		q.enqueue(root);
	}
	
	public int size(){
		return N;
	}

	public double Evaluation(){
		if(BT_root == null){throw new java.lang.NullPointerException();}
		Stack<Double> num = new Stack<Double>();
		Node[] NodeArray =  PrintPrefix();
		
		//System.out.println();
		for(int i = N-1; i > -1; i--){
			String s = NodeArray[i].getValue();
			//System.out.print(s+"" "");
			if(s.matches(""[0-9.]*"")){
				num.push(Double.parseDouble(s));
			}else{
				num.push(eva(num.pop(),num.pop(),s));
			}
		}
		
		double answer = num.pop();
		
		return answer;
    }
	
	private double eva(double d1, double d2, String operator){
		//System.out.println(d1 + "" "" + operator + "" "" + d2);
		if(operator.equals(""+"")){
			return d1 + d2;
		}else if(operator.equals(""-"")){
			return d1 - d2;
		}else if(operator.equals(""*"")){
			return d1 * d2;
		}else if(operator.equals(""/"")){
			return d1 / d2;
		}else{
			throw new NoSuchElementException(""Error operator"");
		}
	}
}


@7676f43d0b84a49b123d80c01b5d8138@"
"b02611002","0","1","105952","@b35df1ce21af4f4aa747c7d423da36bd@import java.util.*;

public class Expression{


    boolean DEBUG = false;
    private Node root;
    Stack<Node> s = new Stack<>();


    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){



        String[] inputs = infix.split(""(?<=[)(+\\-*/=])|(?=[)(+\\-*/=])""); //如果前或後有+-*/就切開
        //(	4.0	+	(	(	(	4	*	2.0	)	/	2	)	/	3	)	)

        Stack<Node> nodeS = new Stack<>();

        if (DEBUG) {
            for (int i = 0; i < inputs.length; i++) {
                System.out.print(inputs[i]+""\t\t"");
            }
        }

        /* Generate Stack of Node from the String[] */
        for (int i = 0; i < inputs.length; i++) {nodeS.add(new Node(null,null,inputs[i]));}   //size = 17

        /* inspect */ //FIXME ignored cases like ""(10+2-59045)""
        for(int i=0;i<nodeS.size();i++){
            if(nodeS.get(i).getValue().equals("")"")){
                nodeS.get(i-2).setLeft(nodeS.get(i-3));
                nodeS.get(i-2).setRight(nodeS.get(i-1));
                nodeS.remove(i);
                nodeS.remove(i-1);
                nodeS.remove(i-3);
                nodeS.remove(i-4);
                i-=5;
                if(DEBUG) for(int j=0;j<nodeS.size();j++){System.out.print(nodeS.get(j).getValue());}
            }
        }
        assert nodeS.size()==1;
        root = nodeS.get(0);

        return root;
    }

    public Node[] PrintPrefix(){



        TraversalPreorder(root);

        Node[] prefix = new Node[s.size()];
        for(int i=0;i<prefix.length;i++) prefix[i] = s.get(i);
        assert s.size()>1;

        return prefix;
    }

    public Void TraversalPreorder(Node p){
        if (p==null) return null;
        s.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        TraversalPreorder(p.getLeft());
        TraversalPreorder(p.getRight());
        return null;
    }

    public Node[] PrintPostfix(){
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        return answer;
    }
}

@b35df1ce21af4f4aa747c7d423da36bd@"
"r04631034","1","0.09","105232","@10fa81c00d8be86405ef9889d02a8b28@
import java.util.*;

public class Expression {

     private Node root;

     // DO NOT MODIFY THIS
     public Expression() {
     }

     private boolean isCalculator(String c) {
          if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"") || c.equals(""."")) {
               return true;
          } else if (java.lang.Character.isDigit(c.charAt(0))) {
               return true;
          }
          return false;
     }

     private boolean isOperation(String c) {
          if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
               return true;
          } else {
               return false;
          }
     }

     private void Calculate(Stack<Double> stack, String operation) {
          double sce = stack.pop();
          double fir = stack.pop();

          if (operation.equals(""+"")) {
               stack.push(fir + sce);
          } else if (operation.equals(""-"")) {
               stack.push(fir - sce);
          } else if (operation.equals(""*"")) {
               stack.push(fir * sce);
          } else if (operation.equals(""/"")) {
               stack.push(fir / sce);
          }

     }

     private void prefix(ArrayList list, Node node) {
          list.add(node);
          if (node.getLeft() != null) {
               prefix(list, node.getLeft());
          }
          if (node.getRight() != null) {
               prefix(list, node.getRight());
          }
     }

     private void posfix(ArrayList list, Node node) {

          if (node.getLeft() != null) {
               posfix(list, node.getLeft());
          }
          if (node.getRight() != null) {
               posfix(list, node.getRight());
          }
          list.add(node);
     }

     private void infix(ArrayList list, Node node) {

          if (node.getLeft() != null) {
               posfix(list, node.getLeft());
          }
          list.add(node);
          if (node.getRight() != null) {
               posfix(list, node.getRight());
          }

     }
// Build a Binary and Return the Root

     public Node Infix2BT(String infix) {
          String[] charater = infix.split("""");
          charater = Arrays.copyOfRange(charater, 1, charater.length);
          Stack<Node> treeNode = new Stack<Node>();
          for (int counter = 0; counter < charater.length; counter++) {
               if (isCalculator(charater[counter])) {
                    if (isOperation(charater[counter])) {
                         treeNode.push(new Node(null, null, charater[counter]));
                    }
                    else{
                         Node temp=treeNode.pop();
                         temp.setValue( temp.getValue() + charater[counter] );
                    }
               } else if (charater[counter].equals("")"")) {
                    Node right = treeNode.pop();
                    Node mid = treeNode.pop();
                    Node left = treeNode.pop();
                    mid.setLeft(left);
                    mid.setRight(right);
                    treeNode.push(mid);
               } else {
                    continue;
               }
          }
          this.root = treeNode.pop();
          return this.root;
     }

     public Node[] PrintPrefix() {
          if (this.root == null) {
               throw new java.lang.NullPointerException();
          } else {
               ArrayList<Node> array = new ArrayList<Node>();
               prefix(array, this.root);
               Node[] prefix = new Node[array.size()];

               for (int count = 0; count < array.size(); count++) {
                    prefix[count] = array.get(count);
               }
               return prefix;
          }
     }

     public Node[] PrintInfix() {
          if (this.root == null) {
               throw new java.lang.NullPointerException();
          } else {
               ArrayList<Node> array = new ArrayList<Node>();
               infix(array, this.root);
               Node[] infix = new Node[array.size()];

               for (int count = 0; count < array.size(); count++) {
                    infix[count] = array.get(count);
               }
               return infix;
          }
     }

     public Node[] PrintPostfix() {
          if (this.root == null) {
               throw new java.lang.NullPointerException();
          } else {
               ArrayList<Node> array = new ArrayList<Node>();
               posfix(array, this.root);
               Node[] posfix = new Node[array.size()];

               for (int count = 0; count < array.size(); count++) {
                    posfix[count] = array.get(count);
               }
               return posfix;
          }
     }

     public double Evaluation() {
          if (this.root == null) {
               throw new java.lang.NullPointerException();
          } else {
               ArrayList<Node> array = new ArrayList<Node>();
               posfix(array, this.root);
               Stack<Double> storge = new Stack<Double>();
               for (int count = 0; count < array.size(); count++) {
                    if (isOperation(array.get(count).getValue())) {

                         Calculate(storge, array.get(count).getValue());
                    } else {
                         storge.push(Double.parseDouble(array.get(count).getValue()));
                    }
               }

               return storge.pop();
          }
     }
}

@10fa81c00d8be86405ef9889d02a8b28@"
"r04921012","10","0.097","105520","@7e95985440fad3c08ea3a69e2e4f9a0f@//package expression;

import java.util.ArrayList;
import java.util.Stack;

public class Expression{
  
    private Node root;
    public String Ans;
    public static ArrayList<Node> preList = new ArrayList();
    public static ArrayList<Node> postList = new ArrayList();

    // DO NOT MODIFY THIS
    public Expression(){}

    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        int L=infix.length();
        int start = 0;
        int stop = 0;
        Stack<String> st = new Stack();
        Stack<Node> node_st = new Stack();
        
        for (int i=0 ; i<L ; i++){
            char c = infix.charAt(i);
            if (c=='(' ){
                
                start++;
                stop++;
            }
            else if ( c==')'){
                Node m ;
                if (stop==start){
                    Node r = node_st.pop();
                    m = node_st.pop();
                    m.setRight(r);
                }
                else{
                    m = node_st.pop();
                    String r_numstr = infix.substring(start, stop);
                    Node r = new Node(null,null,r_numstr);
                    st.push(r.getValue());
                    m.setRight(r);
                }
                    
                    Node l = node_st.pop();
                    m.setLeft(l);
                    node_st.push(m);
                    String ans = calculate(st.pop(),st.pop(),st.pop());
                    st.push(ans);
                    start = i+1;
                    stop = i+1;
                    //System.out.println(""m=""+m.getValue());
                    //System.out.println(""l=""+l.getValue());
                    //System.out.println(""r=""+m.getRight().getValue());
                    if (i==L-1){
                        root = m;
                        Ans = ans;
                    }
                
            }
            else if (Character.isDigit(c)|| c=='.'){
                
                stop++;
            }
            else{
                
                String numstr;
                if (start==stop){}
                    
                else{
                    numstr = infix.substring(start, stop);
                    //System.out.println(""numstr""+numstr);
                    
                    Node l = new Node(null,null,numstr);
                    node_st.push(l);
                    st.push(l.getValue());
                }
                
                Node m = new Node(null,null,Character.toString(c));    
                node_st.push(m);
                
                st.push(m.getValue());
                start = i+1;
                stop = i+1;
                
            }
            //System.out.println(st.size());
        }
        
        return root;
    }
    
    public String calculate(String r,String op,String l){
        //System.out.println(""l""+l);
        //System.out.println(""op""+op);
        //System.out.println(""r""+r);
        double ans = 0;
        double l_num = Double.parseDouble(l);
        double r_num = Double.parseDouble(r);
        if (op.equals(""+""))
            ans = l_num + r_num;
        else if (op.equals(""-""))
            ans = l_num - r_num;
        else if (op.equals(""*""))
            ans = l_num * r_num;
        else
            ans = l_num / r_num;
        return String.valueOf(ans);
    }

    public Node[] PrintPrefix(){
        
        if (root==null)
            throw new NullPointerException();
        else{
        preRecur(root);
        Node[] prefix = new Node[preList.size()];
        prefix = preList.toArray(prefix);
        
        return prefix; 
        }

    }
    public static void preRecur(Node node){
        preList.add(node);
        if (node.getLeft()==null){}
        else{
            Node left = node.getLeft();
            preRecur(left);
        }
        if (node.getRight()==null){}
        else{
            Node right = node.getRight();
            preRecur(right);
        }
    }
    
    public Node[] PrintPostfix(){
        
        if (root==null)
            throw new NullPointerException();
        else{
        postRecur(root);
        Node[] postfix = new Node[postList.size()];
        postfix = postList.toArray(postfix);
        return postfix;
        }
    }
    public static void postRecur(Node node){

        if (node.getLeft()==null){}
            //postList.add(node);
        else{
            Node left = node.getLeft();
            postRecur(left);
        }
        if (node.getRight()==null){}
            //postList.add(node);
        else{
            Node right = node.getRight();
            postRecur(right);
        }
        postList.add(node);
    }
    public double Evaluation(){
        if (root==null)
            throw new NullPointerException();
        double answer = Double.parseDouble(Ans);
        return answer;
    }
    
    public static void main(String[] args){
        Expression ex = new Expression();
        String input = ""(4+(((4*2)/2)/3))"";
        ex.Infix2BT(input);
        //System.out.println(ex.Evaluation());
        //System.out.println(ex.root.getRight().getValue());
        //for (Node node:ex.PrintPostfix())
            //System.out.print(node.getValue());
    }
}

@7e95985440fad3c08ea3a69e2e4f9a0f@"
"b02611002","0","0.098","105952","@1410383c7ca30615e13aab692c0aa7d8@import java.util.*;

public class Expression{


    boolean DEBUG = false;
    private Node root;
    Stack<Node> prefixStack = new Stack<>();
    Stack<Node> postfixStack = new Stack<>();


    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){



        String[] inputs = infix.split(""(?<=[)(+\\-*/=])|(?=[)(+\\-*/=])""); //如果前或後有+-*/就切開
        //(	4.0	+	(	(	(	4	*	2.0	)	/	2	)	/	3	)	)

        Stack<Node> nodeS = new Stack<>();

        if (DEBUG) {
            for (int i = 0; i < inputs.length; i++) {
                System.out.print(inputs[i]+""\t\t"");
            }
        }

        /* Generate Stack of Node from the String[] */
        for (int i = 0; i < inputs.length; i++) {nodeS.add(new Node(null,null,inputs[i]));}   //size = 17

        /* inspect */ //FIXME ignored cases like ""(10+2-59045)""
        for(int i=0;i<nodeS.size();i++){
            if(nodeS.get(i).getValue().equals("")"")){
                nodeS.get(i-2).setLeft(nodeS.get(i-3));
                nodeS.get(i-2).setRight(nodeS.get(i-1));
                nodeS.remove(i);
                nodeS.remove(i-1);
                nodeS.remove(i-3);
                nodeS.remove(i-4);
                i-=5;
                if(DEBUG) for(int j=0;j<nodeS.size();j++){System.out.print(nodeS.get(j).getValue());}
            }
        }
        assert nodeS.size()==1;
        root = nodeS.get(0);

        return root;
    }

    public Node[] PrintPrefix(){
        prefixStack = new Stack<>();
        TraversalPreorder(root);
        Node[] prefix = new Node[this.prefixStack.size()];
        for(int i=0;i<prefix.length;i++) prefix[i] = this.prefixStack.get(i);
        assert this.prefixStack.size()>1;
        return prefix;
    }
    public Void TraversalPreorder(Node p){
        if (p==null) return null;
        prefixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        TraversalPreorder(p.getLeft());
        TraversalPreorder(p.getRight());
        return null;
    }



    public Node[] PrintPostfix(){
        postfixStack = new Stack<>();
        TraversalPostorder(root);
        Node[] postfix = new Node[this.postfixStack.size()];
        for(int i=0;i<postfix.length;i++) postfix[i] = this.postfixStack.get(i);
        return postfix;
    }
    public Void TraversalPostorder(Node p){
        if (p==null) return null;
        TraversalPostorder(p.getLeft());
        TraversalPostorder(p.getRight());
        postfixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        return null;
    }



    public double Evaluation(){
        double answer = 0;
        if(postfixStack.size()==0) return 0.0;
        for(int i=0;i<postfixStack.size();i++){
            if(postfixStack.get(i).getValue().equals(""+"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1+n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""-"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1-n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""*"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1*n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""/"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1/n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }

        }

        answer = Double.parseDouble(postfixStack.get(0).getValue());
        return answer;
    }
}

@1410383c7ca30615e13aab692c0aa7d8@"
"b02611002","0","0.098","105952","@bbd68aba614b768203649d182d3a598e@import java.util.*;

public class Expression{


    boolean DEBUG = false;
    private Node root;
//    Stack<Node> prefixStack = new Stack<>();
//    Stack<Node> postfixStack = new Stack<>();
    List<Node> prefixStack = new LinkedList<>();
    List<Node> postfixStack = new LinkedList<>();


    // DO NOT MODIFY THIS
    public Expression(){} //FIXME

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){



        String[] inputs = infix.split(""(?<=[)(+\\-*/=])|(?=[)(+\\-*/=])""); //如果前或後有+-*/就切開
        //(	4.0	+	(	(	(	4	*	2.0	)	/	2	)	/	3	)	)

//        Stack<Node> nodeS = new Stack<>();
        List<Node> nodeS = new LinkedList<>();

        if (DEBUG) {
            for (int i = 0; i < inputs.length; i++) {
                System.out.print(inputs[i]+""\t\t"");
            }
        }

        /* Generate Stack of Node from the String[] */
        for (int i = 0; i < inputs.length; i++) {nodeS.add(new Node(null,null,inputs[i]));}   //size = 17

        /* inspect */ //FIXME ignored cases like ""(10+2-59045)""
        for(int i=0;i<nodeS.size();i++){
            if(nodeS.get(i).getValue().equals("")"")){
                nodeS.get(i-2).setLeft(nodeS.get(i-3));
                nodeS.get(i-2).setRight(nodeS.get(i-1));
                nodeS.remove(i);
                nodeS.remove(i-1);
                nodeS.remove(i-3);
                nodeS.remove(i-4);
                i-=5;
                if(DEBUG) for(int j=0;j<nodeS.size();j++){System.out.print(nodeS.get(j).getValue());}
            }
        }
        assert nodeS.size()==1;
        root = nodeS.get(0);

        return root;
    }

    public Node[] PrintPrefix(){
        prefixStack = new Stack<>();
        TraversalPreorder(root);
        Node[] prefix = new Node[this.prefixStack.size()];
        for(int i=0;i<prefix.length;i++) prefix[i] = this.prefixStack.get(i);
        assert this.prefixStack.size()>1;
        return prefix;
    }
    public Void TraversalPreorder(Node p){
        if (p==null) return null;
        prefixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        TraversalPreorder(p.getLeft());
        TraversalPreorder(p.getRight());
        return null;
    }



    public Node[] PrintPostfix(){
        postfixStack = new Stack<>();
        TraversalPostorder(root);
        Node[] postfix = new Node[this.postfixStack.size()];
        for(int i=0;i<postfix.length;i++) postfix[i] = this.postfixStack.get(i);
        return postfix;
    }
    public Void TraversalPostorder(Node p){
        if (p==null) return null;
        TraversalPostorder(p.getLeft());
        TraversalPostorder(p.getRight());
        postfixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        return null;
    }



    public double Evaluation(){
        double answer = 0;
        if(postfixStack.size()==0) return 0.0;
        for(int i=0;i<postfixStack.size();i++){
            if(postfixStack.get(i).getValue().equals(""+"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1+n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""-"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1-n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""*"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1*n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""/"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1/n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }

        }

        answer = Double.parseDouble(postfixStack.get(0).getValue());
        return answer;
    }
}

@bbd68aba614b768203649d182d3a598e@"
"b02611002","7","0.92","105616","@b41ed95956fe154ad708224f7d9c9eda@import java.util.*;

public class Expression{


    boolean DEBUG = false;
    private Node root;
//    Stack<Node> prefixStack = new Stack<>();
//    Stack<Node> postfixStack = new Stack<>();
    List<Node> prefixStack = new LinkedList<>();
    List<Node> postfixStack = new LinkedList<>();


    // DO NOT MODIFY THIS
    public Expression(){} //FIXME

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){



        String[] inputs = infix.split(""(?<=[)(+\\-*/=])|(?=[)(+\\-*/=])""); //如果前或後有+-*/就切開
        //(	4.0	+	(	(	(	4	*	2.0	)	/	2	)	/	3	)	)

//        Stack<Node> nodeS = new Stack<>();
        List<Node> nodeS = new LinkedList<>();

        if (DEBUG) {
            for (int i = 0; i < inputs.length; i++) {
                System.out.print(inputs[i]+""\t\t"");
            }
        }

        /* Generate Stack of Node from the String[] */
        for (int i = 0; i < inputs.length; i++) {nodeS.add(new Node(null,null,inputs[i]));}   //size = 17

        /* inspect */ //FIXME ignored cases like ""(10+2-59045)""
        for(int i=0;i<nodeS.size();i++){
            if(nodeS.get(i).getValue().equals("")"")){
                nodeS.get(i-2).setLeft(nodeS.get(i-3));
                nodeS.get(i-2).setRight(nodeS.get(i-1));
                nodeS.remove(i);
                nodeS.remove(i-1);
                nodeS.remove(i-3);
                nodeS.remove(i-4);
                i-=5;
                if(DEBUG) for(int j=0;j<nodeS.size();j++){System.out.print(nodeS.get(j).getValue());}
            }
        }
        assert nodeS.size()==1;
        root = nodeS.get(0);

        return root;
    }

    public Node[] PrintPrefix(){
//        prefixStack = new Stack<>();
        prefixStack = new LinkedList<>();
        TraversalPreorder(root);
        Node[] prefix = new Node[this.prefixStack.size()];
        for(int i=0;i<prefix.length;i++) prefix[i] = this.prefixStack.get(i);
        assert this.prefixStack.size()>1;
        return prefix;
    }
    public Void TraversalPreorder(Node p){
        if (p==null) return null;
        prefixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        TraversalPreorder(p.getLeft());
        TraversalPreorder(p.getRight());
        return null;
    }



    public Node[] PrintPostfix(){
//        postfixStack = new Stack<>();
        postfixStack = new LinkedList<>();
        TraversalPostorder(root);
        Node[] postfix = new Node[this.postfixStack.size()];
        for(int i=0;i<postfix.length;i++) postfix[i] = this.postfixStack.get(i);
        return postfix;
    }
    public Void TraversalPostorder(Node p){
        if (p==null) return null;
        TraversalPostorder(p.getLeft());
        TraversalPostorder(p.getRight());
        postfixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        return null;
    }



    public double Evaluation(){
        double answer = 0;
        if(postfixStack.size()==0) return 0.0;
        for(int i=0;i<postfixStack.size();i++){
            if(postfixStack.get(i).getValue().equals(""+"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1+n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""-"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1-n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""*"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1*n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""/"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1/n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }

        }

        answer = Double.parseDouble(postfixStack.get(0).getValue());
        return answer;
    }
}

@b41ed95956fe154ad708224f7d9c9eda@"
"r04631034","10","0.099","105808","@9d95b678529ca49b28d47f6f8e25dd62@
import java.util.*;

public class Expression {

          private Node root;

          // DO NOT MODIFY THIS
          public Expression() {
          }

          private boolean isCalculator(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else if (java.lang.Character.isDigit(c.charAt(0))) {
                              return true;
                    }
                    return false;
          }

          private boolean isOperation(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else {
                              return false;
                    }
          }

          private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }

          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }

          private void posfix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    list.add(node);
          }

                    private void infix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    list.add(node);
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    
          }
// Build a Binary and Return the Root
          public Node Infix2BT(String infix) {
                    String[] charater = infix.split("""");
                    charater = Arrays.copyOfRange(charater, 1, charater.length);
                    Stack<Node> treeNode = new Stack<Node>();
          for (int counter = 0; counter < charater.length; counter++) {
               if (charater[counter].equals(""("")) {
                    continue;
               } else if (charater[counter].equals("")"")) {
                    Node right = treeNode.pop();
                    Node mid = treeNode.pop();
                    Node left = treeNode.pop();
                    mid.setLeft(left);
                    mid.setRight(right);
                    treeNode.push(mid);
               } else if (isOperation(charater[counter])) {
                    treeNode.push(new Node(null, null, charater[counter]));
               } else {
                    if (treeNode.isEmpty()) {
                         treeNode.push(new Node(null, null, charater[counter]));
                    } else {
                         Node temp = treeNode.pop();
                         if (isOperation(temp.getValue())) {
                              treeNode.push(temp);
                              treeNode.push(new Node(null, null, charater[counter]));
                         } else {
                              temp.setValue(temp.getValue() + charater[counter]);
                              treeNode.push(temp);
                         }
                    }
               }

          }
                    
                    this.root = treeNode.pop();
                    return this.root;
          }

          public Node[] PrintPrefix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              prefix(array, this.root);
                              Node[] prefix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        prefix[count] = array.get(count);
                              }
                              return prefix;
                    }
          }
          
          public Node[] PrintInfix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              infix(array, this.root);
                              Node[] infix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        infix[count] = array.get(count);
                              }
                              return infix;
                    }
          }
          
          public Node[] PrintPostfix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Node[] posfix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        posfix[count] = array.get(count);
                              }
                              return posfix;
                    }
          }

          public double Evaluation() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Stack<Double> storge = new Stack<Double>();
                              for (int count = 0; count < array.size(); count++) {
                                        if (isOperation(array.get(count).getValue())) {

                                                  Calculate(storge, array.get(count).getValue());
                                        } else {
                                                  storge.push(Double.parseDouble(array.get(count).getValue()));
                                        }
                              }

                              return storge.pop();
                    }
          }
}



@9d95b678529ca49b28d47f6f8e25dd62@"
"b02611002","7","0.93","105648","@dd3ff22165aaf69c2bc1d3568d06d2d4@import java.util.*;

public class Expression{


    boolean DEBUG = false;
    private Node root;
    //    Stack<Node> prefixStack = new Stack<>();
//    Stack<Node> postfixStack = new Stack<>();
    List<Node> prefixStack = new LinkedList<>();
    List<Node> postfixStack = new LinkedList<>();


    // DO NOT MODIFY THIS
    public Expression(){} //FIXME

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){


        if(infix.equals("""")) return null;

        String[] inputs = infix.split(""(?<=[)(+\\-*/=])|(?=[)(+\\-*/=])""); //如果前或後有+-*/就切開
        //(	4.0	+	(	(	(	4	*	2.0	)	/	2	)	/	3	)	)

//        Stack<Node> nodeS = new Stack<>();
        List<Node> nodeS = new LinkedList<>();

        if (DEBUG) {
            for (int i = 0; i < inputs.length; i++) {
                System.out.print(inputs[i]+""\t\t"");
            }
        }

        /* Generate Stack of Node from the String[] */
        for (int i = 0; i < inputs.length; i++) {nodeS.add(new Node(null,null,inputs[i]));}   //size = 17

        /* inspect */ //FIXME ignored cases like ""(10+2-59045)""
        for(int i=0;i<nodeS.size();i++){
            if(nodeS.get(i).getValue().equals("")"")){
                nodeS.get(i-2).setLeft(nodeS.get(i-3));
                nodeS.get(i-2).setRight(nodeS.get(i-1));
                nodeS.remove(i);
                nodeS.remove(i-1);
                nodeS.remove(i-3);
                nodeS.remove(i-4);
                i-=5;
                if(DEBUG) for(int j=0;j<nodeS.size();j++){System.out.print(nodeS.get(j).getValue());}
            }
        }
        assert nodeS.size()==1;
        root = nodeS.get(0);

        return root;
    }

    public Node[] PrintPrefix(){
//        prefixStack = new Stack<>();
        prefixStack = new LinkedList<>();
        TraversalPreorder(root);
        Node[] prefix = new Node[this.prefixStack.size()];
        for(int i=0;i<prefix.length;i++) prefix[i] = this.prefixStack.get(i);
        return prefix;
    }
    public Void TraversalPreorder(Node p){
        if (p==null) return null;
        prefixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        TraversalPreorder(p.getLeft());
        TraversalPreorder(p.getRight());
        return null;
    }



    public Node[] PrintPostfix(){
//        postfixStack = new Stack<>();
        postfixStack = new LinkedList<>();
        TraversalPostorder(root);
        Node[] postfix = new Node[this.postfixStack.size()];
        for(int i=0;i<postfix.length;i++) postfix[i] = this.postfixStack.get(i);
        return postfix;
    }
    public Void TraversalPostorder(Node p){
        if (p==null) return null;
        TraversalPostorder(p.getLeft());
        TraversalPostorder(p.getRight());
        postfixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        return null;
    }



    public double Evaluation(){
        double answer = 0;
        if(postfixStack.size()==0) return 0.0;
        for(int i=0;i<postfixStack.size();i++){
            if(postfixStack.get(i).getValue().equals(""+"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1+n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""-"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1-n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""*"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1*n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""/"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1/n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }

        }

        answer = Double.parseDouble(postfixStack.get(0).getValue());
        return answer;
    }
}

@dd3ff22165aaf69c2bc1d3568d06d2d4@"
"r04945022","1","0.09","100944","@6e53e3af207ca6af157efea3d164caa9@
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '-':
                case '+':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                    }
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPrefixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    
    public void PrintPrefixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPrefixRecusive(p, root.getLeft());
        PrintPrefixRecusive(p, root.getRight());
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> postfix = new ArrayList<Node>();
        PrintPostfixRecusive(postfix, root);
        return postfix.toArray(new Node[postfix.size()]);
    }
    public void PrintPostfixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPostfixRecusive(p, root.getLeft());
        PrintPostfixRecusive(p, root.getRight());
        p.add(root);
    }
    

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] eva = this.PrintPostfix();
        Stack<Double> evalue = new Stack<Double>();
        for(Node n:eva){
            String in = n.getValue();
            if(in.equals(""+"")){
                evalue.push(evalue.pop()+evalue.pop());
            } else if(in.equals(""-"")){
                evalue.push(-evalue.pop()+evalue.pop());
            } else if(in.equals(""*"")){
                evalue.push(evalue.pop()*evalue.pop());
            } else if(in.equals(""/"")){
                evalue.push(1/evalue.pop()*evalue.pop());
            } else {
                evalue.push(Double.parseDouble(in));
            }
            
        }
//        double answer = 0;
        return evalue.pop();
    }
}

@6e53e3af207ca6af157efea3d164caa9@"
"r04921115","10","0.099","105888","@bb14f04fc8ef71d11c8b55eb750e446a@import java.util.ArrayList;

public class Expression{
  
    private Node root;
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    	String temp2 = """";
		String[] infixarr;
    	String[] number;
    	String[] operator;
    	Node op_left;
    	Node op_right;
		for(int i = 0 ; i< infix.length();i++){
    		if(infix.charAt(i)=='(' || infix.charAt(i)==')' || infix.charAt(i)=='+' || infix.charAt(i)=='-' || infix.charAt(i)=='*' || infix.charAt(i)=='/'){
    			temp2 = temp2+ infix.charAt(i)+"""";
    			temp2 = temp2+"" "";
    		}else if(i<infix.length()-1){
    			if(Character.isDigit(infix.charAt(i+1))==false && infix.charAt(i+1)!='.'){
    				temp2 = temp2+ infix.charAt(i)+"""";
    				temp2 = temp2+"" "";
    			}else{
    				temp2 = temp2+ infix.charAt(i)+"""";
    			}
    		}
    	}
		infixarr = temp2.split("" "");
    	Stack<Node> stack_node = new Stack<Node>();
    	for(int i = 0 ; i< infixarr.length;i++){
    		if(infixarr[i].equals("")"")){
    			op_right = stack_node.pop();
    			root = stack_node.pop();
    			//System.out.println(""final op:""+op.getValue());
    			op_left = stack_node.pop();
    			stack_node.pop(); //pop ""(""
    			
    			root.setRight(op_right);
    			root.setLeft(op_left);
    			stack_node.push(root);
    			
    		}else{
    			Node node = new Node(null, null, infixarr[i]);
    			stack_node.push(node);
    		}
    	}
    	return root;
    }
    
    public Node[] PrintPrefix(){
        Node[] prefix =null;
        ArrayList<Node> prefixarrlist = new ArrayList<Node>();
        if(root==null){throw new NullPointerException(); };
        preOrder(root, prefixarrlist);
        //prefix[0] = root;
        prefix = new Node[prefixarrlist.size()];// important!! or you will have null pointer error!!
        for(int i = 0 ; i <prefixarrlist.size();i++){
        	prefix[i] = prefixarrlist.get(i);
        }    
        return prefix;
    }
    private void preOrder(Node v, ArrayList<Node> n){
    	if(v==null) return;
    	n.add(v);
    	preOrder(v.getLeft(),n);
    	preOrder(v.getRight(),n);
    }
    
    public Node[] PrintPostfix(){	
        Node[] postfix = null;
        ArrayList<Node> postfixarrlist = new ArrayList<Node>();
        if(root==null){throw new NullPointerException(); };
        postOrder(root, postfixarrlist);
        //prefix[0] = root;
        postfix = new Node[postfixarrlist.size()]; // important!! or you will have null pointer error!!
        for(int i = 0 ; i <postfixarrlist.size();i++){
        	postfix[i] = postfixarrlist.get(i);
        }    
        return postfix;
    }
    private void postOrder(Node v, ArrayList<Node> n){
    	if(v==null) return;
    	postOrder(v.getLeft(),n);
    	postOrder(v.getRight(),n);
    	n.add(v);
    }
    
    public double Evaluation(){
    	if(root==null){throw new NullPointerException(); };
    	double answer = 0;
    	double double1 = 0;
    	double double2 = 0;
    	double double_temp = 0;
        Node[] temp = PrintPostfix();
        Stack<String> stack_post = new Stack<String>();
        for(int i = 0 ; i<temp.length; i++){
        	stack_post.push(temp[i].getValue());
        	if(stack_post.peek().equals(""*"")){
				stack_post.pop();
				double1 = Double.parseDouble(stack_post.pop());
				double2 = Double.parseDouble(stack_post.pop());
				double_temp = double2*double1;
				stack_post.push(double_temp+"""");
			}if(stack_post.peek().equals(""/"")){
				stack_post.pop();
				double1 = Double.parseDouble(stack_post.pop());
				double2 = Double.parseDouble(stack_post.pop());
				double_temp = double2/double1;
				stack_post.push(double_temp+"""");
			}if(stack_post.peek().equals(""+"")){
				stack_post.pop();
				double1 = Double.parseDouble(stack_post.pop());
				double2 = Double.parseDouble(stack_post.pop());
				double_temp = double2+double1;
				stack_post.push(double_temp+"""");
			}if(stack_post.peek().equals(""-"")){
				stack_post.pop();
				double1 = Double.parseDouble(stack_post.pop());
				double2 = Double.parseDouble(stack_post.pop());
				double_temp = double2-double1;
				stack_post.push(double_temp+"""");
			}
        		
        }
        answer = double_temp;
        return answer;
    }
}

@bb14f04fc8ef71d11c8b55eb750e446a@"
"b02611002","8","0.96","105520","@8f7b4b9c5af72931792888034845cf99@import java.util.*;

public class Expression{


    boolean DEBUG = false;
    private Node root;
    //    Stack<Node> prefixStack = new Stack<>();
//    Stack<Node> postfixStack = new Stack<>();
    List<Node> prefixStack = new LinkedList<>();
    List<Node> postfixStack = new LinkedList<>();


    // DO NOT MODIFY THIS
    public Expression(){} //FIXME

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){


        if(infix.equals("""")) return null;

        String[] inputs = infix.split(""(?<=[)(+\\-*/=])|(?=[)(+\\-*/=])""); //如果前或後有+-*/就切開
        //(	4.0	+	(	(	(	4	*	2.0	)	/	2	)	/	3	)	)

//        Stack<Node> nodeS = new Stack<>();
        List<Node> nodeS = new LinkedList<>();

        if (DEBUG) {
            for (int i = 0; i < inputs.length; i++) {
                System.out.print(inputs[i]+""\t\t"");
            }
        }

        /* Generate Stack of Node from the String[] */
        for (int i = 0; i < inputs.length; i++) {nodeS.add(new Node(null,null,inputs[i]));}   //size = 17

        /* inspect */ //FIXME ignored cases like ""(10+2-59045)""
        for(int i=0;i<nodeS.size();i++){
            if(nodeS.get(i).getValue().equals("")"")){
                nodeS.get(i-2).setLeft(nodeS.get(i-3));
                nodeS.get(i-2).setRight(nodeS.get(i-1));
                nodeS.remove(i);
                nodeS.remove(i-1);
                nodeS.remove(i-3);
                nodeS.remove(i-4);
                i-=5;
                if(DEBUG) for(int j=0;j<nodeS.size();j++){System.out.print(nodeS.get(j).getValue());}
            }
        }
        assert nodeS.size()==1;
        root = nodeS.get(0);

        return root;
    }

    public Node[] PrintPrefix() throws NullPointerException {
//        prefixStack = new Stack<>();
        if(root.equals(null)) throw new NullPointerException();
        prefixStack = new LinkedList<>();
        TraversalPreorder(root);
        Node[] prefix = new Node[this.prefixStack.size()];
        for(int i=0;i<prefix.length;i++) prefix[i] = this.prefixStack.get(i);
        return prefix;
    }
    public Void TraversalPreorder(Node p){
        if (p==null) return null;
        prefixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        TraversalPreorder(p.getLeft());
        TraversalPreorder(p.getRight());
        return null;
    }



    public Node[] PrintPostfix() throws NullPointerException {
//        postfixStack = new Stack<>();
        if(root.equals(null)) throw new NullPointerException();
        postfixStack = new LinkedList<>();
        TraversalPostorder(root);
        Node[] postfix = new Node[this.postfixStack.size()];
        for(int i=0;i<postfix.length;i++) postfix[i] = this.postfixStack.get(i);
        return postfix;
    }
    public Void TraversalPostorder(Node p){
        if (p==null) return null;
        TraversalPostorder(p.getLeft());
        TraversalPostorder(p.getRight());
        postfixStack.add(p);
        if(DEBUG) System.out.print(p.getValue()+""\t"");
        return null;
    }



    public double Evaluation() throws NullPointerException {
        if(root.equals(null)) throw new NullPointerException();
        double answer = 0;
        if(postfixStack.size()==0) return 0.0;
        for(int i=0;i<postfixStack.size();i++){
            if(postfixStack.get(i).getValue().equals(""+"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1+n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""-"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1-n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""*"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1*n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }else if(postfixStack.get(i).getValue().equals(""/"")){
                double n1 = Double.parseDouble(postfixStack.get(i-2).getValue());
                double n2 = Double.parseDouble(postfixStack.get(i-1).getValue());
                Node newNode = new Node(null,null,String.valueOf(n1/n2));
                postfixStack.remove(i);
                postfixStack.remove(i-1);
                postfixStack.remove(i-2);
                postfixStack.add(i-2,newNode);
                i-=3;
            }

        }

        answer = Double.parseDouble(postfixStack.get(0).getValue());
        return answer;
    }
}

@8f7b4b9c5af72931792888034845cf99@"
"r04945022","5","0.78","105520","@383d076c8ce7168b4dac3814626335fe@
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '-':
                case '+':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPrefixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    
    public void PrintPrefixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPrefixRecusive(p, root.getLeft());
        PrintPrefixRecusive(p, root.getRight());
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> postfix = new ArrayList<Node>();
        PrintPostfixRecusive(postfix, root);
        return postfix.toArray(new Node[postfix.size()]);
    }
    public void PrintPostfixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPostfixRecusive(p, root.getLeft());
        PrintPostfixRecusive(p, root.getRight());
        p.add(root);
    }
    

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] eva = this.PrintPostfix();
        Stack<Double> evalue = new Stack<Double>();
        for(Node n:eva){
            String in = n.getValue();
            if(in.equals(""+"")){
                evalue.push(evalue.pop()+evalue.pop());
            } else if(in.equals(""-"")){
                evalue.push(-evalue.pop()+evalue.pop());
            } else if(in.equals(""*"")){
                evalue.push(evalue.pop()*evalue.pop());
            } else if(in.equals(""/"")){
                evalue.push(1/evalue.pop()*evalue.pop());
            } else {
                evalue.push(Double.parseDouble(in));
            }
            
        }
//        double answer = 0;
        return evalue.pop();
    }
}

@383d076c8ce7168b4dac3814626335fe@"
"b02611016","0","0.93","105648","@cc4886c61d95a4f4b1b3c78391639207@vals.push(String.valueOf(answer));
@cc4886c61d95a4f4b1b3c78391639207@"
"r04945039","10","0.096","105856","@babf0db956dadac96426c4e00ae1baac@ import java.util.ArrayList;
public class Expression{
  
    private Node root;
    private int Size;
    private Node[] pre;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
      //  Node x=new Node(null,null,null);
        if(infix ==null){
            throw new java.lang.NullPointerException();
        }

        Stack<Node> stack = new Stack<Node>();
        ArrayList<String> splited = new ArrayList<String>();
        String Instrin="""";
        for(int i=0;i<infix.length();i++){
            if(infix.charAt(i)=='(' || infix.charAt(i)==')' ){
                if(!Instrin.equals("""")){
                    splited.add(Instrin);
                    Instrin="""";
                }
                splited.add(String.valueOf(infix.charAt(i)));
            }else if(infix.charAt(i)=='+' || infix.charAt(i)=='-' || infix.charAt(i)=='*' || infix.charAt(i)=='/'){
                if(!Instrin.equals("""")){
                    splited.add(Instrin);
                    Instrin="""";
                }
                splited.add(String.valueOf(infix.charAt(i)));
            }else{
                Instrin =Instrin +infix.charAt(i);
            }
        }

        for(int i=0;i<splited.size();i++){    
            String s = splited.get(i);
            
           if (!s.equals("")"") && !s.equals(""("")) {
                stack.push(new Node(null,null,s));
                Size++;
  } 
           else if (s.equals("")"")) {
               Node rightNode=stack.pop();
               Node subRoot=stack.pop();
               Node leftNode=stack.pop();
               stack.push(new Node(leftNode,rightNode,subRoot.getValue()));                               
            }
        }
        root=stack.pop();
        return root;
    }
    ArrayList<Node> arrli = new ArrayList<Node>();
public  ArrayList<Node> preorder(Node root){
    
    if(root!=null){
        arrli.add(root);
        preorder(root.getLeft());
        preorder(root.getRight());
    }
    return arrli;
}
    public Node[] PrintPrefix(){
        if( root==null){
            throw new java.lang.NullPointerException();
        }
        Node[] prefix=new Node[Size];
        Node node = root;
      ArrayList<Node> arr= preorder(node);

       for(int i=0;i<Size;i++){
          prefix[i]= arr.get(i);
       }
        //prefix[0]=new Node(null,null,""A"");
        return prefix;
    }
      ArrayList<Node> arrlipo = new ArrayList<Node>();
public  ArrayList<Node> postorder(Node root){
    
    if(root!=null){
        
        postorder(root.getLeft());
        postorder(root.getRight());
        arrlipo.add(root);
    }
    
    return arrlipo;
}
    public Node[] PrintPostfix(){
        if( root==null){
            throw new java.lang.NullPointerException();
        }
        Node[] postfix = new Node[Size];
        Node node = root;
      ArrayList<Node> arr= postorder(node);

       for(int i=0;i<Size;i++){
          postfix[i]= arr.get(i);
       }        
        return postfix;
    }

    public double Evaluation(){
        if( root==null){
            throw new java.lang.NullPointerException();
        }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Double[] Num = new Double[2];
        Stack<String> stack = new Stack<String>();
        for(int i=0;i<postfix.length;i++){
            if(!postfix[i].getValue().equals(""+"") && !postfix[i].getValue().equals(""-"") && !postfix[i].getValue().equals(""*"") && !postfix[i].getValue().equals(""/"")){
                stack.push(postfix[i].getValue());
            }
            else{
                 Num[0] =Double.parseDouble((String) stack.pop());
                    Num[1]= Double.parseDouble((String) stack.pop());
                if(postfix[i].getValue().equals(""+"")){
                  answer = Num[1] + Num[0];
                    stack.push(String.valueOf(answer));
                }
                else if(postfix[i].getValue().equals(""-"")){
                    answer = Num[1] - Num[0];
                    stack.push(String.valueOf(answer));
                }
                else if(postfix[i].getValue().equals(""*"")){
                    answer = Num[1] * Num[0];
                    stack.push(String.valueOf(answer));
                }
                else{
                    answer = Num[1] / Num[0];
                    stack.push(String.valueOf(answer));
                }
            }
                
        }
        
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
        String input = ""(12/12)"";
Expression exp = new Expression();
Node root=exp.Infix2BT(input);

//System.out.print(root.getValue());
Node[] A =exp.PrintPrefix();
for(int i=0;i<A.length;i++){
    System.out.print(A[i].getValue());
}
System.out.println();
Node[]B =exp.PrintPostfix();
for(int i=0;i<B.length;i++){
    System.out.print(B[i].getValue());
}
System.out.println();
   System.out.print(exp.Evaluation());
}
        


        
    }


@babf0db956dadac96426c4e00ae1baac@"
"b02611016","0","0.78","105520","@f026c0956c54ba0b344913a2e6516564@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){
                 //System.out.println(vals.peek().getValue());   
                Node temp_node=new Node(vals.pop(),cal.pop(),ops.pop());
                cal.push(temp_node);
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
       //System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(String infix){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
        String num=null;
        String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                answer=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                answer=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                answer=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                answer=y/x;}
                ops.pop();
                vals.push(String.valueOf(answer));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                answer=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                answer=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                answer=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                answer=y/x;}
                vals.push(String.valueOf(answer));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      
  
        
        Double total=Double.parseDouble(String.valueOf(vals.peek()));
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(4+(((4*2)/2)/3))"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation(test);
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}
@f026c0956c54ba0b344913a2e6516564@"
"b02611016","0","0.78","105520","@7b6b9996a34531a051ef01944376cd58@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){
                 //System.out.println(vals.peek().getValue());   
                Node temp_node=new Node(vals.pop(),cal.pop(),ops.pop());
                cal.push(temp_node);
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
       //System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(String infix){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      
  
       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(4+(((4*2)/2)/3))"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation(test);
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}
@7b6b9996a34531a051ef01944376cd58@"
"b03106003","5","0.89","105904","@09b48fd3c83843eee26275b2d669f26b@
import java.util.NoSuchElementException;

class Tree{
    Node root;
    Tree(){
        root = new Node(null,null,""0"");
    }

}

public class Expression {
  
    private Node root;
    private Stack<String> st;
    private Stack<String> op;
    private Stack<Tree> trees;
    private double ans;
    private int howmany = 0;
    
    private void Do(){
        String temp = new String();
        Tree newtree = new Tree();
        Tree R = new Tree();
        Tree L = new Tree();
        try{
            if(st.peek()!= ""tree""){
                temp = st.pop();
            R.root.setValue(temp);
            }else{
                st.pop();
                R = trees.pop();
            }
            

        if(st.peek()!= ""tree""){
                temp = st.pop();
            L.root.setValue(temp);
            }else{
                st.pop();
                L = trees.pop();
            }
        //System.out.println(right);
        //System.out.println(left);
        String s = op.pop();
        newtree.root.setValue(s);
        newtree.root.setRight(R.root);
        newtree.root.setLeft(L.root);
        trees.push(newtree);
        st.push(""tree"");
        }catch(NoSuchElementException ex){
        
        }
    } 

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String data[] = infix.split("""");
        st = new Stack<String>();
        op = new Stack<String>();
        trees = new Stack<Tree>();
        String temp = new String();
        String s = ""speace"";
        for(int i = 0; i<data.length; i++){
            switch(data[i]){
                case ""/0"":
                    break;
                case ""+"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""-"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""*"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""/"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""("":
                    break;
                case "")"":
                    Do();
                    break;
                default:
                        temp = data[i];
                        howmany++;
                        while(data[i+1].equals(""1"")|| data[i+1].equals(""2"") ||data[i+1].equals(""3"")
                                || data[i+1].equals(""4"")|| data[i+1].equals(""5"")|| data[i+1].equals(""6"")
                                || data[i+1].equals(""7"")|| data[i+1].equals(""8"")|| data[i+1].equals(""9"")
                                || data[i+1].equals(""0"")|| data[i+1].equals("".""))
                        {
                            i++;
                            temp = temp + data[i];
                            System.out.print(i);
                        }                        
                            st.push(temp);
                        
            } 
        }
        root = trees.peek().root;
        return root;
    }

    public Node[] PrintPrefix()throws NullPointerException{
        Node[] prefix = new Node[howmany];
        int index = 0;
        Pre(prefix,root,index);
        return prefix;
    }
    private int Pre(Node[] nodes, Node n, int index)throws NullPointerException{
        nodes[index] = n;
        index ++;
        if(n.getLeft() != null)
            index = Pre(nodes, n.getLeft(), index);
        if(n.getRight() != null)
            index = Pre(nodes, n.getRight(), index);
        return index;
    }
  
    public Node[] PrintPostfix()throws NullPointerException{
        Node[] prefix = new Node[howmany];
        int index = 0;
        Pos(prefix,root,index);
        return prefix;
    }
    private int Pos(Node[] nodes, Node n, int index)throws NullPointerException{
        if(n.getLeft() != null)
            index = Pos(nodes, n.getLeft(), index);
        if(n.getRight() != null)
            index = Pos(nodes, n.getRight(), index);
        nodes[index] = n;
        index ++;
        return index;
    }

    public double Evaluation()throws NullPointerException{
        double answer = 0;
        answer = eva(root);
        return answer;
    }
    private double eva(Node n)throws NullPointerException{
        String s = n.getValue();
        double answer = 0;
        switch(s){
            case ""+"":
                    answer = eva(n.getLeft())+ eva(n.getRight());
                    break;
                case ""-"":
                    answer = eva(n.getLeft())- eva(n.getRight());
                    break;
                case ""*"":
                    answer = eva(n.getLeft())* eva(n.getRight());
                    break;
                case ""/"":
                    answer = eva(n.getLeft())/ eva(n.getRight());
                    break;
                default: 
                    answer = Double.parseDouble(n.getValue());
        }

        return answer;
    }
    
    public static void main(String[] args){
        String s = args[0];
        Expression e = new Expression();
        e.Infix2BT(s);
        Node[] n;
        n = e.PrintPrefix();
        for(int i = 0; i<n.length; i++){
            System.out.print(n[i].getValue());
        }
        System.out.println();
        n = e.PrintPostfix();
        for(int i = 0; i<n.length; i++){
            System.out.print(n[i].getValue());
        }
        System.out.print(e.Evaluation());
    }
}

@09b48fd3c83843eee26275b2d669f26b@"
"b03106003","9","0.9","105920","@c7dff09304ea090025aa69432affd382@import java.util.NoSuchElementException;

class Tree{
    Node root;
    Tree(){
        root = new Node(null,null,""0"");
    }

}

public class Expression {
  
    private Node root;
    private Stack<String> st;
    private Stack<String> op;
    private Stack<Tree> trees;
    private double ans;
    private int howmany = 0;
    
    private void Do(){
        String temp = new String();
        Tree newtree = new Tree();
        Tree R = new Tree();
        Tree L = new Tree();
        try{
            if(st.peek()!= ""tree""){
                temp = st.pop();
            R.root.setValue(temp);
            }else{
                st.pop();
                R = trees.pop();
            }
            

        if(st.peek()!= ""tree""){
                temp = st.pop();
            L.root.setValue(temp);
            }else{
                st.pop();
                L = trees.pop();
            }
        //System.out.println(right);
        //System.out.println(left);
        String s = op.pop();
        newtree.root.setValue(s);
        newtree.root.setRight(R.root);
        newtree.root.setLeft(L.root);
        trees.push(newtree);
        st.push(""tree"");
        }catch(NoSuchElementException ex){
        
        }
    } 

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String data[] = infix.split("""");
        st = new Stack<String>();
        op = new Stack<String>();
        trees = new Stack<Tree>();
        String temp = new String();
        String s = ""speace"";
        for(int i = 0; i<data.length; i++){
            switch(data[i]){
                case ""/0"":
                    break;
                case ""+"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""-"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""*"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""/"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""("":
                    break;
                case "")"":
                    Do();
                    break;
                default:
                        temp = data[i];
                        howmany++;
                        while(data[i+1].equals(""1"")|| data[i+1].equals(""2"") ||data[i+1].equals(""3"")
                                || data[i+1].equals(""4"")|| data[i+1].equals(""5"")|| data[i+1].equals(""6"")
                                || data[i+1].equals(""7"")|| data[i+1].equals(""8"")|| data[i+1].equals(""9"")
                                || data[i+1].equals(""0"")|| data[i+1].equals("".""))
                        {
                            i++;
                            temp = temp + data[i];
                            //System.out.print(i);
                        }                        
                            st.push(temp);                        
            } 
        }
        root = trees.peek().root;
        return root;
    }

    public Node[] PrintPrefix()throws NullPointerException{
        Node[] prefix = new Node[howmany];
        int index = 0;
        Pre(prefix,root,index);
        return prefix;
    }
    private int Pre(Node[] nodes, Node n, int index)throws NullPointerException{
        nodes[index] = n;
        index ++;
        if(n.getLeft() != null)
            index = Pre(nodes, n.getLeft(), index);
        if(n.getRight() != null)
            index = Pre(nodes, n.getRight(), index);
        return index;
    }
  
    public Node[] PrintPostfix()throws NullPointerException{
        Node[] prefix = new Node[howmany];
        int index = 0;
        Pos(prefix,root,index);
        return prefix;
    }
    private int Pos(Node[] nodes, Node n, int index)throws NullPointerException{
        if(n.getLeft() != null)
            index = Pos(nodes, n.getLeft(), index);
        if(n.getRight() != null)
            index = Pos(nodes, n.getRight(), index);
        nodes[index] = n;
        index ++;
        return index;
    }

    public double Evaluation()throws NullPointerException{
        double answer = 0;
        answer = eva(root);
        return answer;
    }
    private double eva(Node n)throws NullPointerException{
        String s = n.getValue();
        double answer = 0;
        switch(s){
            case ""+"":
                    answer = eva(n.getLeft())+ eva(n.getRight());
                    break;
                case ""-"":
                    answer = eva(n.getLeft())- eva(n.getRight());
                    break;
                case ""*"":
                    answer = eva(n.getLeft())* eva(n.getRight());
                    break;
                case ""/"":
                    answer = eva(n.getLeft())/ eva(n.getRight());
                    break;
                default: 
                    answer = Double.parseDouble(n.getValue());
        }

        return answer;
    }
    
    public static void main(String[] args){
        String s = args[0];
        Expression e = new Expression();
        e.Infix2BT(s);
        Node[] n;
        n = e.PrintPrefix();
        for(int i = 0; i<n.length; i++){
            System.out.print(n[i].getValue());
        }
        System.out.println();
        n = e.PrintPostfix();
        for(int i = 0; i<n.length; i++){
            System.out.print(n[i].getValue());
        }
        System.out.println();
        System.out.print(e.Evaluation());
    }
}

@c7dff09304ea090025aa69432affd382@"
"b03106003","10","0.098","105872","@488d1df55415bb650d2a309aab8728cb@
import java.util.NoSuchElementException;

class Tree{
    Node root;
    Tree(){
        root = new Node(null,null,""0"");
    }

}

public class Expression {
  
    private Node root;
    private Stack<String> st;
    private Stack<String> op;
    private Stack<Tree> trees;
    private double ans;
    private int howmany = 0;
    
    private void Do(){
        String temp = new String();
        Tree newtree = new Tree();
        Tree R = new Tree();
        Tree L = new Tree();
        try{
            if(st.peek()!= ""tree""){
                temp = st.pop();
            R.root.setValue(temp);
            }else{
                st.pop();
                R = trees.pop();
            }
            

        if(st.peek()!= ""tree""){
                temp = st.pop();
            L.root.setValue(temp);
            }else{
                st.pop();
                L = trees.pop();
            }
        //System.out.println(right);
        //System.out.println(left);
        String s = op.pop();
        newtree.root.setValue(s);
        newtree.root.setRight(R.root);
        newtree.root.setLeft(L.root);
        trees.push(newtree);
        st.push(""tree"");
        }catch(NoSuchElementException ex){
        
        }
    } 

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String data[] = infix.split("""");
        st = new Stack<String>();
        op = new Stack<String>();
        trees = new Stack<Tree>();
        String temp = new String();
        String s = ""speace"";
        for(int i = 0; i<data.length; i++){
            switch(data[i]){
                case ""/0"":
                    break;
                case ""+"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""-"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""*"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""/"":
                    howmany++;
                    op.push(data[i]);
                    break;
                case ""("":
                    break;
                case "")"":
                    Do();
                    break;
                default:
                        temp = data[i];
                        howmany++;
                        while(data[i+1].equals(""1"")|| data[i+1].equals(""2"") ||data[i+1].equals(""3"")
                                || data[i+1].equals(""4"")|| data[i+1].equals(""5"")|| data[i+1].equals(""6"")
                                || data[i+1].equals(""7"")|| data[i+1].equals(""8"")|| data[i+1].equals(""9"")
                                || data[i+1].equals(""0"")|| data[i+1].equals("".""))
                        {
                            i++;
                            temp = temp + data[i];
                            //System.out.print(i);
                        }                        
                            st.push(temp);                        
            } 
        }
        root = trees.peek().root;
        return root;
    }

    public Node[] PrintPrefix()throws NullPointerException{
        Node[] prefix = new Node[howmany];
        int index = 0;
        Pre(prefix,root,index);
        return prefix;
    }
    private int Pre(Node[] nodes, Node n, int index)throws NullPointerException{
        n.getValue();
        nodes[index] = n;
        index ++;
        if(n.getLeft() != null)
            index = Pre(nodes, n.getLeft(), index);
        if(n.getRight() != null)
            index = Pre(nodes, n.getRight(), index);
        
        return index;
    }
  
    public Node[] PrintPostfix()throws NullPointerException{
        Node[] prefix = new Node[howmany];
        int index = 0;
        Pos(prefix,root,index);
        return prefix;
    }
    private int Pos(Node[] nodes, Node n, int index)throws NullPointerException{
        n.getValue();
        if(n.getLeft() != null)
            index = Pos(nodes, n.getLeft(), index);
        if(n.getRight() != null)
            index = Pos(nodes, n.getRight(), index);
        nodes[index] = n;
        index ++;
        return index;
    }

    public double Evaluation()throws NullPointerException{
        double answer = 0;
        answer = eva(root);
        return answer;
    }
    private double eva(Node n)throws NullPointerException{
        String s = n.getValue();
        double answer = 0;
        switch(s){
            case ""+"":
                    answer = eva(n.getLeft())+ eva(n.getRight());
                    break;
                case ""-"":
                    answer = eva(n.getLeft())- eva(n.getRight());
                    break;
                case ""*"":
                    answer = eva(n.getLeft())* eva(n.getRight());
                    break;
                case ""/"":
                    answer = eva(n.getLeft())/ eva(n.getRight());
                    break;
                default: 
                    answer = Double.parseDouble(n.getValue());
        }

        return answer;
    }
    
    public static void main(String[] args){
        String s = args[0];
        Expression e = new Expression();
        //e.Infix2BT(s);
        Node[] n;
        n = e.PrintPrefix();
        for(int i = 0; i<n.length; i++){
            System.out.print(n[i].getValue());
        }
        System.out.println();
        n = e.PrintPostfix();
        for(int i = 0; i<n.length; i++){
            System.out.print(n[i].getValue());
        }
        System.out.println();
        System.out.print(e.Evaluation());
    }
}

@488d1df55415bb650d2a309aab8728cb@"
"b02611016","0","0.89","105904","@7db9421d5654bdba735cd17bbfdd139a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){
                 //System.out.println(vals.peek().getValue());   
                Node temp_node=new Node(vals.pop(),cal.pop(),ops.pop());
                cal.push(temp_node);
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
       //System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(String infix){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(4+(((4*2)/2)/3))"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation(test);
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}
@7db9421d5654bdba735cd17bbfdd139a@"
"r03849033","3","0.29","105520","@d42151f69355af2d9aff8a8429c4c2cd@
import java.util.Arrays;

public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;
    public Node[] postfix;

                
private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    // DO NOT MODIFY THIS
    public Expression(){}
    public int size=0;
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(a1) || da[i].equals(a2) || da[i].equals(a3) || da[i].equals(a4) || da[i].equals(a5) || da[i].equals(a6)) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=root;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        postfix=postfix1;
        return postfix;
    }

    public double Evaluation(){
        Stack s = new Stack(postfix.length); 
        for (Node i : postfix) {
            if(i.getValue().equals(a1) ||i.getValue().equals(a2) ||i.getValue().equals(a3) ||i.getValue().equals(a4)){
                Double b1 = Double.parseDouble(s.pop().getValue());
                Double b2 = Double.parseDouble(s.pop().getValue());
                if(i.getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(i.getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(i.getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(i.getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(i);}
        }
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;
    }
    

   
}

@d42151f69355af2d9aff8a8429c4c2cd@"
"b02611016","3","0.97","105856","@4bf43b0d51d8f4199f5515eb61a67229@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){
                 //System.out.println(vals.peek().getValue());   
                Node temp_node=new Node(vals.pop(),cal.pop(),ops.pop());
                cal.push(temp_node);
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
       //System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(4+(((4*2)/2)/3))"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@4bf43b0d51d8f4199f5515eb61a67229@"
"b02611016","3","0.99","105840","@9418b666f7d7b98bf08f947c9b464e20@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){
                 //System.out.println(vals.peek().getValue());   
                Node temp_node=new Node(vals.pop(),cal.pop(),ops.pop());
                cal.push(temp_node);
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
       //System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(4+(((4*2)/2)/3))"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@9418b666f7d7b98bf08f947c9b464e20@"
"b02611016","2","0.98","105856","@b588380609b0f743860c2bf163de6aeb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){
                 //System.out.println(vals.peek().getValue());   
                Node temp_node=new Node(vals.pop(),cal.pop(),ops.pop());
                cal.push(temp_node);
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
       System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(12/12)"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@b588380609b0f743860c2bf163de6aeb@"
"b02611016","3","0.98","105840","@726dd0c68a9e52067ce5119226fcc09f@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){
                 //System.out.println(vals.peek().getValue());   
                Node temp_node=new Node(vals.pop(),cal.pop(),ops.pop());
                cal.push(temp_node);
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(12/12)"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@726dd0c68a9e52067ce5119226fcc09f@"
"r04631036","5","0.76","105520","@383d076c8ce7168b4dac3814626335fe@
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '-':
                case '+':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPrefixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    
    public void PrintPrefixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPrefixRecusive(p, root.getLeft());
        PrintPrefixRecusive(p, root.getRight());
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> postfix = new ArrayList<Node>();
        PrintPostfixRecusive(postfix, root);
        return postfix.toArray(new Node[postfix.size()]);
    }
    public void PrintPostfixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPostfixRecusive(p, root.getLeft());
        PrintPostfixRecusive(p, root.getRight());
        p.add(root);
    }
    

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] eva = this.PrintPostfix();
        Stack<Double> evalue = new Stack<Double>();
        for(Node n:eva){
            String in = n.getValue();
            if(in.equals(""+"")){
                evalue.push(evalue.pop()+evalue.pop());
            } else if(in.equals(""-"")){
                evalue.push(-evalue.pop()+evalue.pop());
            } else if(in.equals(""*"")){
                evalue.push(evalue.pop()*evalue.pop());
            } else if(in.equals(""/"")){
                evalue.push(1/evalue.pop()*evalue.pop());
            } else {
                evalue.push(Double.parseDouble(in));
            }
            
        }
//        double answer = 0;
        return evalue.pop();
    }
}

@383d076c8ce7168b4dac3814626335fe@"
"b02611016","3","0.98","105856","@30a9c01ec1d503eb75e1c162e7c7f26c@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){
                 //System.out.println(vals.peek().getValue());   
                Node temp_node=new Node(vals.pop(),cal.pop(),ops.pop());
                cal.push(temp_node);
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(4+(((4*2)/2)/3))"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@30a9c01ec1d503eb75e1c162e7c7f26c@"
"r04631036","10","0.099","105536","@cb8c302f1365b82cdcfb11d101a33e54@
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '-':
                case '+':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
            }
        }
         
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPrefixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    
    public void PrintPrefixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPrefixRecusive(p, root.getLeft());
        PrintPrefixRecusive(p, root.getRight());
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> postfix = new ArrayList<Node>();
        PrintPostfixRecusive(postfix, root);
        return postfix.toArray(new Node[postfix.size()]);
    }
    public void PrintPostfixRecusive(List<Node> p, Node root){
        if(root==null) return;
        
        PrintPostfixRecusive(p, root.getLeft());
        PrintPostfixRecusive(p, root.getRight());
        p.add(root);
//        p.add(root);
    }
    

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] eva = this.PrintPostfix();
        Stack<Double> evalue = new Stack<Double>();
        for(Node n:eva){
            String in = n.getValue();
            if(in.equals(""+"")){
                evalue.push(evalue.pop()+evalue.pop());
            } else if(in.equals(""-"")){
                evalue.push(-evalue.pop()+evalue.pop());
            } else if(in.equals(""*"")){
                evalue.push(evalue.pop()*evalue.pop());
            } else if(in.equals(""/"")){
                evalue.push(1/evalue.pop()*evalue.pop());
            } else {
                evalue.push(Double.parseDouble(in));
            }
            
        }
        return evalue.pop();
    }
}

@cb8c302f1365b82cdcfb11d101a33e54@"
"b02611016","0","0.93","105856","@8212c10229bc0b0069a68399e36dd8a5@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
        int eat=0;
        int next=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                next=0;
                System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){if(!vals.isEmpty())
                { Node temp_node=cal.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                else{Node temp_node=cal.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(cal.pop(),temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                cal.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  Node temp_node=vals.pop();
                Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@8212c10229bc0b0069a68399e36dd8a5@"
"b02611016","3","0.98","105872","@14a82950a68d0c9b248869b384cdf645@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        Stack<Node> cal = new Stack<Node>();
        Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
        int eat=0;
        int next=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(cal.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                 cal.push(temp_node1);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(cal.pop(),vals.pop(),ops.pop());
                cal.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){if(!vals.isEmpty())
                { Node temp_node=cal.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                else{Node temp_node=cal.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(cal.pop(),temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,ops.pop());
                cal.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  Node temp_node=vals.pop();
                Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
             //  System.out.println(num);
            }
        }
        root=cal.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@14a82950a68d0c9b248869b384cdf645@"
"b03704074","0","0.099","105536","@b8582defd26c2801ca3963a01a39fb09@
public class Expression {
    
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int lenghtcount = 0;
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))lenghtcount++;}
        String[] Infix = new String[infix.length()-lenghtcount];
        Node[] array = new Node[infix.length()];
        int Infixcount = 0;
        for(int i = 0;i < infix.length();i++){//把輸入的改成字串陣列
            if(!infix.substring(i, i+1).equals(""("")){
            Infix[Infixcount] = infix.substring(i, i+1);Infixcount++;}}
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.left.right.value);
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].value);
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].value);
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.left!=null)preOrder(x.left,y);
        if(x.right!=null)preOrder(x.right,y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].value);
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.left!=null) postOrder(x.left,y);
        if(x.right!=null)postOrder(x.right,y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    private EvaNode Evafirst = null;
    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.value.equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.value);
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""(4+(((4*2)/2)/3))"");
        exp.Evaluation();
        
        
    }
    
}

@b8582defd26c2801ca3963a01a39fb09@"
"b03704074","0","0.099","105536","@5258b8cc062262fb59227949cee2ae7b@
public class Expression {
    private class Node{
    private Node left;
    private Node right;
    private String value;

    public Node(Node left, Node right, String value){
        this.left = left;
        this.right = right;
        this.value = value;
    }

    public Node getLeft(){
        return(this.left);
    }

    public Node getRight(){
        return(this.right);
    }

    public String getValue(){
        return(this.value);
    }

    public void setLeft(Node left){
        this.left = left;
    }

    public void setRight(Node right){
        this.right = right;
    }

    public void setValue(String value){
        this.value = value;
    } }
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int lenghtcount = 0;
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))lenghtcount++;}
        String[] Infix = new String[infix.length()-lenghtcount];
        Node[] array = new Node[infix.length()];
        int Infixcount = 0;
        for(int i = 0;i < infix.length();i++){//把輸入的改成字串陣列
            if(!infix.substring(i, i+1).equals(""("")){
            Infix[Infixcount] = infix.substring(i, i+1);Infixcount++;}}
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.left.right.value);
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].value);
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].value);
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.left!=null)preOrder(x.left,y);
        if(x.right!=null)preOrder(x.right,y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].value);
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.left!=null) postOrder(x.left,y);
        if(x.right!=null)postOrder(x.right,y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    private EvaNode Evafirst = null;
    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.value.equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.value);
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""(4+(((4*2)/2)/3))"");
        exp.Evaluation();
        
        
    }
    
}

@5258b8cc062262fb59227949cee2ae7b@"
"b03704074","0","0.099","105536","@932b5dfb8af8e3f0dcd255b720997cdc@
public class Expression {
    private class Node{
    private Node left;
    private Node right;
    private String value;

    public Node(Node left, Node right, String value){
        this.left = left;
        this.right = right;
        this.value = value;
    }

    public Node getLeft(){
        return(this.left);
    }

    public Node getRight(){
        return(this.right);
    }

    public String getValue(){
        return(this.value);
    }

    public void setLeft(Node left){
        this.left = left;
    }

    public void setRight(Node right){
        this.right = right;
    }

    public void setValue(String value){
        this.value = value;
    } }
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int lenghtcount = 0;
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))lenghtcount++;}
        String[] Infix = new String[infix.length()-lenghtcount];
        Node[] array = new Node[infix.length()];
        int Infixcount = 0;
        for(int i = 0;i < infix.length();i++){//把輸入的改成字串陣列
            if(!infix.substring(i, i+1).equals(""("")){
            Infix[Infixcount] = infix.substring(i, i+1);Infixcount++;}}
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.left.right.value);
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].value);
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].value);
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.left!=null)preOrder(x.left,y);
        if(x.right!=null)preOrder(x.right,y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].value);
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.left!=null) postOrder(x.left,y);
        if(x.right!=null)postOrder(x.right,y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    private EvaNode Evafirst = null;
    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.value.equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.value);
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""(4+(((4*2)/2)/3))"");
        exp.Evaluation();
        
    }
    
}

@932b5dfb8af8e3f0dcd255b720997cdc@"
"b02611016","3","0.96","105856","@6d68816af563a19c0785b510517884e3@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
        int eat=0;
        int next=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node1);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=vals.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               
                 if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(1312.1+((5.132*323.13)/(131313.12+464588)))"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@6d68816af563a19c0785b510517884e3@"
"b03704074","0","0.93","105856","@d3a69df0af5145e96397fefd24b87205@
public class Expression {
    public class Node{
    private Node left;
    private Node right;
    private String value;

    public Node(Node left, Node right, String value){
        this.left = left;
        this.right = right;
        this.value = value;
    }

    public Node getLeft(){
        return(this.left);
    }

    public Node getRight(){
        return(this.right);
    }

    public String getValue(){
        return(this.value);
    }

    public void setLeft(Node left){
        this.left = left;
    }

    public void setRight(Node right){
        this.right = right;
    }

    public void setValue(String value){
        this.value = value;
    } }
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int InfixCount = 0;
        String[] Infix1 = new String[1000];
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))continue;
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"")){
                Infix1[InfixCount++] = infix.substring(i, i+1);
                
            }
            else {
                int temp = i;
                while(!infix.substring(i+1, i+2).equals(""("") &&!infix.substring(i+1, i+2).equals(""+"") &&! infix.substring(i+1, i+2).equals(""-"") &&! infix.substring(i+1, i+2).equals(""*"") &&! infix.substring(i+1, i+2).equals(""/"") &&! infix.substring(i+1, i+2).equals("")"")){
                    i++;
                }
                Infix1[InfixCount++] = infix.substring(temp, i+1);
            }
        }
        String[] Infix = new String[InfixCount];
        for(int i = 0;i < InfixCount;i++){
            Infix[i] = Infix1[i];
        }
                
        
        Node[] array = new Node[infix.length()];//不影響
        
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.left.right.value);
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].value);
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            System.out.println(prefix[i].value);
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.left!=null)preOrder(x.left,y);
        if(x.right!=null)preOrder(x.right,y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            System.out.println(postfix[i].value);
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.left!=null) postOrder(x.left,y);
        if(x.right!=null)postOrder(x.right,y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    private EvaNode Evafirst = null;
    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.value.equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.value.equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.value);
                double b = Double.parseDouble(Evafirst.pre.item.value);
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.value = newvalue;
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.value);
        System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""((20120224791*(121259+797912))+(211544771212/2))"");
        exp.PrintPrefix();
        //exp.PrintPostfix();
        exp.Evaluation();
        
    }
    
}

@d3a69df0af5145e96397fefd24b87205@"
"b02611016","3","0.99","104032","@67e2d60a8c364c4827592432435d9878@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee.length);
        int eat=0;
        int next=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        root=vals.pop();
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""(12.34567)"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@67e2d60a8c364c4827592432435d9878@"
"b03704074","5","0.96","105280","@f730975123092a5e11e2112dd572ecb5@
public class Expression {
    /*public class Node{
    private Node left;
    private Node right;
    private String value;

    public Node(Node left, Node right, String value){
        this.left = left;
        this.right = right;
        this.value = value;
    }

    public Node getLeft(){
        return(this.left);
    }

    public Node getRight(){
        return(this.right);
    }

    public String getValue(){
        return(this.value);
    }

    public void setLeft(Node left){
        this.left = left;
    }

    public void setRight(Node right){
        this.right = right;
    }

    public void setValue(String value){
        this.value = value;
    } }*/
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int InfixCount = 0;
        String[] Infix1 = new String[1000];
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))continue;
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"")){
                Infix1[InfixCount++] = infix.substring(i, i+1);
                
            }
            else {
                int temp = i;
                while(!infix.substring(i+1, i+2).equals(""("") &&!infix.substring(i+1, i+2).equals(""+"") &&! infix.substring(i+1, i+2).equals(""-"") &&! infix.substring(i+1, i+2).equals(""*"") &&! infix.substring(i+1, i+2).equals(""/"") &&! infix.substring(i+1, i+2).equals("")"")){
                    i++;
                }
                Infix1[InfixCount++] = infix.substring(temp, i+1);
            }
        }
        String[] Infix = new String[InfixCount];
        for(int i = 0;i < InfixCount;i++){
            Infix[i] = Infix1[i];
        }
                
        
        Node[] array = new Node[infix.length()];//不影響
        
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.left.right.value);
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].value);
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].value);
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.getLeft()!=null)preOrder(x.getLeft(),y);
        if(x.getRight()!=null)preOrder(x.getRight(),y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            System.out.println(postfix[i].getValue());
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.getLeft()!=null) postOrder(x.getLeft(),y);
        if(x.getRight()!=null)postOrder(x.getRight(),y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    private EvaNode Evafirst = null;
    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.getValue().equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue); 
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.getValue());
        System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""((20120224791*(121259+797912))+(211544771212/2))"");
        exp.PrintPrefix();
        //exp.PrintPostfix();
        exp.Evaluation();
        
    }
    
}

@f730975123092a5e11e2112dd572ecb5@"
"b03704074","9","0.95","105536","@8a8413a16e29afc28e21cdd4b46e57d9@
public class Expression {
    
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int InfixCount = 0;
        String[] Infix1 = new String[1000];
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))continue;
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"")){
                Infix1[InfixCount++] = infix.substring(i, i+1);
                
            }
            else {
                int temp = i;
                while(!infix.substring(i+1, i+2).equals(""("") &&!infix.substring(i+1, i+2).equals(""+"") &&! infix.substring(i+1, i+2).equals(""-"") &&! infix.substring(i+1, i+2).equals(""*"") &&! infix.substring(i+1, i+2).equals(""/"") &&! infix.substring(i+1, i+2).equals("")"")){
                    i++;
                }
                Infix1[InfixCount++] = infix.substring(temp, i+1);
            }
        }
        String[] Infix = new String[InfixCount];
        for(int i = 0;i < InfixCount;i++){
            Infix[i] = Infix1[i];
        }
                
        
        Node[] array = new Node[infix.length()];//不影響
        
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.left.right.value);
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].getValue());
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].getValue());
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.getLeft()!=null)preOrder(x.getLeft(),y);
        if(x.getRight()!=null)preOrder(x.getRight(),y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].getValue());
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.getLeft()!=null) postOrder(x.getLeft(),y);
        if(x.getRight()!=null)postOrder(x.getRight(),y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    private EvaNode Evafirst = null;
    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.getValue().equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue); 
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.getValue());
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""(((0.235+0.88)*7.2)+(200+10))"");
        exp.PrintPrefix();
        //exp.PrintPostfix();
        exp.Evaluation();
        
    }
    
}

@8a8413a16e29afc28e21cdd4b46e57d9@"
"b02611016","0","0.09","101056","@7d2af18985ce1ae23f57119e60bad5b1@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(root == null){ throw new NullPointerException();}
        root=vals.pop();
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test="""";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@7d2af18985ce1ae23f57119e60bad5b1@"
"b02611016","3","0.96","105872","@4f359e69b17f98fd49f040730b51cacc@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.peek()==null){ throw new NullPointerException();}
        root=vals.pop();
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""()"";
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.print(u);
       // tempp[]=tem.PrintPostfix();
    }
}


@4f359e69b17f98fd49f040730b51cacc@"
"b03704074","9","0.98","105536","@8391a61ff608b3edb100d118a49968ed@
public class Expression {
    
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int InfixCount = 0;
        String[] Infix1 = new String[1000];
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))continue;
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"")){
                Infix1[InfixCount++] = infix.substring(i, i+1);
                
            }
            else {
                int temp = i;
                while(!infix.substring(i+1, i+2).equals(""("") &&!infix.substring(i+1, i+2).equals(""+"") &&! infix.substring(i+1, i+2).equals(""-"") &&! infix.substring(i+1, i+2).equals(""*"") &&! infix.substring(i+1, i+2).equals(""/"") &&! infix.substring(i+1, i+2).equals("")"")){
                    i++;
                }
                Infix1[InfixCount++] = infix.substring(temp, i+1);
            }
        }
        String[] Infix = new String[InfixCount];
        for(int i = 0;i < InfixCount;i++){
            Infix[i] = Infix1[i];
        }
                
        
        Node[] array = new Node[infix.length()];//不影響
        
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.left.right.value);
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].getValue());
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].getValue());
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.getLeft()!=null)preOrder(x.getLeft(),y);
        if(x.getRight()!=null)preOrder(x.getRight(),y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].getValue());
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.getLeft()!=null) postOrder(x.getLeft(),y);
        if(x.getRight()!=null)postOrder(x.getRight(),y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    private EvaNode Evafirst = null;
    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.getValue().equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue); 
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.getValue());
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        /*Expression exp = new Expression();
        Node test = exp.Infix2BT(""(12/0)"");
        Node[] a = exp.PrintPrefix();
        for(int i = 0;i < a.length;i++){
            System.out.println(a[i].getValue());
        }/*
        /*Node[] b = exp.PrintPostfix();
        for(int i = 0;i < b.length;i++){
            System.out.println(b[i].getValue());
        }*/
        //double c = exp.Evaluation();
        //System.out.println(c);
        
    }
    
}

@8391a61ff608b3edb100d118a49968ed@"
"b02611016","3","0.95","105648","@abfaf25dec92e4870673e10941e84b7d@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.peek()==null){ throw new NullPointerException();}
        root=vals.pop();
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          n=0;
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test=""(((1.23-(121259+797912))*(21212+213135498))/32349)"";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}


@abfaf25dec92e4870673e10941e84b7d@"
"b02611016","3","0.99","105888","@aec8a13a53a37cf8541d4d0c60d56b55@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     String[] a=new String[100] ;
     String[] b=new String[100] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.peek()==null){ throw new NullPointerException();}
        root=vals.pop();
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot.getValue();
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=new Node(null,null,a[j]);
         //System.out.println(prefix[j].getValue());
        }
        // System.out.println(a);
  
  

        //System.out.println(prefix[0].getValue());
        /*while(i!=5){
            Node testroot1=testroot;
        while(testroot.getLeft()!=null)
        { testroot1=testroot;
            testroot=testroot.getLeft();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;
        }
        testroot=testroot1.getRight();
        prefix[i]=new Node(null,null,testroot.getValue());
        System.out.println(prefix[i].getValue());
        i=i+1;*/
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot.getValue();
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=new Node(null,null,b[j]);
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {/*
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test=""(((1.23-(121259+797912))*(21212+213135498))/32349)"";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);*/
    }
}


@aec8a13a53a37cf8541d4d0c60d56b55@"
"b03704074","9","0.95","105552","@554d7b28a6974e3687c54017c1d62431@
public class Expression {
    
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int InfixCount = 0;
        String[] Infix1 = new String[1000];
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""("") || infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"") ){
                break;
                
            }
            if(i == infix.length()-1){
            Node a = new Node(null,null,infix);
            root = a;
            return root;}
        }
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))continue;
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"")){
                Infix1[InfixCount++] = infix.substring(i, i+1);
                
            }
            else {
                int temp = i;
                while(!infix.substring(i+1, i+2).equals(""("") &&!infix.substring(i+1, i+2).equals(""+"") &&! infix.substring(i+1, i+2).equals(""-"") &&! infix.substring(i+1, i+2).equals(""*"") &&! infix.substring(i+1, i+2).equals(""/"") &&! infix.substring(i+1, i+2).equals("")"") ){
                    i++;
                }
                Infix1[InfixCount++] = infix.substring(temp, i+1);
            }
        }
        String[] Infix = new String[InfixCount];
        for(int i = 0;i < InfixCount;i++){
            Infix[i] = Infix1[i];
        }
                
        
        Node[] array = new Node[infix.length()];//不影響
        
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.left.right.value);
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].getValue());
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].getValue());
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.getLeft()!=null)preOrder(x.getLeft(),y);
        if(x.getRight()!=null)preOrder(x.getRight(),y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].getValue());
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.getLeft()!=null) postOrder(x.getLeft(),y);
        if(x.getRight()!=null)postOrder(x.getRight(),y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    private EvaNode Evafirst = null;
    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.getValue().equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue); 
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.getValue());
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""12.34567"");
        Node[] a = exp.PrintPrefix();
        for(int i = 0;i < a.length;i++){
            System.out.println(a[i].getValue());
        }
        /*Node[] b = exp.PrintPostfix();
        for(int i = 0;i < b.length;i++){
            System.out.println(b[i].getValue());
        }*/
        double c = exp.Evaluation();
        System.out.println(c);
        
    }
    
}

@554d7b28a6974e3687c54017c1d62431@"
"r03525006","1","0.27","103680","@6c940b2760e7b4189c97986eb4af04aa@public class Expression{

    private Node root;
    private Node[] binaryTree;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        int parenCount = 0, levelCount = 0 , levelMax = 0;
        Character a;
        int[] idTemp = new int[infix.length()];
        for (int i = 0; i < infix.length(); i++) {
            a = infix.charAt(i);
            String s = a.toString();
            if (s.equals(""("")) { levelCount++; parenCount++; idTemp[i] = -1;}
            else if (s.equals("")"")) { levelCount--; idTemp[i] = -1;}
            else if (s.equals(""+"") || s.equals(""-"") || s.equals(""*"") || s.equals(""/"")) idTemp[i] = levelCount-1;
            else idTemp[i] = levelCount;
            if (idTemp[i] > levelMax) levelMax = idTemp[i];
        }
        int[] id = new int[infix.length()-parenCount*2];
        String[] newInfix = new String[infix.length()-parenCount*2];
        int index = 0, rootIndex = 0;
        for (int i = 0; i < idTemp.length; i++) {
            if (idTemp[i] != -1) {
                a = infix.charAt(i);
                newInfix[index] = a.toString();
                id[index] = idTemp[i];
                if (id[index] == 0) rootIndex = index;
                index++;
            }
        }

        int[] treeIndex = new int[id.length];
        int[] levelIndexCount = new int[levelMax+1];
        for (int i = 0; i < id.length; i++) {
            levelIndexCount[id[i]] += 1;
            for (int k = id[i]+1; k < levelIndexCount.length; k++) levelIndexCount[k] = 0;
            int startIndex = 1;
            for (int j = 0; j < id[i]; j ++) {
                if (levelIndexCount[j] == 0) startIndex = startIndex*2;
                else startIndex = startIndex*2+1;
            }
            treeIndex[i] = startIndex;
        }
        binaryTree = new Node[treeIndex.length];
        for (int i = 0; i < treeIndex.length; i++) {
            Node n = new Node(null,null,newInfix[i]);
            binaryTree[i] = n;
        }

        for (int i = 0; i < treeIndex.length; i++) {
            for (int j = 0; j < treeIndex.length; j++) {
                if (treeIndex[j] == treeIndex[i]*2) binaryTree[i].setLeft(binaryTree[j]);
                if (treeIndex[j] == treeIndex[i]*2+1) binaryTree[i].setRight(binaryTree[j]);
            }
        }
        return binaryTree[rootIndex];
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        return prefix;
    }

    public Node[] PrintPostfix(){
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        return answer;
    }
}
@6c940b2760e7b4189c97986eb4af04aa@"
"r04522616","0","0.27","103680","@3ac5d4c6ad8bf734f56a8cca983db882@import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      tempRoot.setLeft(a);
                      tempRoot.setRight(b);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          tempRoot.setLeft(tempRoot);
                          tempRoot.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          tempRoot.setLeft(a);
                          tempRoot.setRight(tempRoot);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          tempRoot2.setLeft(a);
                          tempRoot2.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          tempRoot.setLeft(tempRoot);
                          tempRoot.setRight(tempRoot2);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        //preorderPrintTree(root);
        return prefix;
    }
    
//private static void preorderPrintTree(Node root) {
//        if (root.getLeft()==null && root.getRight()==null)
//            System.out.print(root.getValue());
//        else {
//            // interior node -- an operator
//            // first the node itself (the root of the subtree)
//            System.out.print(root.getValue());
//        
////            switch (root.getValue()) {
////                case '+':
////                    System.out.print(""add""); 
////                    break;
////                case '-':
////                    System.out.print(""subtr""); 
////                    break;
////                case '*':
////                    System.out.print(""mult""); 
////                    break;
////                case '/':
////                    System.out.print(""divide""); 
////                    break;
////            }
//            
//            // then the left and right subtrees
//            System.out.print(""("");
//            preorderPrintTree(root.getLeft());
//            System.out.print("", "");
//            preorderPrintTree(root.getRight());
//            System.out.print("")"");
//        }
//    }
  
    public Node[] PrintPostfix(){
        
        Node[] postfix = new Node[outData.length];
        String[] check=new String[outData.length];
        
        Stack<String> stk=new Stack<String>();
        int j=0;
        for(int i=1;i<outData.length;i++)
        {            
            char isANumber=outData[i].charAt(0);
            if(outData[i].equals(""(""))
            {
                j++;
            }
            else if(outData[i].equals("")""))
            {
                String symbol=stk.pop();
                postfix[i-j-1]=new Node(null, null, symbol);
                check[i-j-1]=symbol;
            }
            else if(Character.isDigit(isANumber)!=true && outData[i].equals(""("")!=true && outData[i].equals("")"")!=true)
            {
                j++;
                stk.push(outData[i]);
            }
            else
            {
                Node a=new Node(null, null, outData[i]);
                postfix[i-j-1]=a;
                check[i-j-1]=outData[i];
            }
        }
        int i=0;
        do
        {
            System.out.print(check[i]);
            i++;
        }
        while(i!=((outData.length+1)/2));
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@3ac5d4c6ad8bf734f56a8cca983db882@"
"r04522616","1","0.2","103712","@46149bc329daa03b067cd82cb5fb654a@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      tempRoot.setLeft(a);
                      tempRoot.setRight(b);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          tempRoot.setLeft(tempRoot);
                          tempRoot.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          tempRoot.setLeft(a);
                          tempRoot.setRight(tempRoot);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          tempRoot2.setLeft(a);
                          tempRoot2.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          tempRoot.setLeft(tempRoot);
                          tempRoot.setRight(tempRoot2);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        //preorderPrintTree(root);
        return prefix;
    }
    
//private static void preorderPrintTree(Node root) {
//        if (root.getLeft()==null && root.getRight()==null)
//            System.out.print(root.getValue());
//        else {
//            // interior node -- an operator
//            // first the node itself (the root of the subtree)
//            System.out.print(root.getValue());
//        
////            switch (root.getValue()) {
////                case '+':
////                    System.out.print(""add""); 
////                    break;
////                case '-':
////                    System.out.print(""subtr""); 
////                    break;
////                case '*':
////                    System.out.print(""mult""); 
////                    break;
////                case '/':
////                    System.out.print(""divide""); 
////                    break;
////            }
//            
//            // then the left and right subtrees
//            System.out.print(""("");
//            preorderPrintTree(root.getLeft());
//            System.out.print("", "");
//            preorderPrintTree(root.getRight());
//            System.out.print("")"");
//        }
//    }
  
    public Node[] PrintPostfix(){
        
        Node[] postfix = new Node[outData.length];
        String[] check=new String[outData.length];
        
        Stack<String> stk=new Stack<String>();
        int j=0;
        for(int i=1;i<outData.length;i++)
        {            
            char isANumber=outData[i].charAt(0);
            if(outData[i].equals(""(""))
            {
                j++;
            }
            else if(outData[i].equals("")""))
            {
                String symbol=stk.pop();
                postfix[i-j-1]=new Node(null, null, symbol);
                check[i-j-1]=symbol;
            }
            else if(Character.isDigit(isANumber)!=true && outData[i].equals(""("")!=true && outData[i].equals("")"")!=true)
            {
                j++;
                stk.push(outData[i]);
            }
            else
            {
                Node a=new Node(null, null, outData[i]);
                postfix[i-j-1]=a;
                check[i-j-1]=outData[i];
            }
        }
        int i=0;
        do
        {
            System.out.print(check[i]);
            i++;
        }
        while(i!=((outData.length+1)/2));
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@46149bc329daa03b067cd82cb5fb654a@"
"b02611012","1","0.09","101920","@9eeacb1f2a1274e52b2019849bd3bf8f@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private Node root;
    private Stack<Node> prefix;
    private Stack<Node> postfix;
    private Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] in = infix.split(""(?!^)"");
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (op.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (op.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (op.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (op.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                ops.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        prefix(root);
        int count = this.prefix.size();
        Node[] p = null;
        for (int i = 0; i < count; i++) {
            p[i] = prefix.pop();
        }
        return p;
    }

    private void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public Node[] PrintPostfix() {
        postfix(root);
        int count = this.postfix.size();
        Node[] p = null;
        for (int i = 0; i < count; i++) {
            p[i] = postfix.pop();
        }
        return p;
    }

    public double Evaluation() {
        return answer;
    }
}

@9eeacb1f2a1274e52b2019849bd3bf8f@"
"b02611012","1","0.09","101872","@6cb2467087939b10dd634f4bc234fa1d@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private Node root;
    private Stack<Node> prefix;
    private Stack<Node> postfix;
    private Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] in = infix.split(""(?!^)"");
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (op.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (op.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (op.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (op.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                ops.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = null;
        for (int i = 0; i < count; i++) {
            p[i] = prefix.pop();
        }
        return p;
    }

    private void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = this.postfix.size();
        Node[] p = null;
        for (int i = 0; i < count; i++) {
            p[i] = postfix.pop();
        }
        return p;
    }

    public double Evaluation() {
        return answer;
    }
}

@6cb2467087939b10dd634f4bc234fa1d@"
"r03849033","5","0.5","105552","@6abaa07ffacbcc87f5fce6b500bbce1c@import java.io.BufferedReader;
import java.io.FileReader;
public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;
    public Node[] postfix;

                
private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    // DO NOT MODIFY THIS
    public Expression(){}
    public int size=0;
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(a1) || da[i].equals(a2) || da[i].equals(a3) || da[i].equals(a4) || da[i].equals(a5) || da[i].equals(a6)) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=root;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        postfix=postfix1;
        return postfix;
    }

    public double Evaluation(){
        Stack s = new Stack(postfix.length); 
        for (Node i : postfix) {
            if(i.getValue().equals(a1) ||i.getValue().equals(a2) ||i.getValue().equals(a3) ||i.getValue().equals(a4)){
                Double b1 = Double.parseDouble(s.pop().getValue());
                Double b2 = Double.parseDouble(s.pop().getValue());
                if(i.getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(i.getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(i.getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(i.getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(i);}
        }
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;
    }
 
}

@6abaa07ffacbcc87f5fce6b500bbce1c@"
"b02611012","2","0.28","99872","@353f7306b9e98af0225463562fd09384@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private static Node root;
    private Stack<Node> prefix;
    private Stack<Node> postfix;
    private static Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] in = infix.split(""(?!^)"");
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (op.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (op.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (op.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (op.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                vals.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = null;
        for (int i = 0; i < count; i++) {
            p[i] = prefix.pop();
        }
        return p;
    }

    private void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = this.postfix.size();
        Node[] p = null;
        for (int i = 0; i < count; i++) {
            p[i] = postfix.pop();
        }
        return p;
    }

    public static double Evaluation() {
        return answer;
    }
    
    public static void main(String[] args) {
        Node a = null;
        a = Infix2BT(""(4+(((4*2)/2)/3))"");
        System.out.printf(Evaluation() + """");
    }
}

@353f7306b9e98af0225463562fd09384@"
"b02611012","3","0.28","105520","@9c987a485d4a2d316df782eb1edfbd92@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private static Node root;
    private Stack<Node> prefix;
    private Stack<Node> postfix;
    private static Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] in = infix.split(""(?!^)"");
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (aop.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (aop.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (aop.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (aop.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                vals.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = null;
        for (int i = 0; i < count; i++) {
            p[i] = prefix.pop();
        }
        return p;
    }

    private void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = this.postfix.size();
        Node[] p = null;
        for (int i = 0; i < count; i++) {
            p[i] = postfix.pop();
        }
        return p;
    }

    public static double Evaluation() {
        return answer;
    }
    
    public static void main(String[] args) {
        Node a = null;
        a = Infix2BT(""(4+(((4*2)/2)/3))"");
        System.out.printf(Evaluation() + """");
    }
}

@9c987a485d4a2d316df782eb1edfbd92@"
"b02611012","3","0.76","105616","@ba708d9669344b0744faace2538bd9f2@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private static Node root;
    private static Stack<Node> prefix = new Stack<Node>();
    private static Stack<Node> postfix = new Stack<Node>();
    private static Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] in = infix.split(""(?!^)"");
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (aop.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (aop.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (aop.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (aop.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                vals.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        this.prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = prefix.pop();
        }
        return p;
    }

    private static void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public static Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = Expression.postfix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = postfix.pop();
        }
        return p;
    }

    public static double Evaluation() {
        return answer;
    }
    
public static void main(String[] args) {
        String input = ""(12/12)"";
        
        Expression test = new Expression();
        test.Infix2BT(input);
        print(test.PrintPrefix());
        print(test.PrintPostfix());        
        System.out.println(test.Evaluation());        
    } 
        
    public static void print(Node[] pf){
        for(int i = 0; i < pf.length;i++){
            System.out.printf(pf[i].getValue()+"" "");
        }
        System.out.println();        
    }        
}

@ba708d9669344b0744faace2538bd9f2@"
"b02611012","1","0.09","98624","@3b1622ea9f8a93739c5381fb14fad157@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private static Node root;
    private static Stack<Node> prefix = new Stack<Node>();
    private static Stack<Node> postfix = new Stack<Node>();
    private static Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] in = infix.split(""(?<=\\d)(?=\\D)|(?<=\\D)(?=\\d)"");
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (aop.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (aop.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (aop.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (aop.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                vals.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        this.prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = prefix.pop();
        }
        return p;
    }

    private static void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public static Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = Expression.postfix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = postfix.pop();
        }
        return p;
    }

    public static double Evaluation() {
        return answer;
    }
    
public static void main(String[] args) {
        String input = ""(12/12)"";
        
        Expression test = new Expression();
        test.Infix2BT(input);
        print(test.PrintPrefix());
        print(test.PrintPostfix());        
        System.out.println(test.Evaluation());        
    } 
        
    public static void print(Node[] pf){
        for(int i = 0; i < pf.length;i++){
            System.out.printf(pf[i].getValue()+"" "");
        }
        System.out.println();        
    }        
}

@3b1622ea9f8a93739c5381fb14fad157@"
"b02611012","1","0.09","105248","@2ba9f7b0755619fd0d90c508ecb8fd75@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private static Node root;
    private static Stack<Node> prefix = new Stack<Node>();
    private static Stack<Node> postfix = new Stack<Node>();
    private static Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] in = infix.split(""(?<=\\d)(?=\\D)|(?<=\\D)(?=\\d)"");
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (aop.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (aop.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (aop.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (aop.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                vals.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        this.prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = prefix.pop();
        }
        return p;
    }

    private static void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public static Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = Expression.postfix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = postfix.pop();
        }
        return p;
    }

    public static double Evaluation() {
        return answer;
    }
    
//public static void main(String[] args) {
//        String input = ""(12/12)"";
//        
//        Expression test = new Expression();
//        test.Infix2BT(input);
//        print(test.PrintPrefix());
//        print(test.PrintPostfix());        
//        System.out.println(test.Evaluation());        
//    } 
//        
//    public static void print(Node[] pf){
//        for(int i = 0; i < pf.length;i++){
//            System.out.printf(pf[i].getValue()+"" "");
//        }
//        System.out.println();        
//    }        
}

@2ba9f7b0755619fd0d90c508ecb8fd75@"
"r03849033","5","0.49","105520","@51b02351593ae2985779755743c03e09@import java.io.BufferedReader;
import java.io.FileReader;
public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;
    public Node[] postfix;
    public Node[] prefix;

private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    // DO NOT MODIFY THIS
    public Expression(){}
    public int size=0;
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(a1) || da[i].equals(a2) || da[i].equals(a3) || da[i].equals(a4) || da[i].equals(a5) || da[i].equals(a6)) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix1 = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=root;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix1[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix1[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        prefix=prefix1;
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        postfix=postfix1;
        return postfix;
    }

    public double Evaluation(){
        if(postfix==null){
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  }
        else{
        Stack s = new Stack(postfix.length); 
        for (Node i : postfix) {
            if(i.getValue().equals(a1) ||i.getValue().equals(a2) ||i.getValue().equals(a3) ||i.getValue().equals(a4)){
                Double b1 = Double.parseDouble(s.pop().getValue());
                Double b2 = Double.parseDouble(s.pop().getValue());
                if(i.getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(i.getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(i.getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(i.getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(i);}
        } 
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  }

    }
    
}

@51b02351593ae2985779755743c03e09@"
"b02611012","3","0.97","105568","@f8931eecaefe048140e3c89d693a0abe@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private static Node root;
    private static Stack<Node> prefix = new Stack<Node>();
    private static Stack<Node> postfix = new Stack<Node>();
    private static Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] temp = infix.split(""(?<=[\\(\\)\\+\\-\\*\\/])|(?=[\\(\\)\\+\\-\\*\\/])"");
        String[] in = new String[temp.length-1];
        for (int i = 0; i < in.length; i++) {
            in[i] = temp[i + 1];
        }
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (aop.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (aop.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (aop.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (aop.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                vals.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        this.prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = prefix.pop();
        }
        return p;
    }

    private static void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public static Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = Expression.postfix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = postfix.pop();
        }
        return p;
    }

    public static double Evaluation() {
        return answer;
    }
    
public static void main(String[] args) {
        String input = ""(4+(((4*2)/2)/3))"";
        
        Expression test = new Expression();
        test.Infix2BT(input);
        print(test.PrintPrefix());
        print(test.PrintPostfix());        
        System.out.println(test.Evaluation());        
    } 
        
    public static void print(Node[] pf){
        for(int i = 0; i < pf.length;i++){
            System.out.printf(pf[i].getValue()+"" "");
        }
        System.out.println();        
    }        
}

@f8931eecaefe048140e3c89d693a0abe@"
"b02611012","3","0.98","105536","@664f898b019907d787f305650fa4f08e@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private static Node root;
    private static Stack<Node> prefix = new Stack<Node>();
    private static Stack<Node> postfix = new Stack<Node>();
    private static Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] temp = infix.split(""(?<=[\\(\\)\\+\\-\\*\\/])|(?=[\\(\\)\\+\\-\\*\\/])"");
        String[] in = new String[temp.length-1];
        for (int i = 0; i < in.length; i++) {
            in[i] = temp[i + 1];
        }
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (aop.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (aop.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (aop.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (aop.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                vals.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        this.prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = prefix.pop();
        }
        return p;
    }

    private static void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public static Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = Expression.postfix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[i] = postfix.pop();
        }
        return p;
    }

    public static double Evaluation() {
        return answer;
    }
//    
//public static void main(String[] args) {
//        String input = ""(4+(((4*2)/2)/3))"";
//        
//        Expression test = new Expression();
//        test.Infix2BT(input);
//        print(test.PrintPrefix());
//        print(test.PrintPostfix());        
//        System.out.println(test.Evaluation());        
//    } 
//        
//    public static void print(Node[] pf){
//        for(int i = 0; i < pf.length;i++){
//            System.out.printf(pf[i].getValue()+"" "");
//        }
//        System.out.println();        
//    }        
}

@664f898b019907d787f305650fa4f08e@"
"b02611012","3","0.28","105520","@ad384acb92384cdd7c4f3485b6a681a2@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private static Node root;
    private static Stack<Node> prefix = new Stack<Node>();
    private static Stack<Node> postfix = new Stack<Node>();
    private static Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] temp = infix.split(""(?<=[\\(\\)\\+\\-\\*\\/])|(?=[\\(\\)\\+\\-\\*\\/])"");
        String[] in = new String[temp.length-1];
        for (int i = 0; i < in.length; i++) {
            in[i] = temp[i + 1];
        }
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (aop.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (aop.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (aop.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (aop.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                vals.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        this.prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[count - i] = prefix.pop();
        }
        return p;
    }

    private static void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public static Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = Expression.postfix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[count - i] = postfix.pop();
        }
        return p;
    }

    public static double Evaluation() {
        return answer;
    }
//    
//public static void main(String[] args) {
//        String input = ""(4+(((4*2)/2)/3))"";
//        
//        Expression test = new Expression();
//        test.Infix2BT(input);
//        print(test.PrintPrefix());
//        print(test.PrintPostfix());        
//        System.out.println(test.Evaluation());        
//    } 
//        
//    public static void print(Node[] pf){
//        for(int i = 0; i < pf.length;i++){
//            System.out.printf(pf[i].getValue()+"" "");
//        }
//        System.out.println();        
//    }        
}

@ad384acb92384cdd7c4f3485b6a681a2@"
"b02611012","10","0.099","105568","@379c3ff9a8a28ab4ceb530104d126f4e@
import java.util.ArrayList;
import java.util.Stack;

public class Expression {

    private static Node root;
    private static Stack<Node> prefix = new Stack<Node>();
    private static Stack<Node> postfix = new Stack<Node>();
    private static Double answer;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public static Node Infix2BT(String infix) {
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        Stack<String> aops = new Stack<String>();
        Stack<Double> avals = new Stack<Double>();
        String[] temp = infix.split(""(?<=[\\(\\)\\+\\-\\*\\/])|(?=[\\(\\)\\+\\-\\*\\/])"");
        String[] in = new String[temp.length-1];
        for (int i = 0; i < in.length; i++) {
            in[i] = temp[i + 1];
        }
        for (int i = 0; i < in.length; i++) {
            String s = in[i];
            if (s.equals(""("")) {
                continue;
            } else if (s.equals(""+"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""-"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""*"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals(""/"")) {
                ops.push(new Node(null, null, s));
                aops.push(s);
            } else if (s.equals("")"")) {
                Node op = ops.pop();
                op.setRight(vals.pop());
                op.setLeft(vals.pop());
                if (i == in.length - 1) {
                    root = op;
                } else {
                    vals.push(op);
                }
                String aop = aops.pop();
                if (aop.equals(""+"")) {
                    avals.push(avals.pop() + avals.pop());
                } 
                else if (aop.equals(""-"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b - a);
                }
                else if (aop.equals(""*"")) {
                    avals.push(avals.pop() * avals.pop());
                }
                else if (aop.equals(""/"")) {
                    Double a = avals.pop();
                    Double b = avals.pop();
                    avals.push(b / a);
                }
            } else {
                vals.push(new Node(null, null, s));
                avals.push(Double.parseDouble(s));
            }
        }
        answer = avals.pop();
        return root;
    }

    private void prefix(Node a) {
        this.prefix.push(a);
        if (a.getLeft() != null) {
            prefix(a.getLeft());
        }
        if (a.getRight() != null) {
            prefix(a.getRight());
        }
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        prefix(root);
        int count = this.prefix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[count - 1 - i] = prefix.pop();
        }
        return p;
    }

    private static void postfix(Node a) {
        if (a.getLeft() != null) {
            postfix(a.getLeft());
        }
        if (a.getRight() != null) {
            postfix(a.getRight());
        }
        postfix.push(a);
    }

    public static Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException(""Stack underflow"");
        }
        postfix(root);
        int count = Expression.postfix.size();
        Node[] p = new Node [count];
        for (int i = 0; i < count; i++) {
            p[count - 1 - i] = postfix.pop();
        }
        return p;
    }

    public static double Evaluation() {
        return answer;
    }
    
public static void main(String[] args) {
        String input = ""(4+(((4*2)/2)/3))"";
        
        Expression test = new Expression();
        test.Infix2BT(input);
        print(test.PrintPrefix());
        print(test.PrintPostfix());        
        System.out.println(test.Evaluation());        
    } 
        
    public static void print(Node[] pf){
        for(int i = 0; i < pf.length;i++){
            System.out.printf(pf[i].getValue()+"" "");
        }
        System.out.println();        
    }        
}

@379c3ff9a8a28ab4ceb530104d126f4e@"
"r04522616","1","0.19","105648","@7863f1abbefeeda213a799a3b25eebf8@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      tempRoot.setLeft(a);
                      tempRoot.setRight(b);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          tempRoot.setLeft(tempRoot);
                          tempRoot.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          tempRoot.setLeft(a);
                          tempRoot.setRight(tempRoot);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          tempRoot2.setLeft(a);
                          tempRoot2.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          tempRoot.setLeft(tempRoot);
                          tempRoot.setRight(tempRoot2);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        //preorderPrintTree(root);
        return prefix;
    }
    
//private static void preorderPrintTree(Node root) {
//        if (root.getLeft()==null && root.getRight()==null)
//            System.out.print(root.getValue());
//        else {
//            // interior node -- an operator
//            // first the node itself (the root of the subtree)
//            System.out.print(root.getValue());
//        
////            switch (root.getValue()) {
////                case '+':
////                    System.out.print(""add""); 
////                    break;
////                case '-':
////                    System.out.print(""subtr""); 
////                    break;
////                case '*':
////                    System.out.print(""mult""); 
////                    break;
////                case '/':
////                    System.out.print(""divide""); 
////                    break;
////            }
//            
//            // then the left and right subtrees
//            System.out.print(""("");
//            preorderPrintTree(root.getLeft());
//            System.out.print("", "");
//            preorderPrintTree(root.getRight());
//            System.out.print("")"");
//        }
//    }
  
    public Node[] PrintPostfix(){
        
        Node[] postfix = new Node[outData.length];
        String[] check=new String[outData.length];
        
        Stack<String> stk=new Stack<String>();
        int j=0;
        for(int i=1;i<outData.length;i++)
        {            
            char isANumber=outData[i].charAt(0);
            if(outData[i].equals(""(""))
            {
                j++;
            }
            else if(outData[i].equals("")""))
            {
                String symbol=stk.pop();
                postfix[i-j-1]=new Node(null, null, symbol);
                check[i-j-1]=symbol;
            }
            else if(Character.isDigit(isANumber)!=true && outData[i].equals(""("")!=true && outData[i].equals("")"")!=true)
            {
                j++;
                stk.push(outData[i]);
            }
            else
            {
                Node a=new Node(null, null, outData[i]);
                postfix[i-j-1]=a;
                check[i-j-1]=outData[i];
            }
        }
//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@7863f1abbefeeda213a799a3b25eebf8@"
"r04522616","1","0.19","105616","@068205f2a40efb8a818d2a9dbf0e31c1@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      tempRoot.setLeft(a);
                      tempRoot.setRight(b);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          tempRoot.setLeft(tempRoot);
                          tempRoot.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          tempRoot.setLeft(a);
                          tempRoot.setRight(tempRoot);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          tempRoot2.setLeft(a);
                          tempRoot2.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          tempRoot.setLeft(tempRoot);
                          tempRoot.setRight(tempRoot2);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        //preorderPrintTree(root);
        return prefix;
    }
    
//private static void preorderPrintTree(Node root) {
//        if (root.getLeft()==null && root.getRight()==null)
//            System.out.print(root.getValue());
//        else {
//            // interior node -- an operator
//            // first the node itself (the root of the subtree)
//            System.out.print(root.getValue());
//        
////            switch (root.getValue()) {
////                case '+':
////                    System.out.print(""add""); 
////                    break;
////                case '-':
////                    System.out.print(""subtr""); 
////                    break;
////                case '*':
////                    System.out.print(""mult""); 
////                    break;
////                case '/':
////                    System.out.print(""divide""); 
////                    break;
////            }
//            
//            // then the left and right subtrees
//            System.out.print(""("");
//            preorderPrintTree(root.getLeft());
//            System.out.print("", "");
//            preorderPrintTree(root.getRight());
//            System.out.print("")"");
//        }
//    }
  
    public Node[] PrintPostfix(){
        
        Node[] postfix = new Node[outData.length];
        //String[] check=new String[outData.length];
        
        Stack<String> stk=new Stack<String>();
        int j=0;
        for(int i=1;i<outData.length;i++)
        {            
            char isANumber=outData[i].charAt(0);
            if(outData[i].equals(""(""))
            {
                j++;
            }
            else if(outData[i].equals("")""))
            {
                String symbol=stk.pop();
                postfix[i-j-1]=new Node(null, null, symbol);
                //check[i-j-1]=symbol;
            }
            else if(Character.isDigit(isANumber)!=true && outData[i].equals(""("")!=true && outData[i].equals("")"")!=true)
            {
                j++;
                stk.push(outData[i]);
            }
            else
            {
                Node a=new Node(null, null, outData[i]);
                postfix[i-j-1]=a;
                //check[i-j-1]=outData[i];
            }
        }
//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@068205f2a40efb8a818d2a9dbf0e31c1@"
"r03849033","5","0.48","105536","@93f820b1960c109a63cc517cf66d1ad0@import java.io.BufferedReader;
import java.io.FileReader;
public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;
    public Node[] postfix;
    public Node[] prefix;

private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    // DO NOT MODIFY THIS
    public Expression(){}
    public int size=0;
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(a1) || da[i].equals(a2) || da[i].equals(a3) || da[i].equals(a4) || da[i].equals(a5) || da[i].equals(a6)) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix1 = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=root;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix1[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix1[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        prefix=prefix1;
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        postfix=postfix1;
        return postfix;
    }

    public double Evaluation(){
                if(root==null){ throw new NullPointerException();}
        if(postfix==null){
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  }
        else{
        Stack s = new Stack(postfix.length); 
        for (Node i : postfix) {
            if(i.getValue().equals(a1) ||i.getValue().equals(a2) ||i.getValue().equals(a3) ||i.getValue().equals(a4)){
                Double b1 = Double.parseDouble(s.pop().getValue());
                Double b2 = Double.parseDouble(s.pop().getValue());
                if(i.getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(i.getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(i.getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(i.getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(i);}
        } 
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  }

    }
   
}

@93f820b1960c109a63cc517cf66d1ad0@"
"r03849033","5","0.49","102592","@a668d593875a2b85533eb09729a9398d@
public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;
    public Node[] postfix;
    public Node[] prefix;

private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    // DO NOT MODIFY THIS
    public Expression(){}
    public int size=0;
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(a1) || da[i].equals(a2) || da[i].equals(a3) || da[i].equals(a4) || da[i].equals(a5) || da[i].equals(a6)) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix1 = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=root;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix1[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix1[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        prefix=prefix1;
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        postfix=postfix1;
        return postfix;
    }

    public double Evaluation(){
                if(root==null){ throw new NullPointerException();}
        if(postfix==null){
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  }
        else{
        Stack s = new Stack(postfix.length); 
        for (Node i : postfix) {
            if(i.getValue().equals(a1) ||i.getValue().equals(a2) ||i.getValue().equals(a3) ||i.getValue().equals(a4)){
                Double b1 = Double.parseDouble(s.pop().getValue());
                Double b2 = Double.parseDouble(s.pop().getValue());
                if(i.getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(i.getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(i.getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(i.getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(i);}
        } 
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  }

    }
   
}


@a668d593875a2b85533eb09729a9398d@"
"r03849033","4","0.4","105504","@fe036a01f96b1da9f59ae997dd2f6059@public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;


private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    // DO NOT MODIFY THIS
    public Expression(){}
    public int size=0;
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(a1) || da[i].equals(a2) || da[i].equals(a3) || da[i].equals(a4) || da[i].equals(a5) || da[i].equals(a6)) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix1 = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=root;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix1[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix1[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix1;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=root;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }        
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }
    
}

@fe036a01f96b1da9f59ae997dd2f6059@"
"r04546014","4","1.26","115856","@67ea8ec9eeb388f9b4232140a6b2e5fd@
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;
import java.lang.NullPointerException;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    private List<Node> nodeList = new ArrayList<>();
    private String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix)throws Exception {
        if(infix.isEmpty()) throw new NullPointerException();
        StringBuffer sb = new StringBuffer(infix);//由於近來的資料沒有空格，因此無法使用scanner直接做判斷，在這裡先把字串每一個不同的部分都加入空格，並且刪去左括號
        for (int i = 0; i < sb.length(); i++) {
            String kk = sb.substring(i, i + 1);
            if ( sb.substring(i, i + 1).equals("")"") || sb.substring(i, i + 1).equals(""+"") || sb.substring(i, i + 1).equals(""-"") || sb.substring(i, i + 1).equals(""*"") || sb.substring(i, i + 1).equals(""/"")) {
                sb.insert(i, "" "");
                sb.insert(i + 2, "" "");
                i = i + 2;                
            }
            else if(sb.substring(i, i + 1).equals(""("") ){            
                sb.delete(i,i+1); 
                i--;
            }
            
        }
        infixClone = sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();

        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a, operator, b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node = new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    if(st.size()<3) break; //如果只有一個數字                   
                    b = st.pop();//第一個pop出來是後面的數字b
                    operator = st.pop();//第二個是運算式
                    a = st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node = new Node(null, null, value);
                    st.push(node);
                }
            }
        }
        root = st.pop();
        return root;
    }

    public Node[] PrintPrefix() throws Exception {
        if(root!=null){
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix=new Node[nodeList.size()];
        nodeList.toArray(prefix);//將list轉成array
        return prefix;
        }
        else throw new NullPointerException();
    }

    public Node[] PrintPostfix()throws Exception {
        if(root!=null){
        
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix=new Node[nodeList.size()];
        nodeList.toArray(postfix);//將list轉成array
        return postfix;
        }
        else throw new NullPointerException();
    }

    public double Evaluation() throws Exception {
        if(root!=null){
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a, b;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    if(dou.size()<2){//處理如果只有一個數字的情況
                        answer=dou.pop();
                        break;
                    }
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;                  
        }
        else throw new NullPointerException();
    }

    private void prefixRecursive(Node n) {
        nodeList.add(n);//先儲存再往左往右
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        return;
    }

    private void postfixRecursive(Node n) {
        if (n.getLeft() != null) {
            postfixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            postfixRecursive(n.getRight());
        }
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@67ea8ec9eeb388f9b4232140a6b2e5fd@"
"r04945022","10","0.097","105552","@c1b79bc92a340a65a973d4157a8949a7@
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '-':
                case '+':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPrefixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    
    public void PrintPrefixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPrefixRecusive(p, root.getLeft());
        PrintPrefixRecusive(p, root.getRight());
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> postfix = new ArrayList<Node>();
        PrintPostfixRecusive(postfix, root);
        return postfix.toArray(new Node[postfix.size()]);
    }
    public void PrintPostfixRecusive(List<Node> p, Node root){
        if(root==null) return;
        PrintPostfixRecusive(p, root.getLeft());
        PrintPostfixRecusive(p, root.getRight());
        p.add(root);
    }
    

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] eva = this.PrintPostfix();
        Stack<Double> evalue = new Stack<Double>();
        for(Node n:eva){
            String in = n.getValue();
            if(in.equals(""+"")){
                evalue.push(evalue.pop()+evalue.pop());
            } else if(in.equals(""-"")){
                evalue.push(-evalue.pop()+evalue.pop());
            } else if(in.equals(""*"")){
                evalue.push(evalue.pop()*evalue.pop());
            } else if(in.equals(""/"")){
                evalue.push(1/evalue.pop()*evalue.pop());
            } else {
                evalue.push(Double.parseDouble(in));
            }
            
        }
//        double answer = 0;
        return evalue.pop();
    }
}

@c1b79bc92a340a65a973d4157a8949a7@"
"r04631004","5","0.77","105920","@d0bb928411dd8410f9ddc373a085eac9@/**
 *
 * @author Po-Lin
 */
public class Expression {

    private Node root;
    private char[] a;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        a = infix.toCharArray();
        String[] b = new String[a.length];
        for (int i = 0; i < a.length - 1; i++) {
            b[i] = infix.subSequence(i, i + 1).toString();
            //System.out.println(b[i]);
        }
        root = new Node(null, null, null);
        //若為(1+(1+1))的形式
        Stack<String> stack = new Stack<String>();
        if (b[2].equals(""+"") || b[2].equals(""-"") || b[2].equals(""*"") || b[2].equals(""/"")) {
            root.setValue(b[2]);
            Node temp = new Node(null, null, b[1]);
            root.setLeft(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 3; i < b.length - 1; i++) {
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setRight(connectnode);
        } //若為((1+1)+1)的形式
        else if (b[b.length - 3].equals(""+"") || b[b.length - 3].equals(""-"") || b[b.length - 3].equals(""*"") || b[b.length - 3].equals(""/"")) {
            root.setValue(b[b.length - 3]);
            Node temp = new Node(null, null, b[b.length - 2]);
            root.setRight(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < b.length - 3; i++) {
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
        }//若為((1+1)+(1+1))的形式
        else {
            int rootposition=0;
            for (int i = 0; i < b.length - 1; i++) {
                if(b[i].equals("")"") || b[i+2].equals(""("")){
                    rootposition=i+1;
                    break;
                }
            }
            root.setValue(b[rootposition]);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < rootposition; i++) {  //先連接root左邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
            checknum=0;
            for (int i = rootposition+1; i < b.length-1; i++) {  //再連接root右邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setRight(connectnode);
        }

        return root;
    }

    private void Prefixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        q.enqueue(x);
        Prefixtraversal(x.getLeft(), q);
        Prefixtraversal(x.getRight(), q);
    }

    public Node[] PrintPrefix() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return null;
        }
        Queue<Node> q = new Queue<Node>();
        Prefixtraversal(this.root, q);
        Node[] prefix = new Node[(a.length + 1) / 2];
        for (int i = 0; i < prefix.length; i++) {
            prefix[i] = q.dequeue();
        }
        return prefix;
    }

    private void Postfixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        Postfixtraversal(x.getLeft(), q);
        Postfixtraversal(x.getRight(), q);
        q.enqueue(x);
    }

    public Node[] PrintPostfix() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return null;
        }
        Queue<Node> q = new Queue<Node>();
        Postfixtraversal(this.root, q);
        Node[] postfix = new Node[(a.length + 1) / 2];
        for (int i = 0; i < postfix.length; i++) {
            postfix[i] = q.dequeue();
        }
        return postfix;
    }

    public double Evaluation() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return 0.0;
        }
        Node[] c = this.PrintPostfix();
        Stack<Double> stack = new Stack<Double>();
        for (int i = 0; i < c.length; i++) {
            if (c[i].getValue().equals(""+"") == false && c[i].getValue().equals(""-"") == false && c[i].getValue().equals(""*"") == false && c[i].getValue().equals(""/"") == false) {
                stack.push(Double.valueOf(c[i].getValue()));
            } else {
                double num2 = 0.0;
                double num1 = 0.0;
                switch (c[i].getValue()) {
                    case ""+"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 + num2);
                        break;
                    case ""-"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 - num2);
                        break;
                    case ""*"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 * num2);
                        break;
                    case ""/"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 / num2);
                        break;
                }
            }

        }
        double answer = stack.pop();
        return answer;
    }

    public static void main(String[] args) {
        Expression b = new Expression();
        //  Node a = b.Infix2BT(""(4+(((4*2)/2)/3))"");
        //Node a = b.Infix2BT(""((1+(2+1))+1)"");
         Node a = b.Infix2BT(""((1+1)+(1+1))"");
//        Node[] c = b.PrintPrefix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        System.out.println("" "");
//        c = b.PrintPostfix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        System.out.println("" "");
//        System.out.println(b.Evaluation());
    }

}

@d0bb928411dd8410f9ddc373a085eac9@"
"r04522616","2","0.29","105808","@68ad47adf09037054177361665fcbd17@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
//                      tempRoot.setLeft(a);
//                      tempRoot.setRight(b);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
//                          tempRoot.setLeft(tempRoot);
//                          tempRoot.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
//                          tempRoot.setLeft(a);
//                          tempRoot.setRight(tempRoot);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
//                          tempRoot2.setLeft(a);
//                          tempRoot2.setRight(b);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
//                          tempRoot.setLeft(tempRoot);
//                          tempRoot.setRight(tempRoot2);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        //if (root != null)
        //preorderPrintTree(root);
        return prefix;
    }
    
//private static void preorderPrintTree(Node root) {
//        if (root.getLeft()==null && root.getRight()==null)
//        {
//            System.out.print(root.getValue());
//            root=root.getRight();
//            preorderPrintTree(root);
//        }
//        else 
//        {
//            System.out.print(root.getValue());
//            
//            preorderPrintTree(root.getLeft());
//            
//            preorderPrintTree(root.getRight());            
//        }
//    }
  
    public Node[] PrintPostfix(){
        
        Node[] postfix = new Node[outData.length];
        //String[] check=new String[outData.length];
        
        Stack<String> stk=new Stack<String>();
        int j=0;
        for(int i=1;i<outData.length;i++)
        {            
            char isANumber=outData[i].charAt(0);
            if(outData[i].equals(""(""))
            {
                j++;
            }
            else if(outData[i].equals("")""))
            {
                String symbol=stk.pop();
                postfix[i-j-1]=new Node(null, null, symbol);
                //check[i-j-1]=symbol;
            }
            else if(Character.isDigit(isANumber)!=true && outData[i].equals(""("")!=true && outData[i].equals("")"")!=true)
            {
                j++;
                stk.push(outData[i]);
            }
            else
            {
                Node a=new Node(null, null, outData[i]);
                postfix[i-j-1]=a;
                //check[i-j-1]=outData[i];
            }
        }
//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@68ad47adf09037054177361665fcbd17@"
"r03222054","4","0.63","105536","@ac3f27fe4598c0382f3d943da16b7135@
import java.util.ArrayList;

public class Expression{
    
    public static boolean isOperator(char x)
    {
        if(x =='+' || x=='-' || x=='*' || x=='/'  )
        {
            return true;
        }
        
        else return false;
    }
    
    
        public static boolean isBracket(char x)
    {
        if(x =='(' || x==')'  )
        {
            return true;
        }
        
        else return false;
    }
    
    public ArrayList<String> seperate(String x)
    {
        int count =0;
        ArrayList<String> list = new ArrayList<String>();
        while(!x.isEmpty())
        {
            while(! isOperator(x.charAt(count)) && x.length()>count+1)
            {
                count++;
            }
            if(x.length()==count+1)
            {
                if(!isOperator(x.charAt(x.length()-1)) )
                {
                list.add(x);
                x="""";
                break;
                }
                
                else
                {
                     String value = x.substring(0, count);  
                     list.add(value);
                    list.add(x.substring(x.length()-1, x.length()));
                    x="""";
                }
            }

            else
            {
            if(count==0)
             list.add(x.substring(count,count+1));
            else
            {
            String value = x.substring(0, count);
             list.add(value);
            }
            x = x.substring(count+1, x.length());
            
            count =0;
            }
        }
 
        return list;
       
        
    }

  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix)
    { 
        if(!infix.contains(""(""))
        {
           root = new Node(null,null,infix);
        //    System.out.print(infix+""\n"");
            return root;
        }

       infix =infix.substring(1, infix.length()-1);
       int count = 0;
       int index =0;
       if(infix.contains(""(""))
        {
            for(int i=0; i<infix.length();i++)
            {
              //   System.out.print(i+""shit""+""\n"");
                if( infix.charAt(i) == '(')
                {
                    count++;

                }
                if( infix.charAt(i) == ')')
                {
                    count --;

                }

                if( isOperator(infix.charAt(i)) )
                {
                    if(count ==0)
                    {
                     //   System.out.print(i+""shit"");
                        index =i;
                        break;
                    }
                }

            }
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index));  
    //        System.out.print(value + ""\n"" );

            root = new Node(Infix2BT(left), Infix2BT(right),value);     
             return root;
       }
       
       else
       {

           for(int i = 0; i<infix.length(); i++)
           {
               if(isOperator(infix.charAt(i)))
               {
                   index = i;
                   break;
               }
           }
       //    System.out.print(infix.charAt(index)+""\n"");
           
           if(index != 0)
           {
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index)); 
            root = new Node(Infix2BT(left), Infix2BT(right), value);
             return root;
           }
           else
           {
               Node newNode = new Node(null, null,infix);
               return root;
           }
       } 
    }
private ArrayList<Node>prefixArray = new ArrayList<Node>();
    public void prefixInsert(Node a)
    {
       if(a!=null)
       {
        prefixArray.add(a);
        System.out.print(a.getValue());
        prefixInsert(a.getLeft());
        prefixInsert(a.getRight());
       }
    }
    public Node[] PrintPrefix(){
        Node[] prefix = null;
        
        prefixInsert(root);
        prefix = new Node[prefixArray.size()];
       // System.out
        for(int i =0; i<prefixArray.size();i++)
        {
            prefix[i] = prefixArray.get(i);
        }

        return prefix;
    }
    
    private ArrayList<Node>postfixArray = new ArrayList<Node>();
    public void postfixInsert(Node a)
    {
       if(a!=null)
       {
        postfixInsert(a.getLeft());
        postfixInsert(a.getRight());
        postfixArray.add(a);
       }
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;       
       postfixInsert(root);
       postfix= new Node[postfixArray.size()];
        for(int i =0; i<postfixArray.size();i++)
        {
         //   System.out.print(postfixArray.get(i).getValue());
            postfix[i] = postfixArray.get(i);
        }

        return postfix;
    }

    public double Evaluation(){
        
        double answer = 0;
       ArrayList<String> array =new ArrayList<String>();
        for(int i=0; i<postfixArray.size(); i++)
        {
            array.add(postfixArray.get(i).getValue());
        }
        
        while(array.size()!=1)
        {
            for(int i =0; i<array.size(); i++)
            {
                if(isOperator(array.get(i).charAt(0)))
                {
                    char operator = array.get(i).charAt(0);
                    double val1 = Double.parseDouble(array.get(i-2));
                    double val2 = Double.parseDouble(array.get(i-1));
                    double temp=0;
                    if(operator == '+')
                        temp = val1+val2;
                     if(operator == '-')
                        temp = val1-val2;
                     if(operator == '*')
                        temp = val1*val2;
                     if(operator == '/')
                        temp = val1/val2;
                     
                     array.set(i, Double.toString(temp));
                     array.remove(i-1);
                     array.remove(i-2);
                     break;
                }
            }
        }
        answer = Double.parseDouble(array.get(0));
        
        return answer;
       
        
        
    }
    
    public static void main(String[] args)
    {
        String str = ""(4+(((4*2)/2)/3))"";
        Expression test =new Expression();
        test.Infix2BT(str);
        test.PrintPostfix();
        System.out.print(test.Evaluation());

    }
}

@ac3f27fe4598c0382f3d943da16b7135@"
"r03222054","1","0.89","105520","@7b3b5ceb138796ba890e9c7255cb4479@
import java.util.ArrayList;

public class Expression{
    
    public static boolean isOperator(char x)
    {
        if(x =='+' || x=='-' || x=='*' || x=='/'  )
        {
            return true;
        }
        
        else return false;
    }
    
    
        public static boolean isBracket(char x)
    {
        if(x =='(' || x==')'  )
        {
            return true;
        }
        
        else return false;
    }
    
    public ArrayList<String> seperate(String x)
    {
        int count =0;
        ArrayList<String> list = new ArrayList<String>();
        while(!x.isEmpty())
        {
            while(! isOperator(x.charAt(count)) && x.length()>count+1)
            {
                count++;
            }
            if(x.length()==count+1)
            {
                if(!isOperator(x.charAt(x.length()-1)) )
                {
                list.add(x);
                x="""";
                break;
                }
                
                else
                {
                     String value = x.substring(0, count);  
                     list.add(value);
                    list.add(x.substring(x.length()-1, x.length()));
                    x="""";
                }
            }

            else
            {
            if(count==0)
             list.add(x.substring(count,count+1));
            else
            {
            String value = x.substring(0, count);
             list.add(value);
            }
            x = x.substring(count+1, x.length());
            
            count =0;
            }
        }
 
        return list;
       
        
    }

  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix)
    { 
        if(!infix.contains(""(""))
        {
           root = new Node(null,null,infix);
        //    System.out.print(infix+""\n"");
            return root;
        }

       infix =infix.substring(1, infix.length()-1);
       int count = 0;
       int index =0;
       if(infix.contains(""(""))
        {
            for(int i=0; i<infix.length();i++)
            {
              //   System.out.print(i+""shit""+""\n"");
                if( infix.charAt(i) == '(')
                {
                    count++;

                }
                if( infix.charAt(i) == ')')
                {
                    count --;

                }

                if( isOperator(infix.charAt(i)) )
                {
                    if(count ==0)
                    {
                     //   System.out.print(i+""shit"");
                        index =i;
                        break;
                    }
                }

            }
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index));  
    //        System.out.print(value + ""\n"" );

            root = new Node(Infix2BT(left), Infix2BT(right),value);     
             return root;
       }
       
       else
       {

           for(int i = 0; i<infix.length(); i++)
           {
               if(isOperator(infix.charAt(i)))
               {
                   index = i;
                   break;
               }
           }
       //    System.out.print(infix.charAt(index)+""\n"");
           
           if(index != 0)
           {
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index)); 
            root = new Node(Infix2BT(left), Infix2BT(right), value);
             return root;
           }
           else
           {
               Node newNode = new Node(null, null,infix);
               return root;
           }
       } 
    }
private ArrayList<Node>prefixArray = new ArrayList<Node>();
    public void prefixInsert(Node a)
    {
       if(a!=null)
       {
        prefixArray.add(a);
        System.out.print(a.getValue());
        prefixInsert(a.getLeft());
        prefixInsert(a.getRight());
       }
    }
    public Node[] PrintPrefix(){
        Node[] prefix = null;
        
        prefixInsert(root);
        prefix = new Node[prefixArray.size()];
       // System.out
        for(int i =0; i<prefixArray.size();i++)
        {
            prefix[i] = prefixArray.get(i);
        }

        return prefix;
    }
    
    private ArrayList<Node>postfixArray = new ArrayList<Node>();
    public void postfixInsert(Node a)
    {
       if(a!=null)
       {
        postfixInsert(a.getLeft());
        postfixInsert(a.getRight());
        postfixArray.add(a);
       }
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;       
       postfixInsert(root);
       postfix= new Node[postfixArray.size()];
        for(int i =0; i<postfixArray.size();i++)
        {
            System.out.print(postfixArray.get(i).getValue());
            postfix[i] = postfixArray.get(i);
        }

        return postfix;
    }

    public double Evaluation(){
         postfixInsert(root);
        double answer = 0;
       ArrayList<String> array =new ArrayList<String>();
        for(int i=0; i<postfixArray.size(); i++)
        {
            array.add(postfixArray.get(i).getValue());
        }
        
        while(array.size()!=1)
        {
            
            for(int i =0; i<array.size(); i++)
            {
                if(isOperator(array.get(i).charAt(0)))
                {
                    char operator = array.get(i).charAt(0);
                    double val1 = Double.parseDouble(array.get(i-2));
                    double val2 = Double.parseDouble(array.get(i-1));
                    double temp=0;
                    if(operator == '+')
                        temp = val1+val2;
                     if(operator == '-')
                        temp = val1-val2;
                     if(operator == '*')
                        temp = val1*val2;
                     if(operator == '/')
                        temp = val1/val2;
                     
                     array.set(i, Double.toString(temp));
                     array.remove(i-1);
                     array.remove(i-2);
                     break;
                }
            }
        }
        answer = Double.parseDouble(array.get(0));
        System.out.print(answer);
        return answer;
       
        
        
    }
    
    public static void main(String[] args)
    {
        String str = ""((20120224791*(121259+797912))+(211544771212/2))"";
        Expression test =new Expression();
        test.Infix2BT(str);
        //test.PrintPostfix();
      //  System.out.print(""\n"");
        //test.PrintPrefix();
       // System.out.print(""\n"");
       test.Evaluation();

    }
}

@7b3b5ceb138796ba890e9c7255cb4479@"
"r03222054","1","0.85","105520","@51db60c2a22853f1d3e2b0ef3699545e@
import java.util.ArrayList;

public class Expression{
    
    public static boolean isOperator(char x)
    {
        if(x =='+' || x=='-' || x=='*' || x=='/'  )
        {
            return true;
        }
        
        else return false;
    }
    
    
        public static boolean isBracket(char x)
    {
        if(x =='(' || x==')'  )
        {
            return true;
        }
        
        else return false;
    }
    
    public ArrayList<String> seperate(String x)
    {
        int count =0;
        ArrayList<String> list = new ArrayList<String>();
        while(!x.isEmpty())
        {
            while(! isOperator(x.charAt(count)) && x.length()>count+1)
            {
                count++;
            }
            if(x.length()==count+1)
            {
                if(!isOperator(x.charAt(x.length()-1)) )
                {
                list.add(x);
                x="""";
                break;
                }
                
                else
                {
                     String value = x.substring(0, count);  
                     list.add(value);
                    list.add(x.substring(x.length()-1, x.length()));
                    x="""";
                }
            }

            else
            {
            if(count==0)
             list.add(x.substring(count,count+1));
            else
            {
            String value = x.substring(0, count);
             list.add(value);
            }
            x = x.substring(count+1, x.length());
            
            count =0;
            }
        }
 
        return list;
       
        
    }

  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix)
    { 
        if(!infix.contains(""(""))
        {
           root = new Node(null,null,infix);
        //    System.out.print(infix+""\n"");
            return root;
        }

       infix =infix.substring(1, infix.length()-1);
       int count = 0;
       int index =0;
       if(infix.contains(""(""))
        {
            for(int i=0; i<infix.length();i++)
            {
              //   System.out.print(i+""shit""+""\n"");
                if( infix.charAt(i) == '(')
                {
                    count++;

                }
                if( infix.charAt(i) == ')')
                {
                    count --;

                }

                if( isOperator(infix.charAt(i)) )
                {
                    if(count ==0)
                    {
                     //   System.out.print(i+""shit"");
                        index =i;
                        break;
                    }
                }

            }
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index));  
    //        System.out.print(value + ""\n"" );

            root = new Node(Infix2BT(left), Infix2BT(right),value);     
             return root;
       }
       
       else
       {

           for(int i = 0; i<infix.length(); i++)
           {
               if(isOperator(infix.charAt(i)))
               {
                   index = i;
                   break;
               }
           }
       //    System.out.print(infix.charAt(index)+""\n"");
           
           if(index != 0)
           {
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index)); 
            root = new Node(Infix2BT(left), Infix2BT(right), value);
             return root;
           }
           else
           {
               Node newNode = new Node(null, null,infix);
               return root;
           }
       } 
    }
private ArrayList<Node>prefixArray = new ArrayList<Node>();
    public void prefixInsert(Node a)
    {
       if(a!=null)
       {
        prefixArray.add(a);
        System.out.print(a.getValue());
        prefixInsert(a.getLeft());
        prefixInsert(a.getRight());
       }
    }
    public Node[] PrintPrefix(){
        Node[] prefix = null;
        
        prefixInsert(root);
        prefix = new Node[prefixArray.size()];
       // System.out
        for(int i =0; i<prefixArray.size();i++)
        {
            prefix[i] = prefixArray.get(i);
        }

        return prefix;
    }
    
    private ArrayList<Node>postfixArray = new ArrayList<Node>();
    public void postfixInsert(Node a)
    {
       if(a!=null)
       {
        postfixInsert(a.getLeft());
        postfixInsert(a.getRight());
        postfixArray.add(a);
       }
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix; 
        postfixArray.clear();
       postfixInsert(root);
       postfix= new Node[postfixArray.size()];
        for(int i =0; i<postfixArray.size();i++)
        {
            System.out.print(postfixArray.get(i).getValue());
            postfix[i] = postfixArray.get(i);
        }

        return postfix;
    }

    public double Evaluation(){
         postfixArray.clear();
         postfixInsert(root);
        double answer = 0;
       ArrayList<String> array =new ArrayList<String>();
        for(int i=0; i<postfixArray.size(); i++)
        {
            array.add(postfixArray.get(i).getValue());
        }
        
        while(array.size()!=1)
        {
            
            for(int i =0; i<array.size(); i++)
            {
                if(isOperator(array.get(i).charAt(0)))
                {
                    char operator = array.get(i).charAt(0);
                    double val1 = Double.parseDouble(array.get(i-2));
                    double val2 = Double.parseDouble(array.get(i-1));
                    double temp=0;
                    if(operator == '+')
                        temp = val1+val2;
                     if(operator == '-')
                        temp = val1-val2;
                     if(operator == '*')
                        temp = val1*val2;
                     if(operator == '/')
                        temp = val1/val2;
                     
                     array.set(i, Double.toString(temp));
                     array.remove(i-1);
                     array.remove(i-2);
                     break;
                }
            }
        }
        answer = Double.parseDouble(array.get(0));
        System.out.print(answer);
        return answer;
       
        
        
    }
    
    public static void main(String[] args)
    {
        String str = ""((20120224791*(121259+797912))+(211544771212/2))"";
        Expression test =new Expression();
        test.Infix2BT(str);
        test.PrintPostfix();
      //  System.out.print(""\n"");
        test.PrintPrefix();
       // System.out.print(""\n"");
       test.Evaluation();

    }
}

@51db60c2a22853f1d3e2b0ef3699545e@"
"r04921105","6","0.79","105952","@bcec7ad3654286b3346c51663946de2c@
import java.util.ArrayList;
import java.util.List;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();        
        Stack<Node> vals = new Stack<Node>();
        boolean flag =false;
        String[] input = infix.split("""");
         for(int i=0;i<input.length;i++){
            String s = input[i];
            //System.out.println(s);
            switch(s){
                case(""(""):
                    flag=false;
                    break;
                   
            case(""+""):
                //else if (s.equals(""+"") || s.equals(""-"") || s.equals(""*"") || s.equals(""/""))
                //Node ops =(null,null,s);          
            case(""-""):
            case(""*""):
            case(""/""):
                ops.push(new Node(null,null,s));
                flag=false;
                break;
                
            case("")""):               
                //vals.pop();
                //vals.pop();              
                //ops.pop();
                String val =ops.pop().getValue();
                
                //new Node(vals.pop(),vals.pop(),ss);
                Node r = vals.pop();
                Node l = vals.pop();
                vals.push(new Node(l,r,val));
                flag=false;
                //System.out.println(val);
                break;
            default:
                if(flag==false){
                vals.push(new Node(null,null,s));
                flag=true;
                }
                else if(flag==true){
                    String f1=vals.pop().getValue();
                    //System.out.println(f1);
                 vals.push(new Node(null,null,f1+s));
                 //System.out.println(f1+s);                
                }                
                break;

            }//end of switch              
         }//end of for
        root = vals.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> prefix;
        prefix = new ArrayList<>();
        get_prefix(prefix,root);

        return prefix.toArray(new Node[prefix.size()]);
    }
  
    public Node[] PrintPostfix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> postfix;
        postfix = new ArrayList<>();
        get_postfix(postfix,root);

        return postfix.toArray(new Node[postfix.size()]);
    }

    public double Evaluation(){
        if(root==null)
            throw new NullPointerException();        
       // switch()       
        return evaluate(root);
    }

    private void get_prefix(List<Node> a,Node b) {
        if(b==null)
            return;
            a.add(b);
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
    }
    private void get_postfix(List<Node> a,Node b) {
        if(b==null)
            return;
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
            a.add(b);
    }

    private double evaluate(Node root) {
        switch(root.getValue()){
            case""+"":
                return evaluate(root.getLeft())+evaluate(root.getRight());
            case""-"":
                return evaluate(root.getLeft())-evaluate(root.getRight());
            case""*"":
                return evaluate(root.getLeft())*evaluate(root.getRight());
            case""/"":
                return evaluate(root.getLeft())/evaluate(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }                        
        
       
    }
}

@bcec7ad3654286b3346c51663946de2c@"
"r03222054","9","0.88","105616","@6b14f5c3c61e3167366ff3d20032d235@
import java.util.ArrayList;

public class Expression{
    
    public static boolean isOperator(char x)
    {
        if(x =='+' || x=='-' || x=='*' || x=='/'  )
        {
            return true;
        }
        
        else return false;
    }
    
    
        public static boolean isBracket(char x)
    {
        if(x =='(' || x==')'  )
        {
            return true;
        }
        
        else return false;
    }
    
    public ArrayList<String> seperate(String x)
    {
        int count =0;
        ArrayList<String> list = new ArrayList<String>();
        while(!x.isEmpty())
        {
            while(! isOperator(x.charAt(count)) && x.length()>count+1)
            {
                count++;
            }
            if(x.length()==count+1)
            {
                if(!isOperator(x.charAt(x.length()-1)) )
                {
                list.add(x);
                x="""";
                break;
                }
                
                else
                {
                     String value = x.substring(0, count);  
                     list.add(value);
                    list.add(x.substring(x.length()-1, x.length()));
                    x="""";
                }
            }

            else
            {
            if(count==0)
             list.add(x.substring(count,count+1));
            else
            {
            String value = x.substring(0, count);
             list.add(value);
            }
            x = x.substring(count+1, x.length());
            
            count =0;
            }
        }
 
        return list;
       
        
    }

  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix)
    { 
        if(!infix.contains(""(""))
        {
           root = new Node(null,null,infix);
        //    System.out.print(infix+""\n"");
            return root;
        }

       infix =infix.substring(1, infix.length()-1);
       int count = 0;
       int index =0;
       if(infix.contains(""(""))
        {
            for(int i=0; i<infix.length();i++)
            {
              //   System.out.print(i+""shit""+""\n"");
                if( infix.charAt(i) == '(')
                {
                    count++;

                }
                if( infix.charAt(i) == ')')
                {
                    count --;

                }

                if( isOperator(infix.charAt(i)) )
                {
                    if(count ==0)
                    {
                     //   System.out.print(i+""shit"");
                        index =i;
                        break;
                    }
                }

            }
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index));  
    //        System.out.print(value + ""\n"" );

            root = new Node(Infix2BT(left), Infix2BT(right),value);     
             return root;
       }
       
       else
       {

           for(int i = 0; i<infix.length(); i++)
           {
               if(isOperator(infix.charAt(i)))
               {
                   index = i;
                   break;
               }
           }
       //    System.out.print(infix.charAt(index)+""\n"");
           
           if(index != 0)
           {
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index)); 
            root = new Node(Infix2BT(left), Infix2BT(right), value);
             return root;
           }
           else
           {
               Node newNode = new Node(null, null,infix);
               return root;
           }
       } 
    }
private ArrayList<Node>prefixArray = new ArrayList<Node>();
    public void prefixInsert(Node a)
    {
       if(a!=null)
       {
        prefixArray.add(a);
     //   System.out.print(a.getValue());
        prefixInsert(a.getLeft());
        prefixInsert(a.getRight());
       }
    }
    public Node[] PrintPrefix(){
        Node[] prefix = null;
        
        prefixInsert(root);
        prefix = new Node[prefixArray.size()];
       // System.out
        for(int i =0; i<prefixArray.size();i++)
        {
            prefix[i] = prefixArray.get(i);
        }

        return prefix;
    }
    
    private ArrayList<Node>postfixArray = new ArrayList<Node>();
    public void postfixInsert(Node a)
    {
       if(a!=null)
       {
        postfixInsert(a.getLeft());
        postfixInsert(a.getRight());
        postfixArray.add(a);
       }
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix; 
        postfixArray.clear();
       postfixInsert(root);
       postfix= new Node[postfixArray.size()];
        for(int i =0; i<postfixArray.size();i++)
        {
            //System.out.print(postfixArray.get(i).getValue());
            postfix[i] = postfixArray.get(i);
        }

        return postfix;
    }

    public double Evaluation(){
         postfixArray.clear();
         postfixInsert(root);
        double answer = 0;
       ArrayList<String> array =new ArrayList<String>();
        for(int i=0; i<postfixArray.size(); i++)
        {
            array.add(postfixArray.get(i).getValue());
        }
        
        while(array.size()!=1)
        {
            
            for(int i =0; i<array.size(); i++)
            {
                if(isOperator(array.get(i).charAt(0)))
                {
                    char operator = array.get(i).charAt(0);
                    double val1 = Double.parseDouble(array.get(i-2));
                    double val2 = Double.parseDouble(array.get(i-1));
                    double temp=0;
                    if(operator == '+')
                        temp = val1+val2;
                     if(operator == '-')
                        temp = val1-val2;
                     if(operator == '*')
                        temp = val1*val2;
                     if(operator == '/')
                        temp = val1/val2;
                     
                     array.set(i, Double.toString(temp));
                     array.remove(i-1);
                     array.remove(i-2);
                     break;
                }
            }
        }
        answer = Double.parseDouble(array.get(0));
       // System.out.print(answer);
        return answer;
       
        
        
    }
    
    public static void main(String[] args)
    {
        String str = ""(4+(((4*2)/2)/3))"";
        Expression test =new Expression();
        test.Infix2BT(str);
        test.PrintPostfix();
      //  System.out.print(""\n"");
        test.PrintPrefix();
       // System.out.print(""\n"");
       test.Evaluation();

    }
}

@6b14f5c3c61e3167366ff3d20032d235@"
"b01502105","10","0.098","105856","@c3a07ee0458411c413e476a3b54d27fb@
import java.io.BufferedReader;
import java.io.FileReader;

public class Expression {

    private Node root;
    private double ans;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        
        Stack<String> operator = new Stack<String>();
        Stack<Double> value = new Stack<Double>();
        Stack<Node> node = new Stack<Node>();
        int flag = 0;  //when dealing with num, flag = 1
        int first_index = 0;
        
        for(int i=0;i<infix.length();i++){
            
            int charAscii = (int)infix.charAt(i);   
            if(flag == 1 && !((charAscii>=48 && charAscii<=57)||(charAscii==46)) ){  // back to symbol, need tp push num
                String s = infix.substring(first_index, i);
                value.push(Double.parseDouble(s));
                node.push(new Node(null,null,s));
                flag = 0;
            }
            if(infix.charAt(i) == '('); 
            else if(infix.charAt(i) == '+') { operator.push(infix.substring(i,i+1)); }
            else if(infix.charAt(i) == '-') { operator.push(infix.substring(i,i+1)); }
            else if(infix.charAt(i) == '*') { operator.push(infix.substring(i,i+1)); }
            else if(infix.charAt(i) == '/') { operator.push(infix.substring(i,i+1)); }
            else if(infix.charAt(i) == ')') {
                Node right = node.pop();
                Node left = node.pop();
                String op = operator.pop();
                Node new_node = new Node(left,right,op);
                node.push(new_node);
                
                if (op.equals(""+"")) {value.push(value.pop() + value.pop());} 
                else if (op.equals(""*"")) {value.push(value.pop() * value.pop());}
                else if (op.equals(""-"")) {
                    double temp_1 = value.pop();
                    double temp_2 = value.pop();
                    value.push(temp_2 - temp_1);
                } 
                else if (op.equals(""/"")) {
                    double temp_1 = value.pop();
                    double temp_2 = value.pop();
                    value.push(temp_2 / temp_1);
                }
            }
            else if((charAscii>=48 && charAscii<=57)||(charAscii==46)){ 
                if(flag == 0){
                    first_index = i;
                    flag = 1;
                }
            }
            else {System.out.printf(""Input wrong!""); }
        }
        this.root = node.pop();
        this.ans = value.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null){throw new NullPointerException();}
        Queue<Node> q = new Queue<Node>();
        Preorder(root,q);
        int size = q.size();
        Node[] prefix = new Node[size];
        for(int i=0;i<size;i++){
            prefix[i]=q.dequeue();
        }      
        return prefix;
    }

    public void Preorder (Node node, Queue<Node> q){
        if(node == null) { return; }
        q.enqueue(node);
        Preorder(node.getLeft(),q);
        Preorder(node.getRight(),q);
    }
    
    public Node[] PrintPostfix(){
        if(root == null){throw new NullPointerException();}
        Queue<Node> q = new Queue<Node>();
        Postorder(root,q);
        int size = q.size();
        Node[] postfix = new Node[size];
        for(int i=0;i<size;i++){
            postfix[i]=q.dequeue();
        }
        return postfix;
    }
    
    public void Postorder (Node node, Queue<Node> q){
        if(node == null) { return; }
        Postorder(node.getLeft(),q);
        Postorder(node.getRight(),q);
        q.enqueue(node);
    }
    
    public double Evaluation(){
        if(root == null){throw new NullPointerException();}
        double answer = this.ans;
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
        
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            
            String line = br.readLine();
            Expression exp = new Expression();

            Node[] prefix = exp.PrintPrefix();
            Node[] postfix = exp.PrintPostfix();

            System.out.printf(""preorder Traversal = "");
            for(int i=0;i<prefix.length;i++){
                System.out.printf(prefix[i].getValue()+"" "");
            }
            System.out.printf(""\n"");
            System.out.printf(""postorder Traversal = "");
            for(int i=0;i<postfix.length;i++){
                System.out.printf(postfix[i].getValue()+"" "");
            }
            System.out.printf(""\n"");
            System.out.println(""ans = "" + exp.Evaluation());
        }
    }
    
}

@c3a07ee0458411c413e476a3b54d27fb@"
"r04631004","0","0.19","105312","@eb37844359968c27a8a04a4bad682cb5@public class Expression {

    private Node root;
    private String[] b;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] a = infix.toCharArray();
        String[] tempb = new String[a.length];
        int arraysize = 0;
        for (int i = 0; i < a.length - 1; i++) {
            tempb[i] = infix.subSequence(i, i + 1).toString();
            int tempcount = i;
            if (tempb[i].equals(""+"") == false && tempb[i].equals(""-"") == false && tempb[i].equals(""*"") == false && tempb[i].equals(""/"") == false && tempb[i].equals(""("") == false && tempb[i].equals("")"") == false) {
                for (int j = i + 1; j < a.length - 1; j++) {
                    String tempbb = infix.subSequence(j, j + 1).toString();
                    if (tempbb.equals(""+"") == false && tempbb.equals(""-"") == false && tempbb.equals(""*"") == false && tempbb.equals(""/"") == false && tempbb.equals(""("") == false && tempbb.equals("")"") == false) {
                        tempcount = j;
                    } else {
                        break;
                    }
                }

                if (tempcount != i) {
                    tempb[i] = infix.subSequence(i, tempcount + 1).toString();
                    i = tempcount;
                }
            }
            arraysize++;
        }
        int idx = 0;
        b = new String[arraysize];
        for (int i = 0; i < tempb.length; i++) {
            if (tempb[i] != null) {
                b[idx] = tempb[i];
                idx++;
            }
        }

        root = new Node(null, null, null);
        //若為(1+(1+1))的形式
        Stack<String> stack = new Stack<String>();
        if (b[2].equals(""+"") || b[2].equals(""-"") || b[2].equals(""*"") || b[2].equals(""/"")) {
            root.setValue(b[2]);
            Node temp = new Node(null, null, b[1]);
            root.setLeft(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            if ((b.length - 1 - 3) >= 3) {
                for (int i = 3; i < b.length - 1; i++) {
                    if (checknum == 0) {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {

                            String rightvalue = stack.pop();
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                            checknum = 1;

                        }
                    } else {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {
                            String in = stack.pop();
                            if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                                String operator = in;
                                String leftvalue = stack.pop();
                                Node lefttemp = new Node(null, null, leftvalue);
                                Node temproot = new Node(lefttemp, connectnode, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            } else {
                                String rightvalue = in;
                                Node righttemp = new Node(null, null, rightvalue);
                                String operator = stack.pop();
                                Node temproot = new Node(connectnode, righttemp, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            }
                        }
                    }
                }
                root.setRight(connectnode);
            } else {
                temp = new Node(null, null, b[3]);
                root.setRight(temp);
            }
        } //若為((1+1)+1)的形式
        else if (b[b.length
                - 3].equals(
                        ""+"") || b[b.length - 3].equals(""-"") || b[b.length - 3].equals(""*"") || b[b.length - 3].equals(""/"")) {
            root.setValue(b[b.length - 3]);
            Node temp = new Node(null, null, b[b.length - 2]);
            root.setRight(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < b.length - 3; i++) {
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
        }//若為((1+1)+(1+1))的形式
        else {
            int rootposition = 0;
            for (int i = 0; i < b.length - 1; i++) {
                if (b[i].equals("")"") || b[i + 2].equals(""("")) {
                    rootposition = i + 1;
                    break;
                }
            }
            root.setValue(b[rootposition]);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < rootposition; i++) {  //先連接root左邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
            checknum = 0;
            for (int i = rootposition + 1; i < b.length - 1; i++) {  //再連接root右邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setRight(connectnode);
        }

        return root;
    }

    private void Prefixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        q.enqueue(x);
        Prefixtraversal(x.getLeft(), q);
        Prefixtraversal(x.getRight(), q);
    }

    public Node[] PrintPrefix() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return null;
        }
        Queue<Node> q = new Queue<Node>();
        Prefixtraversal(this.root, q);
        Node[] prefix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < prefix.length; i++) {
            prefix[i] = q.dequeue();
        }
        return prefix;
    }

    private void Postfixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        Postfixtraversal(x.getLeft(), q);
        Postfixtraversal(x.getRight(), q);
        q.enqueue(x);
    }

    public Node[] PrintPostfix() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return null;
        }
        Queue<Node> q = new Queue<Node>();
        Postfixtraversal(this.root, q);
        Node[] postfix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < postfix.length; i++) {
            postfix[i] = q.dequeue();
        }
        return postfix;
    }

    public double Evaluation() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return 0.0;
        }
        Node[] c = this.PrintPostfix();
        Stack<Double> stack = new Stack<Double>();
        for (int i = 0; i < c.length; i++) {
            if (c[i].getValue().equals(""+"") == false && c[i].getValue().equals(""-"") == false && c[i].getValue().equals(""*"") == false && c[i].getValue().equals(""/"") == false) {
                stack.push(Double.valueOf(c[i].getValue()));
            } else {
                double num2 = 0.0;
                double num1 = 0.0;
                switch (c[i].getValue()) {
                    case ""+"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 + num2);
                        break;
                    case ""-"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 - num2);
                        break;
                    case ""*"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 * num2);
                        break;
                    case ""/"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 / num2);
                        break;
                }
            }

        }
        double answer = stack.pop();
        return answer;
    }

    public static void main(String[] args) {
        //       Expression b = new Expression();
        //Node a = b.Infix2BT(""(4+(((4*2)/2)/3))"");
        //       Node a = b.Infix2BT(""(12+12)"");
        //        Node a = b.Infix2BT(""((1+1)+(1+1))"");
//        Node[] c = b.PrintPrefix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        System.out.println("" "");
//               c = b.PrintPostfix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        b.Evaluation();
//        System.out.println("" "");
//        System.out.println(b.Evaluation());

    }
}

@eb37844359968c27a8a04a4bad682cb5@"
"r03849033","5","0.49","105520","@71e07e3d98af87f5b4ed73be19608789@public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;


private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    // DO NOT MODIFY THIS
    public Expression(){}
    public int size=0;
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(a1) || da[i].equals(a2) || da[i].equals(a3) || da[i].equals(a4) || da[i].equals(a5) || da[i].equals(a6)) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }
}

@71e07e3d98af87f5b4ed73be19608789@"
"r04921065","9","0.86","105824","@4d210cb041b168a531417b26465403f4@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Expression{
  
    private Node root;
    public int eleSize = 0;
    public int size = 1;
    public int porder = 0;
    public Node[] p;
    
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        int count_r=0;
        int count =0;
        int sidelo = 0;
        int lengthB = infix.length();
        char[] ch = new char[lengthB]; // char array
        for (int i = 0;i<lengthB;i++){
            ch[i] = infix.charAt(i);
            if ( ch[i]==')' ) count_r++;
        }
        //System.out.println(ch.length);
        eleSize =  count_r*2+1; // not include ""("" and　"")""
        String[] str = new String[4*count_r+1];  // string array
        
           for(int i = 0;i<lengthB;i++){
               if (ch[i]=='('||ch[i]==')'||ch[i]=='+'||ch[i]=='-'||ch[i]=='*'||ch[i]=='/'){
                   str[count] = String.valueOf(ch[i]);
                   count++;}
               else if (ch[i-1]=='('||ch[i-1]==')'||ch[i-1]=='+'||ch[i-1]=='-'||ch[i-1]=='*'||ch[i-1]=='/'){ // maybe integer or float
                   sidelo = i; // float left bound
                   if (ch[i+1]=='('||ch[i+1]==')'||ch[i+1]=='+'||ch[i+1]=='-'||ch[i+1]=='*'||ch[i+1]=='/'){ // integer
                       str[count] = String.valueOf(ch[i]);
                       count++;
                   }
               }
               else if (ch[i+1]=='('||ch[i+1]==')'||ch[i+1]=='+'||ch[i+1]=='-'||ch[i+1]=='*'||ch[i+1]=='/'){
                   String t = """";//initialization
                   for (int j = sidelo;j<i+1;j++){
                       t = t + String.valueOf(ch[j]);
                   }
                   //System.out.println(count);
                   str[count] = t;
                   count++;
               }
             }
        
        
        //System.out.println(str.length);
        int lengthA = str.length;
        Stack<String> ops = new Stack<String>();
        Stack<Node> val = new Stack<Node>();
        
        // binary tree
        for (int i=0;i<lengthA;i++){
            String temp = str[i];
            if (temp.equals(""(""));
            else if (temp.equals(""+"")|| temp.equals(""-"")||temp.equals(""/"")||temp.equals(""*""))
                ops.push(temp);
            else if (temp.equals("")"")){
                size +=2; // element number: 1.最裡面括號以外 2.不含括號
                Node right = val.pop();
                Node left = val.pop();
                Node N = new Node(left,right,ops.pop());
                root = N;
                val.push(N);
            }
            else 
                val.push(new Node(null,null,temp));
         }
        //System.out.println(size);
        //System.out.println(eleSize);
        return root;
    }
    

    public Node[] PrintPrefix(){ //自己->左->右
//        Node[] prefix = null;
        if (root==null){
            throw new NullPointerException();
        }
        int order = 0;
        Node[] prefix = new Node[eleSize];
        Stack<Node> pre = new Stack<Node>();
        pre.push(root);
        while (!pre.isEmpty()){
            Node n = pre.pop();
            prefix[order] = n;
            order++;
            if (n.getRight()!=null)
                pre.push(n.getRight());
            if (n.getLeft()!=null)
                pre.push(n.getLeft());
        }
        return prefix;
    }
  
    public void postOrder(Node input){
        if (input!=null){
            postOrder(input.getLeft());
            postOrder(input.getRight());
            p[porder] = input;
            porder++;
        }
    }
    
    public Node[] PrintPostfix(){ // 左->右->自己
        //Node[] postfix = null;
        Node[] postfix = new Node[eleSize];
        if (root ==null){
            throw new NullPointerException();
        }
        //System.out.println(porder);
        //porder = 0;
        p = new Node[eleSize];
        postOrder(root);
        //System.out.println(porder);
        for (int i=0;i<eleSize;i++){
            postfix[i]=p[i];
        }
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        if (root == null) {
            throw new NullPointerException();
        }
        Stack<String> stack = new Stack<String>(); // 只用來存數值，不存operaters
        Node[] E = PrintPostfix();
        String v1;
        String v2;
        String v;
        double an;
        for (int i=0;i<E.length;i++){
            String temp = E[i].getValue();
            if (temp.equals(""+"")){
                v2 = stack.pop();
                v1 = stack.pop();
                an = Double.parseDouble(v2)+Double.parseDouble(v1);
                v = String.valueOf(an);
                stack.push(v);
            }
            else if (temp.equals(""-"")){
                v2 = stack.pop();
                v1 = stack.pop();
                an = Double.parseDouble(v1)-Double.parseDouble(v2);
                v = String.valueOf(an);
                stack.push(v);
            }
            else if (temp.equals(""*"")){
                v2 = stack.pop();
                v1 = stack.pop();
                an = Double.parseDouble(v1)*Double.parseDouble(v2);
                v = String.valueOf(an);
                stack.push(v);
            }
            else if (temp.equals(""/"")){
                v2 = stack.pop();
                v1 = stack.pop();
                an = Double.parseDouble(v1)/Double.parseDouble(v2);
                v = String.valueOf(an);
                stack.push(v);
            }
            else stack.push(temp);
        }
        answer = Double.parseDouble(stack.peek()); // peek: would not move out and just observe ， pop : would move out
        return answer;
    }
    
       public static void main(String[] args) throws IOException {
        // TODO code application logic here
       try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           String input = br.readLine();
           
//           Calculator cct = new Calculator();
//           double y = cct.ans(data);
           //System.out.println(input.length());
           Expression e = new Expression();
           Node x = e.Infix2BT(input);
           //Node[] A = e.PrintPostfix();
           //System.out.println(A[6].getValue());
           double an = e.Evaluation();
           System.out.println(an);
    }
   }
}

@4d210cb041b168a531417b26465403f4@"
"r04921065","10","0.099","105824","@b5e6b353129b5ff88e831b0f39b146c6@
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class Expression{
  
    private Node root;
    public int eleSize = 0;
    public int size = 1;
    public int porder = 0;
    public Node[] p;
    
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        int count_r=0;
        int count =0;
        int sidelo = 0;
        int lengthB = infix.length();
        char[] ch = new char[lengthB]; // char array
        for (int i = 0;i<lengthB;i++){
            ch[i] = infix.charAt(i);
            if ( ch[i]==')' ) count_r++;
        }
        //System.out.println(ch.length);
        eleSize =  count_r*2+1; // not include ""("" and　"")""
        String[] str = new String[4*count_r+1];  // string array
        
           for(int i = 0;i<lengthB;i++){
               if (ch[i]=='('||ch[i]==')'||ch[i]=='+'||ch[i]=='-'||ch[i]=='*'||ch[i]=='/'){
                   str[count] = String.valueOf(ch[i]);
                   count++;}
               else if (ch[i-1]=='('||ch[i-1]==')'||ch[i-1]=='+'||ch[i-1]=='-'||ch[i-1]=='*'||ch[i-1]=='/'){ // maybe integer or float
                   sidelo = i; // float left bound
                   if (ch[i+1]=='('||ch[i+1]==')'||ch[i+1]=='+'||ch[i+1]=='-'||ch[i+1]=='*'||ch[i+1]=='/'){ // integer
                       str[count] = String.valueOf(ch[i]);
                       count++;
                   }
               }
               else if (ch[i+1]=='('||ch[i+1]==')'||ch[i+1]=='+'||ch[i+1]=='-'||ch[i+1]=='*'||ch[i+1]=='/'){
                   String t = """";//initialization
                   for (int j = sidelo;j<i+1;j++){
                       t = t + String.valueOf(ch[j]);
                   }
                   //System.out.println(count);
                   str[count] = t;
                   count++;
               }
             }
        
        
        //System.out.println(str.length);
        int lengthA = str.length;
        Stack<String> ops = new Stack<String>();
        Stack<Node> val = new Stack<Node>();
        
        // binary tree
        for (int i=0;i<lengthA;i++){
            String temp = str[i];
            if (temp.equals(""(""));
            else if (temp.equals(""+"")|| temp.equals(""-"")||temp.equals(""/"")||temp.equals(""*""))
                ops.push(temp);
            else if (temp.equals("")"")){
                size +=2; // element number: 1.最裡面括號以外 2.不含括號
                Node right = val.pop();
                Node left = val.pop();
                Node N = new Node(left,right,ops.pop());
                root = N;
                val.push(N);
            }
            else 
                val.push(new Node(null,null,temp));
         }
        //System.out.println(size);
        //System.out.println(eleSize);
        return root;
    }
    

    public Node[] PrintPrefix(){ //自己->左->右
//        Node[] prefix = null;
        if (root==null){
            throw new NullPointerException();
        }
        int order = 0;
        Node[] prefix = new Node[eleSize];
        Stack<Node> pre = new Stack<Node>();
        pre.push(root);
        while (!pre.isEmpty()){
            Node n = pre.pop();
            prefix[order] = n;
            order++;
            if (n.getRight()!=null)
                pre.push(n.getRight());
            if (n.getLeft()!=null)
                pre.push(n.getLeft());
        }
        return prefix;
    }
  
    public void postOrder(Node input){
        if (input!=null){
            postOrder(input.getLeft());
            postOrder(input.getRight());
            p[porder] = input;
            porder++;
        }
    }
    
    public Node[] PrintPostfix(){ // 左->右->自己
        //Node[] postfix = null;
        Node[] postfix = new Node[eleSize];
        if (root ==null){
            throw new NullPointerException();
        }
        //System.out.println(porder);
        porder = 0;
        p = new Node[eleSize];
        postOrder(root);
        //System.out.println(porder);
        for (int i=0;i<eleSize;i++){
            postfix[i]=p[i];
        }
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        if (root == null) {
            throw new NullPointerException();
        }
        Stack<String> stack = new Stack<String>(); // 只用來存數值，不存operaters
        Node[] E = PrintPostfix();
        String v1;
        String v2;
        String v;
        double an;
        for (int i=0;i<E.length;i++){
            String temp = E[i].getValue();
            if (temp.equals(""+"")){
                v2 = stack.pop();
                v1 = stack.pop();
                an = Double.parseDouble(v2)+Double.parseDouble(v1);
                v = String.valueOf(an);
                stack.push(v);
            }
            else if (temp.equals(""-"")){
                v2 = stack.pop();
                v1 = stack.pop();
                an = Double.parseDouble(v1)-Double.parseDouble(v2);
                v = String.valueOf(an);
                stack.push(v);
            }
            else if (temp.equals(""*"")){
                v2 = stack.pop();
                v1 = stack.pop();
                an = Double.parseDouble(v1)*Double.parseDouble(v2);
                v = String.valueOf(an);
                stack.push(v);
            }
            else if (temp.equals(""/"")){
                v2 = stack.pop();
                v1 = stack.pop();
                an = Double.parseDouble(v1)/Double.parseDouble(v2);
                v = String.valueOf(an);
                stack.push(v);
            }
            else stack.push(temp);
        }
        answer = Double.parseDouble(stack.peek()); // peek: would not move out and just observe ， pop : would move out
        return answer;
    }
    
       public static void main(String[] args) throws IOException {
        // TODO code application logic here
       try(BufferedReader br = new BufferedReader(new FileReader(args[0]))){
           String input = br.readLine();
           
//           Calculator cct = new Calculator();
//           double y = cct.ans(data);
           //System.out.println(input.length());
           Expression e = new Expression();
           Node x = e.Infix2BT(input);
           //Node[] A = e.PrintPostfix();
           //System.out.println(A[6].getValue());
           double an = e.Evaluation();
           System.out.println(an);
    }
   }
}

@b5e6b353129b5ff88e831b0f39b146c6@"
"r04631004","0","0.98","105856","@3f6d194a4dbcf7792175475316440a87@public class Expression {

    private Node root;
    private String[] b;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] a = infix.toCharArray();
        String[] tempb = new String[a.length];
        int arraysize = 0;
        for (int i = 0; i < a.length - 1; i++) {
            tempb[i] = infix.subSequence(i, i + 1).toString();
            int tempcount = i;
            if (tempb[i].equals(""+"") == false && tempb[i].equals(""-"") == false && tempb[i].equals(""*"") == false && tempb[i].equals(""/"") == false && tempb[i].equals(""("") == false && tempb[i].equals("")"") == false) {
                for (int j = i + 1; j < a.length - 1; j++) {
                    String tempbb = infix.subSequence(j, j + 1).toString();
                    if (tempbb.equals(""+"") == false && tempbb.equals(""-"") == false && tempbb.equals(""*"") == false && tempbb.equals(""/"") == false && tempbb.equals(""("") == false && tempbb.equals("")"") == false) {
                        tempcount = j;
                    } else {
                        break;
                    }
                }

                if (tempcount != i) {
                    tempb[i] = infix.subSequence(i, tempcount + 1).toString();
                    i = tempcount;
                }
            }
            arraysize++;
        }
        int idx = 0;
        b = new String[arraysize];
        for (int i = 0; i < tempb.length; i++) {
            if (tempb[i] != null) {
                b[idx] = tempb[i];
                System.out.print(b[idx]);
                idx++;
            }
        }
        
        root = new Node(null, null, null);
        //若為(1+(1+1))的形式
        Stack<String> stack = new Stack<String>();
        if (b[2].equals(""+"") || b[2].equals(""-"") || b[2].equals(""*"") || b[2].equals(""/"")) {
            root.setValue(b[2]);
            Node temp = new Node(null, null, b[1]);
            root.setLeft(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            if ((b.length - 1 - 3) >= 3) {
                for (int i = 3; i < b.length; i++) {
                    if (checknum == 0) {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {

                            String rightvalue = stack.pop();
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                            checknum = 1;

                        }
                    } else {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {
                            String in = stack.pop();
                            if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                                String operator = in;
                                String leftvalue = stack.pop();
                                Node lefttemp = new Node(null, null, leftvalue);
                                Node temproot = new Node(lefttemp, connectnode, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            } else {
                                String rightvalue = in;
                                Node righttemp = new Node(null, null, rightvalue);
                                String operator = stack.pop();
                                Node temproot = new Node(connectnode, righttemp, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            }
                        }
                    }
                }
                root.setRight(connectnode);
            } else {
                temp = new Node(null, null, b[3]);
                root.setRight(temp);
            }
        } //若為((1+1)+1)的形式
        else if (b[b.length- 2].equals(""+"") || b[b.length - 2].equals(""-"") || b[b.length - 2].equals(""*"") || b[b.length - 2].equals(""/"")) {
            root.setValue(b[b.length - 2]);
            Node temp = new Node(null, null, b[b.length - 1]);
            root.setRight(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < b.length - 2; i++) {
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
        }//若為((1+1)+(1+1))的形式
        else {
            int rootposition = 0;
            for (int i = 0; i < b.length; i++) {
                if (b[i].equals("")"") || b[i + 2].equals(""("")) {
                    rootposition = i + 1;
                    break;
                }
            }
            root.setValue(b[rootposition]);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < rootposition; i++) {  //先連接root左邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
            checknum = 0;
            for (int i = rootposition + 1; i < b.length; i++) {  //再連接root右邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setRight(connectnode);
        }

        return root;
    }

    private void Prefixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        q.enqueue(x);
        Prefixtraversal(x.getLeft(), q);
        Prefixtraversal(x.getRight(), q);
    }

    public Node[] PrintPrefix() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return null;
        }
        Queue<Node> q = new Queue<Node>();
        Prefixtraversal(this.root, q);
        
        Node[] prefix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < prefix.length; i++) {
            prefix[i] = q.dequeue();
           // System.out.println(prefix[i].getValue());
        }
        return prefix;
    }

    private void Postfixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        Postfixtraversal(x.getLeft(), q);
        Postfixtraversal(x.getRight(), q);
        q.enqueue(x);
    }

    public Node[] PrintPostfix() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return null;
        }
        Queue<Node> q = new Queue<Node>();
        Postfixtraversal(this.root, q);
        Node[] postfix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < postfix.length; i++) {
            postfix[i] = q.dequeue();
        }
        return postfix;
    }

    public double Evaluation() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return 0.0;
        }
        Node[] c = this.PrintPostfix();
        Stack<Double> stack = new Stack<Double>();
        for (int i = 0; i < c.length; i++) {
            if (c[i].getValue().equals(""+"") == false && c[i].getValue().equals(""-"") == false && c[i].getValue().equals(""*"") == false && c[i].getValue().equals(""/"") == false) {
                stack.push(Double.valueOf(c[i].getValue()));
            } else {
                double num2 = 0.0;
                double num1 = 0.0;
                switch (c[i].getValue()) {
                    case ""+"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 + num2);
                        break;
                    case ""-"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 - num2);
                        break;
                    case ""*"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 * num2);
                        break;
                    case ""/"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 / num2);
                        break;
                }
            }

        }
        double answer = stack.pop();
        return answer;
    }

    public static void main(String[] args) {
//               Expression b = new Expression();
//       //Node a = b.Infix2BT(""(4+(((4*2)/2)/3))"");
//        //       Node a = b.Infix2BT(""(12+12)"");
//                Node a = b.Infix2BT(""((1+1)+(1+1))"");
//        Node[] c = b.PrintPrefix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        System.out.println("" "");
//               c = b.PrintPostfix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        b.Evaluation();
//        System.out.println("" "");
//        System.out.println(b.Evaluation());

    }
}

@3f6d194a4dbcf7792175475316440a87@"
"r04631004","5","0.98","105728","@62f76a37c1dfa3705f2d110f365d2660@public class Expression {

    private Node root;
    private String[] b;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] a = infix.toCharArray();
        String[] tempb = new String[a.length];
        int arraysize = 0;
        for (int i = 0; i < a.length - 1; i++) {
            tempb[i] = infix.subSequence(i, i + 1).toString();
            int tempcount = i;
            if (tempb[i].equals(""+"") == false && tempb[i].equals(""-"") == false && tempb[i].equals(""*"") == false && tempb[i].equals(""/"") == false && tempb[i].equals(""("") == false && tempb[i].equals("")"") == false) {
                for (int j = i + 1; j < a.length - 1; j++) {
                    String tempbb = infix.subSequence(j, j + 1).toString();
                    if (tempbb.equals(""+"") == false && tempbb.equals(""-"") == false && tempbb.equals(""*"") == false && tempbb.equals(""/"") == false && tempbb.equals(""("") == false && tempbb.equals("")"") == false) {
                        tempcount = j;
                    } else {
                        break;
                    }
                }

                if (tempcount != i) {
                    tempb[i] = infix.subSequence(i, tempcount + 1).toString();
                    i = tempcount;
                }
            }
            arraysize++;
        }
        int idx = 0;
        b = new String[arraysize];
        for (int i = 0; i < tempb.length; i++) {
            if (tempb[i] != null) {
                b[idx] = tempb[i];
                idx++;
            }
        }
        
        root = new Node(null, null, null);
        //若為(1+(1+1))的形式
        Stack<String> stack = new Stack<String>();
        if (b[2].equals(""+"") || b[2].equals(""-"") || b[2].equals(""*"") || b[2].equals(""/"")) {
            root.setValue(b[2]);
            Node temp = new Node(null, null, b[1]);
            root.setLeft(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            if ((b.length - 1 - 3) >= 3) {
                for (int i = 3; i < b.length; i++) {
                    if (checknum == 0) {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {

                            String rightvalue = stack.pop();
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                            checknum = 1;

                        }
                    } else {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {
                            String in = stack.pop();
                            if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                                String operator = in;
                                String leftvalue = stack.pop();
                                Node lefttemp = new Node(null, null, leftvalue);
                                Node temproot = new Node(lefttemp, connectnode, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            } else {
                                String rightvalue = in;
                                Node righttemp = new Node(null, null, rightvalue);
                                String operator = stack.pop();
                                Node temproot = new Node(connectnode, righttemp, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            }
                        }
                    }
                }
                root.setRight(connectnode);
            } else {
                temp = new Node(null, null, b[3]);
                root.setRight(temp);
            }
        } //若為((1+1)+1)的形式
        else if (b[b.length- 2].equals(""+"") || b[b.length - 2].equals(""-"") || b[b.length - 2].equals(""*"") || b[b.length - 2].equals(""/"")) {
            root.setValue(b[b.length - 2]);
            Node temp = new Node(null, null, b[b.length - 1]);
            root.setRight(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < b.length - 2; i++) {
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
        }//若為((1+1)+(1+1))的形式
        else {
            int rootposition = 0;
            for (int i = 0; i < b.length; i++) {
                if (b[i].equals("")"") || b[i + 2].equals(""("")) {
                    rootposition = i + 1;
                    break;
                }
            }
            root.setValue(b[rootposition]);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < rootposition; i++) {  //先連接root左邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
            checknum = 0;
            for (int i = rootposition + 1; i < b.length; i++) {  //再連接root右邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setRight(connectnode);
        }

        return root;
    }

    private void Prefixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        q.enqueue(x);
        Prefixtraversal(x.getLeft(), q);
        Prefixtraversal(x.getRight(), q);
    }

    public Node[] PrintPrefix() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return null;
        }
        Queue<Node> q = new Queue<Node>();
        Prefixtraversal(this.root, q);
        
        Node[] prefix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < prefix.length; i++) {
            prefix[i] = q.dequeue();
           // System.out.println(prefix[i].getValue());
        }
        return prefix;
    }

    private void Postfixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        Postfixtraversal(x.getLeft(), q);
        Postfixtraversal(x.getRight(), q);
        q.enqueue(x);
    }

    public Node[] PrintPostfix() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return null;
        }
        Queue<Node> q = new Queue<Node>();
        Postfixtraversal(this.root, q);
        Node[] postfix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < postfix.length; i++) {
            postfix[i] = q.dequeue();
        }
        return postfix;
    }

    public double Evaluation() {
        if (this.root == null) {
            System.out.println(""NullPointerException"");
            return 0.0;
        }
        Node[] c = this.PrintPostfix();
        Stack<Double> stack = new Stack<Double>();
        for (int i = 0; i < c.length; i++) {
            if (c[i].getValue().equals(""+"") == false && c[i].getValue().equals(""-"") == false && c[i].getValue().equals(""*"") == false && c[i].getValue().equals(""/"") == false) {
                stack.push(Double.valueOf(c[i].getValue()));
            } else {
                double num2 = 0.0;
                double num1 = 0.0;
                switch (c[i].getValue()) {
                    case ""+"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 + num2);
                        break;
                    case ""-"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 - num2);
                        break;
                    case ""*"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 * num2);
                        break;
                    case ""/"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 / num2);
                        break;
                }
            }

        }
        double answer = stack.pop();
        return answer;
    }

    public static void main(String[] args) {
               Expression b = new Expression();
       Node a = b.Infix2BT(""(4+(((4*2)/2)/3))"");
//        //       Node a = b.Infix2BT(""(12+12)"");
//                Node a = b.Infix2BT(""((1+1)+(1+1))"");
//        Node[] c = b.PrintPrefix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        System.out.println("" "");
//               c = b.PrintPostfix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        b.Evaluation();
//        System.out.println("" "");
       // System.out.println(b.Evaluation());

    }
}

@62f76a37c1dfa3705f2d110f365d2660@"
"r03849033","1","0.09","98672","@5494794a573aa0c32cd1c372eecfef15@public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;

private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length/2];
        int d = 0;
        String tempstring="""";
        for (String da1 : da) {
            if (da1.equals(""+"") || da1.equals(""-"") || da1.equals(""*"") || da1.equals(""/"") || da1.equals(""("") || da1.equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++] = da1;
            } else if (!da1.equals("""")) {
                tempstring = tempstring + da1;
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }      
}

@5494794a573aa0c32cd1c372eecfef15@"
"r04631004","4","0.99","105856","@fb4506bc0db690959ff4350b1c99988d@public class Expression {

    private Node root;
    private String[] b;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] a = infix.toCharArray();
        String[] tempb = new String[a.length];
        int arraysize = 0;
        for (int i = 0; i < a.length - 1; i++) {
            tempb[i] = infix.subSequence(i, i + 1).toString();
            int tempcount = i;
            if (tempb[i].equals(""+"") == false && tempb[i].equals(""-"") == false && tempb[i].equals(""*"") == false && tempb[i].equals(""/"") == false && tempb[i].equals(""("") == false && tempb[i].equals("")"") == false) {
                for (int j = i + 1; j < a.length - 1; j++) {
                    String tempbb = infix.subSequence(j, j + 1).toString();
                    if (tempbb.equals(""+"") == false && tempbb.equals(""-"") == false && tempbb.equals(""*"") == false && tempbb.equals(""/"") == false && tempbb.equals(""("") == false && tempbb.equals("")"") == false) {
                        tempcount = j;
                    } else {
                        break;
                    }
                }

                if (tempcount != i) {
                    tempb[i] = infix.subSequence(i, tempcount + 1).toString();
                    i = tempcount;
                }
            }
            arraysize++;
        }
        int idx = 0;
        b = new String[arraysize];
        for (int i = 0; i < tempb.length; i++) {
            if (tempb[i] != null) {
                b[idx] = tempb[i];
                //System.out.println(b[idx]);
                idx++;
            }
        }
        
        root = new Node(null, null, null);
        //若為(1+(1+1))的形式
        Stack<String> stack = new Stack<String>();
        if (b[2].equals(""+"") || b[2].equals(""-"") || b[2].equals(""*"") || b[2].equals(""/"")) {
            root.setValue(b[2]);
            Node temp = new Node(null, null, b[1]);
            root.setLeft(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            if ((b.length - 1 - 3) >= 3) {
                for (int i = 3; i < b.length; i++) {
                    if (checknum == 0) {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {

                            String rightvalue = stack.pop();
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                            checknum = 1;

                        }
                    } else {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {
                            String in = stack.pop();
                            if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                                String operator = in;
                                String leftvalue = stack.pop();
                                Node lefttemp = new Node(null, null, leftvalue);
                                Node temproot = new Node(lefttemp, connectnode, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            } else {
                                String rightvalue = in;
                                Node righttemp = new Node(null, null, rightvalue);
                                String operator = stack.pop();
                                Node temproot = new Node(connectnode, righttemp, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            }
                        }
                    }
                }
                root.setRight(connectnode);
            } else {
                temp = new Node(null, null, b[3]);
                root.setRight(temp);
            }
        } //若為((1+1)+1)的形式
        else if (b[b.length- 2].equals(""+"") || b[b.length - 2].equals(""-"") || b[b.length - 2].equals(""*"") || b[b.length - 2].equals(""/"")) {
            root.setValue(b[b.length - 2]);
            Node temp = new Node(null, null, b[b.length - 1]);
            root.setRight(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < b.length - 2; i++) {
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
        }//若為((1+1)+(1+1))的形式
        else {
            int rootposition = 0;
            for (int i = 0; i < b.length; i++) {
                if (b[i].equals("")"") || b[i + 2].equals(""("")) {
                    rootposition = i + 1;
                    break;
                }
            }
            root.setValue(b[rootposition]);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < rootposition; i++) {  //先連接root左邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
            checknum = 0;
            for (int i = rootposition + 1; i < b.length; i++) {  //再連接root右邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setRight(connectnode);
        }

        return root;
    }

    private void Prefixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        q.enqueue(x);
        Prefixtraversal(x.getLeft(), q);
        Prefixtraversal(x.getRight(), q);
    }

    public Node[] PrintPrefix() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Queue<Node> q = new Queue<Node>();
        Prefixtraversal(this.root, q);
        
        Node[] prefix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < prefix.length; i++) {
            prefix[i] = q.dequeue();
           // System.out.println(prefix[i].getValue());
        }
        return prefix;
    }

    private void Postfixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        Postfixtraversal(x.getLeft(), q);
        Postfixtraversal(x.getRight(), q);
        q.enqueue(x);
    }

    public Node[] PrintPostfix() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Queue<Node> q = new Queue<Node>();
        Postfixtraversal(this.root, q);
        Node[] postfix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < postfix.length; i++) {
            postfix[i] = q.dequeue();
        }
        return postfix;
    }

    public double Evaluation() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Node[] c = this.PrintPostfix();
        System.out.println(c.length);
        Stack<Double> stack = new Stack<Double>();
        for (int i = 0; i < c.length; i++) {
            if (c[i].getValue().equals(""+"") == false && c[i].getValue().equals(""-"") == false && c[i].getValue().equals(""*"") == false && c[i].getValue().equals(""/"") == false) {
                stack.push(Double.valueOf(c[i].getValue()));
            } else {
                double num2 = 0.0;
                double num1 = 0.0;
                switch (c[i].getValue()) {
                    case ""+"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 + num2);
                        break;
                    case ""-"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 - num2);
                        break;
                    case ""*"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 * num2);
                        break;
                    case ""/"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 / num2);
                        break;
                }
            }

        }
        double answer = stack.pop();
        return answer;
    }

    public static void main(String[] args) {
               Expression b = new Expression();
 //      Node a = b.Infix2BT(""((20120224791*(121259+797912))+(211544771212/2))"");
//        //       Node a = b.Infix2BT(""(12+12)"");
//                Node a = b.Infix2BT(""((1+1)+(1+1))"");
//        Node[] c = b.PrintPrefix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        System.out.println("" "");
//               c = b.PrintPostfix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        b.Evaluation();
//        System.out.println("" "");
 //       System.out.println(b.Evaluation());

    }
}

@fb4506bc0db690959ff4350b1c99988d@"
"r04631004","6","0.98","105856","@f0f87e3d3807df7b6651562efb56b4ec@public class Expression {

    private Node root;
    private String[] b;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] a = infix.toCharArray();
        String[] tempb = new String[a.length];
        int arraysize = 0;
        for (int i = 0; i < a.length - 1; i++) {
            tempb[i] = infix.subSequence(i, i + 1).toString();
            int tempcount = i;
            if (tempb[i].equals(""+"") == false && tempb[i].equals(""-"") == false && tempb[i].equals(""*"") == false && tempb[i].equals(""/"") == false && tempb[i].equals(""("") == false && tempb[i].equals("")"") == false) {
                for (int j = i + 1; j < a.length - 1; j++) {
                    String tempbb = infix.subSequence(j, j + 1).toString();
                    if (tempbb.equals(""+"") == false && tempbb.equals(""-"") == false && tempbb.equals(""*"") == false && tempbb.equals(""/"") == false && tempbb.equals(""("") == false && tempbb.equals("")"") == false) {
                        tempcount = j;
                    } else {
                        break;
                    }
                }

                if (tempcount != i) {
                    tempb[i] = infix.subSequence(i, tempcount + 1).toString();
                    i = tempcount;
                }
            }
            arraysize++;
        }
        int idx = 0;
        b = new String[arraysize];
        for (int i = 0; i < tempb.length; i++) {
            if (tempb[i] != null) {
                b[idx] = tempb[i];
                //System.out.println(b[idx]);
                idx++;
            }
        }
        
        root = new Node(null, null, null);
        //若為(1+(1+1))的形式
        Stack<String> stack = new Stack<String>();
        if (b[2].equals(""+"") || b[2].equals(""-"") || b[2].equals(""*"") || b[2].equals(""/"")) {
            root.setValue(b[2]);
            Node temp = new Node(null, null, b[1]);
            root.setLeft(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            if ((b.length - 1 - 3) >= 3) {
                for (int i = 3; i < b.length; i++) {
                    if (checknum == 0) {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {

                            String rightvalue = stack.pop();
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                            checknum = 1;

                        }
                    } else {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {
                            String in = stack.pop();
                            if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                                String operator = in;
                                String leftvalue = stack.pop();
                                Node lefttemp = new Node(null, null, leftvalue);
                                Node temproot = new Node(lefttemp, connectnode, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            } else {
                                String rightvalue = in;
                                Node righttemp = new Node(null, null, rightvalue);
                                String operator = stack.pop();
                                Node temproot = new Node(connectnode, righttemp, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            }
                        }
                    }
                }
                root.setRight(connectnode);
            } else {
                temp = new Node(null, null, b[3]);
                root.setRight(temp);
            }
        } //若為((1+1)+1)的形式
        else if (b[b.length- 2].equals(""+"") || b[b.length - 2].equals(""-"") || b[b.length - 2].equals(""*"") || b[b.length - 2].equals(""/"")) {
            root.setValue(b[b.length - 2]);
            Node temp = new Node(null, null, b[b.length - 1]);
            root.setRight(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < b.length - 2; i++) {
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
        }//若為((1+1)+(1+1))的形式
        else {
            int rootposition = 0;
            for (int i = 0; i < b.length; i++) {
                if (b[i].equals("")"") || b[i + 2].equals(""("")) {
                    rootposition = i + 1;
                    break;
                }
            }
            root.setValue(b[rootposition]);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < rootposition; i++) {  //先連接root左邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
            checknum = 0;
            for (int i = rootposition + 1; i < b.length; i++) {  //再連接root右邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setRight(connectnode);
        }

        return root;
    }

    private void Prefixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        q.enqueue(x);
        Prefixtraversal(x.getLeft(), q);
        Prefixtraversal(x.getRight(), q);
    }

    public Node[] PrintPrefix() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Queue<Node> q = new Queue<Node>();
        Prefixtraversal(this.root, q);
        
        Node[] prefix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < prefix.length; i++) {
            prefix[i] = q.dequeue();
           // System.out.println(prefix[i].getValue());
        }
        return prefix;
    }

    private void Postfixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        Postfixtraversal(x.getLeft(), q);
        Postfixtraversal(x.getRight(), q);
        q.enqueue(x);
    }

    public Node[] PrintPostfix() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Queue<Node> q = new Queue<Node>();
        Postfixtraversal(this.root, q);
        Node[] postfix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < postfix.length; i++) {
            postfix[i] = q.dequeue();
        }
        return postfix;
    }

    public double Evaluation() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Node[] c = this.PrintPostfix();
        Stack<Double> stack = new Stack<Double>();
        for (int i = 0; i < c.length; i++) {
            if (c[i].getValue().equals(""+"") == false && c[i].getValue().equals(""-"") == false && c[i].getValue().equals(""*"") == false && c[i].getValue().equals(""/"") == false) {
                stack.push(Double.valueOf(c[i].getValue()));
            } else {
                double num2 = 0.0;
                double num1 = 0.0;
                switch (c[i].getValue()) {
                    case ""+"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 + num2);
                        break;
                    case ""-"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 - num2);
                        break;
                    case ""*"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 * num2);
                        break;
                    case ""/"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 / num2);
                        break;
                }
            }

        }
        double answer = stack.pop();
        return answer;
    }

    public static void main(String[] args) {
               Expression b = new Expression();
 //      Node a = b.Infix2BT(""((20120224791*(121259+797912))+(211544771212/2))"");
//        //       Node a = b.Infix2BT(""(12+12)"");
                Node a = b.Infix2BT(""((1+1)+(1+1))"");
//        Node[] c = b.PrintPrefix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        System.out.println("" "");
//               c = b.PrintPostfix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        b.Evaluation();
//        System.out.println("" "");
      //  System.out.println(b.Evaluation());

    }
}

@f0f87e3d3807df7b6651562efb56b4ec@"
"r04631004","6","0.98","105936","@891b4832d7bae2c4860bce008a680980@public class Expression {

    private Node root;
    private String[] b;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] a = infix.toCharArray();
        String[] tempb = new String[a.length];
        int arraysize = 0;
        for (int i = 0; i < a.length - 1; i++) {
            tempb[i] = infix.subSequence(i, i + 1).toString();
            int tempcount = i;
            if (tempb[i].equals(""+"") == false && tempb[i].equals(""-"") == false && tempb[i].equals(""*"") == false && tempb[i].equals(""/"") == false && tempb[i].equals(""("") == false && tempb[i].equals("")"") == false) {
                for (int j = i + 1; j < a.length - 1; j++) {
                    String tempbb = infix.subSequence(j, j + 1).toString();
                    if (tempbb.equals(""+"") == false && tempbb.equals(""-"") == false && tempbb.equals(""*"") == false && tempbb.equals(""/"") == false && tempbb.equals(""("") == false && tempbb.equals("")"") == false) {
                        tempcount = j;
                    } else {
                        break;
                    }
                }

                if (tempcount != i) {
                    tempb[i] = infix.subSequence(i, tempcount + 1).toString();
                    i = tempcount;
                }
            }
            arraysize++;
        }
        int idx = 0;
        b = new String[arraysize];
        for (int i = 0; i < tempb.length; i++) {
            if (tempb[i] != null) {
                b[idx] = tempb[i];
                //System.out.println(b[idx]);
                idx++;
            }
        }
        
        root = new Node(null, null, null);
        //若為(1+(1+1))的形式
        Stack<String> stack = new Stack<String>();
        if (b[2].equals(""+"") || b[2].equals(""-"") || b[2].equals(""*"") || b[2].equals(""/"")) {
            root.setValue(b[2]);
            Node temp = new Node(null, null, b[1]);
            root.setLeft(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            if ((b.length - 1 - 3) >= 3) {
                for (int i = 3; i < b.length; i++) {
                    if (checknum == 0) {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {

                            String rightvalue = stack.pop();
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                            checknum = 1;

                        }
                    } else {
                        if (b[i].equals("")"") != true) {
                            stack.push(b[i]);
                        } else {
                            String in = stack.pop();
                            if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                                String operator = in;
                                String leftvalue = stack.pop();
                                Node lefttemp = new Node(null, null, leftvalue);
                                Node temproot = new Node(lefttemp, connectnode, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            } else {
                                String rightvalue = in;
                                Node righttemp = new Node(null, null, rightvalue);
                                String operator = stack.pop();
                                Node temproot = new Node(connectnode, righttemp, operator);
                                connectnode = temproot;
                                stack.pop();  //remove the nearest '('}
                            }
                        }
                    }
                }
                root.setRight(connectnode);
            } else {
                temp = new Node(null, null, b[3]);
                root.setRight(temp);
            }
        } //若為((1+1)+1)的形式
        else if (b[b.length- 2].equals(""+"") || b[b.length - 2].equals(""-"") || b[b.length - 2].equals(""*"") || b[b.length - 2].equals(""/"")) {
            root.setValue(b[b.length - 2]);
            Node temp = new Node(null, null, b[b.length - 1]);
            root.setRight(temp);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < b.length - 2; i++) {
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
        }//若為((1+1)+(1+1))的形式
        else {
            int rootposition = 0;
            for (int i = 0; i < b.length; i++) {
                if (b[i].equals("")"") && b[i + 2].equals(""("")) {
                    rootposition = i + 1;
                    break;
                }
            }
            root.setValue(b[rootposition]);
            int checknum = 0;
            Node connectnode = new Node(null, null, null);
            for (int i = 0; i < rootposition; i++) {  //先連接root左邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setLeft(connectnode);
            checknum = 0;
            for (int i = rootposition + 1; i < b.length; i++) {  //再連接root右邊
                if (checknum == 0) {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String rightvalue = stack.pop();
                        Node righttemp = new Node(null, null, rightvalue);
                        String operator = stack.pop();
                        String leftvalue = stack.pop();
                        Node lefttemp = new Node(null, null, leftvalue);
                        Node temproot = new Node(lefttemp, righttemp, operator);
                        connectnode = temproot;
                        stack.pop();  //remove the nearest '('}
                        checknum = 1;
                    }
                } else {
                    if (b[i].equals("")"") != true) {
                        stack.push(b[i]);
                    } else {
                        String in = stack.pop();
                        if (in.equals(""+"") || in.equals(""-"") || in.equals(""*"") || in.equals(""/"")) {
                            String operator = in;
                            String leftvalue = stack.pop();
                            Node lefttemp = new Node(null, null, leftvalue);
                            Node temproot = new Node(lefttemp, connectnode, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        } else {
                            String rightvalue = in;
                            Node righttemp = new Node(null, null, rightvalue);
                            String operator = stack.pop();
                            Node temproot = new Node(connectnode, righttemp, operator);
                            connectnode = temproot;
                            stack.pop();  //remove the nearest '('}
                        }
                    }
                }
            }
            root.setRight(connectnode);
        }

        return root;
    }

    private void Prefixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        q.enqueue(x);
        Prefixtraversal(x.getLeft(), q);
        Prefixtraversal(x.getRight(), q);
    }

    public Node[] PrintPrefix() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Queue<Node> q = new Queue<Node>();
        Prefixtraversal(this.root, q);
        
        Node[] prefix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < prefix.length; i++) {
            prefix[i] = q.dequeue();
           // System.out.println(prefix[i].getValue());
        }
        return prefix;
    }

    private void Postfixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        Postfixtraversal(x.getLeft(), q);
        Postfixtraversal(x.getRight(), q);
        q.enqueue(x);
    }

    public Node[] PrintPostfix() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Queue<Node> q = new Queue<Node>();
        Postfixtraversal(this.root, q);
        Node[] postfix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < postfix.length; i++) {
            postfix[i] = q.dequeue();
        }
        return postfix;
    }

    public double Evaluation() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Node[] c = this.PrintPostfix();
        Stack<Double> stack = new Stack<Double>();
        for (int i = 0; i < c.length; i++) {
            if (c[i].getValue().equals(""+"") == false && c[i].getValue().equals(""-"") == false && c[i].getValue().equals(""*"") == false && c[i].getValue().equals(""/"") == false) {
                stack.push(Double.valueOf(c[i].getValue()));
            } else {
                double num2 = 0.0;
                double num1 = 0.0;
                switch (c[i].getValue()) {
                    case ""+"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 + num2);
                        break;
                    case ""-"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 - num2);
                        break;
                    case ""*"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 * num2);
                        break;
                    case ""/"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 / num2);
                        break;
                }
            }

        }
        double answer = stack.pop();
        return answer;
    }

    public static void main(String[] args) {
               Expression b = new Expression();
       Node a = b.Infix2BT(""((20120224791*(121259+797912))+(211544771212/2))"");
//        //       Node a = b.Infix2BT(""(12+12)"");
             //   Node a = b.Infix2BT(""((1+1)+(1+1))"");
//        Node[] c = b.PrintPrefix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        System.out.println("" "");
//               c = b.PrintPostfix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        b.Evaluation();
//        System.out.println("" "");
 //       System.out.println(b.Evaluation());

    }
}

@891b4832d7bae2c4860bce008a680980@"
"r03849033","5","0.49","105552","@aa9446bbea89ee7e71c04a669c569bd5@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;


public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;

private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }
        public static void main(String[] args) {
        String input = ""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression test = new Expression();
        test.Infix2BT(input);
        print(test.PrintPrefix());
        print(test.PrintPostfix());        
        System.out.println(test.Evaluation());      
    } 
        
    public static void print(Node[] pf){
        for(int i = 0; i < pf.length;i++){
            System.out.printf(pf[i].getValue()+"" "");
        }
        System.out.println();        
    }        
}

@aa9446bbea89ee7e71c04a669c569bd5@"
"b02611016","9","0.97","105872","@65e38f37fece008066219c3ed47fe01e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.peek()==null){ throw new NullPointerException();}
        root=vals.pop();
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test=""(7/((5+(6-3))*(5-9)))"";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@65e38f37fece008066219c3ed47fe01e@"
"b02611016","9","0.99","105888","@65e38f37fece008066219c3ed47fe01e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.peek()==null){ throw new NullPointerException();}
        root=vals.pop();
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test=""(7/((5+(6-3))*(5-9)))"";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@65e38f37fece008066219c3ed47fe01e@"
"b02611016","9","0.98","105856","@afd6d3e51a94dd29c2de20d34cc470ea@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(ee[i+1].equals("")"")){throw new NullPointerException();}
                if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.peek()==null){ throw new NullPointerException();}
        root=vals.pop();
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //System.out.println(1);
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test=""()"";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@afd6d3e51a94dd29c2de20d34cc470ea@"
"b02611016","9","0.93","105856","@4e3c7b9c87e4668c7a89afe02b790d33@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { //if(ee[i+1].equals("")"")){throw new NullPointerException();}
                if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        //if(vals.peek().getValue()==null){ throw new NullPointerException();}
        root=vals.pop();
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        if(root.getValue()==null){throw new NullPointerException();}
       // System.out.println(root.getValue());
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test=""()"";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@4e3c7b9c87e4668c7a89afe02b790d33@"
"b02611016","9","0.99","105840","@26af991d03ce643314eb341f60312192@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { //if(ee[i+1].equals("")"")){throw new NullPointerException();}
                if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.isEmpty()){ throw new NullPointerException();}
        root=vals.pop();
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        if(root.getValue()==null){throw new NullPointerException();}
       // System.out.println(root.getValue());
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      

       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test="""";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@26af991d03ce643314eb341f60312192@"
"b02611016","9","0.99","105888","@0bf922302fafb997a6038ebc20c24740@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { //if(ee[i+1].equals("")"")){throw new NullPointerException();}
                if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.isEmpty()){ }
        else{root=vals.pop();}
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        if(root.getValue()==null){throw new NullPointerException();}
        if(root.equals(null)){throw new NullPointerException();}
       // System.out.println(root.getValue());
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      
         if(vals.isEmpty()){throw new NullPointerException();}
       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test="""";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@0bf922302fafb997a6038ebc20c24740@"
"b02611016","9","0.98","105872","@2a1edd0c6b1b6317d23ac82c0d80416e@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { //if(ee[i+1].equals("")"")){throw new NullPointerException();}
                if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.isEmpty()){root=new Node(null,null,null); }
        else{root=vals.pop();}
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        if(root.getValue()==null){throw new NullPointerException();}
        if(root.equals(null)){throw new NullPointerException();}
       // System.out.println(root.getValue());
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      
         if(vals.isEmpty()){throw new NullPointerException();}
       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test="""";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@2a1edd0c6b1b6317d23ac82c0d80416e@"
"b02611016","9","0.93","105872","@81db5baafa54d9acdd6ffa1eab219c17@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { //if(ee[i+1].equals("")"")){throw new NullPointerException();}
                if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.isEmpty()){root=new Node(null,null,null); }
        else{root=vals.pop();}
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //if(root.getValue()==null){throw new NullPointerException();}
        if(root.equals(null)){throw new NullPointerException();}
       // System.out.println(root.getValue());
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      
         if(vals.isEmpty()){throw new NullPointerException();}
       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test="""";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@81db5baafa54d9acdd6ffa1eab219c17@"
"r03525006","2","0.28","105520","@3a29f583a820e47eaca3f67cd438731c@public class Expression{

    private Node root;
    private Node[] binaryTree;
    private String[] infixArray;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] splitInfix = infix.split("""");
        String newInfix = splitInfix[0] + "","";
        for (int i = 1; i < infix.length()-1; i++) {
            if (splitInfix[i].equals(""("")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals("")"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""+"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""-"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""*"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""/"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else { newInfix = newInfix + splitInfix[i];}
        }
        newInfix = newInfix + "")"";
        infixArray = newInfix.split("","");

        int parenCount = 0, levelCount = 0 , levelMax = 0;
        int[] idTemp = new int[infixArray.length];
        for (int i = 0; i < infixArray.length; i++) {
            if (infixArray[i].equals(""("")) { levelCount++; parenCount++; idTemp[i] = -1;}
            else if (infixArray[i].equals("")"")) { levelCount--; idTemp[i] = -1;}
            else if (infixArray[i].equals(""+"") || infixArray[i].equals(""-"") || infixArray[i].equals(""*"") || infixArray[i].equals(""/"")) {
                idTemp[i] = levelCount-1;
            } else idTemp[i] = levelCount;
            if (idTemp[i] > levelMax) levelMax = idTemp[i];
        }
        int[] id = new int[infix.length()-parenCount*2];
        String[] newInfixArray = new String[infix.length()-parenCount*2];
        int index = 0, rootIndex = 0;
        for (int i = 0; i < idTemp.length; i++) {
            if (idTemp[i] != -1) {
                newInfixArray[index] = infixArray[i];
                id[index] = idTemp[i];
                if (id[index] == 0) rootIndex = index;
                index++;
            }
        }

        int[] treeIndex = new int[id.length];
        int[] levelIndexCount = new int[levelMax+1];
        for (int i = 0; i < id.length; i++) {
            levelIndexCount[id[i]] += 1;
            for (int k = id[i]+1; k < levelIndexCount.length; k++) levelIndexCount[k] = 0;
            int startIndex = 1;
            for (int j = 0; j < id[i]; j ++) {
                if (levelIndexCount[j] == 0) startIndex = startIndex*2;
                else startIndex = startIndex*2+1;
            }
            treeIndex[i] = startIndex;
        }
        binaryTree = new Node[treeIndex.length];
        for (int i = 0; i < treeIndex.length; i++) {
            Node n = new Node(null,null,newInfixArray[i]);
            binaryTree[i] = n;
        }

        for (int i = 0; i < treeIndex.length; i++) {
            for (int j = 0; j < treeIndex.length; j++) {
                if (treeIndex[j] == treeIndex[i]*2) binaryTree[i].setLeft(binaryTree[j]);
                if (treeIndex[j] == treeIndex[i]*2+1) binaryTree[i].setRight(binaryTree[j]);
            }
        }
        return binaryTree[rootIndex];
    }

    public Node[] PrintPrefix(){
        Node[] prefix = null;
        return prefix;
    }

    public Node[] PrintPostfix(){
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation(){
        return Expression.calculator(infixArray);
    }

    public static Double calculator(String[] e) {
        Stack<String> ops = new Stack<String>();
        Stack<Double> vals = new Stack<Double>();
        for (int i = 0; i < e.length; i++) {
            String s = e[i];
            if (s.equals(""("")) ;
            else if (s.equals(""+"")) ops.push(s);
            else if (s.equals(""-"")) ops.push(s);
            else if (s.equals(""*"")) ops.push(s);
            else if (s.equals(""/"")) ops.push(s);
            else if (s.equals("")""))
            {
                String op = ops.pop();
                if (op.equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (op.equals(""-"")) {
                    vals.push(- vals.pop() + vals.pop());
                } else if (op.equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (op.equals(""/"")) {
                    Double a = vals.pop();
                    Double b = vals.pop();
                    vals.push(b/a);
                }
            }
            else vals.push(Double.parseDouble(s));
        }
        return vals.pop();
    }

//    public static void main(String[] args) {
//        String infix1 = ""((4*3)+((((4*2)/2)/3)+((2+1)*3)))"";
//        String infix = ""((41+2)+(((4*2)/2)/3))"";
//        Expression e = new Expression();
//        Node n = e.Infix2BT(infix);
//        System.out.println(e.Evaluation());
//    }
}
@3a29f583a820e47eaca3f67cd438731c@"
"r04631004","10","0.098","105888","@150553184b67e722ee2f379773e338a5@public class Expression {

    private Node root;
    private Node[] b;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        char[] a = infix.toCharArray();
        String[] tempb = new String[a.length];
        int arraysize = 0;
        for (int i = 0; i < a.length - 1; i++) {
            tempb[i] = infix.subSequence(i, i + 1).toString();
            int tempcount = i;
            if (tempb[i].equals(""+"") == false && tempb[i].equals(""-"") == false && tempb[i].equals(""*"") == false && tempb[i].equals(""/"") == false && tempb[i].equals(""("") == false && tempb[i].equals("")"") == false) {
                for (int j = i + 1; j < a.length - 1; j++) {
                    String tempbb = infix.subSequence(j, j + 1).toString();
                    if (tempbb.equals(""+"") == false && tempbb.equals(""-"") == false && tempbb.equals(""*"") == false && tempbb.equals(""/"") == false && tempbb.equals(""("") == false && tempbb.equals("")"") == false) {
                        tempcount = j;
                    } else {
                        break;
                    }
                }

                if (tempcount != i) {
                    tempb[i] = infix.subSequence(i, tempcount + 1).toString();
                    i = tempcount;
                }
            }
            arraysize++;
        }
        int idx = 0;
        b = new Node[arraysize + 1];
        Node temp = new Node(null, null, "")"");
        b[arraysize] = temp;
        for (int i = 0; i < tempb.length; i++) {
            if (tempb[i] != null) {
                temp = new Node(null, null, tempb[i]);
                b[idx] = temp;
                //System.out.println(b[idx]);
                idx++;
            }
        }

        root = new Node(null, null, null);
        Stack<Node> stack = new Stack<Node>();
        for (int i = 0; i < b.length; i++) {
            if (b[i].getValue().equals("")"") != true) {
                stack.push(b[i]);
            } else {
                Node rightvalue = stack.pop();
                Node operator = stack.pop();
                Node leftvalue = stack.pop();
                operator.setLeft(leftvalue);
                operator.setRight(rightvalue);
                stack.pop();  //remove the nearest '('}
                stack.push(operator);

            }
        }
        root=stack.pop();
        return root;
    }

    private void Prefixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        q.enqueue(x);
        Prefixtraversal(x.getLeft(), q);
        Prefixtraversal(x.getRight(), q);
    }

    public Node[] PrintPrefix() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Queue<Node> q = new Queue<Node>();
        Prefixtraversal(this.root, q);

        Node[] prefix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < prefix.length; i++) {
            prefix[i] = q.dequeue();
            // System.out.println(prefix[i].getValue());
        }
        return prefix;
    }

    private void Postfixtraversal(Node x, Queue<Node> q) {
        if (x == null) {
            return;
        }
        Postfixtraversal(x.getLeft(), q);
        Postfixtraversal(x.getRight(), q);
        q.enqueue(x);
    }

    public Node[] PrintPostfix() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Queue<Node> q = new Queue<Node>();
        Postfixtraversal(this.root, q);
        Node[] postfix = new Node[(b.length + 2) / 2];
        for (int i = 0; i < postfix.length; i++) {
            postfix[i] = q.dequeue();
        }
        return postfix;
    }

    public double Evaluation() {
        if (this.root == null) {
            throw new NullPointerException();
        }
        Node[] c = this.PrintPostfix();
        Stack<Double> stack = new Stack<Double>();
        for (int i = 0; i < c.length; i++) {
            if (c[i].getValue().equals(""+"") == false && c[i].getValue().equals(""-"") == false && c[i].getValue().equals(""*"") == false && c[i].getValue().equals(""/"") == false) {
                stack.push(Double.valueOf(c[i].getValue()));
            } else {
                double num2 = 0.0;
                double num1 = 0.0;
                switch (c[i].getValue()) {
                    case ""+"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 + num2);
                        break;
                    case ""-"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 - num2);
                        break;
                    case ""*"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 * num2);
                        break;
                    case ""/"":
                        num2 = stack.pop();
                        num1 = stack.pop();
                        stack.push(num1 / num2);
                        break;
                }
            }

        }
        double answer = stack.pop();
        return answer;
    }

    public static void main(String[] args) {
        Expression b = new Expression();
  //      Node a = b.Infix2BT(""(((2+3)+(4+5))+((2+3)+(4+5)))"");
       //        Node a = b.Infix2BT(""(12+12)"");
        //   Node a = b.Infix2BT(""((1+1)+(1+1))"");
//        Node[] c = b.PrintPrefix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        System.out.println("" "");
//               c = b.PrintPostfix();
//        for (int i = 0; i < c.length; i++) {
//            System.out.print(c[i].getValue());
//        }
//        b.Evaluation();
//        System.out.println("" "");
      //  System.out.println(b.Evaluation());

    }
}

@150553184b67e722ee2f379773e338a5@"
"b02611016","9","0.97","105840","@6a8f576f6dcf63e4c1c3b8c625926cce@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { //if(ee[i+1].equals("")"")){throw new NullPointerException();}
                if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.isEmpty()){ }
        else{root=vals.pop();}
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //if(root.getValue()==null){throw new NullPointerException();}
        if(root.getValue()==null){throw new NullPointerException();}
       //System.out.println(root.getValue());
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        //Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        if(n==0){throw new NullPointerException();}
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      
         if(vals.isEmpty()){throw new NullPointerException();}
       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test="""";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@6a8f576f6dcf63e4c1c3b8c625926cce@"
"b02611016","9","1","104256","@0678924e096b9cdf9224cad6e6b7d40a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { //if(ee[i+1].equals("")"")){throw new NullPointerException();}
                if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    if(num!=null){
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;}
                   else {}
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.isEmpty()){ }
        else{root=vals.pop();}
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //if(root.getValue()==null){throw new NullPointerException();}
        if(root.getValue()==null){throw new NullPointerException();}
       //System.out.println(root.getValue());
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        //Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
        if(n==0){throw new NullPointerException();}
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
        
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      
         if(vals.isEmpty()){throw new NullPointerException();}
       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test=""()"";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@0678924e096b9cdf9224cad6e6b7d40a@"
"b02611016","10","0.095","105904","@2079c2b9e6535e1f01a369fcfdde948a@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.NoSuchElementException;
public class Expression{
  
    private Node root;
    
     Node[] a=new Node[1000] ;
     Node[] b=new Node[1000] ;
     String[] ee;
    // DO NOT MODIFY THIS
    public Expression(){}
    int n=0 ;
    int count=0;
    int count1=0;
    // Build a Binary and Return the Root
    public Node  Infix2BT(String infix){
        n=0;
      //  this.root=root;
        Stack<Node> vals = new Stack<Node>();
        //Stack<Node> cal = new Stack<Node>();
       // Stack<String> ops = new Stack<String>();
        String num=null;
        ee=infix.split("""");
       // System.out.println(ee);
        int eat=0;
        int next=0;
        //if(ee==null){throw new NullPointerException();}
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=1; i < ee.length; i++) {
            if (ee[i].equals(""("")) { //if(ee[i+1].equals("")"")){throw new NullPointerException();}
                if(num==null){next=1;}
            
            } 
            else if (ee[i].equals(""+"")) { if(num==null){vals.push(new Node(null,null,ee[i]));}
            else{Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""-"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
              
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""*"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals(""/"")) {if(num==null){vals.push(new Node(null,null,ee[i]));}
                     else{
                Node temp_node = new Node(null, null, num);
                vals.push(temp_node); 
                num=null;
                vals.push(new Node(null,null,ee[i]));
                
                //System.out.println(vals.peek().getValue());
            }
            n++;
            } 
            else if (ee[i].equals("")"")) {
                if(vals.isEmpty())
                {//throw new NoSuchElementException(""Stack underflow"");
                    if(num!=null){
                    Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                //Node opt_node =vals.pop();
                num=null;
                 //Node temp=vals.pop();
                 //Node temp_node1=new Node(vals.pop(),temp_node,opt_node.toString());
                 vals.push(temp_node);
                 eat=0;
                 next=0;}
                   else {}
                // System.out.println(vals.peek().getValue());
                }
                else if(eat==1&&next==0)
                {Node temp_node = new Node(null, null, num);
               // vals.push(temp_node); 
               Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node, opt_node.getValue() );
                vals.push(temp_node1);
                eat=0;
                next=0;
          //      System.out.println(vals.peek().getValue());
                }
                else if(eat==0&&next==0){
                Node temp_node=vals.pop();
                Node opt_node =vals.pop();
                   //System.out.println(vals.peek().getValue()); 
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                
               vals.push(temp_node1);
                eat=0;
                next=0;
               
                }
                else if(eat==1&&next==1)
                {Node temp_node = new Node(null, null, num);
                //vals.push(temp_node); 
                 Node opt_node =vals.pop();
                num=null;
                Node temp_node1=new Node(vals.pop(),temp_node,opt_node.getValue());
                vals.push(temp_node1);
                eat=0;
                next=0;
                //System.out.println(vals.peek().getValue());
                }
           /*     else if(eat==0&&next==1){
                  // System.out.println(vals.peek().getValue()); 
                  
                  Node temp_node=vals.pop();
                  if(!cal.isEmpty())
                  {Node temp_node1=new Node(cal.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                  else{Node temp_node1=new Node(vals.pop(), temp_node,ops.pop());
                
                cal.push(temp_node1);
                eat=0;
                next=0;}
                }*/
            } 
            else{if(num==null)
                  {num=ee[i];n++;}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            //n++;
                eat=1;
               //System.out.println(num);
            }
        }
        if(vals.isEmpty()){ }
        else{root=vals.pop();}
        
        return root;
    }
    
    private void printPreOrderRec(Node currRoot ) {
       if (currRoot == null) {
    return ;
     }
      
       
       //int i=0;
        a[count]=currRoot;
       
      //System.out.print(a[i]);
       count=count+1;
      printPreOrderRec(currRoot.getLeft());
      printPreOrderRec(currRoot.getRight());
      
     }

    public Node[] PrintPrefix(){
        //if(root.getValue()==null){throw new NullPointerException();}
        if(root.getValue()==null){throw new NullPointerException();}
//         if(n==0){throw new NullPointerException();}
       //System.out.println(root.getValue());
    //   System.out.println(n);
        Node[] prefix =new Node[n];
        //Node testroot=root;
       // prefix[i]=new Node(null,null,testroot.getValue());
        //System.out.println(prefix[i].getValue());
      //  i=i+1;
        
       printPreOrderRec(root);
        for(int j=0;j<n;j++)
        {prefix[j]=a[j];
         //System.out.println(prefix[j].getValue());
        }
//        if(n==0){throw new NullPointerException();}
    
        count=0;
        
        return prefix;
    }
  
  private void printPostOrderRec(Node currRoot) {
  if (currRoot == null) {
    return;
  }
  printPostOrderRec(currRoot.getLeft());
  printPostOrderRec(currRoot.getRight());
  //System.out.print(currRoot.getValue());
  b[count1]=currRoot;
  count1=count1+1;
}
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[n];
         if(n==0){throw new NullPointerException();}
        printPostOrderRec(root);
        for(int j=0;j<n;j++)
        {postfix[j]=b[j];
         //System.out.println(prefix[j].getValue());
        }
         count1=0;
          
        return postfix;
    }

    public double Evaluation(){
        Stack<String> vals = new Stack<String>();
         if(n==0){throw new NullPointerException();}
        Stack<String> ops = new Stack<String>();
         double answer = 0;
         double ans=0;
        String num=null;
        //String[] ee=infix.split("""");
        int eat=0;
       // n=ee.length-1;
        //System.out.println(n);
        for (int i=0; i < ee.length; i++) {
            if (ee[i].equals(""("")) { if(num==null){}
            } 
            else if (ee[i].equals(""+"")) { if(num==null){ops.push(ee[i]);}
            else{
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""-"")) {if(num==null){ops.push(ee[i]);}
                     else{
               
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
              
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""*"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals(""/"")) {if(num==null){ops.push(ee[i]);}
                     else{
                
                vals.push(num); 
                num=null;
                ops.push(ee[i]);
                
                //System.out.println(vals.peek().getValue());
            }
            
            } 
            else if (ee[i].equals("")"")) {
               if(vals.isEmpty()){vals.push(num);}
                else if(eat==1)
                {
                vals.push(num); 
                num=null;
                eat=0;
                if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                ops.pop();
                vals.push(String.valueOf(ans));
                
                //System.out.println(vals.peek().getValue());
                }
                else if(eat==0){if(ops.peek().equals(""*"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y*x;}
                else if(ops.peek().equals(""+"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y+x;}
                else if(ops.peek().equals(""-"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y-x;}
                else if(ops.peek().equals(""/"")){
                Double x=Double.parseDouble(vals.pop());
                Double y=Double.parseDouble(vals.pop());
                ans=y/x;}
                vals.push(String.valueOf(ans));
                ops.pop();
                 //System.out.println(vals.peek().getValue());   
                num=null;
                eat=0;
                }
            } 
            else{if(num==null)
                  {num=ee[i];}
            else{num=num+ee[i];}
                //Node temp_node = new Node(null, null, ee[i]);
                //vals.push(temp_node); 
            
                eat=1;
               //System.out.println(num);
            }
        }
      
         if(vals.isEmpty()){throw new NullPointerException();}
       // System.out.printf(""%.2f"",s_d)
        Double total=Double.parseDouble(vals.peek());
       //total=(Math.floor(total*1000000000))/1000000000 ;
     answer=total;
        return answer;
    }
    public static void main(String[] args) throws Exception {
        String test=""((20120224791*(121259+797912))+(211544771212/2))"";
        
        Expression tem=new Expression();
       // tem.Infix2BT(test);
        
       // temp=tem.Infix2BT(test);
        String abc = tem.Infix2BT(test).getValue();
       // System.out.println(abc);
        
       // Node temp = tem.Infix2BT(test);
       // System.out.println(temp.getValue());
        Node[] tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
       // tempp[]=tem.PrintPostfix();
    System.out.println();
    Node[] temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
        double u=tem.Evaluation();
        System.out.println(u);
       // tempp[]=tem.PrintPostfix();
        test=""()"";
        tem.Infix2BT(test);
        tempp = tem.PrintPrefix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(tempp[i].getValue());}
          System.out.println();
        temppp = tem.PrintPostfix();
        for(int i=0;i<tempp.length;i++)
        { System.out.print(temppp[i].getValue());}
         u=tem.Evaluation();
        System.out.println(u);
    }
}



@2079c2b9e6535e1f01a369fcfdde948a@"
"r04522616","3","0.29","102256","@bf2b7883736801f37efe778d887b24dc@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix  = new Node[outData.length];
        //String[] check=new String[outData.length];
        int j=0;
        int k=0;
        int l=0;
        for(int i=0;i<outData.length;i++)
        {
            j=i;
            char isANumber=outData[i].charAt(0);
            if(outData[i].equals(""(""))
            {
                Node a=new Node(null,null,outData[i]);
                prefix[i-k-l]=a;
                //check[i-k-l]=outData[i];
            }
            else if(outData[i].equals("")""))
            {
                l++;
            }
            else if(Character.isDigit(isANumber)==true)
            {
                Node a=new Node(null,null,outData[i]);
                prefix[i-k-l]=a;
                //check[i-k-l]=outData[i];
            }
            else if(Character.isDigit(isANumber)!=true && outData[i].equals(""("")!=true && outData[i].equals("")"")!=true)
            {
                do
                {                    
                    if(outData[j].equals(""("")!=true)
                    {
                        j--;
                    }
                    else if(outData[j].equals(""("")==true)
                    {
                        Node a=new Node(null,null,outData[i]);
                        prefix[j-k]=a;
                        //check[j-k]=outData[i];
                        break;
                    }
                }
                while(j>=0);
                k++;
            }
        }
//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
        

        return prefix;
    }
    
//private static void preorderPrintTree(Node root) {
//        if (root.getLeft()==null && root.getRight()==null)
//        {
//            System.out.print(root.getValue());
//            
//        }
//        else 
//        {
//            System.out.print(root.getValue());
//            
//            preorderPrintTree(root.getLeft());
//            
//            preorderPrintTree(root.getRight());            
//        }
//    }
  
    public Node[] PrintPostfix(){
        
        Node[] postfix = new Node[outData.length];
        //String[] check=new String[outData.length];
        
        Stack<String> stk=new Stack<String>();
        int j=0;
        for(int i=1;i<outData.length;i++)
        {            
            char isANumber=outData[i].charAt(0);
            if(outData[i].equals(""(""))
            {
                j++;
            }
            else if(outData[i].equals("")""))
            {
                String symbol=stk.pop();
                postfix[i-j-1]=new Node(null, null, symbol);
                //check[i-j-1]=symbol;
            }
            else if(Character.isDigit(isANumber)!=true && outData[i].equals(""("")!=true && outData[i].equals("")"")!=true)
            {
                j++;
                stk.push(outData[i]);
            }
            else
            {
                Node a=new Node(null, null, outData[i]);
                postfix[i-j-1]=a;
                //check[i-j-1]=outData[i];
            }
        }
//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
//        System.out.print(""\n"");
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@bf2b7883736801f37efe778d887b24dc@"
"r03945012","3","0.98","105968","@bc49e9cb23b41b222954877fc4a74ceb@
import java.util.ArrayList;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */

public class Expression{
  
    private Node root;
    private final ArrayList<Node> prefix_answer = new ArrayList<>();
    private final ArrayList<Node> postfix_answer = new ArrayList<>();
    private String[] dataArr;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++){
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++){
                if (string.charAt(i) == operator.get(j)){
                    isoperater = true;
                    if (n != 0){
                        data.add(string.substring(i-n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i+1));
                }
            }
            if (isoperater == false){
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");
        
        // Node 2 tmp: a, b
        Node a = null;
        Node b = null;
        Stack<String> s = new Stack<String>();
        for (int i=0; i < dataArr.length; i++){
            s.push(dataArr[i]);
            if (root == null && "")"".equals(dataArr[i])){
                s.pop();
                String num2 = s.pop();
                String operat = s.pop();
                String num1 = s.pop();
                s.pop();
                a = new Node(null, null, num1);
                b = new Node(null, null, num2);
                root = new Node(a, b, operat);
            }
            else if ("")"".equals((dataArr[i]))){
                s.pop();
                String tmp1 = s.pop();
                String tmp2 = s.pop();
                s.pop();
                if (op.contains(tmp1)){
                    a = new Node(null, null, tmp2);
                    root = new Node(a, root, tmp1);
                }
                else if(op.contains(tmp2)){
                    b = new Node(null, null, tmp1);
                    root = new Node(root, b, tmp2);
                }   
            }        
        }
        return(root);
    }

    public Node[] PrintPrefix(){
        preOrder(root);
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }
    
    private void preOrder(Node a){
        if (a != null){
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }
  
    public Node[] PrintPostfix(){
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a){
        if (a != null){
            postfix_answer.add(a);
            postOrder(a.getLeft());
            postOrder(a.getRight());
        }
}
    
    
    public double Evaluation(){
        double answer = 0;        
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i=0; i<data.length; i++){
            s.push(data[i]);
            if ("")"".equals(s.peek())){
                for (int j=0; j<5; j++)
                    tmp[j] = s.pop();
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]){
                    case ""+"":
                        answer = num1+num2;
                        break;
                    case ""-"":
                        answer = num1-num2;
                        break;
                    case ""*"":
                        answer = num1*num2;
                        break;
                    case ""/"":
                        answer = num1/num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return(answer);
    }
    
    
    // testing
//    public static void main(String[] args){
//        String a = ""(4+(((4*2)/2)/3))"";
//        Expression cct = new Expression();
//        Node result = cct.Infix2BT(a);
//        Node[] test = cct.PrintPrefix();
//        StdOut.println(cct.Evaluation());
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
//        StdOut.println(result.getValue());
//        StdOut.println(result.getLeft().getValue());
//        StdOut.println(result.getRight().getValue());
//        
//    }
    
}
@bc49e9cb23b41b222954877fc4a74ceb@"
"r03945012","3","0.99","105792","@e203fce0a1c50ae151622b79b84f2f47@
import java.util.ArrayList;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */

public class Expression{
  
    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++){
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++){
                if (string.charAt(i) == operator.get(j)){
                    isoperater = true;
                    if (n != 0){
                        data.add(string.substring(i-n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i+1));
                }
            }
            if (isoperater == false){
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");
        
        // Node 2 tmp: a, b
        Node a = null;
        Node b = null;
        Stack<String> s = new Stack<String>();
        for (int i=0; i < dataArr.length; i++){
            s.push(dataArr[i]);
            if (root == null && "")"".equals(dataArr[i])){
                s.pop();
                String num2 = s.pop();
                String operat = s.pop();
                String num1 = s.pop();
                s.pop();
                a = new Node(null, null, num1);
                b = new Node(null, null, num2);
                root = new Node(a, b, operat);
            }
            else if ("")"".equals((dataArr[i]))){
                s.pop();
                String tmp1 = s.pop();
                String tmp2 = s.pop();
                s.pop();
                if (op.contains(tmp1)){
                    a = new Node(null, null, tmp2);
                    root = new Node(a, root, tmp1);
                }
                else if(op.contains(tmp2)){
                    b = new Node(null, null, tmp1);
                    root = new Node(root, b, tmp2);
                }   
            }        
        }
        return(root);
    }

    public Node[] PrintPrefix(){
        preOrder(root);
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }
    
    private void preOrder(Node a){
        if (a != null){
            prefix_answer = new ArrayList<>();
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }
  
    public Node[] PrintPostfix(){
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a){
        if (a != null){
            postfix_answer = new ArrayList<>();
            postfix_answer.add(a);
            postOrder(a.getLeft());
            postOrder(a.getRight());
        }
}
    
    
    public double Evaluation(){
        double answer = 0;        
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i=0; i<data.length; i++){
            s.push(data[i]);
            if ("")"".equals(s.peek())){
                for (int j=0; j<5; j++)
                    tmp[j] = s.pop();
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]){
                    case ""+"":
                        answer = num1+num2;
                        break;
                    case ""-"":
                        answer = num1-num2;
                        break;
                    case ""*"":
                        answer = num1*num2;
                        break;
                    case ""/"":
                        answer = num1/num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return(answer);
    }
    
    
    // testing
    public static void main(String[] args){
        String a = ""(4+(((4*2)/2)/3))"";
        Expression cct = new Expression();
        Node result = cct.Infix2BT(a);
        Node[] test = cct.PrintPrefix();
//        StdOut.println(cct.Evaluation());
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
//        StdOut.println(result.getValue());
//        StdOut.println(result.getLeft().getValue());
//        StdOut.println(result.getRight().getValue());
        
    }
    
}
@e203fce0a1c50ae151622b79b84f2f47@"
"r03945012","3","0.96","105840","@3380df9478a8ce2fe6caa19a156daf7e@
import java.util.ArrayList;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */

public class Expression{
  
    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        // initize root
        root = null;
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++){
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++){
                if (string.charAt(i) == operator.get(j)){
                    isoperater = true;
                    if (n != 0){
                        data.add(string.substring(i-n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i+1));
                }
            }
            if (isoperater == false){
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");
        
        // Node 2 tmp: a, b
        Node a = null;
        Node b = null;
        Stack<String> s = new Stack<String>();
        for (int i=0; i < dataArr.length; i++){
            s.push(dataArr[i]);
            if (root == null && "")"".equals(dataArr[i])){
                s.pop();
                String num2 = s.pop();
                String operat = s.pop();
                String num1 = s.pop();
                s.pop();
                a = new Node(null, null, num1);
                b = new Node(null, null, num2);
                root = new Node(a, b, operat);
            }
            else if ("")"".equals((dataArr[i]))){
                s.pop();
                String tmp1 = s.pop();
                String tmp2 = s.pop();
                s.pop();
                if (op.contains(tmp1)){
                    a = new Node(null, null, tmp2);
                    root = new Node(a, root, tmp1);
                }
                else if(op.contains(tmp2)){
                    b = new Node(null, null, tmp1);
                    root = new Node(root, b, tmp2);
                }   
            }        
        }
        return(root);
    }

    public Node[] PrintPrefix(){
        preOrder(root);
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }
    
    private void preOrder(Node a){
        if (a != null){
            prefix_answer = new ArrayList<>();
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }
  
    public Node[] PrintPostfix(){
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a){
        if (a != null){
            postfix_answer = new ArrayList<>();
            postfix_answer.add(a);
            postOrder(a.getLeft());
            postOrder(a.getRight());
        }
}
    
    
    public double Evaluation(){
        double answer = 0;        
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i=0; i<data.length; i++){
            s.push(data[i]);
            if ("")"".equals(s.peek())){
                for (int j=0; j<5; j++)
                    tmp[j] = s.pop();
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]){
                    case ""+"":
                        answer = num1+num2;
                        break;
                    case ""-"":
                        answer = num1-num2;
                        break;
                    case ""*"":
                        answer = num1*num2;
                        break;
                    case ""/"":
                        answer = num1/num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return(answer);
    }
    
    
    // testing
    public static void main(String[] args){
        String a = ""(4+(((4*2)/2)/3))"";
        String b = ""(60*(((4*2)/2)*3))"";
        Expression cct = new Expression();
        Node result = cct.Infix2BT(a);
        result = cct.Infix2BT(b);
        Node[] test = cct.PrintPrefix();
//        StdOut.println(cct.Evaluation());
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
        StdOut.println(result.getValue());
        StdOut.println(result.getLeft().getValue());
        StdOut.println(result.getRight().getValue());
        
    }
    
}
@3380df9478a8ce2fe6caa19a156daf7e@"
"b02611026","0","0","0","@65ed7e025afd44e81c037a0d0d1ea6aa@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] input = new String[infix.length()];
        int count = 0;

        Stack<Node> left = new Stack<Node>();
        Stack<Node> roots = new Stack<Node>();
        Stack<Node> right = new Stack<Node>();

        for (int i = 0; i < infix.length() + 1; i++) {
            input = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])"");
            if (input[i].equals(""("") || input[i].equals("")"")) {
                count++;
            }
        }
//        for (int i = 0; i < infix.length() + 1; i++) {
//            System.out.print(input[i] + ""\n"");
//        }

//        System.out.print(""-------------------------\n"");
        //stem.out.print(infix.length());
//        Node[] inputarray = new Node[infix.length() - count];
        Node ing;
        Node[] ans = new Node[count / 2];
        Node temp = new Node(null, null, ""null"");;
//        Node temp_root1 = new Node(null, null, null);
//        Node temp_root2 = new Node(null, null, null);

        int root_flag = 0;
        int left_flag = 0;
//        int left_ff = 0;
        int right_flag = 0;
//        int right_ff = 0;
        int j = 1;
        int k = 0;
        
        left.push(temp);
        roots.push(temp);
        right.push(temp);
        

        for (int i = 0; i < (infix.length() ); i++) {
            while (j < (infix.length())) {
                j++;
                if (input[j].equals(""("")) {
//                    if (left_flag != 1) {
//                        left_ff = 1;
//                    }
//                    if (right_flag != 1) {
//                        right_ff = 1;
//                    }
                    root_flag = 0;
                    left_flag = 0;
                    right_flag = 0;
                    //System.out.print(j);
                    continue;
                } else if (input[j].equals("")"")) {
                    if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {//都有      
                        //temp_root1 = roots.pop();
                        ans[k] = new Node(left.pop(), right.pop(), roots.pop().getValue());
                        right_flag = right_flag - 1;
                        root_flag = root_flag - 1;
                        left_flag = left_flag - 1;
//                        System.out.print(""all\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {  //沒有left
                        //temp_root2 = roots.pop();
                        if (((k - 1) >= 0)) {
                            ans[k] = new Node(ans[k - 1], right.pop(), roots.pop().getValue());
                            right_flag = right_flag - 1;
                            root_flag = root_flag - 1;
                        }
                        left.pop();
//                        System.out.print(""no left\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) {   //沒有right
                        if (((k - 1) >= 0)) {
                            ans[k] = new Node(left.pop(), ans[k - 1], roots.pop().getValue());
                            left_flag = left_flag - 1;
                            root_flag = root_flag - 1;
                        }
                        right.pop();
//                        System.out.print(""no right\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) { //只有root
                        if (((k - 2) >= 0) && ((k - 1) >= 0)) {
                            ans[k] = new Node(ans[k - 2], ans[k - 1], roots.pop().getValue());
                            root_flag = root_flag - 1;
                        }
                        left.pop();
                        right.pop();
//                        System.out.print(""only root\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    }
                    k++;
                    break;

                } else if ((input[j].equals(""+"")) || (input[j].equals(""-"")) || (input[j].equals(""*"")) || (input[j].equals(""/""))) {
                    root_flag++;
                    ing = new Node(null, null, input[j]);
                    roots.push(ing);
                    //System.out.print(j);
                    break;
                } else {
                    temp = new Node(null, null, ""null"");
                    ing = new Node(null, null, input[j]);
                    if (root_flag != 0) {
                        if (left_flag != 0) {                            
                            right.push(ing);
                            right_flag++;
                        } else {
                            left.push(temp);                            
                            right.push(ing);
                            right_flag++;
                        }
                    } //System.out.print(j);
                    else {
                        left.push(ing);
                        right.push(temp);
                        left_flag++;
                        //System.out.print(j);
                    }
                    break;
                }

            }
        }
        root = ans[k-1];
        return root;
    }
    
    Stack<Node> a = new Stack<Node>();
    Stack<Node> b = new Stack<Node>();
    Stack<Node> c = new Stack<Node>();
    
    public Node[] PrintPrefix() {
        pre(root);       
        int size = a.size();
        Node[] ans = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
        //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
        for(int i = 0 ; i < size ; i++){
            //ans[0] = prefix.pop();
            ans[i] = a.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
            //System.out.print(i+ ""\n"");
        }
        return ans;
    }
    
    private void pre(Node n){        
        if(n != null){            
            //System.out.printf(n.getValue() + ""\n"");
            pre(n.getRight());
            pre(n.getLeft());
            a.push(n);
        }
    }   
    
    public Node[] PrintPostfix() {
        post(root);       
        int size = b.size();
        Node[] ans = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
        //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
        for(int i = 0 ; i < size ; i++){
            //ans[0] = prefix.pop();
            ans[i] = b.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
            //System.out.print(i+ ""\n"");
        }
        return ans;
    }
    
    private void post(Node n){        
        if(n != null){            
            //System.out.printf(n.getValue() + ""\n"");
            b.push(n);
            post(n.getRight());
            post(n.getLeft());
            
        }
    } 

    public double Evaluation() {
        eva(root);       
        int size = c.size();
        Node[] ans = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
        //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
        for(int i = 0 ; i < size ; i++){
            //ans[0] = prefix.pop();
            ans[i] = c.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
            //System.out.print(i+ ""\n"");
        }        
        
        Stack<String> ops = new Stack<String>();
        Stack<Double> vals = new Stack<Double>();
        for(int i = 0 ; i < size ; i++){
            if (ans[i].getValue().equals(""+"")) {
                vals.push(vals.pop() + vals.pop());
            } else if (ans[i].getValue().equals(""*"")) {
                vals.push(vals.pop() * vals.pop());
            } else if (ans[i].getValue().equals(""/"")) {
                double one = vals.pop();
                double two = vals.pop();
                vals.push(two / one);
            } else if (ans[i].getValue().equals(""-"")) {
                double one = vals.pop();
                double two = vals.pop();
                vals.push(two - one);
            } else {
                vals.push(Double.parseDouble(ans[i].getValue()));
            }
        }
        double answer = vals.pop();
        
        return answer;
    }
    
    private void eva(Node n){        
        if(n != null){            
            //System.out.printf(n.getValue() + ""\n"");
            c.push(n);
            eva(n.getRight());
            eva(n.getLeft());
            
        }
    }

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            String input = ""(4+(((4*2)/2)/3))"";
//
//            Expression test = new Expression();
//            test.Infix2BT(input);
//            test.PrintPrefix();
//            test.PrintPostfix();
//            
//            //Node[] a = test.PrintPrefix();
//            //System.out.printf(test.PrintPrefix()[0].getValue());
//            //System.out.print();
//            test.Evaluation();
//            
//
//        }
//    }

}

@65ed7e025afd44e81c037a0d0d1ea6aa@"
"r04945009","0","0.99","105792","@c9069eea70799dea37977bb264e6c6d6@
import java.util.Arrays;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    public void rightin(Node root, String[] in) {
        int count = 0;      
        if (in[0].equals(""("")) {
            for (int i=1; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setRight(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getRight(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getRight(), leftout);  
                    }
            }
        }
        else {
            int num=0;
            for (int i=1; i<in.length; i++) {
                if (in[i].equals("")"")) {
                    num = i;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, 0, out, 0, num);
            root.setRight(new Node(null, null, Arrays.toString(out)));
        }
    }
    
    public void leftin(Node root, String[] in) {
        int count = 0;      
        if (in[in.length-1].equals("")"")) {
            for (int i=in.length-2; i>-1; i--) {
                if      (in[i].equals("")"")) count++;
                else if (in[i].equals(""("")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setLeft(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getLeft(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getLeft(), leftout);  
                    }
            }
        }        
        else {
            int num=0;
            for (int i=in.length-2; i>-1; i--) {
                if (in[i].equals(""("")) {
                    num = in.length-2-i+1;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, in.length-num, out, 0, num);
            root.setLeft(new Node(null, null, Arrays.toString(out)));
        }
    }
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] in = infix.split("""");
        
        int count = 0;      
        if (in[1].equals(""("")) {
            for (int i=2; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root = new Node(null, null, in[i]);
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root, rightout);
                        String[] leftout = new String[i-1];
                        System.arraycopy(in, 1, leftout, 0, i-1);
                        leftin(root, leftout);  
                    }
            }
        }
        else {
            int num=0;
            for (int i=2; i<in.length; i++) {
                if (in[i].equals("")"")) {
                    num = i;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, 1, out, 0, num-1);
            root = new Node(null, null, Arrays.toString(out));
        }

        return root;
    }
    
//    public void traversal(Node p, Node[] prefix)
//        {
//            if (p == null) return;
//            prefix[precount] = p;
//            traversal(p.getLeft(), prefix); // 次輸出左子樹
//            traversal(p.getRight(), prefix);// 後輸出右子樹
//        }
//    
//    int precount;
//    public Node[] PrintPrefix(){
//        Node[] prefix = null;
//        precount = 0;
//        traversal(root, prefix);
//        return prefix;
//    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        return answer;
    }
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""(4+(((4*2)/2)/3))"");
//        Node[] prefix = go.PrintPrefix();
        System.out.println(root.getValue());
}
}

@c9069eea70799dea37977bb264e6c6d6@"
"r04921105","6","0.99","105856","@8903b466de39f504511676b89163ccaf@import java.util.*;
import java.util.NoSuchElementException;

public class Expression{
    private Node root;
    private String[] input;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String e){
        List<String> p = new ArrayList<>();                        

        int counter = 0;
        int c = 0;
        while(c < e.length()){
            counter = c;
            String a = e.substring(c,c+1);
            if(a.equals(""("") || a.equals("")"") || a.equals(""+"") || a.equals(""-"") || a.equals(""*"") || a.equals(""/"")){    
            p.add(a);
            c++;}
            else{            
            int temp = c+1; 
            String b = e.substring(temp,temp+1);
            while(!(b.equals("")"") || b.equals(""+"") || b.equals(""-"") || b.equals(""*"") || b.equals(""/""))){            
            temp++;
            b = e.substring(temp,temp+1);
            }
            p.add(e.substring(c,temp));
            c = temp;
            }
        }
        
        
        input = new String[p.size()];
        input = p.toArray(input);
        
        Stack<Node> ops = new Stack<>();        
        Stack<Node> vals = new Stack<>();
        
        for (String s : input) {
            if (s.equals(""("")) ;
            else if (s.equals(""+"") || s.equals(""-"") || s.equals(""*"") || s.equals(""/"")) {ops.push(new Node(null,null,s));}
            else if (s.equals("")""))
            {
                if(ops.isEmpty());
                else{
                Node a = ops.pop();
                a.setRight(vals.pop());
                a.setLeft(vals.pop());
                vals.push(a);}
            }
            else vals.push(new Node(null,null,s));         
        }
        
        root = vals.pop();
        return(root);
    }
    public Node[] PrintPrefix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> prefix;
        prefix = new ArrayList<>();
        get_prefix(prefix,root);

        return prefix.toArray(new Node[prefix.size()]);
    }
  
    public Node[] PrintPostfix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> postfix;
        postfix = new ArrayList<>();
        get_postfix(postfix,root);

        return postfix.toArray(new Node[postfix.size()]);
    }

    public double Evaluation(){
        if(root==null)
            throw new NullPointerException();        
       // switch()       
        return evaluate(root);
    }

    private void get_prefix(List<Node> a,Node b) {
        if(b==null)
            return;
            a.add(b);
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
    }
    private void get_postfix(List<Node> a,Node b) {
        if(b==null)
            return;
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
            a.add(b);
    }

    private double evaluate(Node root) {
        switch(root.getValue()){
            case""+"":
                return evaluate(root.getLeft())+evaluate(root.getRight());
            case""-"":
                return evaluate(root.getLeft())-evaluate(root.getRight());
            case""*"":
                return evaluate(root.getLeft())*evaluate(root.getRight());
            case""/"":
                return evaluate(root.getLeft())/evaluate(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }                        
        
       
    }


}

@8903b466de39f504511676b89163ccaf@"
"r04921105","0","0.99","105856","@378f358edf5b71719eda4c52543e8833@import java.util.ArrayList;
import java.util.List;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();        
        Stack<Node> vals = new Stack<Node>();
        boolean flag =false;
        String[] input = infix.split("""");
         for(int i=0;i<input.length;i++){
            String s = input[i];
            //System.out.println(s);
            switch(s){
                case(""(""):
                    flag=false;
                    break;
                   
            case(""+""):
                //else if (s.equals(""+"") || s.equals(""-"") || s.equals(""*"") || s.equals(""/""))
                //Node ops =(null,null,s);          
            case(""-""):
            case(""*""):
            case(""/""):
                ops.push(new Node(null,null,s));
                flag=false;
                break;
                
            case("")""):               
                //vals.pop();
                //vals.pop();              
                //ops.pop();
                String val =ops.pop().getValue();
                
                //new Node(vals.pop(),vals.pop(),ss);
                Node r = vals.pop();
                Node l = vals.pop();
                vals.push(new Node(l,r,val));
                flag=false;
                //System.out.println(val);
                break;
            default:
                if(flag==false){
                vals.push(new Node(null,null,s));
                flag=true;
                }
                else if(flag==true){
                    String f1=vals.pop().getValue();
                    //System.out.println(f1);
                 vals.push(new Node(null,null,f1+s));
                 //System.out.println(f1+s);                
                }                
                break;

            }//end of switch              
         }//end of for
        root = vals.pop();
        return root;
    }

    public Node[] PrintInfix(){
        if(root == null) throw new NullPointerException();
        List<Node> n = new ArrayList<>();
        for (String input1 : input) {    
                n.add(new Node(null, null, input1));
        }

        Node[] infix = new Node[n.size()];
        infix = n.toArray(infix);
        
        return(infix);        
                
    }    
    
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> n = new ArrayList<>();
        Stack<Node> stack = new Stack<>(); 
                
        stack.push(root);  
    
         while(stack.isEmpty()==false){  
             Node node = stack.pop();
             n.add(node);
 
             if((node.getRight() == null)==false){  
                 stack.push(node.getRight());  
             }  
             if((node.getLeft() == null)==false){  
                 stack.push(node.getLeft());  
             }  
    
         }  


        Node[] prefix = new Node[n.size()];
        prefix = n.toArray(prefix);
        
        return(prefix);
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> n = new ArrayList<>();
        Stack<Node> s = new Stack<>(); 
        
        Node current = root;
        
    while( true ) {  
    
        if(( current == null )==false) {  
             if(( current.getRight() == null )==false)   
              s.push( current.getRight() );  
             s.push( current );  
             current = current.getLeft();  
             continue;  
        }  

        if(s.isEmpty())
            break;
        current = s.pop( );
        
        if( (current.getRight() == null)==false && s.isEmpty( )==false && current.getRight() == s.peek() ) {  
            s.pop( );  
            s.push( current );  
            current = current.getRight();} 
        else {  
            n.add(current);
            current = null;  
        }  
    } 
        Node[] postfix = new Node[n.size()];
        postfix = n.toArray(postfix);
        
        return(postfix);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        
        Stack<String> ops = new Stack<>();        
        Stack<Double> vals = new Stack<>();
        
        for (String s : input) {
            if (s.equals(""("")) ;
            else if (s.equals(""+"") || s.equals(""-"")) ops.push(s);
            else if (s.equals(""*"") || s.equals(""/"")) ops.push(s);
            else if (s.equals("")""))
            {
                if(ops.isEmpty());
                else{
                String op = ops.pop();
                if (op.equals(""+"")) vals.push(vals.pop() + vals.pop());
                else if (op.equals(""-"")) {
                    double a = vals.pop();
                    vals.push(vals.pop() - a);
                }
                else if (op.equals(""*"")) vals.push(vals.pop() * vals.pop());
                else if (op.equals(""/"")) {
                    double a = vals.pop();
                    vals.push(vals.pop() / a);
                }}
            }
            else vals.push(Double.parseDouble(s));
        }
        return(vals.pop());
    }
    
}
@378f358edf5b71719eda4c52543e8833@"
"r04945009","0","0.63","105472","@76c0f7bc728d7f4d43cd8985adbc444e@
import java.util.Arrays;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    public void rightin(Node root, String[] in) {
        int count = 0;      
        if (in[0].equals(""("")) {
            for (int i=1; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setRight(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getRight(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getRight(), leftout);  
                    }
            }
        }
        else {
            int num=0;
            for (int i=1; i<in.length; i++) {
                if (in[i].equals("")"")) {
                    num = i;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, 0, out, 0, num);
            String str1 = Arrays.toString(out);
            str1 = str1.substring(1, str1.length()-1);
            root.setRight(new Node(null, null, str1));
        }
    }
    
    public void leftin(Node root, String[] in) {
        int count = 0;      
        if (in[in.length-1].equals("")"")) {
            for (int i=in.length-2; i>-1; i--) {
                if      (in[i].equals("")"")) count++;
                else if (in[i].equals(""("")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setLeft(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getLeft(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getLeft(), leftout);  
                    }
            }
        }        
        else {
            int num=0;
            for (int i=in.length-2; i>-1; i--) {
                if (in[i].equals(""("")) {
                    num = in.length-2-i+1;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, in.length-num, out, 0, num);
            String str1 = Arrays.toString(out);
            str1 = str1.substring(1, str1.length()-1);
            root.setLeft(new Node(null, null, str1));
        }
    }
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] in = infix.split("""");
        
        int count = 0;      
        if (in[1].equals(""("")) {
            for (int i=2; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root = new Node(null, null, in[i]);
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root, rightout);
                        String[] leftout = new String[i-1];
                        System.arraycopy(in, 1, leftout, 0, i-1);
                        leftin(root, leftout);  
                    }
            }
//            if (count<0) {
//                int num=0;
//                for (int i=2; i<in.length; i++) {
//                    if (in[i].equals("")"")) {
//                        num = i-1;
//                        break;
//                    }
//                }
//                String[] out = new String[num-1];
//                System.arraycopy(in, 2, out, 0, num-1);
//                String str1 = Arrays.toString(out);
//                str1 = str1.substring(1, str1.length()-1);
//                root = new Node(null, null, str1);
//                
//            }
        }
        

        return root;
    }
    
    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    int precount;
    public Node[] PrintPrefix(){
        Node[] pre = new Node[100];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    int postcount;
    public Node[] PrintPostfix(){
        Node[] post = new Node[100];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""(4+(((4*2)/2)/3))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
}
}

@76c0f7bc728d7f4d43cd8985adbc444e@"
"r04945009","1","0.18","102496","@49d7fea584bb2969d91488c6ba580220@
import java.util.Arrays;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    public void rightin(Node root, String[] in) {
        int count = 0;      
        if (in[0].equals(""("")) {
            for (int i=1; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setRight(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getRight(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getRight(), leftout);  
                    }
            }
        }
        else {
            int num=0;
            for (int i=1; i<in.length; i++) {
                if (in[i].equals("")"")) {
                    num = i;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, 0, out, 0, num);
            String str1 = Arrays.toString(out);
            str1 = str1.substring(1, str1.length()-1).replaceAll("","", """");
            root.setRight(new Node(null, null, str1));
        }
    }
    
    public void leftin(Node root, String[] in) {
        int count = 0;      
        if (in[in.length-1].equals("")"")) {
            for (int i=in.length-2; i>-1; i--) {
                if      (in[i].equals("")"")) count++;
                else if (in[i].equals(""("")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setLeft(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getLeft(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getLeft(), leftout);  
                    }
            }
        }        
        else {
            int num=0;
            for (int i=in.length-2; i>-1; i--) {
                if (in[i].equals(""("")) {
                    num = in.length-2-i+1;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, in.length-num, out, 0, num);
            String str1 = Arrays.toString(out);
            str1 = str1.substring(1, str1.length()-1).replaceAll("","", """");
            root.setLeft(new Node(null, null, str1));
        }
    }
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] in = infix.split("""");
        
        int count = 0;      
        if (in[1].equals(""("")) {
            for (int i=2; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root = new Node(null, null, in[i]);
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root, rightout);
                        String[] leftout = new String[i-1];
                        System.arraycopy(in, 1, leftout, 0, i-1);
                        leftin(root, leftout);  
                    }
            }
//            if (count<0) {
//                int num=0;
//                for (int i=2; i<in.length; i++) {
//                    if (in[i].equals("")"")) {
//                        num = i-1;
//                        break;
//                    }
//                }
//                String[] out = new String[num-1];
//                System.arraycopy(in, 2, out, 0, num-1);
//                String str1 = Arrays.toString(out);
//                str1 = str1.substring(1, str1.length()-1);
//                root = new Node(null, null, str1);
//                
//            }
        }
        

        return root;
    }
    
    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[100];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[100];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
//    public static void main(String[] args) {
//        Expression go = new Expression();
//        Node root = go.Infix2BT(""(((2+3)+(4+5))+((2+3)+(4+5)))"");
//        Node[] prefix = go.PrintPrefix();
//        Node[] postfix = go.PrintPostfix();
//        double answer = go.Evaluation();
//        System.out.println(root.getValue());
//}
}

@49d7fea584bb2969d91488c6ba580220@"
"r04945009","1","0.18","101408","@ee6bad8c2c104f3596c742d1cb868dfc@
import java.util.Arrays;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    public void rightin(Node root, String[] in) {
        int count = 0;      
        if (in[0].equals(""("")) {
            for (int i=1; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setRight(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getRight(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getRight(), leftout);  
                    }
            }
        }
        else {
            int num=0;
            for (int i=1; i<in.length; i++) {
                if (in[i].equals("")"")) {
                    num = i;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, 0, out, 0, num);
            String str1 = Arrays.toString(out);
            str1 = str1.substring(1, str1.length()-1).replaceAll("","", """");
            root.setRight(new Node(null, null, str1));
        }
    }
    
    public void leftin(Node root, String[] in) {
        int count = 0;      
        if (in[in.length-1].equals("")"")) {
            for (int i=in.length-2; i>-1; i--) {
                if      (in[i].equals("")"")) count++;
                else if (in[i].equals(""("")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setLeft(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getLeft(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getLeft(), leftout);  
                    }
            }
        }        
        else {
            int num=0;
            for (int i=in.length-2; i>-1; i--) {
                if (in[i].equals(""("")) {
                    num = in.length-2-i+1;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, in.length-num, out, 0, num);
            String str1 = Arrays.toString(out);
            str1 = str1.substring(1, str1.length()-1).replaceAll("","", """");
            root.setLeft(new Node(null, null, str1));
        }
    }
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] in = infix.split("""");
        
        int count = 0;      
        if (in[1].equals(""("")) {
            for (int i=2; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root = new Node(null, null, in[i]);
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root, rightout);
                        String[] leftout = new String[i-1];
                        System.arraycopy(in, 1, leftout, 0, i-1);
                        leftin(root, leftout);  
                    }
            }
//            if (count<0) {
//                int num=0;
//                for (int i=2; i<in.length; i++) {
//                    if (in[i].equals("")"")) {
//                        num = i-1;
//                        break;
//                    }
//                }
//                String[] out = new String[num-1];
//                System.arraycopy(in, 2, out, 0, num-1);
//                String str1 = Arrays.toString(out);
//                str1 = str1.substring(1, str1.length()-1);
//                root = new Node(null, null, str1);
//                
//            }
        }
        

        return root;
    }
    
    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[1000];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[1000];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""(((2+3)+(4+5))+((2+3)+(4+5)))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
}
}

@ee6bad8c2c104f3596c742d1cb868dfc@"
"r04945009","1","0.17","105248","@d7a472a2848556bb35ad304946da9363@
import java.util.Arrays;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    public void rightin(Node root, String[] in) {
        int count = 0;      
        if (in[0].equals(""("")) {
            for (int i=1; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setRight(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getRight(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getRight(), leftout);  
                    }
            }
        }
        else {
            int num=0;
            for (int i=1; i<in.length; i++) {
                if (in[i].equals("")"")) {
                    num = i;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, 0, out, 0, num);
            String str1 = Arrays.toString(out);
            str1 = str1.substring(1, str1.length()-1).replaceAll("","", """");
            root.setRight(new Node(null, null, str1));
        }
    }
    
    public void leftin(Node root, String[] in) {
        int count = 0;      
        if (in[in.length-1].equals("")"")) {
            for (int i=in.length-2; i>-1; i--) {
                if      (in[i].equals("")"")) count++;
                else if (in[i].equals(""("")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setLeft(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getLeft(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getLeft(), leftout);  
                    }
            }
        }        
        else {
            int num=0;
            for (int i=in.length-2; i>-1; i--) {
                if (in[i].equals(""("")) {
                    num = in.length-2-i+1;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, in.length-num, out, 0, num);
            String str1 = Arrays.toString(out);
            str1 = str1.substring(1, str1.length()-1).replaceAll("","", """");
            root.setLeft(new Node(null, null, str1));
        }
    }
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        String[] in = infix.split("""");
        
        int count = 0;      
        if (in[1].equals(""("")) {
            for (int i=2; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root = new Node(null, null, in[i]);
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root, rightout);
                        String[] leftout = new String[i-1];
                        System.arraycopy(in, 1, leftout, 0, i-1);
                        leftin(root, leftout);  
                    }
            }
//            if (count<0) {
//                int num=0;
//                for (int i=2; i<in.length; i++) {
//                    if (in[i].equals("")"")) {
//                        num = i-1;
//                        break;
//                    }
//                }
//                String[] out = new String[num-1];
//                System.arraycopy(in, 2, out, 0, num-1);
//                String str1 = Arrays.toString(out);
//                str1 = str1.substring(1, str1.length()-1);
//                root = new Node(null, null, str1);
//                
//            }
        }
        

        return root;
    }
    
    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[100];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[100];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""(((2+3)+(4+5))+((2+3)+(4+5)))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
}
}


@d7a472a2848556bb35ad304946da9363@"
"r04945009","1","0.18","105456","@61812cdfab27e0cdf42bcd14cc9b8ba6@
import java.util.Arrays;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    public void rightin(Node root, String[] in) {
        int count = 0;      
        if (in[0].equals(""("")) {
            for (int i=1; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setRight(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getRight(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getRight(), leftout);  
                    }
            }
        }
        else {
            int num=0;
            for (int i=1; i<in.length; i++) {
                if (in[i].equals("")"")) {
                    num = i;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, 0, out, 0, num);

            
            
            StringBuffer result = new StringBuffer();
            for (int i = 0; i < out.length; i++) {
            result.append( out[i] );
            //result.append( optional separator );
            }
            String str1 = result.toString();
            root.setRight(new Node(null, null, str1));
        }
    }
    
    public void leftin(Node root, String[] in) {
        int count = 0;      
        if (in[in.length-1].equals("")"")) {
            for (int i=in.length-2; i>-1; i--) {
                if      (in[i].equals("")"")) count++;
                else if (in[i].equals(""("")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setLeft(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getLeft(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getLeft(), leftout);  
                    }
            }
        }        
        else {
            int num=0;
            for (int i=in.length-2; i>-1; i--) {
                if (in[i].equals(""("")) {
                    num = in.length-2-i+1;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, in.length-num, out, 0, num);
            StringBuffer result = new StringBuffer();
            for (int i = 0; i < out.length; i++) {
            result.append( out[i] );
            //result.append( optional separator );
            }
            String str1 = result.toString();
            root.setLeft(new Node(null, null, str1));
        }
    }
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        String[] in = infix.split("""");
        
        int count = 0;      
        if (in[1].equals(""("")) {
            for (int i=2; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root = new Node(null, null, in[i]);
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root, rightout);
                        String[] leftout = new String[i-1];
                        System.arraycopy(in, 1, leftout, 0, i-1);
                        leftin(root, leftout);  
                    }
            }
//            if (count<0) {
//                int num=0;
//                for (int i=2; i<in.length; i++) {
//                    if (in[i].equals("")"")) {
//                        num = i-1;
//                        break;
//                    }
//                }
//                String[] out = new String[num-1];
//                System.arraycopy(in, 2, out, 0, num-1);
//                String str1 = Arrays.toString(out);
//                str1 = str1.substring(1, str1.length()-1);
//                root = new Node(null, null, str1);
//                
//            }
        }
        

        return root;
    }
    
    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[100];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[100];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""(((12+3)+(6.4+5))+((2+3)+(4+5.5)))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
}
}

@61812cdfab27e0cdf42bcd14cc9b8ba6@"
"r04945009","1","0.19","105040","@3f0a2229da8fca45cf8fce86b95a0bb2@
import java.util.Arrays;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    public void rightin(Node root, String[] in) {
        int count = 0;      
        if (in[0].equals(""("")) {
            for (int i=1; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setRight(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getRight(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getRight(), leftout);  
                    }
            }
        }
        else {
            int num=0;
            for (int i=1; i<in.length; i++) {
                if (in[i].equals("")"")) {
                    num = i;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, 0, out, 0, num);

            
            
            StringBuffer result = new StringBuffer();
            for (int i = 0; i < out.length; i++) {
            result.append( out[i] );
            //result.append( optional separator );
            }
            String str1 = result.toString();
            root.setRight(new Node(null, null, str1));
        }
    }
    
    public void leftin(Node root, String[] in) {
        int count = 0;      
        if (in[in.length-1].equals("")"")) {
            for (int i=in.length-2; i>-1; i--) {
                if      (in[i].equals("")"")) count++;
                else if (in[i].equals(""("")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root.setLeft(new Node(null, null, in[i]));
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root.getLeft(), rightout);
                        String[] leftout = new String[i];
                        System.arraycopy(in, 0, leftout, 0, i);
                        leftin(root.getLeft(), leftout);  
                    }
            }
        }        
        else {
            int num=0;
            for (int i=in.length-2; i>-1; i--) {
                if (in[i].equals(""("")) {
                    num = in.length-2-i+1;
                    break;
                }
            }
            String[] out = new String[num];
            System.arraycopy(in, in.length-num, out, 0, num);
            StringBuffer result = new StringBuffer();
            for (int i = 0; i < out.length; i++) {
            result.append( out[i] );
            //result.append( optional separator );
            }
            String str1 = result.toString();
            root.setLeft(new Node(null, null, str1));
        }
    }
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        String[] in = infix.split("""");
        
        int count = 0;      
        if (in[1].equals(""("")) {
            for (int i=2; i<in.length; i++) {
                if      (in[i].equals(""("")) count++;
                else if (in[i].equals("")"")) count--;
                else if (in[i].equals(""+"") || in[i].equals(""-"") || in[i].equals(""*"") || in[i].equals(""/""))
                    if (count == 0) {
                        root = new Node(null, null, in[i]);
                        String[] rightout = new String[in.length-i-1];
                        System.arraycopy(in, i+1, rightout, 0, in.length-i-1);
                        rightin(root, rightout);
                        String[] leftout = new String[i-1];
                        System.arraycopy(in, 1, leftout, 0, i-1);
                        leftin(root, leftout);  
                    }
            }
//            if (count<0) {
//                int num=0;
//                for (int i=2; i<in.length; i++) {
//                    if (in[i].equals("")"")) {
//                        num = i-1;
//                        break;
//                    }
//                }
//                String[] out = new String[num-1];
//                System.arraycopy(in, 2, out, 0, num-1);
//                String str1 = Arrays.toString(out);
//                str1 = str1.substring(1, str1.length()-1);
//                root = new Node(null, null, str1);
//                
//            }
        }
        

        return root;
    }
    
    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[20];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[20];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""(((12+3)+(6.4+5))+((2+3)+(4+5.5)))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
}
}

@3f0a2229da8fca45cf8fce86b95a0bb2@"
"b02611026","1","0.09","99008","@1b8cdadaa2c5ee10b5c2b4c2103ddab9@

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] input = new String[infix.length()];
        int count = 0;

        Stack<Node> left = new Stack<Node>();
        Stack<Node> roots = new Stack<Node>();
        Stack<Node> right = new Stack<Node>();

        for (int i = 0; i < infix.length() + 1; i++) {
            input = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])"");
            if (input[i].equals(""("") || input[i].equals("")"")) {
                count++;
            }
        }
//        for (int i = 0; i < infix.length() + 1; i++) {
//            System.out.print(input[i] + ""\n"");
//        }

//        System.out.print(""-------------------------\n"");
        //stem.out.print(infix.length());
//        Node[] inputarray = new Node[infix.length() - count];
        Node ing;
        Node[] ans = new Node[count / 2];
        Node temp = new Node(null, null, ""null"");;
//        Node temp_root1 = new Node(null, null, null);
//        Node temp_root2 = new Node(null, null, null);

        int root_flag = 0;
        int left_flag = 0;
//        int left_ff = 0;
        int right_flag = 0;
//        int right_ff = 0;
        int j = 1;
        int k = 0;
        
        left.push(temp);
        roots.push(temp);
        right.push(temp);
        

        for (int i = 0; i < (infix.length() ); i++) {
            while (j < (infix.length())) {
                j++;
                if (input[j].equals(""("")) {
//                    if (left_flag != 1) {
//                        left_ff = 1;
//                    }
//                    if (right_flag != 1) {
//                        right_ff = 1;
//                    }
                    root_flag = 0;
                    left_flag = 0;
                    right_flag = 0;
                    //System.out.print(j);
                    continue;
                } else if (input[j].equals("")"")) {
                    if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {//都有      
                        //temp_root1 = roots.pop();
                        ans[k] = new Node(left.pop(), right.pop(), roots.pop().getValue());
                        right_flag = right_flag - 1;
                        root_flag = root_flag - 1;
                        left_flag = left_flag - 1;
//                        System.out.print(""all\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {  //沒有left
                        //temp_root2 = roots.pop();
                        if (((k - 1) >= 0)) {
                            ans[k] = new Node(ans[k - 1], right.pop(), roots.pop().getValue());
                            right_flag = right_flag - 1;
                            root_flag = root_flag - 1;
                        }
                        left.pop();
//                        System.out.print(""no left\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) {   //沒有right
                        if (((k - 1) >= 0)) {
                            ans[k] = new Node(left.pop(), ans[k - 1], roots.pop().getValue());
                            left_flag = left_flag - 1;
                            root_flag = root_flag - 1;
                        }
                        right.pop();
//                        System.out.print(""no right\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) { //只有root
                        if (((k - 2) >= 0) && ((k - 1) >= 0)) {
                            ans[k] = new Node(ans[k - 2], ans[k - 1], roots.pop().getValue());
                            root_flag = root_flag - 1;
                        }
                        left.pop();
                        right.pop();
//                        System.out.print(""only root\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    }
                    k++;
                    break;

                } else if ((input[j].equals(""+"")) || (input[j].equals(""-"")) || (input[j].equals(""*"")) || (input[j].equals(""/""))) {
                    root_flag++;
                    ing = new Node(null, null, input[j]);
                    roots.push(ing);
                    //System.out.print(j);
                    break;
                } else {
                    temp = new Node(null, null, ""null"");
                    ing = new Node(null, null, input[j]);
                    if (root_flag != 0) {
                        if (left_flag != 0) {                            
                            right.push(ing);
                            right_flag++;
                        } else {
                            left.push(temp);                            
                            right.push(ing);
                            right_flag++;
                        }
                    } //System.out.print(j);
                    else {
                        left.push(ing);
                        right.push(temp);
                        left_flag++;
                        //System.out.print(j);
                    }
                    break;
                }

            }
        }
        root = ans[k-1];
        return root;
    }
    
    Stack<Node> a = new Stack<Node>();
    Stack<Node> b = new Stack<Node>();
    Stack<Node> c = new Stack<Node>();
    
    public Node[] PrintPrefix() throws Exception{
        if(root != null){
        pre(root);
        int size = a.size();
        Node[] ans = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
        //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
        for(int i = 0 ; i < size ; i++){
            //ans[0] = prefix.pop();
            ans[i] = a.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
            //System.out.print(i+ ""\n"");
        }
        return ans;
        }else
            throw new NullPointerException();
        
    }
    
    private void pre(Node n){        
        if(n != null){            
            //System.out.printf(n.getValue() + ""\n"");
            pre(n.getRight());
            pre(n.getLeft());
            a.push(n);
        }
    }   
    
    public Node[] PrintPostfix() throws Exception{
        if(root != null){
        post(root);       
        int size = b.size();
        Node[] ans = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
        //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
        for(int i = 0 ; i < size ; i++){
            //ans[0] = prefix.pop();
            ans[i] = b.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
            //System.out.print(i+ ""\n"");
        }
        return ans;}
        else
            throw new NullPointerException();
    }
    
    private void post(Node n){        
        if(n != null){            
            //System.out.printf(n.getValue() + ""\n"");
            b.push(n);
            post(n.getRight());
            post(n.getLeft());
            
        }
    } 

    public double Evaluation() {
        if(root != null){
        eva(root);       
        int size = c.size();
        Node[] ans = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
        //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
        for(int i = 0 ; i < size ; i++){
            //ans[0] = prefix.pop();
            ans[i] = c.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
            //System.out.print(i+ ""\n"");
        }        
        
        Stack<String> ops = new Stack<String>();
        Stack<Double> vals = new Stack<Double>();
        for(int i = 0 ; i < size ; i++){
            if (ans[i].getValue().equals(""+"")) {
                vals.push(vals.pop() + vals.pop());
            } else if (ans[i].getValue().equals(""*"")) {
                vals.push(vals.pop() * vals.pop());
            } else if (ans[i].getValue().equals(""/"")) {
                double one = vals.pop();
                double two = vals.pop();
                vals.push(two / one);
            } else if (ans[i].getValue().equals(""-"")) {
                double one = vals.pop();
                double two = vals.pop();
                vals.push(two - one);
            } else {
                vals.push(Double.parseDouble(ans[i].getValue()));
            }
        }
        double answer = vals.pop();
        
        return answer;}
        else
            throw new NullPointerException();
    }
    
    private void eva(Node n){        
        if(n != null){            
            //System.out.printf(n.getValue() + ""\n"");
            c.push(n);
            eva(n.getRight());
            eva(n.getLeft());
            
        }
    }

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            String input = ""(4+(((4*2)/2)/3))"";
//
//            Expression test = new Expression();
//            test.Infix2BT(input);
//            test.PrintPrefix();
//            test.PrintPostfix();
//            
//            //Node[] a = test.PrintPrefix();
//            //System.out.printf(test.PrintPrefix()[0].getValue());
//            //System.out.print();
//            test.Evaluation();
//            
//
//        }
//    }

}

@1b8cdadaa2c5ee10b5c2b4c2103ddab9@"
"b02611026","1","0.09","105056","@49e271221299aa463e216a7684793317@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] input = new String[infix.length()];
        int count = 0;

        Stack<Node> left = new Stack<Node>();
        Stack<Node> roots = new Stack<Node>();
        Stack<Node> right = new Stack<Node>();

        for (int i = 0; i < infix.length() + 1; i++) {
            input = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])"");
            if (input[i].equals(""("") || input[i].equals("")"")) {
                count++;
            }
        }
//        for (int i = 0; i < infix.length() + 1; i++) {
//            System.out.print(input[i] + ""\n"");
//        }

//        System.out.print(""-------------------------\n"");
        //stem.out.print(infix.length());
//        Node[] inputarray = new Node[infix.length() - count];
        Node ing;
        Node[] ans = new Node[count / 2];
        Node temp = new Node(null, null, ""null"");;
//        Node temp_root1 = new Node(null, null, null);
//        Node temp_root2 = new Node(null, null, null);

        int root_flag = 0;
        int left_flag = 0;
//        int left_ff = 0;
        int right_flag = 0;
//        int right_ff = 0;
        int j = 1;
        int k = 0;

        left.push(temp);
        roots.push(temp);
        right.push(temp);

        for (int i = 0; i < (infix.length()); i++) {
            while (j < (infix.length())) {
                j++;
                if (input[j].equals(""("")) {
//                    if (left_flag != 1) {
//                        left_ff = 1;
//                    }
//                    if (right_flag != 1) {
//                        right_ff = 1;
//                    }
                    root_flag = 0;
                    left_flag = 0;
                    right_flag = 0;
                    //System.out.print(j);
                    continue;
                } else if (input[j].equals("")"")) {
                    if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {//都有      
                        //temp_root1 = roots.pop();
                        ans[k] = new Node(left.pop(), right.pop(), roots.pop().getValue());
                        right_flag = right_flag - 1;
                        root_flag = root_flag - 1;
                        left_flag = left_flag - 1;
//                        System.out.print(""all\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {  //沒有left
                        //temp_root2 = roots.pop();
                        if (((k - 1) >= 0)) {
                            ans[k] = new Node(ans[k - 1], right.pop(), roots.pop().getValue());
                            right_flag = right_flag - 1;
                            root_flag = root_flag - 1;
                        }
                        left.pop();
//                        System.out.print(""no left\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) {   //沒有right
                        if (((k - 1) >= 0)) {
                            ans[k] = new Node(left.pop(), ans[k - 1], roots.pop().getValue());
                            left_flag = left_flag - 1;
                            root_flag = root_flag - 1;
                        }
                        right.pop();
//                        System.out.print(""no right\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) { //只有root
                        if (((k - 2) >= 0) && ((k - 1) >= 0)) {
                            ans[k] = new Node(ans[k - 2], ans[k - 1], roots.pop().getValue());
                            root_flag = root_flag - 1;
                        }
                        left.pop();
                        right.pop();
//                        System.out.print(""only root\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    }
                    k++;
                    break;

                } else if ((input[j].equals(""+"")) || (input[j].equals(""-"")) || (input[j].equals(""*"")) || (input[j].equals(""/""))) {
                    root_flag++;
                    ing = new Node(null, null, input[j]);
                    roots.push(ing);
                    //System.out.print(j);
                    break;
                } else {
                    temp = new Node(null, null, ""null"");
                    ing = new Node(null, null, input[j]);
                    if (root_flag != 0) {
                        if (left_flag != 0) {
                            right.push(ing);
                            right_flag++;
                        } else {
                            left.push(temp);
                            right.push(ing);
                            right_flag++;
                        }
                    } //System.out.print(j);
                    else {
                        left.push(ing);
                        right.push(temp);
                        left_flag++;
                        //System.out.print(j);
                    }
                    break;
                }

            }
        }
        root = ans[k - 1];
        return root;
    }

    Stack<Node> a = new Stack<Node>();
    Stack<Node> b = new Stack<Node>();
    Stack<Node> c = new Stack<Node>();

    public Node[] PrintPrefix(){
        if (root != null) {
            pre(root);
            int size = a.size();
            Node[] prefix = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                prefix[i] = a.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return prefix;
        } else {
            throw new NullPointerException();
        }

    }

    private void pre(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            pre(n.getRight());
            pre(n.getLeft());
            a.push(n);
        }
    }

    public Node[] PrintPostfix(){
        if (root != null) {
            post(root);
            int size = b.size();
            Node[] postfix = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                postfix[i] = b.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return postfix;
        } else {
            throw new NullPointerException();
        }
    }

    private void post(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            b.push(n);
            post(n.getRight());
            post(n.getLeft());

        }
    }

    public double Evaluation() {
        if (root != null) {
            eva(root);
            int size = c.size();
            Node[] ans = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                ans[i] = c.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }

            Stack<String> ops = new Stack<String>();
            Stack<Double> vals = new Stack<Double>();
            for (int i = 0; i < size; i++) {
                if (ans[i].getValue().equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (ans[i].getValue().equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (ans[i].getValue().equals(""/"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two / one);
                } else if (ans[i].getValue().equals(""-"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two - one);
                } else {
                    vals.push(Double.parseDouble(ans[i].getValue()));
                }
            }
            double answer = vals.pop();

            return answer;
        } else {
            throw new NullPointerException();
        }
    }

    private void eva(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            c.push(n);
            eva(n.getRight());
            eva(n.getLeft());

        }
    }

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            String input = ""(4+(((4*2)/2)/3))"";
//
//            Expression test = new Expression();
//            test.Infix2BT(input);
//            test.PrintPrefix();
//            test.PrintPostfix();
//            
//            //Node[] a = test.PrintPrefix();
//            //System.out.printf(test.PrintPrefix()[0].getValue());
//            //System.out.print();
//            test.Evaluation();
//            
//
//        }
//    }
}

@49e271221299aa463e216a7684793317@"
"b02611026","1","0.09","102816","@4ece20c5edb8fd71c7ae954ab18dcc55@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] input = new String[infix.length()];
        int count = 0;

        Stack<Node> left = new Stack<Node>();
        Stack<Node> roots = new Stack<Node>();
        Stack<Node> right = new Stack<Node>();

        for (int i = 0; i < infix.length() + 1; i++) {
            input = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])"");
            if (input[i].equals(""("") || input[i].equals("")"")) {
                count++;
            }
        }
//        for (int i = 0; i < infix.length() + 1; i++) {
//            System.out.print(input[i] + ""\n"");
//        }

//        System.out.print(""-------------------------\n"");
        //stem.out.print(infix.length());
//        Node[] inputarray = new Node[infix.length() - count];
        Node ing;
        Node[] ans = new Node[count / 2];
        Node temp = new Node(null, null, ""null"");;
//        Node temp_root1 = new Node(null, null, null);
//        Node temp_root2 = new Node(null, null, null);

        int root_flag = 0;
        int left_flag = 0;
//        int left_ff = 0;
        int right_flag = 0;
//        int right_ff = 0;
        int j = 1;
        int k = 0;

        left.push(temp);
        roots.push(temp);
        right.push(temp);

        for (int i = 0; i < (infix.length()); i++) {
            while (j < (infix.length())) {
                j++;
                if (input[j].equals(""("")) {
//                    if (left_flag != 1) {
//                        left_ff = 1;
//                    }
//                    if (right_flag != 1) {
//                        right_ff = 1;
//                    }
                    root_flag = 0;
                    left_flag = 0;
                    right_flag = 0;
                    //System.out.print(j);
                    continue;
                } else if (input[j].equals("")"")) {
                    if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {//都有      
                        //temp_root1 = roots.pop();
                        ans[k] = new Node(left.pop(), right.pop(), roots.pop().getValue());
                        right_flag = right_flag - 1;
                        root_flag = root_flag - 1;
                        left_flag = left_flag - 1;
//                        System.out.print(""all\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {  //沒有left
                        //temp_root2 = roots.pop();
                        if (((k - 1) >= 0)) {
                            ans[k] = new Node(ans[k - 1], right.pop(), roots.pop().getValue());
                            right_flag = right_flag - 1;
                            root_flag = root_flag - 1;
                        }
                        left.pop();
//                        System.out.print(""no left\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) {   //沒有right
                        if (((k - 1) >= 0)) {
                            ans[k] = new Node(left.pop(), ans[k - 1], roots.pop().getValue());
                            left_flag = left_flag - 1;
                            root_flag = root_flag - 1;
                        }
                        right.pop();
//                        System.out.print(""no right\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) { //只有root
                        if (((k - 2) >= 0) && ((k - 1) >= 0)) {
                            ans[k] = new Node(ans[k - 2], ans[k - 1], roots.pop().getValue());
                            root_flag = root_flag - 1;
                        }
                        left.pop();
                        right.pop();
//                        System.out.print(""only root\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                    }
                    k++;
                    break;

                } else if ((input[j].equals(""+"")) || (input[j].equals(""-"")) || (input[j].equals(""*"")) || (input[j].equals(""/""))) {
                    root_flag++;
                    ing = new Node(null, null, input[j]);
                    roots.push(ing);
                    //System.out.print(j);
                    break;
                } else {
                    temp = new Node(null, null, ""null"");
                    ing = new Node(null, null, input[j]);
                    if (root_flag != 0) {
                        if (left_flag != 0) {
                            right.push(ing);
                            right_flag++;
                        } else {
                            left.push(temp);
                            right.push(ing);
                            right_flag++;
                        }
                    } //System.out.print(j);
                    else {
                        left.push(ing);
                        right.push(temp);
                        left_flag++;
                        //System.out.print(j);
                    }
                    break;
                }

            }
        }
        root = ans[k - 1];
        return root;
    }

    private Stack<Node> a = new Stack<Node>();
    private Stack<Node> b = new Stack<Node>();
    private Stack<Node> c = new Stack<Node>();

    public Node[] PrintPrefix(){
        if (root != null) {
            pre(root);
            int size = a.size();
            Node[] prefix = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                prefix[i] = a.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return prefix;
        } else {
            throw new NullPointerException();
        }

    }

    private void pre(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            pre(n.getRight());
            pre(n.getLeft());
            a.push(n);
        }
    }

    public Node[] PrintPostfix(){
        if (root != null) {
            post(root);
            int size = b.size();
            Node[] postfix = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                postfix[i] = b.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return postfix;
        } else {
            throw new NullPointerException();
        }
    }

    private void post(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            b.push(n);
            post(n.getRight());
            post(n.getLeft());

        }
    }

    public double Evaluation() {
        if (root != null) {
            eva(root);
            int size = c.size();
            Node[] ans = new Node[size];
        //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                ans[i] = c.pop();
            //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }

            Stack<String> ops = new Stack<String>();
            Stack<Double> vals = new Stack<Double>();
            for (int i = 0; i < size; i++) {
                if (ans[i].getValue().equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (ans[i].getValue().equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (ans[i].getValue().equals(""/"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two / one);
                } else if (ans[i].getValue().equals(""-"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two - one);
                } else {
                    vals.push(Double.parseDouble(ans[i].getValue()));
                }
            }
            double answer = vals.pop();

            return answer;
        } else {
            throw new NullPointerException();
        }
    }

    private void eva(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            c.push(n);
            eva(n.getRight());
            eva(n.getLeft());

        }
    }

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            String input = ""(4+(((4*2)/2)/3))"";
//
//            Expression test = new Expression();
//            test.Infix2BT(input);
//            Node[] t1 = test.PrintPrefix();
//            Node[] t2 = test.PrintPostfix();
//            
//            for(int i = 0 ; i < t1.length ; i++){
//                System.out.printf(t1[i].getValue() + "" "");
//            }
//            System.out.printf(""\n"");
//            for(int i = 0 ; i < t2.length ; i++){
//                System.out.printf(t2[i].getValue() + "" "");
//            }
//            
//            //Node[] a = test.PrintPrefix();
//            //System.out.printf(test.PrintPrefix()[0].getValue());
//            //System.out.print();
//            test.Evaluation();
//            
//
//        }
//    }
}

@4ece20c5edb8fd71c7ae954ab18dcc55@"
"b02611026","1","0.09","104992","@00aea307424d8cea3271add45254980c@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] input/* = new String[infix.length()]*/;
        int count = 0;
        int input_length = 0;
        int z = 0;
        Stack<Node> left = new Stack<Node>();
        Stack<Node> roots = new Stack<Node>();
        Stack<Node> right = new Stack<Node>();
        //System.out.print(infix.length() + ""\n"");
        input = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])"");
//        while((input = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])""))!=null){
//            if(input == null){
//                break;
//            }
//            System.out.print(z+ ""\n"");
//            input_length++;
//            if (input[z].equals(""("") || input[z].equals("")"")) {                
//                count++;
//                //System.out.print(count+ ""\n"");
//            }
//            z++;
//            System.out.print(input_length+ ""\n"");
//        }       
        //System.out.print(input.length + ""\n"");

        for (int i = 1; i < input.length; i++) {
            //input = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])"");
            //System.out.print(input[i] + ""\n"");
            //System.out.print(i+ ""\n"");
            input_length++;
            if (input[i].equals(""("") || input[i].equals("")"")) {
                count++;
                //System.out.print(count+ ""\n"");
            }
        }
//        for (int i = 0; i < input_length; i++) {            
//            if (input[i].equals(""("") || input[i].equals("")"")) {                
//                count++;
//                //System.out.print(count+ ""\n"");
//            }
//        }

//        for (int i = 0; i < infix.length() + 1; i++) {
//            System.out.print(input[i] + ""\n"");
//        }
//        System.out.print(""-------------------------\n"");
            //stem.out.print(infix.length());
//        Node[] inputarray = new Node[infix.length() - count];
            Node ing;
            Node[] ans = new Node[count / 2];
            Node temp = new Node(null, null, ""null"");;
//        Node temp_root1 = new Node(null, null, null);
//        Node temp_root2 = new Node(null, null, null);

            int root_flag = 0;
            int left_flag = 0;
//        int left_ff = 0;
            int right_flag = 0;
//        int right_ff = 0;
            int j = 1;
            int k = 0;

            left.push(temp);
            roots.push(temp);
            right.push(temp);

            for (int i = 0; i < (input_length); i++) {
                while (j < (input_length)) {
                    j++;
                    if (input[j].equals(""("")) {
//                    if (left_flag != 1) {
//                        left_ff = 1;
//                    }
//                    if (right_flag != 1) {
//                        right_ff = 1;
//                    }
                        root_flag = 0;
                        left_flag = 0;
                        right_flag = 0;
                        //System.out.print(j);
                        continue;
                    } else if (input[j].equals("")"")) {
                        if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {//都有      
                            //temp_root1 = roots.pop();
                            ans[k] = new Node(left.pop(), right.pop(), roots.pop().getValue());
                            right_flag = right_flag - 1;
                            root_flag = root_flag - 1;
                            left_flag = left_flag - 1;
//                        System.out.print(""all\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                        } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && (!(right.peek().getValue().equals(""null"")))) {  //沒有left
                            //temp_root2 = roots.pop();
                            if (((k - 1) >= 0)) {
                                ans[k] = new Node(ans[k - 1], right.pop(), roots.pop().getValue());
                                right_flag = right_flag - 1;
                                root_flag = root_flag - 1;
                            }
                            left.pop();
//                        System.out.print(""no left\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                        } else if ((!(left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) {   //沒有right
                            if (((k - 1) >= 0)) {
                                ans[k] = new Node(left.pop(), ans[k - 1], roots.pop().getValue());
                                left_flag = left_flag - 1;
                                root_flag = root_flag - 1;
                            }
                            right.pop();
//                        System.out.print(""no right\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                        } else if (((left.peek().getValue().equals(""null""))) && (!(roots.peek().getValue().equals(""null""))) && ((right.peek().getValue().equals(""null"")))) { //只有root
                            if (((k - 2) >= 0) && ((k - 1) >= 0)) {
                                ans[k] = new Node(ans[k - 2], ans[k - 1], roots.pop().getValue());
                                root_flag = root_flag - 1;
                            }
                            left.pop();
                            right.pop();
//                        System.out.print(""only root\n"");
//                        System.out.print(ans[k].getValue() + ""\n"");
//                        System.out.print(ans[k].getLeft().getValue() + ""\n"");
//                        System.out.print(ans[k].getRight().getValue() + ""\n"");
                        }
                        k++;
                        break;

                    } else if ((input[j].equals(""+"")) || (input[j].equals(""-"")) || (input[j].equals(""*"")) || (input[j].equals(""/""))) {
                        root_flag++;
                        ing = new Node(null, null, input[j]);
                        roots.push(ing);
                        //System.out.print(j);
                        break;
                    } else {
                        temp = new Node(null, null, ""null"");
                        ing = new Node(null, null, input[j]);
                        if (root_flag != 0) {
                            if (left_flag != 0) {
                                right.push(ing);
                                right_flag++;
                            } else {
                                left.push(temp);
                                right.push(ing);
                                right_flag++;
                            }
                        } //System.out.print(j);
                        else {
                            left.push(ing);
                            right.push(temp);
                            left_flag++;
                            //System.out.print(j);
                        }
                        break;
                    }

                }
            }
            root = ans[k - 1];
            return root;
        }

    private Stack<Node> a = new Stack<Node>();
    private Stack<Node> b = new Stack<Node>();
    private Stack<Node> c = new Stack<Node>();

    public Node[] PrintPrefix() {
        if (root != null) {
            pre(root);
            int size = a.size();
            Node[] prefix = new Node[size];
            //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                prefix[i] = a.pop();
                //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return prefix;
        } else {
            throw new NullPointerException();
        }

    }

    private void pre(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            pre(n.getRight());
            pre(n.getLeft());
            a.push(n);
        }
    }

    public Node[] PrintPostfix() {
        if (root != null) {
            post(root);
            int size = b.size();
            Node[] postfix = new Node[size];
            //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                postfix[i] = b.pop();
                //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return postfix;
        } else {
            throw new NullPointerException();
        }
    }

    private void post(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            b.push(n);
            post(n.getRight());
            post(n.getLeft());

        }
    }

    public double Evaluation() {
        if (root != null) {
            eva(root);
            int size = c.size();
            Node[] ans = new Node[size];
            //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                ans[i] = c.pop();
                //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }

            Stack<String> ops = new Stack<String>();
            Stack<Double> vals = new Stack<Double>();
            for (int i = 0; i < size; i++) {
                if (ans[i].getValue().equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (ans[i].getValue().equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (ans[i].getValue().equals(""/"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two / one);
                } else if (ans[i].getValue().equals(""-"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two - one);
                } else {
                    vals.push(Double.parseDouble(ans[i].getValue()));
                }
            }
            double answer = vals.pop();

            return answer;
        } else {
            throw new NullPointerException();
        }
    }

    private void eva(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            c.push(n);
            eva(n.getRight());
            eva(n.getLeft());

        }
    }

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            String input = ""(12/12)"";
//
//            Expression test = new Expression();
//            test.Infix2BT(input);
//            System.out.print(test.Infix2BT(input).getValue() + ""\n"");
//            Node[] t1 = test.PrintPrefix();
//            Node[] t2 = test.PrintPostfix();
//
//            for (int i = 0; i < t1.length; i++) {
//                System.out.printf(t1[i].getValue() + "" "");
//            }
//            System.out.printf(""\n"");
//            for (int i = 0; i < t2.length; i++) {
//                System.out.printf(t2[i].getValue() + "" "");
//            }
//
//            //Node[] a = test.PrintPrefix();
//            //System.out.printf(test.PrintPrefix()[0].getValue());
//            //System.out.print();
//            System.out.print(test.Evaluation());
//
//        }
//    }
}

@00aea307424d8cea3271add45254980c@"
"r03525006","0","0.09","99008","@2e14fb5ba465bbb00ac635fe2da6df57@import java.util.ArrayList;
import java.util.List;

public class Expression{

    private Node root;
    private Node[] binaryTree;
    private String[] infixArray;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] splitInfix = infix.split("""");
        String newInfix = splitInfix[0] + "","";
        for (int i = 1; i < infix.length()-1; i++) {
            if (splitInfix[i].equals(""("")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals("")"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""+"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""-"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""*"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""/"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else { newInfix = newInfix + splitInfix[i];}
        }
        newInfix = newInfix + "")"";
        infixArray = newInfix.split("","");

        int parenCount = 0, levelCount = 0 , levelMax = 0;
        int[] idTemp = new int[infixArray.length];
        for (int i = 0; i < infixArray.length; i++) {
            if (infixArray[i].equals(""("")) { levelCount++; parenCount++; idTemp[i] = -1;}
            else if (infixArray[i].equals("")"")) { levelCount--; idTemp[i] = -1;}
            else if (infixArray[i].equals(""+"") || infixArray[i].equals(""-"") || infixArray[i].equals(""*"") || infixArray[i].equals(""/"")) {
                idTemp[i] = levelCount-1;
            } else idTemp[i] = levelCount;
            if (idTemp[i] > levelMax) levelMax = idTemp[i];
        }
        int[] id = new int[infix.length()-parenCount*2];
        String[] newInfixArray = new String[infix.length()-parenCount*2];
        int index = 0, rootIndex = 0;
        for (int i = 0; i < idTemp.length; i++) {
            if (idTemp[i] != -1) {
                newInfixArray[index] = infixArray[i];
                id[index] = idTemp[i];
                if (id[index] == 0) rootIndex = index;
                index++;
            }
        }

        int[] treeIndex = new int[id.length];
        int[] levelIndexCount = new int[levelMax+1];
        for (int i = 0; i < id.length; i++) {
            levelIndexCount[id[i]] += 1;
            for (int k = id[i]+1; k < levelIndexCount.length; k++) levelIndexCount[k] = 0;
            int startIndex = 1;
            for (int j = 0; j < id[i]; j ++) {
                if (levelIndexCount[j] == 0) startIndex = startIndex*2;
                else startIndex = startIndex*2+1;
            }
            treeIndex[i] = startIndex;
        }
        binaryTree = new Node[treeIndex.length];
        for (int i = 0; i < treeIndex.length; i++) {
            Node n = new Node(null,null,newInfixArray[i]);
            binaryTree[i] = n;
        }

        for (int i = 0; i < treeIndex.length; i++) {
            for (int j = 0; j < treeIndex.length; j++) {
                if (treeIndex[j] == treeIndex[i]*2) binaryTree[i].setLeft(binaryTree[j]);
                if (treeIndex[j] == treeIndex[i]*2+1) binaryTree[i].setRight(binaryTree[j]);
            }
        }
        return binaryTree[rootIndex];
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        findPrintPrefix(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void findPrintPrefix(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        findPrintPrefix(list, root.getLeft());
        findPrintPrefix(list, root.getRight());
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        findPrintPostfix(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void findPrintPostfix(List<Node> list, Node root){
        if (root == null) return;
        findPrintPostfix(list, root.getLeft());
        findPrintPostfix(list, root.getRight());
        list.add(root);

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        return Expression.calculator(infixArray);
    }

    public static Double calculator(String[] e) {
        Stack<String> ops = new Stack<String>();
        Stack<Double> vals = new Stack<Double>();
        for (int i = 0; i < e.length; i++) {
            String s = e[i];
            if (s.equals(""("")) ;
            else if (s.equals(""+"")) ops.push(s);
            else if (s.equals(""-"")) ops.push(s);
            else if (s.equals(""*"")) ops.push(s);
            else if (s.equals(""/"")) ops.push(s);
            else if (s.equals("")""))
            {
                String op = ops.pop();
                if (op.equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (op.equals(""-"")) {
                    vals.push(- vals.pop() + vals.pop());
                } else if (op.equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (op.equals(""/"")) {
                    Double a = vals.pop();
                    Double b = vals.pop();
                    vals.push(b/a);
                }
            }
            else vals.push(Double.parseDouble(s));
        }
        return vals.pop();
    }

//    public static void main(String[] args) {
//
//        String infix = ""(4+(((4*2)/2)/3))"";
//        String infix1 = ""((4*3)+((((4*2)/2)/3)+((2+1)*3)))"";
//        String infix2 = ""((4.4+3)+((((4*2)/2)/3)+((2+1)*3)))"";
//        Expression e = new Expression();
//        Node n = e.Infix2BT(infix2);
//        System.out.println(e.Evaluation());
//    }
}
@2e14fb5ba465bbb00ac635fe2da6df57@"
"r03525006","2","0.18","105520","@6c9bf5ee611f587dc0b254058f2facd3@import java.util.ArrayList;
import java.util.List;

public class Expression{

    private Node root;
    private Node[] binaryTree;
    private String[] infixArray;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] splitInfix = infix.split("""");
        String newInfix = splitInfix[0] + "","";
        for (int i = 1; i < infix.length()-1; i++) {
            if (splitInfix[i].equals(""("")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals("")"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""+"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""-"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""*"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else if (splitInfix[i].equals(""/"")) {
                if (!newInfix.endsWith("","")) newInfix = newInfix + "","";
                newInfix = newInfix + splitInfix[i] + "","";
            } else { newInfix = newInfix + splitInfix[i];}
        }
        newInfix = newInfix + "")"";
        infixArray = newInfix.split("","");

        int parenCount = 0, levelCount = 0 , levelMax = 0;
        int[] idTemp = new int[infixArray.length];
        for (int i = 0; i < infixArray.length; i++) {
            if (infixArray[i].equals(""("")) { levelCount++; parenCount++; idTemp[i] = -1;}
            else if (infixArray[i].equals("")"")) { levelCount--; idTemp[i] = -1;}
            else if (infixArray[i].equals(""+"") || infixArray[i].equals(""-"") || infixArray[i].equals(""*"") || infixArray[i].equals(""/"")) {
                idTemp[i] = levelCount-1;
            } else idTemp[i] = levelCount;
            if (idTemp[i] > levelMax) levelMax = idTemp[i];
        }
        int[] id = new int[infix.length()-parenCount*2];
        String[] newInfixArray = new String[infix.length()-parenCount*2];
        int index = 0, rootIndex = 0;
        for (int i = 0; i < idTemp.length; i++) {
            if (idTemp[i] != -1) {
                newInfixArray[index] = infixArray[i];
                id[index] = idTemp[i];
                if (id[index] == 0) rootIndex = index;
                index++;
            }
        }

        int[] treeIndex = new int[id.length];
        int[] levelIndexCount = new int[levelMax+1];
        for (int i = 0; i < id.length; i++) {
            levelIndexCount[id[i]] += 1;
            for (int k = id[i]+1; k < levelIndexCount.length; k++) levelIndexCount[k] = 0;
            int startIndex = 1;
            for (int j = 0; j < id[i]; j ++) {
                if (levelIndexCount[j] == 0) startIndex = startIndex*2;
                else startIndex = startIndex*2+1;
            }
            treeIndex[i] = startIndex;
        }
        binaryTree = new Node[treeIndex.length];
        for (int i = 0; i < treeIndex.length; i++) {
            Node n = new Node(null,null,newInfixArray[i]);
            binaryTree[i] = n;
        }

        for (int i = 0; i < treeIndex.length; i++) {
            for (int j = 0; j < treeIndex.length; j++) {
                if (treeIndex[j] == treeIndex[i]*2) binaryTree[i].setLeft(binaryTree[j]);
                if (treeIndex[j] == treeIndex[i]*2+1) binaryTree[i].setRight(binaryTree[j]);
            }
        }
        return binaryTree[rootIndex];
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        findPrintPrefix(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void findPrintPrefix(List<Node> list, Node root){
        if (root == null) return;
        list.add(root);
        findPrintPrefix(list, root.getLeft());
        findPrintPrefix(list, root.getRight());
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        findPrintPostfix(list, root);
        return list.toArray(new Node[list.size()]);
    }

    private void findPrintPostfix(List<Node> list, Node root) {
        if (root == null) return;
        findPrintPostfix(list, root.getLeft());
        findPrintPostfix(list, root.getRight());
        list.add(root);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        return Expression.calculator(infixArray);
    }

    public static Double calculator(String[] e) {
        Stack<String> ops = new Stack<String>();
        Stack<Double> vals = new Stack<Double>();
        for (int i = 0; i < e.length; i++) {
            String s = e[i];
            if (s.equals(""("")) ;
            else if (s.equals(""+"")) ops.push(s);
            else if (s.equals(""-"")) ops.push(s);
            else if (s.equals(""*"")) ops.push(s);
            else if (s.equals(""/"")) ops.push(s);
            else if (s.equals("")""))
            {
                String op = ops.pop();
                if (op.equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (op.equals(""-"")) {
                    vals.push(- vals.pop() + vals.pop());
                } else if (op.equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (op.equals(""/"")) {
                    Double a = vals.pop();
                    Double b = vals.pop();
                    vals.push(b/a);
                }
            }
            else vals.push(Double.parseDouble(s));
        }
        return vals.pop();
    }

//    public static void main(String[] args) {
//
//        String infix = ""(4+(((4*2)/2)/3))"";
//        String infix1 = ""((4*3)+((((4*2)/2)/3)+((2+1)*3)))"";
//        String infix2 = ""((4.4+3)+((((4*2)/2)/3)+((2+1)*3)))"";
//        Expression e = new Expression();
//        Node n = e.Infix2BT(infix2);
//        System.out.println(e.Evaluation());
//    }
}
@6c9bf5ee611f587dc0b254058f2facd3@"
"r03222054","10","0.098","105552","@eab0ee4ec6498d1eed63a6d6c71b1892@
import java.util.ArrayList;

public class Expression{
    
    public static boolean isOperator(char x)
    {
        if(x =='+' || x=='-' || x=='*' || x=='/'  )
        {
            return true;
        }
        
        else return false;
    }
    
    
        public static boolean isBracket(char x)
    {
        if(x =='(' || x==')'  )
        {
            return true;
        }
        
        else return false;
    }
    
    public ArrayList<String> seperate(String x)
    {
        int count =0;
        ArrayList<String> list = new ArrayList<String>();
        while(!x.isEmpty())
        {
            while(! isOperator(x.charAt(count)) && x.length()>count+1)
            {
                count++;
            }
            if(x.length()==count+1)
            {
                if(!isOperator(x.charAt(x.length()-1)) )
                {
                list.add(x);
                x="""";
                break;
                }
                
                else
                {
                     String value = x.substring(0, count);  
                     list.add(value);
                    list.add(x.substring(x.length()-1, x.length()));
                    x="""";
                }
            }

            else
            {
            if(count==0)
             list.add(x.substring(count,count+1));
            else
            {
            String value = x.substring(0, count);
             list.add(value);
            }
            x = x.substring(count+1, x.length());
            
            count =0;
            }
        }
 
        return list;
       
        
    }

  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix)
    { 
        if(!infix.contains(""(""))
        {
           root = new Node(null,null,infix);
        //    System.out.print(infix+""\n"");
            return root;
        }

       infix =infix.substring(1, infix.length()-1);
       int count = 0;
       int index =0;
       if(infix.contains(""(""))
        {
            for(int i=0; i<infix.length();i++)
            {
              //   System.out.print(i+""shit""+""\n"");
                if( infix.charAt(i) == '(')
                {
                    count++;

                }
                if( infix.charAt(i) == ')')
                {
                    count --;

                }

                if( isOperator(infix.charAt(i)) )
                {
                    if(count ==0)
                    {
                     //   System.out.print(i+""shit"");
                        index =i;
                        break;
                    }
                }

            }
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index));  
    //        System.out.print(value + ""\n"" );

            root = new Node(Infix2BT(left), Infix2BT(right),value);     
             return root;
       }
       
       else
       {

           for(int i = 0; i<infix.length(); i++)
           {
               if(isOperator(infix.charAt(i)))
               {
                   index = i;
                   break;
               }
           }
       //    System.out.print(infix.charAt(index)+""\n"");
           
           if(index != 0)
           {
            String left = infix.substring(0,index);
            String right = infix.substring(index+1, infix.length());
            String value = String.valueOf(infix.charAt(index)); 
            root = new Node(Infix2BT(left), Infix2BT(right), value);
             return root;
           }
           else
           {
               Node newNode = new Node(null, null,infix);
               return root;
           }
       } 
    }
private ArrayList<Node>prefixArray = new ArrayList<Node>();
    public void prefixInsert(Node a)
    {
       if(a!=null)
       {
        prefixArray.add(a);
     //   System.out.print(a.getValue());
        prefixInsert(a.getLeft());
        prefixInsert(a.getRight());
       }
    }
    public Node[] PrintPrefix() throws Exception{
        nullroot();
        Node[] prefix = null;
        
        prefixInsert(root);
        prefix = new Node[prefixArray.size()];
       // System.out
        for(int i =0; i<prefixArray.size();i++)
        {
            prefix[i] = prefixArray.get(i);
        }

        return prefix;
    }
    
    private ArrayList<Node>postfixArray = new ArrayList<Node>();
    public void postfixInsert(Node a)
    {
        
       if(a!=null)
       {
        postfixInsert(a.getLeft());
        postfixInsert(a.getRight());
        postfixArray.add(a);
       }
    }
  
    public Node[] PrintPostfix() throws Exception{
        nullroot();
        Node[] postfix; 
        postfixArray.clear();
       postfixInsert(root);
       postfix= new Node[postfixArray.size()];
        for(int i =0; i<postfixArray.size();i++)
        {
            //System.out.print(postfixArray.get(i).getValue());
            postfix[i] = postfixArray.get(i);
        }

        return postfix;
    }

    public double Evaluation() throws Exception{
        nullroot();
         postfixArray.clear();
         postfixInsert(root);
        double answer = 0;
       ArrayList<String> array =new ArrayList<String>();
        for(int i=0; i<postfixArray.size(); i++)
        {
            array.add(postfixArray.get(i).getValue());
        }
        
        while(array.size()!=1)
        {
            
            for(int i =0; i<array.size(); i++)
            {
                if(isOperator(array.get(i).charAt(0)))
                {
                    char operator = array.get(i).charAt(0);
                    double val1 = Double.parseDouble(array.get(i-2));
                    double val2 = Double.parseDouble(array.get(i-1));
                    double temp=0;
                    if(operator == '+')
                        temp = val1+val2;
                     if(operator == '-')
                        temp = val1-val2;
                     if(operator == '*')
                        temp = val1*val2;
                     if(operator == '/')
                        temp = val1/val2;
                     
                     array.set(i, Double.toString(temp));
                     array.remove(i-1);
                     array.remove(i-2);
                     break;
                }
            }
        }
        answer = Double.parseDouble(array.get(0));
       // System.out.print(answer);
        return answer;
       
        
        
    }
    
    public  void nullroot() throws Exception
    {
        if(root==null)
        {
            throw new NullPointerException(""shit"");
        }
        
    }
    
    
    
    public static void main(String[] args) throws Exception
    {
        String str = ""(4+(((4*2)/2)/3))"";
        Expression test =new Expression();
        test.Infix2BT(str);
        test.PrintPostfix();
      //  System.out.print(""\n"");
        test.PrintPrefix();
       // System.out.print(""\n"");
       test.Evaluation();

    }
}

@eab0ee4ec6498d1eed63a6d6c71b1892@"
"b03704074","9","0.99","105536","@ae69b02da2134eacb6f5856cc4ca4b19@
public class Expression {
    
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int InfixCount = 0;
        String[] Infix1 = new String[1000];
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"")){
                break;
                
            }
            if(i == infix.length()-1){
            Node a = new Node(null,null,infix.substring(1, i));
            root = a;
            return root;}
        }
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))continue;
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"")){
                Infix1[InfixCount++] = infix.substring(i, i+1);
                
            }
            else {
                int temp = i;
                while(!infix.substring(i+1, i+2).equals(""("") &&!infix.substring(i+1, i+2).equals(""+"") &&! infix.substring(i+1, i+2).equals(""-"") &&! infix.substring(i+1, i+2).equals(""*"") &&! infix.substring(i+1, i+2).equals(""/"") &&! infix.substring(i+1, i+2).equals("")"") ){
                    i++;
                }
                Infix1[InfixCount++] = infix.substring(temp, i+1);
            }
        }
        String[] Infix = new String[InfixCount];
        for(int i = 0;i < InfixCount;i++){
            Infix[i] = Infix1[i];
        }
                
        
        Node[] array = new Node[infix.length()];//不影響
        
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        //System.out.println(root.right.left.left.right.value);
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].getValue());
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].getValue());
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.getLeft()!=null)preOrder(x.getLeft(),y);
        if(x.getRight()!=null)preOrder(x.getRight(),y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].getValue());
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.getLeft()!=null) postOrder(x.getLeft(),y);
        if(x.getRight()!=null)postOrder(x.getRight(),y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    private EvaNode Evafirst = null;
    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.getValue().equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue); 
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.getValue());
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""(5)"");
        Node[] a = exp.PrintPrefix();
        //for(int i = 0;i < a.length;i++){
        //    System.out.println(a[i].getValue());
        //}
        /*Node[] b = exp.PrintPostfix();
        for(int i = 0;i < b.length;i++){
            System.out.println(b[i].getValue());
        }*/
        double c = exp.Evaluation();
        System.out.println(c);//考慮(5)括弧內只有一種的
        
    }
    
}

@ae69b02da2134eacb6f5856cc4ca4b19@"
"r04522616","3","0.28","101920","@da86b359ca36085e034e9a18c559e757@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix  = new Node[outData.length];
        //String[] check=new String[outData.length];
        String[] copyOutData=new String[outData.length];
        copyOutData=outData.clone();
        for(int i=0;i<outData.length;i++)
        {
            char isANumber=copyOutData[i].charAt(0);
            if(Character.isDigit(isANumber)!=true && copyOutData[i].equals(""("")!=true && copyOutData[i].equals("")"")!=true)
            {
                for(int j=i-1;j>=0;j--)
                {
                    if(copyOutData[j].equals(""(""))
                    {
                        copyOutData[j]=copyOutData[i];
                        copyOutData[i]="")"";
                        break;
                    }
                }
            }
        }
        String out = """";
        int a=0;
        for(int i=0;i<outData.length;i++)
        {
            if(copyOutData[i].equals("")"")!=true)
            {
                out = copyOutData[i];
                Node b=new Node(null,null,out);
                prefix[i-a]=b;
//                check[i-a]=out;
            }
            else if(copyOutData[i].equals("")"")==true)
            {
                a++;
            }
        }

//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
        

        return prefix;
    }
    

  
    public Node[] PrintPostfix(){
        
        Node[] postfix = new Node[outData.length];
        //String[] check=new String[outData.length];
        
        Stack<String> stk=new Stack<String>();
        int j=0;
        for(int i=1;i<outData.length;i++)
        {            
            char isANumber=outData[i].charAt(0);
            if(outData[i].equals(""(""))
            {
                j++;
            }
            else if(outData[i].equals("")""))
            {
                String symbol=stk.pop();
                postfix[i-j-1]=new Node(null, null, symbol);
                //check[i-j-1]=symbol;
            }
            else if(Character.isDigit(isANumber)!=true && outData[i].equals(""("")!=true && outData[i].equals("")"")!=true)
            {
                j++;
                stk.push(outData[i]);
            }
            else
            {
                Node a=new Node(null, null, outData[i]);
                postfix[i-j-1]=a;
                //check[i-j-1]=outData[i];
            }
        }
//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
//        System.out.print(""\n"");
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@da86b359ca36085e034e9a18c559e757@"
"r03945012","1","0.09","102720","@5bcfa0d3a213926d0b392b0b085650ea@
import java.util.ArrayList;


/**
 * 1042 PDSA
 * hw09_Expression
 * @author Robert
 */

public class Expression{
  
    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        // initize root
        root = null;
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++){
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++){
                if (string.charAt(i) == operator.get(j)){
                    isoperater = true;
                    if (n != 0){
                        data.add(string.substring(i-n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i+1));
                }
            }
            if (isoperater == false){
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);
        
//        for(String s : dataArr)
//            System.out.println(s);
        
        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");
        
        // Node 2 tmp: a, b
        Node a = null;
        Node b = null;
        Stack<String> s = new Stack<String>();
        int count = 0;
        for (int i=0; i < dataArr.length; i++){
            if ("")"".equals(dataArr[i]) && ""("".equals(dataArr[i-4]))
                count++;
        }
        Node[] rootArr = new Node[count];
        int k = 0;
        for (int i=0; i < dataArr.length; i++){
            s.push(dataArr[i]);
            if ("")"".equals(dataArr[i]) && ""("".equals(dataArr[i-4])){
                s.pop();
                String num2 = s.pop();
                String operat = s.pop();
                String num1 = s.pop();
                s.pop();
                a = new Node(null, null, num1);
                b = new Node(null, null, num2);
                rootArr[++k] = new Node(a, b, operat);
            }
            else if ("")"".equals(dataArr[i]) && ""("".equals(dataArr[i-2])){
                s.pop();
                String tmp1 = s.pop();
                s.pop();
                if (root == null){
                    root = new Node(rootArr[k-1], rootArr[k], tmp1);
                }
                else{
					root = new Node(root, rootArr[k-1], tmp1);
				}
            }
            else if ("")"".equals(dataArr[i])){
                s.pop();
                String tmp1 = s.pop();
                String tmp2 = s.pop();
                s.pop();
                if (op.contains(tmp1)){
                    a = new Node(null, null, tmp2);
                    rootArr[k] = new Node(a, rootArr[k], tmp1);
                }
                else if(op.contains(tmp2)){
                    b = new Node(null, null, tmp1);
                    rootArr[k] = new Node(rootArr[k], b, tmp2);
                }   
            }
        }
        return(root);
    }

    public Node[] PrintPrefix(){
        preOrder(root);
//        StdOut.println(prefix_answer.size());
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }
    
    private void preOrder(Node a){
        if (a != null){
            prefix_answer = new ArrayList<>();
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }
  
    public Node[] PrintPostfix(){
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a){
        if (a != null){
            postfix_answer = new ArrayList<>();
            postfix_answer.add(a);
            postOrder(a.getLeft());
            postOrder(a.getRight());
        }
}
    
    
    public double Evaluation(){
        double answer = 0;        
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i=0; i<data.length; i++){
            s.push(data[i]);
            if ("")"".equals(s.peek())){
                for (int j=0; j<5; j++)
                    tmp[j] = s.pop();
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]){
                    case ""+"":
                        answer = num1+num2;
                        break;
                    case ""-"":
                        answer = num1-num2;
                        break;
                    case ""*"":
                        answer = num1*num2;
                        break;
                    case ""/"":
                        answer = num1/num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return(answer);
    }
    
    
    // testing
    public static void main(String[] args){
//        String a = ""(4+(((4*2)/2)/3))"";
//        String b = ""(60*(((4*2)/2)*3))"";
        String a = ""(((0.235+0.88)*7.2)+(200+10))"";
        Expression cct = new Expression();
        Node result = cct.Infix2BT(a);
//        result = cct.Infix2BT(c);
        Node[] test = cct.PrintPrefix();
//        StdOut.println(cct.Evaluation());
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
//        StdOut.println(test[2].getValue());
//        StdOut.println(test[3].getValue());
//        StdOut.println(test[4].getValue());
//        StdOut.println(test[5].getValue());
//        StdOut.println(test[6].getValue());
//        StdOut.println(test[7].getValue());

        StdOut.println(result.getValue());
        StdOut.println(result.getLeft().getValue());
        StdOut.println(result.getRight().getValue());
        
    }
    
}
@5bcfa0d3a213926d0b392b0b085650ea@"
"b03704074","9","0.97","105312","@72ca5d36f1d06aff8c3f6af63b0f11f3@
public class Expression {
    
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int InfixCount = 0;
        String[] Infix1 = new String[1000];
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"")){
                break;
                
            }
            if(i == infix.length()-1){
            Node a = new Node(null,null,infix.substring(1, i));
            root = a;
            return root;}
        }
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))continue;
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"")){
                Infix1[InfixCount++] = infix.substring(i, i+1);
                
            }
            else {
                int temp = i;
                while(!infix.substring(i+1, i+2).equals(""("") &&!infix.substring(i+1, i+2).equals(""+"") &&! infix.substring(i+1, i+2).equals(""-"") &&! infix.substring(i+1, i+2).equals(""*"") &&! infix.substring(i+1, i+2).equals(""/"") &&! infix.substring(i+1, i+2).equals("")"") ){
                    i++;
                }
                Infix1[InfixCount++] = infix.substring(temp, i+1);
            }
        }
        String[] Infix = new String[InfixCount];
        for(int i = 0;i < InfixCount;i++){
            Infix[i] = Infix1[i];
        }
                
        
        Node[] array = new Node[infix.length()];//不影響
        
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        count = 0;
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].getValue());
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].getValue());
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.getLeft()!=null)preOrder(x.getLeft(),y);
        if(x.getRight()!=null)preOrder(x.getRight(),y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        countt = 0;
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].getValue());
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.getLeft()!=null) postOrder(x.getLeft(),y);
        if(x.getRight()!=null)postOrder(x.getRight(),y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    
    public double Evaluation(){
        EvaNode Evafirst = null;
        if(root == null) throw new NullPointerException();
        
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            //System.out.println(A[i].getValue());
        }
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.getValue().equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue); 
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.getValue());
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""(2+2)"");       
        exp.PrintPrefix();
        exp.PrintPostfix();
        double c = exp.Evaluation();
        System.out.println(c);
        Node test2 = exp.Infix2BT(""(3+3)"");
        exp.PrintPrefix();
        exp.PrintPostfix();
        double d = exp.Evaluation();
        System.out.println(d);
        
    }
    
}

@72ca5d36f1d06aff8c3f6af63b0f11f3@"
"b03704074","9","0.99","105584","@c589e9202b48794fee64c903bf4f4e2f@
public class Expression {
    
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int InfixCount = 0;
        String[] Infix1 = new String[1000];
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"")){
                break;
                
            }
            if(i == infix.length()-1){
            Node a = new Node(null,null,infix.substring(1, i));
            root = a;
            return root;}
        }
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))continue;
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"")){
                Infix1[InfixCount++] = infix.substring(i, i+1);
                
            }
            else {
                int temp = i;
                while(!infix.substring(i+1, i+2).equals(""("") &&!infix.substring(i+1, i+2).equals(""+"") &&! infix.substring(i+1, i+2).equals(""-"") &&! infix.substring(i+1, i+2).equals(""*"") &&! infix.substring(i+1, i+2).equals(""/"") &&! infix.substring(i+1, i+2).equals("")"") ){
                    i++;
                }
                Infix1[InfixCount++] = infix.substring(temp, i+1);
            }
        }
        String[] Infix = new String[InfixCount];
        for(int i = 0;i < InfixCount;i++){
            Infix[i] = Infix1[i];
        }
                
        
        Node[] array = new Node[infix.length()];//不影響
        
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        count = 0;
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].getValue());
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].getValue());
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.getLeft()!=null)preOrder(x.getLeft(),y);
        if(x.getRight()!=null)preOrder(x.getRight(),y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        countt = 0;
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].getValue());
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.getLeft()!=null) postOrder(x.getLeft(),y);
        if(x.getRight()!=null)postOrder(x.getRight(),y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    
    public double Evaluation(){
        EvaNode Evafirst = null;
        if(root == null) throw new NullPointerException();
        
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            //System.out.println(A[i].getValue());
        }
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.getValue().equals(""+"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a+b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""-"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a-b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""*"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a*b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue);
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
            else if(Evafirst.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a/b;
                String newvalue=Double.toString(c);
                Evafirst.item.setValue(newvalue); 
                Evafirst.pre = Evafirst.pre.pre.pre;
                //System.out.println(Evafirst.item.value);
            }
        }
        double answer = Double.parseDouble(Evafirst.item.getValue());
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""(4+(((4*2)/2)/3))"");       
        exp.PrintPrefix();
        exp.PrintPostfix();
        double c = exp.Evaluation();
        System.out.println(c);
        Node test2 = exp.Infix2BT(""(3+3)"");
        exp.PrintPrefix();
        exp.PrintPostfix();
        double d = exp.Evaluation();
        System.out.println(d);
        Node test3 = exp.Infix2BT(""(1+3)"");
        double e = exp.Evaluation();
        System.out.println(e);
        
    }
    
}

@c589e9202b48794fee64c903bf4f4e2f@"
"r03849033","5","0.49","105520","@df1414290c2db27d49e5761ae25fb670@
public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;

private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      
    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }  
}

@df1414290c2db27d49e5761ae25fb670@"
"r03849033","5","0.49","105488","@2a886b5ffe40ccaa59eef1052e709f01@
public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;

private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        size=0;
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }
    
}

@2a886b5ffe40ccaa59eef1052e709f01@"
"r03849033","5","0.5","105056","@c8411b0c4a10d083e5ed70b263452d3b@
public class Expression{
    
    public String a1=""+"";
    public String a2=""-"";
    public String a3=""*"";
    public String a4=""/"";
    public String a5=""("";
    public String a6="")"";  
    public Node root;

private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{
		index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)
	{
		stack[++index] = a;
	}
	public Node pop()
	{
		return stack[index--];
	}
	public Node now()
	{
		return stack[index];
	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        size=0;
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(a1) || data[dd].equals(a2) || data[dd].equals(a3) || data[dd].equals(a4)) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(a5)) {
            } else if (data[dd].equals(a6)) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(a1) ||prefix[i].getValue().equals(a2) ||prefix[i].getValue().equals(a3) ||prefix[i].getValue().equals(a4)){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(a1)){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a2)){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a3)){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(a4)){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }
        public static void main(String[] args) {
        String input = ""((20120224791*(121259+797912))+(211544771212/2))"";
        String input2 = ""(12/12)"";       
        Expression test = new Expression();
        test.Infix2BT(input);
        print(test.PrintPrefix());
        print(test.PrintPostfix()); 
        test.Infix2BT(input2);
        print(test.PrintPrefix());
        print(test.PrintPostfix());           
        System.out.println(test.Evaluation());      
    } 
        
    public static void print(Node[] pf){
        for(int i = 0; i < pf.length;i++){
            System.out.printf(pf[i].getValue()+"" "");
        }
        System.out.println();        
    }        
}

@c8411b0c4a10d083e5ed70b263452d3b@"
"r03522809","6","0.98","105920","@e65b97dcbb1d4f7b1c1b9e86dd5b7ecc@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */
public class Expression{
  
    private Node root;
    private int N;
    Queue<Node> findmidqueue =new Queue<Node>();
    Queue<Node> findleftqueue =new Queue<Node>();
    Stack<String> findans =new Stack<String>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] Num = infix.split("""");
        Stack<Node>  numsta =new Stack<Node> ();
        Stack optsta =new Stack();
        Stack<Node> nodesta =new Stack<Node>();
        int N = Num.length;
        this.N=N;
        Node[] Infnode =new Node[N/2];
        int nodenum=0;
        
          for(int i=1;i<N;i++){
              if(Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"")){
                  optsta.push(Num[i]);
               }else if( Num[i].equals(""("")){

               }else if( Num[i].equals("")"")){
                   Infnode[0]=numsta.pop();
                   Infnode[1]=numsta.pop();
                   
                   numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));

               }else{
                  numsta.push(new Node(null,null,Num[i]));
              }
          }
        root=numsta.peek();
        this.root=root;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findmid(rootnode[0]);
        Node[] prefix = new Node[findmidqueue.size()];
        int n=0;
        while(!findmidqueue.isEmpty()){
           prefix[n]=findmidqueue.dequeue();
           n=n+1;
       }
        return prefix;
    }
    
        public Node findmid(Node x){
            findmidqueue.enqueue(x);
//            System.out.println(findmidqueue.peek().getValue()); 
            if( !(x.getLeft()==null) ){
                    findmid(x.getLeft());
            }
            if( !(x.getRight()==null) ){
                    findmid(x.getRight());
            }
        return x;
    }
  
    public Node[] PrintPostfix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        while(!findleftqueue.isEmpty()){
           postfix[n]=findleftqueue.dequeue();
           n=n+1;
       }
          postfix[n]=rootnode[0];
        return postfix;
    }
    
    public Node findleft(Node x){
           
            if( !(x.getLeft()==null) ){
                    findleft(x.getLeft());
                     findleftqueue.enqueue(x.getLeft());
//                    System.out.println(x.getLeft().getValue()); 
            }
            if( !(x.getRight()==null) ){
                    findleft(x.getRight());
                    findleftqueue.enqueue(x.getRight());
//                    System.out.println(x.getRight().getValue()); 
            }
        return x;
    }
    
    public double Evaluation(){
        
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        findleftqueue.enqueue(rootnode[0]);
        
//        while(!findleftqueue.isEmpty()){
//           postfix[n]=findleftqueue.dequeue();
//           System.out.println(postfix[n].getValue());
//           n=n+1;
//       }

        while( !findleftqueue.isEmpty() ){

            findans.push(findleftqueue.dequeue().getValue());
            if( findans.peek().equals(""+"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=a+b;
                String stringc = Double.toString(c);
                findans.push(stringc);
                
            }else if( findans.peek().equals(""-"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b-a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""*"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b*a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""/"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b/a;
                String stringc = Double.toString(c);
                findans.push(stringc);
            }
        }

        double answer =Double.parseDouble( findans.peek());
        return answer;
    
    }

    /**
     * @param args the command line arguments
     */

     public static void main(String[] args)throws Exception {
        Node[] rootnode = new Node[1];
        String problem =""(4+(((4*2)/2)/3))"";
        Expression build = new Expression();
        rootnode[0]=build.Infix2BT(problem);
        System.out.println(build.Evaluation());

        
//        for(int i=0;i<build.PrintPostfix().length;i++ ){
//        System.out.println(build.PrintPostfix()[i].getValue());
//        }



    }
}

@e65b97dcbb1d4f7b1c1b9e86dd5b7ecc@"
"r03522809","6","0.99","105920","@77a889cb66d7d7b056a64b626039b90b@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */
public class Expression{
  
    private Node root;
    private int N;
    Queue<Node> findmidqueue =new Queue<Node>();
    Queue<Node> findleftqueue =new Queue<Node>();
    Stack<String> findans =new Stack<String>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] Num = infix.split("""");
        Stack<Node>  numsta =new Stack<Node> ();
        Stack optsta =new Stack();
        Stack<Node> nodesta =new Stack<Node>();
        int N = Num.length;
        this.N=N;
        Node[] Infnode =new Node[N/2+1];
        int nodenum=0;
        
          for(int i=1;i<N;i++){
              if(Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"")){
                  optsta.push(Num[i]);
               }else if( Num[i].equals(""("")){

               }else if( Num[i].equals("")"")){
                   Infnode[0]=numsta.pop();
                   Infnode[1]=numsta.pop();
                   
                   numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));

               }else{
                  numsta.push(new Node(null,null,Num[i]));
              }
          }
        root=numsta.peek();
        this.root=root;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findmid(rootnode[0]);
        Node[] prefix = new Node[findmidqueue.size()];
        int n=0;
        while(!findmidqueue.isEmpty()){
           prefix[n]=findmidqueue.dequeue();
           n=n+1;
       }
        return prefix;
    }
    
        public Node findmid(Node x){
            findmidqueue.enqueue(x);
//            System.out.println(findmidqueue.peek().getValue()); 
            if( !(x.getLeft()==null) ){
                    findmid(x.getLeft());
            }
            if( !(x.getRight()==null) ){
                    findmid(x.getRight());
            }
        return x;
    }
  
    public Node[] PrintPostfix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        while(!findleftqueue.isEmpty()){
           postfix[n]=findleftqueue.dequeue();
           n=n+1;
       }
          postfix[n]=rootnode[0];
        return postfix;
    }
    
    public Node findleft(Node x){
           
            if( !(x.getLeft()==null) ){
                    findleft(x.getLeft());
                     findleftqueue.enqueue(x.getLeft());
//                    System.out.println(x.getLeft().getValue()); 
            }
            if( !(x.getRight()==null) ){
                    findleft(x.getRight());
                    findleftqueue.enqueue(x.getRight());
//                    System.out.println(x.getRight().getValue()); 
            }
        return x;
    }
    
    public double Evaluation(){
        
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        findleftqueue.enqueue(rootnode[0]);
        
//        while(!findleftqueue.isEmpty()){
//           postfix[n]=findleftqueue.dequeue();
//           System.out.println(postfix[n].getValue());
//           n=n+1;
//       }

        while( !findleftqueue.isEmpty() ){

            findans.push(findleftqueue.dequeue().getValue());
            if( findans.peek().equals(""+"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=a+b;
                String stringc = Double.toString(c);
                findans.push(stringc);
                
            }else if( findans.peek().equals(""-"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b-a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""*"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b*a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""/"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b/a;
                String stringc = Double.toString(c);
                findans.push(stringc);
            }
        }

        double answer =Double.parseDouble( findans.peek());
        return answer;
    
    }

    /**
     * @param args the command line arguments
     */

     public static void main(String[] args)throws Exception {
        Node[] rootnode = new Node[1];
        String problem =""(4+(((4*2)/2)/3))"";
        Expression build = new Expression();
        rootnode[0]=build.Infix2BT(problem);
        System.out.println(build.Evaluation());

        
//        for(int i=0;i<build.PrintPostfix().length;i++ ){
//        System.out.println(build.PrintPostfix()[i].getValue());
//        }



    }
}

@77a889cb66d7d7b056a64b626039b90b@"
"r03522809","6","0.97","105872","@77a889cb66d7d7b056a64b626039b90b@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */
public class Expression{
  
    private Node root;
    private int N;
    Queue<Node> findmidqueue =new Queue<Node>();
    Queue<Node> findleftqueue =new Queue<Node>();
    Stack<String> findans =new Stack<String>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] Num = infix.split("""");
        Stack<Node>  numsta =new Stack<Node> ();
        Stack optsta =new Stack();
        Stack<Node> nodesta =new Stack<Node>();
        int N = Num.length;
        this.N=N;
        Node[] Infnode =new Node[N/2+1];
        int nodenum=0;
        
          for(int i=1;i<N;i++){
              if(Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"")){
                  optsta.push(Num[i]);
               }else if( Num[i].equals(""("")){

               }else if( Num[i].equals("")"")){
                   Infnode[0]=numsta.pop();
                   Infnode[1]=numsta.pop();
                   
                   numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));

               }else{
                  numsta.push(new Node(null,null,Num[i]));
              }
          }
        root=numsta.peek();
        this.root=root;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findmid(rootnode[0]);
        Node[] prefix = new Node[findmidqueue.size()];
        int n=0;
        while(!findmidqueue.isEmpty()){
           prefix[n]=findmidqueue.dequeue();
           n=n+1;
       }
        return prefix;
    }
    
        public Node findmid(Node x){
            findmidqueue.enqueue(x);
//            System.out.println(findmidqueue.peek().getValue()); 
            if( !(x.getLeft()==null) ){
                    findmid(x.getLeft());
            }
            if( !(x.getRight()==null) ){
                    findmid(x.getRight());
            }
        return x;
    }
  
    public Node[] PrintPostfix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        while(!findleftqueue.isEmpty()){
           postfix[n]=findleftqueue.dequeue();
           n=n+1;
       }
          postfix[n]=rootnode[0];
        return postfix;
    }
    
    public Node findleft(Node x){
           
            if( !(x.getLeft()==null) ){
                    findleft(x.getLeft());
                     findleftqueue.enqueue(x.getLeft());
//                    System.out.println(x.getLeft().getValue()); 
            }
            if( !(x.getRight()==null) ){
                    findleft(x.getRight());
                    findleftqueue.enqueue(x.getRight());
//                    System.out.println(x.getRight().getValue()); 
            }
        return x;
    }
    
    public double Evaluation(){
        
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        findleftqueue.enqueue(rootnode[0]);
        
//        while(!findleftqueue.isEmpty()){
//           postfix[n]=findleftqueue.dequeue();
//           System.out.println(postfix[n].getValue());
//           n=n+1;
//       }

        while( !findleftqueue.isEmpty() ){

            findans.push(findleftqueue.dequeue().getValue());
            if( findans.peek().equals(""+"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=a+b;
                String stringc = Double.toString(c);
                findans.push(stringc);
                
            }else if( findans.peek().equals(""-"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b-a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""*"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b*a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""/"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b/a;
                String stringc = Double.toString(c);
                findans.push(stringc);
            }
        }

        double answer =Double.parseDouble( findans.peek());
        return answer;
    
    }

    /**
     * @param args the command line arguments
     */

     public static void main(String[] args)throws Exception {
        Node[] rootnode = new Node[1];
        String problem =""(4+(((4*2)/2)/3))"";
        Expression build = new Expression();
        rootnode[0]=build.Infix2BT(problem);
        System.out.println(build.Evaluation());

        
//        for(int i=0;i<build.PrintPostfix().length;i++ ){
//        System.out.println(build.PrintPostfix()[i].getValue());
//        }



    }
}

@77a889cb66d7d7b056a64b626039b90b@"
"r03849033","5","0.49","105488","@d4e6ab3f82c83fdaf7a63c9f8fdc4dbf@public class Expression{
public Node root;
private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{	index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)	{	stack[++index] = a;	}
	public Node pop(){	return stack[index--];	}
	public Node now(){	return stack[index];	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        size=0;
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(""+"") || data[dd].equals(""-"") || data[dd].equals(""*"") || data[dd].equals(""/"")) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(""("")) {
            } else if (data[dd].equals("")"")) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(""+"") ||prefix[i].getValue().equals(""-"") ||prefix[i].getValue().equals(""*"") ||prefix[i].getValue().equals(""/"")){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(""+"")){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""-"")){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""*"")){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""/"")){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }
}

@d4e6ab3f82c83fdaf7a63c9f8fdc4dbf@"
"r04945009","6","0.55","105680","@0d502516ece80c25649bf70778c0d9eb@public class Expression{
  
    private Node root;
    private String infix;
    private int count;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    private Node readTree() {
        Node n = new Node(null, null, null);
        // get next non-whitespace char
        char ch = infix.charAt(count); count++;
        if ((ch >= '0') && (ch <='9')) {
            // leaf node
            n.setValue(String.valueOf(ch));
        } 
        else if (ch == '(') {
            // an expression
            n.setLeft(readTree());
            n.setValue(String.valueOf(infix.charAt(count))); count++; 
            n.setRight(readTree());
            ch = infix.charAt(count); count++;
            if (ch != ')')
                System.out.print(""EXPECTED ) - } ASSUMED..."");
        } 
        else {
            System.out.print(""EXPECTED ( - CAN'T PARSE"");
            System.exit(1);
        }
        return n;
    }
    
    
    
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        this.infix = infix;
        count = 0;
        root =  readTree();
        return root;
    }

    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    private int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[20];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    private int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[20];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""(4+(((4*2)/2)/3))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
        }
    
    
    
}

@0d502516ece80c25649bf70778c0d9eb@"
"r03849033","0","0.18","99968","@b91bff66ab0a26244696e54e8c2fc67f@public class Expression{
public Node root;
    public Expression(){}

    public Node Infix2BT(String infix){
        root= new Node(null,null,infix);
        return root;
    }
 
    public Node[] PrintPrefix(){
        Node[] prefix = new Node[2];
        prefix[0]= root;
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix1 = new Node[2];
        postfix1[0]= root;
        return postfix1;
    }

    public double Evaluation(){
        double answer = Double.parseDouble(root.getValue());
        return answer;  
    }
        public static void main(String[] args) {
        String input = ""(((1111111+1111111)+(11+1111))+11111)"";
        String input2 = ""(12/12)"";       
        Expression test = new Expression();
        test.Infix2BT(input);
        print(test.PrintPrefix());
        print(test.PrintPostfix()); 
        test.Infix2BT(input2);
        print(test.PrintPrefix());
        print(test.PrintPostfix());           
        System.out.println(test.Evaluation());      
    } 
        
    public static void print(Node[] pf){
        for(int i = 0; i < pf.length;i++){
            System.out.printf(pf[i].getValue()+"" "");
        }
        System.out.println();        
    }        
}

@b91bff66ab0a26244696e54e8c2fc67f@"
"r03849033","0","0.28","105456","@8b9e264c12cb708bd3d64aa53f28cd13@public class Expression{
public Node root;
    public Expression(){}

    public Node Infix2BT(String infix){
        root= new Node(null,null,""1"");
        return root;
    }
 
    public Node[] PrintPrefix(){
        Node[] prefix = new Node[2];
        prefix[0]= root;
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix1 = new Node[2];
        postfix1[0]= root;
        return postfix1;
    }

    public double Evaluation(){
        double answer = 1.1;
        return answer;  
    }
}

@8b9e264c12cb708bd3d64aa53f28cd13@"
"r03849033","1","0.09","104288","@db2099644e2201078ad400bb5c340219@public class Expression{
public Node root;
    public Expression(){}

    public Node Infix2BT(String infix){
throw new NullPointerException();
    }
 
    public Node[] PrintPrefix(){
throw new NullPointerException();
    }
  
    public Node[] PrintPostfix(){
throw new NullPointerException();
    }

    public double Evaluation(){
        throw new NullPointerException();
    }
}

@db2099644e2201078ad400bb5c340219@"
"r03522809","1","0.98","105888","@d83718d0b7f2b8d44e67a06a9b9cebfb@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */
public class Expression{
  
    private Node root;
    private int N;
    Queue<Node> findmidqueue =new Queue<Node>();
    Queue<Node> findleftqueue =new Queue<Node>();
    Stack<String> findans =new Stack<String>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] Num = infix.split("""");
        Stack<Node>  numsta =new Stack<Node> ();
        Stack optsta =new Stack();
        Stack<Node> nodesta =new Stack<Node>();
        int N = Num.length;
        this.N=N;
        Node[] Infnode =new Node[N/2+1];
        int nodenum=0;
        
          for(int i=1;i<N;i++){
              if(Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"")){
                  optsta.push(Num[i]);
               }else if( Num[i].equals(""("")){

               }else if( Num[i].equals("")"")){
                  if(Num[i-1].equals(""("") )
                    {
                       throw new NullPointerException(""NullPointerException"");
                    }
                   Infnode[0]=numsta.pop();
                   Infnode[1]=numsta.pop();
                   numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
               }else{
                  numsta.push(new Node(null,null,Num[i]));
              }
          }
        root=numsta.peek();
        this.root=root;
        
        System.out.println(root.getValue());
        
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findmid(rootnode[0]);
        Node[] prefix = new Node[findmidqueue.size()];
        int n=0;
        while(!findmidqueue.isEmpty()){
           prefix[n]=findmidqueue.dequeue();
           n=n+1;
       }
        return prefix;
    }
    
        public Node findmid(Node x){
            findmidqueue.enqueue(x);
//            System.out.println(findmidqueue.peek().getValue()); 
            if( !(x.getLeft()==null) ){
                    findmid(x.getLeft());
            }
            if( !(x.getRight()==null) ){
                    findmid(x.getRight());
            }
        return x;
    }
  
    public Node[] PrintPostfix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        while(!findleftqueue.isEmpty()){
           postfix[n]=findleftqueue.dequeue();
           n=n+1;
       }
          postfix[n]=rootnode[0];
        return postfix;
    }
    
    public Node findleft(Node x){
           
            if( !(x.getLeft()==null) ){
                    findleft(x.getLeft());
                     findleftqueue.enqueue(x.getLeft());
//                    System.out.println(x.getLeft().getValue()); 
            }
            if( !(x.getRight()==null) ){
                    findleft(x.getRight());
                    findleftqueue.enqueue(x.getRight());
//                    System.out.println(x.getRight().getValue()); 
            }
        return x;
    }
    
    public double Evaluation(){
        
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        findleftqueue.enqueue(rootnode[0]);
        
//        while(!findleftqueue.isEmpty()){
//           postfix[n]=findleftqueue.dequeue();
//           System.out.println(postfix[n].getValue());
//           n=n+1;
//       }

        while( !findleftqueue.isEmpty() ){

            findans.push(findleftqueue.dequeue().getValue());
            if( findans.peek().equals(""+"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=a+b;
                String stringc = Double.toString(c);
                findans.push(stringc);
                
            }else if( findans.peek().equals(""-"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b-a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""*"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b*a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""/"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b/a;
                String stringc = Double.toString(c);
                findans.push(stringc);
            }
        }

        double answer =Double.parseDouble( findans.peek());
        return answer;
    
    }

    /**
     * @param args the command line arguments
     */

     public static void main(String[] args)throws Exception {
        Node[] rootnode = new Node[1];
        String problem =""()"";
        Expression build = new Expression();
        rootnode[0]=build.Infix2BT(problem);
        System.out.println(build.Evaluation());

        
        for(int i=0;i<build.PrintPostfix().length;i++ ){
        System.out.println(build.PrintPostfix()[i].getValue());
        }



    }
}

@d83718d0b7f2b8d44e67a06a9b9cebfb@"
"r03522809","6","0.99","105888","@19760f29e2b9acc251c472e159332f75@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */
public class Expression{
  
    private Node root;
    private int N;
    Queue<Node> findmidqueue =new Queue<Node>();
    Queue<Node> findleftqueue =new Queue<Node>();
    Stack<String> findans =new Stack<String>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] Num = infix.split("""");
        Stack<Node>  numsta =new Stack<Node> ();
        Stack optsta =new Stack();
        Stack<Node> nodesta =new Stack<Node>();
        int N = Num.length;
        this.N=N;
        Node[] Infnode =new Node[N/2+1];
        int nodenum=0;
        
          for(int i=1;i<N;i++){
              if(Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"")){
                  optsta.push(Num[i]);
               }else if( Num[i].equals(""("")){

               }else if( Num[i].equals("")"")){
                  if(Num[i-1].equals(""("") )
                    {
                       throw new NullPointerException(""NullPointerException"");
                    }
                   Infnode[0]=numsta.pop();
                   Infnode[1]=numsta.pop();
                   numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
               }else{
                  numsta.push(new Node(null,null,Num[i]));
              }
          }
        root=numsta.peek();
        this.root=root;
        
//        System.out.println(root.getValue());
        
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findmid(rootnode[0]);
        Node[] prefix = new Node[findmidqueue.size()];
        int n=0;
        while(!findmidqueue.isEmpty()){
           prefix[n]=findmidqueue.dequeue();
           n=n+1;
       }
        return prefix;
    }
    
        public Node findmid(Node x){
            findmidqueue.enqueue(x);
//            System.out.println(findmidqueue.peek().getValue()); 
            if( !(x.getLeft()==null) ){
                    findmid(x.getLeft());
            }
            if( !(x.getRight()==null) ){
                    findmid(x.getRight());
            }
        return x;
    }
  
    public Node[] PrintPostfix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        while(!findleftqueue.isEmpty()){
           postfix[n]=findleftqueue.dequeue();
           n=n+1;
       }
          postfix[n]=rootnode[0];
        return postfix;
    }
    
    public Node findleft(Node x){
           
            if( !(x.getLeft()==null) ){
                    findleft(x.getLeft());
                     findleftqueue.enqueue(x.getLeft());
//                    System.out.println(x.getLeft().getValue()); 
            }
            if( !(x.getRight()==null) ){
                    findleft(x.getRight());
                    findleftqueue.enqueue(x.getRight());
//                    System.out.println(x.getRight().getValue()); 
            }
        return x;
    }
    
    public double Evaluation(){
        
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        findleftqueue.enqueue(rootnode[0]);
        
//        while(!findleftqueue.isEmpty()){
//           postfix[n]=findleftqueue.dequeue();
//           System.out.println(postfix[n].getValue());
//           n=n+1;
//       }

        while( !findleftqueue.isEmpty() ){

            findans.push(findleftqueue.dequeue().getValue());
            if( findans.peek().equals(""+"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=a+b;
                String stringc = Double.toString(c);
                findans.push(stringc);
                
            }else if( findans.peek().equals(""-"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b-a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""*"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b*a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""/"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b/a;
                String stringc = Double.toString(c);
                findans.push(stringc);
            }
        }

        double answer =Double.parseDouble( findans.peek());
        return answer;
    
    }

    /**
     * @param args the command line arguments
     */

     public static void main(String[] args)throws Exception {
        Node[] rootnode = new Node[1];
        String problem =""(((2+3)+(4+5))+((2+3)+(4+5)))"";
        Expression build = new Expression();
        rootnode[0]=build.Infix2BT(problem);
        System.out.println(build.Evaluation());

        
        for(int i=0;i<build.PrintPostfix().length;i++ ){
        System.out.println(build.PrintPostfix()[i].getValue());
        }



    }
}

@19760f29e2b9acc251c472e159332f75@"
"r04945009","2","0.99","105504","@b944b51ffc51ec32a95b1a3d1e6db683@public class Expression{
  
    private Node root;
    private String infix;
    private int count;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    private Node readTree() {
        Node n = new Node(null, null, null);
        // get next non-whitespace char
        char ch = infix.charAt(count); count++;
        int chArrayCount = 0;
        char[] chArray = new char[20];
        if ((ch >= '0') && (ch <='9')) {
            // leaf node
            chArray[chArrayCount] = ch; chArrayCount++;
            while((infix.charAt(count) == '.') || (infix.charAt(count) >= '0' && infix.charAt(count) <= '9')) {
                chArray[chArrayCount] = infix.charAt(count); chArrayCount++;
                count++;
            }
            n.setValue(String.valueOf(chArray));
        } 
        else if (ch == '(') {
            // an expression
            n.setLeft(readTree());
            n.setValue(String.valueOf(infix.charAt(count))); count++; 
            n.setRight(readTree());
            ch = infix.charAt(count); count++;
            if (ch != ')')
                System.out.print(""EXPECTED ) - } ASSUMED..."");
        } 
        else {
            System.out.print(""EXPECTED ( - CAN'T PARSE"");
            System.exit(1);
        }
        return n;
    }
    
    
    
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        this.infix = infix;
        count = 0;
        root =  readTree();
        return root;
    }

    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    private int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[20];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    private int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[20];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""(14.2+(((4*2)/2)/3))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
        }
    
    
    
}

@b944b51ffc51ec32a95b1a3d1e6db683@"
"r04921105","3","0.29","105936","@7c3991b4197f1fdbd31cfab6745a4c13@
import java.util.ArrayList;
import java.util.List;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();        
        Stack<Node> vals = new Stack<Node>();
        boolean flag =false;
        String[] input = infix.split("""");
         for(int i=0;i<input.length;i++){
            String s = input[i];
            //System.out.println(s);
            switch(s){
                case(""(""):
                    flag=false;
                    break;
                   
            case(""+""):
                //else if (s.equals(""+"") || s.equals(""-"") || s.equals(""*"") || s.equals(""/""))
                //Node ops =(null,null,s);          
            case(""-""):
            case(""*""):
            case(""/""):
                ops.push(new Node(null,null,s));
                flag=false;
                break;
                
            case("")""):               
                //vals.pop();
                //vals.pop();              
                //ops.pop();
                String val =ops.pop().getValue();
                
                //new Node(vals.pop(),vals.pop(),ss);
                Node r = vals.pop();
                Node l = vals.pop();
                vals.push(new Node(l,r,val));
                flag=false;
                //System.out.println(val);
                break;
            default:
                if(flag==false){
                vals.push(new Node(null,null,s));
                flag=true;
                }
                else if(flag==true){
                    String f1=vals.pop().getValue();
                    //System.out.println(f1);
                 vals.push(new Node(null,null,f1+s));
                 //System.out.println(f1+s);                
                }                
                break;

            }//end of switch              
         }//end of for
        root = vals.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> prefix;
        prefix = new ArrayList<>();
        get_prefix(prefix,root);

        return prefix.toArray(new Node[prefix.size()]);
    }
  
    public Node[] PrintPostfix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> postfix;
        postfix = new ArrayList<>();
        get_postfix(postfix,root);

        return postfix.toArray(new Node[postfix.size()]);
    }

    public double Evaluation(){
        if(root==null)
            throw new NullPointerException();        
       // switch()       
        return evaluate(root);
    }

    private void get_prefix(List<Node> a,Node b) {
        if(b==null)
            throw new NullPointerException();;
            a.add(b);
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
    }
    private void get_postfix(List<Node> a,Node b) {
        if(b==null)
            throw new NullPointerException();;
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
            a.add(b);
    }

    private double evaluate(Node root) {
        switch(root.getValue()){
            case""+"":
                return evaluate(root.getLeft())+evaluate(root.getRight());
            case""-"":
                return evaluate(root.getLeft())-evaluate(root.getRight());
            case""*"":
                return evaluate(root.getLeft())*evaluate(root.getRight());
            case""/"":
                return evaluate(root.getLeft())/evaluate(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }                        
        
       
    }
}

@7c3991b4197f1fdbd31cfab6745a4c13@"
"r04921105","3","0.28","105872","@f6a2e94ab50d4f67166a011817c17cac@
import java.util.ArrayList;
import java.util.List;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();        
        Stack<Node> vals = new Stack<Node>();
        boolean flag =false;
        String[] input = infix.split("""");
         for(int i=0;i<input.length;i++){
            String s = input[i];
            //System.out.println(s);
            switch(s){
                case(""(""):
                    flag=false;
                    break;
                   
            case(""+""):
                //else if (s.equals(""+"") || s.equals(""-"") || s.equals(""*"") || s.equals(""/""))
                //Node ops =(null,null,s);          
            case(""-""):
            case(""*""):
            case(""/""):
                ops.push(new Node(null,null,s));
                flag=false;
                break;
                
            case("")""):               
                //vals.pop();
                //vals.pop();              
                //ops.pop();
                String val =ops.pop().getValue();
                
                //new Node(vals.pop(),vals.pop(),ss);
                Node r = vals.pop();
                Node l = vals.pop();
                vals.push(new Node(l,r,val));
                flag=false;
                //System.out.println(val);
                break;
            default:
                if(flag==false){
                vals.push(new Node(null,null,s));
                flag=true;
                }
                else if(flag==true){
                    String f1=vals.pop().getValue();
                    //System.out.println(f1);
                 vals.push(new Node(null,null,f1+s));
                 //System.out.println(f1+s);                
                }                
                break;

            }//end of switch              
         }//end of for
        root = vals.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> prefix;
        prefix = new ArrayList<>();
        get_prefix(prefix,root);

        return prefix.toArray(new Node[prefix.size()]);
    }
  
    public Node[] PrintPostfix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> postfix;
        postfix = new ArrayList<>();
        get_postfix(postfix,root);

        return postfix.toArray(new Node[postfix.size()]);
    }

    public double Evaluation(){
        if(root==null)
            throw new NullPointerException();        
       // switch()       
        return evaluate(root);
    }

    private void get_prefix(List<Node> a,Node b) {
        if(b==null)
            throw new NullPointerException();
            a.add(b);
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
    }
    private void get_postfix(List<Node> a,Node b) {
        if(b==null)
            throw new NullPointerException();
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
            a.add(b);
    }

    private double evaluate(Node root) {
        switch(root.getValue()){
            case""+"":
                return evaluate(root.getLeft())+evaluate(root.getRight());
            case""-"":
                return evaluate(root.getLeft())-evaluate(root.getRight());
            case""*"":
                return evaluate(root.getLeft())*evaluate(root.getRight());
            case""/"":
                return evaluate(root.getLeft())/evaluate(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }                        
        
       
    }
}

@f6a2e94ab50d4f67166a011817c17cac@"
"r04921105","6","0.96","105856","@52d1bae8bfbca8c794a1edb311ca7cde@
import java.util.ArrayList;
import java.util.List;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();        
        Stack<Node> vals = new Stack<Node>();
        boolean flag =false;
        String[] input = infix.split("""");
         for(int i=0;i<input.length;i++){
            String s = input[i];
            //System.out.println(s);
            switch(s){
                case(""(""):
                    flag=false;
                    break;
                   
            case(""+""):
                //else if (s.equals(""+"") || s.equals(""-"") || s.equals(""*"") || s.equals(""/""))
                //Node ops =(null,null,s);          
            case(""-""):
            case(""*""):
            case(""/""):
                ops.push(new Node(null,null,s));
                flag=false;
                break;
                
            case("")""):               
                //vals.pop();
                //vals.pop();              
                //ops.pop();
                if(ops.isEmpty()){
                    break;
                }
                    
                String val =ops.pop().getValue();
                
                //new Node(vals.pop(),vals.pop(),ss);
                Node r = vals.pop();
                Node l = vals.pop();
                vals.push(new Node(l,r,val));
                flag=false;
                //System.out.println(val);
                break;
            default:
                if(flag==false){
                vals.push(new Node(null,null,s));
                flag=true;
                }
                else if(flag==true){
                    String f1=vals.pop().getValue();
                    //System.out.println(f1);
                 vals.push(new Node(null,null,f1+s));
                 //System.out.println(f1+s);                
                }                
                break;

            }//end of switch              
         }//end of for
        root = vals.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> prefix;
        prefix = new ArrayList<>();
        get_prefix(prefix,root);

        return prefix.toArray(new Node[prefix.size()]);
    }
  
    public Node[] PrintPostfix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> postfix;
        postfix = new ArrayList<>();
        get_postfix(postfix,root);

        return postfix.toArray(new Node[postfix.size()]);
    }

    public double Evaluation(){
        if(root==null)
            throw new NullPointerException();        
       // switch()       
        return evaluate(root);
    }

    private void get_prefix(List<Node> a,Node b) {
        if(b==null)
            return;
            a.add(b);
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
    }
    private void get_postfix(List<Node> a,Node b) {
        if(b==null)
            return;
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
            a.add(b);
    }

    private double evaluate(Node root) {
        switch(root.getValue()){
            case""+"":
                return evaluate(root.getLeft())+evaluate(root.getRight());
            case""-"":
                return evaluate(root.getLeft())-evaluate(root.getRight());
            case""*"":
                return evaluate(root.getLeft())*evaluate(root.getRight());
            case""/"":
                return evaluate(root.getLeft())/evaluate(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }                        
        
       
    }
}

@52d1bae8bfbca8c794a1edb311ca7cde@"
"r04945009","2","0.96","105584","@056ebbabf6fe39d0b059f768eef54b35@public class Expression{
  
    private Node root;
    private String infix;
    private int count;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    private Node readTree() {
        Node n = new Node(null, null, null);
        // get next non-whitespace char
        char ch = infix.charAt(count); count++;
        int chArrayCount = 0;
        char[] chArray = new char[20];
        if ((ch >= '0') && (ch <='9')) {
            // leaf node
            chArray[chArrayCount] = ch; chArrayCount++;
            while((infix.charAt(count) == '.') || (infix.charAt(count) >= '0' && infix.charAt(count) <= '9')) {
                chArray[chArrayCount] = infix.charAt(count); chArrayCount++;
                count++;
            }
            n.setValue(String.valueOf(chArray));
        } 
        else if (ch == '(') {
            // an expression
            n.setLeft(readTree());
            n.setValue(String.valueOf(infix.charAt(count))); count++; 
            n.setRight(readTree());
            ch = infix.charAt(count); count++;
            if (ch != ')')
                System.out.print(""EXPECTED ) - } ASSUMED..."");
        } 
        else {
            System.out.print(""EXPECTED ( - CAN'T PARSE"");
            System.exit(1);
        }
        return n;
    }
    
    
    
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        this.infix = infix;
        count = 0;
        root =  readTree();
        return root;
    }

    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    private int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[20];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    private int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[20];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""(14.2+(((4.5*20)/2)/3))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
        }
    
    
    
}

@056ebbabf6fe39d0b059f768eef54b35@"
"r04631027","10","0.098","105520","@e196f63b5266f05a960ac88fa027863d@import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '-':
                case '+':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
            }
        }
         
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPrefixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    
    public void PrintPrefixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPrefixRecusive(p, root.getLeft());
        PrintPrefixRecusive(p, root.getRight());
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> postfix = new ArrayList<Node>();
        PrintPostfixRecusive(postfix, root);
        return postfix.toArray(new Node[postfix.size()]);
    }
    public void PrintPostfixRecusive(List<Node> p, Node root){
        if(root==null) return;
        
        PrintPostfixRecusive(p, root.getLeft());
        PrintPostfixRecusive(p, root.getRight());
        p.add(root);
//        p.add(root);
    }
    

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] eva = this.PrintPostfix();
        Stack<Double> evalue = new Stack<Double>();
        for(Node n:eva){
            String in = n.getValue();
            if(in.equals(""+"")){
                evalue.push(evalue.pop()+evalue.pop());
            } else if(in.equals(""-"")){
                evalue.push(-evalue.pop()+evalue.pop());
            } else if(in.equals(""*"")){
                evalue.push(evalue.pop()*evalue.pop());
            } else if(in.equals(""/"")){
                evalue.push(1/evalue.pop()*evalue.pop());
            } else {
                evalue.push(Double.parseDouble(in));
            }
            
        }
        return evalue.pop();
    }
}

@e196f63b5266f05a960ac88fa027863d@"
"r04945009","2","0.94","105584","@5e87a60c44e29a566d6e2835ec62230d@public class Expression{
  
    private Node root;
    private String infix;
    private int count;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    private Node readTree() {
        Node n = new Node(null, null, null);
        // get next non-whitespace char
        char ch = infix.charAt(count); count++;
        int chArrayCount = 0;
        char[] chArray = new char[20];
        if ((ch >= '0') && (ch <='9')) {
            // leaf node
            chArray[chArrayCount] = ch; chArrayCount++;
            while((infix.charAt(count) != '+') && (infix.charAt(count) != '-') && (infix.charAt(count) != '*') && (infix.charAt(count) != '/') && (infix.charAt(count) != ')')) {
                chArray[chArrayCount] = infix.charAt(count); chArrayCount++;
                count++;
            }
            n.setValue(String.valueOf(chArray));
        } 
        else if (ch == '(') {
            // an expression
            n.setLeft(readTree());
            n.setValue(String.valueOf(infix.charAt(count))); count++; 
            n.setRight(readTree());
            ch = infix.charAt(count); count++;
            if (ch != ')')
                System.out.print(""EXPECTED ) - } ASSUMED..."");
        } 
        else {
            System.out.print(""EXPECTED ( - CAN'T PARSE"");
            System.exit(1);
        }
        return n;
    }
    
    
    
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        this.infix = infix;
        count = 0;
        root =  readTree();
        return root;
    }

    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    private int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[20];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    private int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[20];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""((20120224791*(121259+797912))+(211544771212/2))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
        }
    
    
    
}

@5e87a60c44e29a566d6e2835ec62230d@"
"b02611026","10","0.097","105856","@ba67b600ae63779d3f56499a76b32cdb@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }
    private Stack<Node> z = new Stack<Node>();

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] input;
        int count = 0;
        int input_length = 0;
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
//        Stack<Node> roots = new Stack<Node>();
//        Stack<Node> right = new Stack<Node>();
        input = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])"");

        for (int i = 1; i < input.length; i++) {
            input_length++;
            //System.out.printf(input[i]);
            if (input[i].equals(""("") || input[i].equals("")"")) {
                count++;
            }
        }
        //System.out.printf(""\n"");
        
        Node[] inputarray = new Node[input.length - 1];
        for (int i = 1; i < input.length; i++) {
            inputarray[i - 1] = new Node(null, null, input[i]);
            //System.out.printf(inputarray[i - 1].getValue());
        }
        
        //System.out.printf(""\n"");
        
        ArrayList<Node> tree = new ArrayList<Node>();
        
        for (int i = 0; i < inputarray.length; i++) {
            if (inputarray[i].getValue().equals(""("")) {
                continue;
            } else if (inputarray[i].getValue().equals(""+"")) {
                ops.push(inputarray[i]);
                //StdOut.println(""1"");
            } else if (inputarray[i].getValue().equals(""*"")) {
                ops.push(inputarray[i]);
                //StdOut.println(""2"");
            } else if (inputarray[i].getValue().equals(""/"")) {
                ops.push(inputarray[i]);
                //StdOut.println(""3"");
            } else if (inputarray[i].getValue().equals(""-"")) {
                ops.push(inputarray[i]);
                //StdOut.println(""4"");
            } else if (inputarray[i].getValue().equals("")"")) {                
                //StdOut.println(""6"");
                Node right = vals.pop();
                //StdOut.println(""7"");
                Node left = vals.pop();
                //StdOut.println(""8"");
                Node ing = new Node(left, right,ops.pop().getValue());
                //StdOut.println(""9"");
                vals.push(ing);
                tree.add(ing);
                
            } else {
                vals.push((inputarray[i]));
                //StdOut.println(""5"");
            }
        }
        //StdOut.println(tree.get(0).getValue());
//        StdOut.println(op[0].getLeft().getValue());
//        StdOut.println(op[0].getRight().getValue());
//        StdOut.println(op[1].getValue());
//        StdOut.println(op[1].getLeft().getValue());
//        StdOut.println(op[1].getRight().getValue());
//        StdOut.println(op[2].getValue());
//        StdOut.println(op[2].getLeft().getValue());
//        StdOut.println(op[2].getRight().getValue());
        
//        if (infix.isEmpty()) {
//            return null;
//        }
        //StdOut.println(tree.get(tree.size()-1).getValue());
        root = tree.get(tree.size()-1);
        return root;
    }

    

    private Stack<Node> a = new Stack<Node>();
    private Stack<Node> b = new Stack<Node>();
    private Stack<Node> c = new Stack<Node>();

    public Node[] PrintPrefix() {
        //System.out.print(root.getValue());
        if (root != null) {
            //System.out.print(""1"");
            pre(root);
            int size = a.size();
            Node[] prefix = new Node[size];
            //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                prefix[i] = a.pop();
                //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return prefix;
        } else {
            throw new NullPointerException();
        }

    }

    private void pre(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            pre(n.getRight());
            pre(n.getLeft());
            a.push(n);
        }
    }

    public Node[] PrintPostfix() {
        if (root != null) {
            post(root);
            int size = b.size();
            Node[] postfix = new Node[size];
            //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                postfix[i] = b.pop();
                //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return postfix;
        } else {
            throw new NullPointerException();
        }
    }

    private void post(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            b.push(n);
            post(n.getRight());
            post(n.getLeft());

        }
    }

    public double Evaluation() {
        if (root != null) {
            eva(root);
            int size = c.size();
            Node[] ans = new Node[size];
            //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                ans[i] = c.pop();
                //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }

            //Stack<String> ops = new Stack<String>();
            Stack<Double> vals = new Stack<Double>();
            for (int i = 0; i < size; i++) {
                if (ans[i].getValue().equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (ans[i].getValue().equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (ans[i].getValue().equals(""/"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two / one);
                } else if (ans[i].getValue().equals(""-"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two - one);
                } else {
                    vals.push(Double.parseDouble(ans[i].getValue()));
                }
            }
            double answer = vals.pop();

            return answer;
        } else {
            throw new NullPointerException();
        }
    }

    private void eva(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            c.push(n);
            eva(n.getRight());
            eva(n.getLeft());

        }
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String input = ""(((2+3)+(4+5))+((2+3)+(4+5)))"";

            Expression test = new Expression();
            test.Infix2BT(input);
            
            
            //System.out.print(test.Infix2BT(input).getValue() + ""\n"");
            Node[] t1 = test.PrintPrefix();
            Node[] t2 = test.PrintPostfix();

//            for (int i = 0; i < t1.length; i++) {
//                System.out.printf(t1[i].getValue() + "" "");
//            }
//            System.out.printf(""\n"");
//            for (int i = 0; i < t2.length; i++) {
//                System.out.printf(t2[i].getValue() + "" "");
//            }

            //Node[] a = test.PrintPrefix();
            //System.out.printf(test.PrintPrefix()[0].getValue());
            //System.out.print();
//            System.out.print(test.Evaluation());

        }
    }
}

@ba67b600ae63779d3f56499a76b32cdb@"
"b02611026","10","0.097","105872","@4ef6ce5f23ca2d472e265957010e4ccf@
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Arrays;

public class Expression {

    private Node root;
    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] input;
        int input_length = 0;
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        input = infix.split(""(?<=[\\(\\)\\+\\-*\\/])|(?=[\\(\\)\\+\\-*\\/])"");

        for (int i = 1; i < input.length; i++) {
            input_length++;
        }
        //System.out.printf(""\n"");
        
        Node[] inputarray = new Node[input.length - 1];
        for (int i = 1; i < input.length; i++) {
            inputarray[i - 1] = new Node(null, null, input[i]);
            //System.out.printf(inputarray[i - 1].getValue());
        }
        
        ArrayList<Node> tree = new ArrayList<Node>();
        
        for (int i = 0; i < inputarray.length; i++) {
            if (inputarray[i].getValue().equals(""("")) {
                continue;
            } else if (inputarray[i].getValue().equals(""+"")) {
                ops.push(inputarray[i]);
            } else if (inputarray[i].getValue().equals(""*"")) {
                ops.push(inputarray[i]);
            } else if (inputarray[i].getValue().equals(""/"")) {
                ops.push(inputarray[i]);
            } else if (inputarray[i].getValue().equals(""-"")) {
                ops.push(inputarray[i]);
            } else if (inputarray[i].getValue().equals("")"")) {               
                Node right = vals.pop();
                Node left = vals.pop();
                Node ing = new Node(left, right,ops.pop().getValue());
                vals.push(ing);
                tree.add(ing);
                
            } else {
                vals.push((inputarray[i]));
            }
        }
        root = tree.get(tree.size()-1);
        return root;
    }

    

    private Stack<Node> a = new Stack<Node>();
    private Stack<Node> b = new Stack<Node>();
    private Stack<Node> c = new Stack<Node>();

    public Node[] PrintPrefix() {
        //System.out.print(root.getValue());
        if (root != null) {
            //System.out.print(""1"");
            pre(root);
            int size = a.size();
            Node[] prefix = new Node[size];
            //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                prefix[i] = a.pop();
                //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return prefix;
        } else {
            throw new NullPointerException();
        }

    }

    private void pre(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            pre(n.getRight());
            pre(n.getLeft());
            a.push(n);
        }
    }

    public Node[] PrintPostfix() {
        if (root != null) {
            post(root);
            int size = b.size();
            Node[] postfix = new Node[size];
            //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                postfix[i] = b.pop();
                //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }
            return postfix;
        } else {
            throw new NullPointerException();
        }
    }

    private void post(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            b.push(n);
            post(n.getRight());
            post(n.getLeft());

        }
    }

    public double Evaluation() {
        if (root != null) {
            eva(root);
            int size = c.size();
            Node[] ans = new Node[size];
            //System.out.printf(""size"" + size + ""\n"");
            //System.out.printf(test.getValuetest = a.pop();() + ""\n"");
            for (int i = 0; i < size; i++) {
                //ans[0] = prefix.pop();
                ans[i] = c.pop();
                //System.out.printf(ans[i].getValue()+ ""\n"");
                //System.out.print(i+ ""\n"");
            }

            //Stack<String> ops = new Stack<String>();
            Stack<Double> vals = new Stack<Double>();
            for (int i = 0; i < size; i++) {
                if (ans[i].getValue().equals(""+"")) {
                    vals.push(vals.pop() + vals.pop());
                } else if (ans[i].getValue().equals(""*"")) {
                    vals.push(vals.pop() * vals.pop());
                } else if (ans[i].getValue().equals(""/"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two / one);
                } else if (ans[i].getValue().equals(""-"")) {
                    double one = vals.pop();
                    double two = vals.pop();
                    vals.push(two - one);
                } else {
                    vals.push(Double.parseDouble(ans[i].getValue()));
                }
            }
            double answer = vals.pop();

            return answer;
        } else {
            throw new NullPointerException();
        }
    }

    private void eva(Node n) {
        if (n != null) {
            //System.out.printf(n.getValue() + ""\n"");
            c.push(n);
            eva(n.getRight());
            eva(n.getLeft());
        }
    }

//    public static void main(String[] args) throws Exception {
//        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
//            String input = ""(((2+3)+(4+5))+((2+3)+(4+5)))"";
//
//            Expression test = new Expression();
//            test.Infix2BT(input);
//            
//            
//            //System.out.print(test.Infix2BT(input).getValue() + ""\n"");
//            Node[] t1 = test.PrintPrefix();
//            Node[] t2 = test.PrintPostfix();
//
////            for (int i = 0; i < t1.length; i++) {
////                System.out.printf(t1[i].getValue() + "" "");
////            }
////            System.out.printf(""\n"");
////            for (int i = 0; i < t2.length; i++) {
////                System.out.printf(t2[i].getValue() + "" "");
////            }
//
//            //Node[] a = test.PrintPrefix();
//            //System.out.printf(test.PrintPrefix()[0].getValue());
//            //System.out.print();
////            System.out.print(test.Evaluation());
//
//        }
//    }
}

@4ef6ce5f23ca2d472e265957010e4ccf@"
"r03525006","6","0.98","105888","@9157160197ad876931c6028b0461d092@import java.util.AbstractList;
import java.util.ArrayList;
import java.util.List;

public class Expression{

    private Node root;
    private List<String> infixArry = new ArrayList<>();

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operator = new Stack<Node>();
        Stack<Node> value = new Stack<Node>();
        Character a;
        String num = """", c;
        for (int i = 0; i < infix.length(); i++) {
            a = infix.charAt(i);
            c = a.toString();

            if (c.equals(""("")) {
                num = """";
                infixArry.add(c);
            } else if (c.equals("")"")) {
                if (!num.equals("""")) value.push(new Node(null,null,num));
                infixArry.add(c);
                num = """";
                Node n = operator.pop();
                n.setRight(value.pop());
                n.setLeft(value.pop());
                root = n;
                value.push(n);
            } else if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"") ) {
                if (!num.equals("""")) value.push(new Node(null,null,num));
                infixArry.add(c);
                num = """";
                operator.push(new Node(null,null,c));
            } else {
                num = num + c;
                infixArry.add(num);
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        list.add(root);
        traversalTree(list,root.getLeft());
        traversalTree(list,root.getRight());
        return list.toArray(new Node[list.size()]);
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        traversalTree(list,root.getLeft());
        traversalTree(list,root.getRight());
        list.add(root);
        return list.toArray(new Node[list.size()]);
    }

    private void traversalTree(List<Node> list, Node root) {
        if (root == null) return;
        list.add(root);
        traversalTree(list,root.getLeft());
        traversalTree(list,root.getRight());
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        String[] e = infixArry.toArray(new String[infixArry.size()]);
        Stack<String> operator = new Stack<>();
        Stack<Double> value = new Stack<>();
        for (int i = 0; i <e.length; i++) {
            String s = e[i];
            if (s.equals(""("")) ;
            else if (s.equals(""+"")) operator.push(s);
            else if (s.equals(""-"")) operator.push(s);
            else if (s.equals(""*"")) operator.push(s);
            else if (s.equals(""/"")) operator.push(s);
            else if (s.equals("")""))
            {
                String op = operator.pop();
                if (op.equals(""+"")) {
                    value.push(value.pop() + value.pop());
                } else if (op.equals(""-"")) {
                    value.push(- value.pop() + value.pop());
                } else if (op.equals(""*"")) {
                    value.push(value.pop() * value.pop());
                } else if (op.equals(""/"")) {
                    Double a = value.pop();
                    Double b = value.pop();
                    value.push(b/a);
                }
            }
            else value.push(Double.parseDouble(s));
        }
        return value.pop();
    }
//
//    public static void main(String[] args) {
//
//        String infix = ""(4+(((4*2)/2)/3))"";
//        String infix1 = ""((4.4-3)+((((4*2)/2)/3)+((2+1)*3)))"";
//        Expression e = new Expression();
//        Node n = e.Infix2BT(infix1);
//        Node[] nArray = e.PrintPostfix();
//        for (int i = 0; i < nArray.length; i++) System.out.println(nArray[i].getValue());
//        System.out.println(e.Evaluation());
//    }
}
@9157160197ad876931c6028b0461d092@"
"r04945009","10","0.098","105856","@5399719c7ad213e6adf41082ca0984b7@public class Expression{
  
    private Node root;
    private String infix;
    private int count;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    private Node readTree() {
        Node n = new Node(null, null, null);
        // get next non-whitespace char
        char ch = infix.charAt(count); count++;
        int chArrayCount = 0;
        String ans ;
        if ((ch >= '0') && (ch <='9')) {
            // leaf node
            ans = String.valueOf(ch);
            while((infix.charAt(count) == '.') || (infix.charAt(count) >= '0' && infix.charAt(count) <= '9')) {
                ans = ans.concat(String.valueOf(infix.charAt(count)));
                count++;
            }
            n.setValue(ans);
        } 
        else if (ch == '(') {
            // an expression
            n.setLeft(readTree());
            n.setValue(String.valueOf(infix.charAt(count))); count++; 
            n.setRight(readTree());
            ch = infix.charAt(count); count++;
            if (ch != ')')
                System.out.print(""EXPECTED ) - } ASSUMED..."");
        } 
        else {
            System.out.print(""EXPECTED ( - CAN'T PARSE"");
            System.exit(1);
        }
        return n;
    }
    
    
    
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        root = null;
        this.infix = infix;
        count = 0;
        root =  readTree();
        return root;
    }

    public void pretraversal(Node p, Node[] pre) {
        if (p == null) return;
        pre[precount] = p;
        precount++;
        pretraversal(p.getLeft(), pre); // 次輸出左子樹
        pretraversal(p.getRight(), pre);// 後輸出右子樹
    }
    
    private int precount;
    public Node[] PrintPrefix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] pre = new Node[20];
        precount = 0;
        pretraversal(root, pre);
        Node[] prefix = new Node[precount];
        System.arraycopy(pre, 0, prefix, 0, precount);
        return prefix;
    }
    
    public void posttraversal(Node p, Node[] post) {
        if (p == null) return;
        posttraversal(p.getLeft(), post); // 次輸出左子樹
        posttraversal(p.getRight(), post);// 後輸出右子樹
        post[postcount] = p;
        postcount++;
    }
    
    private int postcount;
    public Node[] PrintPostfix(){
        if (root == null) { throw new NullPointerException(); }
        Node[] post = new Node[20];
        postcount = 0;
        posttraversal(root, post);
        Node[] postfix = new Node[postcount];
        System.arraycopy(post, 0, postfix, 0, postcount);
        return postfix;
    }

    public double Evaluation(){
        if (root == null) { throw new NullPointerException(); }
        double answer = 0;
        Node[] postfix = PrintPostfix();
        Stack<String> C = new Stack();
        for (int i=0; i<postfix.length; i++){
            if (postfix[i].getValue().equals(""+"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1+num2) );
            }
            else if (postfix[i].getValue().equals(""-"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1-num2) );
            }
            else if (postfix[i].getValue().equals(""*"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1*num2) );
            }
            else if (postfix[i].getValue().equals(""/"")) {
                double num2 = Double.parseDouble(C.pop());
                double num1 = Double.parseDouble(C.pop());
                C.push( String.valueOf(num1/num2) );
            }
            else C.push(postfix[i].getValue());
        }
        answer = Double.parseDouble(C.pop());
        return answer;
    }
    
    
    public static void main(String[] args) {
        Expression go = new Expression();
        Node root = go.Infix2BT(""((20120224791*(121259+797912))+(211544771212/2))"");
        Node[] prefix = go.PrintPrefix();
        Node[] postfix = go.PrintPostfix();
        double answer = go.Evaluation();
        System.out.println(root.getValue());
        }
    
    
    
}

@5399719c7ad213e6adf41082ca0984b7@"
"r04921105","10","0.097","105856","@e38c062e1c1e649aba7e8aa6f4552105@
import java.util.ArrayList;
import java.util.List;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();        
        Stack<Node> vals = new Stack<Node>();
        boolean flag =false;
        String[] input = infix.split("""");
         for(int i=0;i<input.length;i++){
            String s = input[i];
            //System.out.println(s);
            switch(s){
                case(""(""):
                    flag=false;
                    break;
                   
            case(""+""):
                //else if (s.equals(""+"") || s.equals(""-"") || s.equals(""*"") || s.equals(""/""))
                //Node ops =(null,null,s);          
            case(""-""):
            case(""*""):
            case(""/""):
                ops.push(new Node(null,null,s));
                flag=false;
                break;
                
            case("")""):               
                //vals.pop();
                //vals.pop();              
                //ops.pop();
                if(ops.isEmpty()){
                    break;
                }
                    
                String val =ops.pop().getValue();
                
                //new Node(vals.pop(),vals.pop(),ss);
                Node r = vals.pop();
                Node l = vals.pop();
                vals.push(new Node(l,r,val));
                flag=false;
                //System.out.println(val);
                break;
            default:
                if(flag==false){
                vals.push(new Node(null,null,s));
                flag=true;
                }
                else if(flag==true){
                    String f1=vals.pop().getValue();
                    //System.out.println(f1);
                 vals.push(new Node(null,null,f1+s));
                 //System.out.println(f1+s);                
                }                
                break;

            }//end of switch              
         }//end of for
        root = vals.pop();
        return root;
    }

    public Node[] PrintPrefix(){
        if(root==null)
         throw new NullPointerException();
        List<Node> prefix;
        prefix = new ArrayList<>();
        get_prefix(prefix,root);

        return prefix.toArray(new Node[prefix.size()]);
    }
  
    public Node[] PrintPostfix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> postfix;
        postfix = new ArrayList<>();
        get_postfix(postfix,root);

        return postfix.toArray(new Node[postfix.size()]);
    }
    public Node[] Printinfix(){
        if(root==null)
            throw new NullPointerException();
        List<Node> infix;
        infix = new ArrayList<>();
        get_infix(infix,root);

        return infix.toArray(new Node[infix.size()]);
    }

    public double Evaluation(){
        if(root==null)
            throw new NullPointerException();        
       // switch()       
        return evaluate(root);
    }

    private void get_prefix(List<Node> a,Node b) {
        if(b==null)
            return;
            a.add(b);
            get_prefix(a,b.getLeft());
            get_prefix(a,b.getRight());
    }
    private void get_postfix(List<Node> a,Node b) {
        if(b==null)
            return;
            get_postfix(a,b.getLeft());
            get_postfix(a,b.getRight());
            a.add(b);
    }
    private void get_infix(List<Node> a,Node b) {
        if(b==null)
            return;
            get_infix(a,b.getLeft());          
            a.add(b);
            get_infix(a,b.getRight());
    }

    private double evaluate(Node root) {
        switch(root.getValue()){
            case""+"":
                return evaluate(root.getLeft())+evaluate(root.getRight());
            case""-"":
                return evaluate(root.getLeft())-evaluate(root.getRight());
            case""*"":
                return evaluate(root.getLeft())*evaluate(root.getRight());
            case""/"":
                return evaluate(root.getLeft())/evaluate(root.getRight());
            default:
                return Double.parseDouble(root.getValue());
        }                        
        
       
    }
}

@e38c062e1c1e649aba7e8aa6f4552105@"
"r03525006","6","0.98","105840","@8bbd67145383910188c460d276694ee8@import java.util.AbstractList;
import java.util.ArrayList;
import java.util.List;

public class Expression{

    private Node root;
    private List<String> infixAarry = new ArrayList<>();

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operator = new Stack<Node>();
        Stack<Node> value = new Stack<Node>();
        Character a;
        String num = """", c;
        for (int i = 0; i < infix.length(); i++) {
            a = infix.charAt(i);
            c = a.toString();

            if (c.equals(""("")) {
                num = """";
                infixAarry.add(c);
            } else if (c.equals("")"")) {
                if (!num.equals("""")) { value.push(new Node(null,null,num)); infixAarry.add(num); }
                infixAarry.add(c);
                num = """";
                Node n = operator.pop();
                n.setRight(value.pop());
                n.setLeft(value.pop());
                root = n;
                value.push(n);
            } else if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"") ) {
                if (!num.equals("""")) { value.push(new Node(null,null,num)); infixAarry.add(num); }
                infixAarry.add(c);
                num = """";
                operator.push(new Node(null,null,c));
            } else {
                num = num + c;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        list.add(root);
        traversalTree(list,root.getLeft());
        traversalTree(list,root.getRight());
        return list.toArray(new Node[list.size()]);
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        traversalTree(list,root.getLeft());
        traversalTree(list,root.getRight());
        list.add(root);
        return list.toArray(new Node[list.size()]);
    }

    private void traversalTree(List<Node> list, Node root) {
        if (root == null) return;
        list.add(root);
        traversalTree(list,root.getLeft());
        traversalTree(list,root.getRight());
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        String[] e = infixAarry.toArray(new String[infixAarry.size()]);
        Stack<String> operator = new Stack<>();
        Stack<Double> value = new Stack<>();
        for (int i = 0; i < e.length; i++) {
            String s = e[i];
            if (s.equals(""("")) ;
            else if (s.equals(""+"")) operator.push(s);
            else if (s.equals(""-"")) operator.push(s);
            else if (s.equals(""*"")) operator.push(s);
            else if (s.equals(""/"")) operator.push(s);
            else if (s.equals("")""))
            {
                String op = operator.pop();
                if (op.equals(""+"")) {
                    value.push(value.pop() + value.pop());
                } else if (op.equals(""-"")) {
                    value.push(- value.pop() + value.pop());
                } else if (op.equals(""*"")) {
                    value.push(value.pop() * value.pop());
                } else if (op.equals(""/"")) {
                    Double a = value.pop();
                    Double b = value.pop();
                    value.push(b/a);
                }
            }
            else value.push(Double.parseDouble(s));
        }
        return value.pop();
    }

//    public static void main(String[] args) {
//
//        String infix = ""(4+(((4*2)/2)/3))"";
//        String infix1 = ""((4.4-3)+((((4*2)/2)/3)+((2+1)*3)))"";
//        Expression e = new Expression();
//        Node n = e.Infix2BT(infix1);
//        for (int i = 0; i < e.infixAarry.size(); i++) System.out.println(e.infixAarry.get(i));
////        Node[] nArray = e.PrintPostfix();
////        for (int i = 0; i < nArray.length; i++) System.out.println(nArray[i].getValue());
//        System.out.println(e.Evaluation());
//    }
}
@8bbd67145383910188c460d276694ee8@"
"r03525006","10","0.096","105920","@ff9e1243766c856df0b088c2a34520a3@import java.util.AbstractList;
import java.util.ArrayList;
import java.util.List;

public class Expression{

    private Node root;
    private List<String> infixAarry = new ArrayList<>();

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operator = new Stack<Node>();
        Stack<Node> value = new Stack<Node>();
        Character a;
        String num = """", c;
        for (int i = 0; i < infix.length(); i++) {
            a = infix.charAt(i);
            c = a.toString();

            if (c.equals(""("")) {
                num = """";
                infixAarry.add(c);
            } else if (c.equals("")"")) {
                if (!num.equals("""")) { value.push(new Node(null,null,num)); infixAarry.add(num); }
                infixAarry.add(c);
                num = """";
                Node n = operator.pop();
                n.setRight(value.pop());
                n.setLeft(value.pop());
                root = n;
                value.push(n);
            } else if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"") ) {
                if (!num.equals("""")) { value.push(new Node(null,null,num)); infixAarry.add(num); }
                infixAarry.add(c);
                num = """";
                operator.push(new Node(null,null,c));
            } else {
                num = num + c;
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        list.add(root);
        boolean isPrefix = true;
        traversalTree(list,root.getLeft(),isPrefix);
        traversalTree(list,root.getRight(),isPrefix);
        return list.toArray(new Node[list.size()]);
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        boolean isPrefix = false;
        traversalTree(list,root.getLeft(),isPrefix);
        traversalTree(list,root.getRight(),isPrefix);
        list.add(root);
        return list.toArray(new Node[list.size()]);
    }

    private void traversalTree(List<Node> list, Node root,boolean isPrefix) {
        if (root == null) return;
        if (isPrefix) list.add(root);
        traversalTree(list,root.getLeft(),isPrefix);
        traversalTree(list,root.getRight(),isPrefix);
        if (!isPrefix) list.add(root);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        String[] e = infixAarry.toArray(new String[infixAarry.size()]);
        Stack<String> operator = new Stack<>();
        Stack<Double> value = new Stack<>();
        for (int i = 0; i < e.length; i++) {
            String s = e[i];
            if (s.equals(""("")) ;
            else if (s.equals(""+"")) operator.push(s);
            else if (s.equals(""-"")) operator.push(s);
            else if (s.equals(""*"")) operator.push(s);
            else if (s.equals(""/"")) operator.push(s);
            else if (s.equals("")""))
            {
                String op = operator.pop();
                if (op.equals(""+"")) {
                    value.push(value.pop() + value.pop());
                } else if (op.equals(""-"")) {
                    value.push(- value.pop() + value.pop());
                } else if (op.equals(""*"")) {
                    value.push(value.pop() * value.pop());
                } else if (op.equals(""/"")) {
                    Double a = value.pop();
                    Double b = value.pop();
                    value.push(b/a);
                }
            }
            else value.push(Double.parseDouble(s));
        }
        return value.pop();
    }

//    public static void main(String[] args) {
//
//        String infix = ""(4+(((4*2)/2)/3))"";
//        String infix1 = ""((4.4-3)+((((4*2)/2)/3)+((2+1)*3)))"";
//        Expression e = new Expression();
//        Node n = e.Infix2BT(infix);
//        for (int i = 0; i < e.infixAarry.size(); i++) System.out.println(e.infixAarry.get(i));
//        Node[] nArray = e.PrintPostfix();
//        for (int i = 0; i < nArray.length; i++) System.out.println(nArray[i].getValue());
//        System.out.println(e.Evaluation());
//    }
}
@ff9e1243766c856df0b088c2a34520a3@"
"r03945012","3","1.01","105824","@ee0ebcbcba66d3ce3239352d895cf88c@
import java.util.ArrayList;

/**
 * 1042 PDSA hw09_Expression
 *
 * @author Robert
 */
public class Expression {

    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;

    // DO NOT MODIFY THIS

    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        // initize root
        root = null;
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++) {
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++) {
                if (string.charAt(i) == operator.get(j)) {
                    isoperater = true;
                    if (n != 0) {
                        data.add(string.substring(i - n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i + 1));
                }
            }
            if (isoperater == false) {
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

//        for(String s : dataArr)
//            System.out.println(s);
        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");

        // Node 2 tmp: a, b
        Node a = null;
        Node b = null;
        Stack<String> s = new Stack<String>();
        Stack<Node> tmpStack = new Stack<Node>();
        int count = 0;
        for (int i = 0; i < dataArr.length; i++) {
            if ("")"".equals(dataArr[i]) && ""("".equals(dataArr[i - 4])) {
                count++;
            }
        }
        Node[] rootArr = new Node[count];
        int k = 0;

        for (int i = 0; i < dataArr.length; i++) {

            if ("")"".equals(dataArr[i])) {
                Node tmp1 = tmpStack.pop();
                Node tmp2 = tmpStack.pop();
                String operat = s.pop();
                Node tmp = new Node(tmp2, tmp1, operat);
                root = tmp;
                tmpStack.push(tmp);
            } else if (op.contains(dataArr[i])) {
                s.push(dataArr[i]);
            } else if (""("".equals(dataArr[i])) {
            } else {
                Node tmp = new Node(null, null, dataArr[i]);
                tmpStack.push(tmp);
            }
        }
        return (root);
    }

    public Node[] PrintPrefix() {
        preOrder(root);
//        StdOut.println(prefix_answer.size());
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }

    private void preOrder(Node a) {
        if (a != null) {
            prefix_answer = new ArrayList<>();
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }

    public Node[] PrintPostfix() {
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a) {
        if (a != null) {
            postfix_answer = new ArrayList<>();
            postfix_answer.add(a);
            postOrder(a.getLeft());
            postOrder(a.getRight());
        }
    }

    public double Evaluation() {
        double answer = 0;
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i = 0; i < data.length; i++) {
            s.push(data[i]);
            if ("")"".equals(s.peek())) {
                for (int j = 0; j < 5; j++) {
                    tmp[j] = s.pop();
                }
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]) {
                    case ""+"":
                        answer = num1 + num2;
                        break;
                    case ""-"":
                        answer = num1 - num2;
                        break;
                    case ""*"":
                        answer = num1 * num2;
                        break;
                    case ""/"":
                        answer = num1 / num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return (answer);
    }

    // testing
    public static void main(String[] args) {
//        String a = ""(4+(((4*2)/2)/3))"";
//        String b = ""(60*(((4*2)/2)*3))"";
        String a = ""(((0.235+0.88)*7.2)+(200+10))"";
        Expression cct = new Expression();
        Node result = cct.Infix2BT(a);
//        result = cct.Infix2BT(c);
        Node[] test = cct.PrintPrefix();
//        StdOut.println(cct.Evaluation());
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
//        StdOut.println(test[2].getValue());
//        StdOut.println(test[3].getValue());
//        StdOut.println(test[4].getValue());
//        StdOut.println(test[5].getValue());
//        StdOut.println(test[6].getValue());
//        StdOut.println(test[7].getValue());

        StdOut.println(result.getValue());
        StdOut.println(result.getLeft().getValue());
        StdOut.println(result.getRight().getValue());

    }

}

@ee0ebcbcba66d3ce3239352d895cf88c@"
"r03525006","10","0.098","105824","@34afbd670a3ff65abd4e23a08cb9009b@import java.util.ArrayList;
import java.util.List;

public class Expression{

    private Node root;
    public List<String> infixArray = new ArrayList<>();

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> operator = new Stack<Node>();
        Stack<Node> value = new Stack<Node>();
        Character a;
        String num = """", c;
        for (int i = 0; i < infix.length(); i++) {
            a = infix.charAt(i);
            c = a.toString();

            if (c.equals(""("")) {
                num = """";
                infixArray.add(c);
            } else if (c.equals("")"")) {
                if (!num.equals("""")) { value.push(new Node(null,null,num)); infixArray.add(num); }
                infixArray.add(c);
                num = """";
                Node n = operator.pop();
                n.setRight(value.pop());
                n.setLeft(value.pop());
                root = n;
                value.push(n);
            } else if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"") ) {
                if (!num.equals("""")) { value.push(new Node(null,null,num)); infixArray.add(num); }
                infixArray.add(c);
                num = """";
                operator.push(new Node(null,null,c));
            } else num = num + c;
        } return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        list.add(root);
        boolean isPrefix = true;
        traversalTree(list,root.getLeft(),isPrefix);
        traversalTree(list,root.getRight(),isPrefix);
        return list.toArray(new Node[list.size()]);
    }

    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> list = new ArrayList<Node>();
        boolean isPrefix = false;
        traversalTree(list,root.getLeft(),isPrefix);
        traversalTree(list,root.getRight(),isPrefix);
        list.add(root);
        return list.toArray(new Node[list.size()]);
    }

    private void traversalTree(List<Node> list, Node root,boolean isPrefix) {
        if (root == null) return;
        if (isPrefix) list.add(root);
        traversalTree(list,root.getLeft(),isPrefix);
        traversalTree(list,root.getRight(),isPrefix);
        if (!isPrefix) list.add(root);
    }

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        String[] e = infixArray.toArray(new String[infixArray.size()]);
        Stack<String> operator = new Stack<>();
        Stack<Double> value = new Stack<>();
        for (int i = 0; i < e.length; i++) {
            String s = e[i];
            if (s.equals(""("")) ;
            else if (s.equals(""+"")) operator.push(s);
            else if (s.equals(""-"")) operator.push(s);
            else if (s.equals(""*"")) operator.push(s);
            else if (s.equals(""/"")) operator.push(s);
            else if (s.equals("")""))
            {
                String op = operator.pop();
                if (op.equals(""+"")) value.push(value.pop() + value.pop());
                else if (op.equals(""-"")) value.push(- value.pop() + value.pop());
                else if (op.equals(""*"")) value.push(value.pop() * value.pop());
                else if (op.equals(""/"")) {
                    Double a = value.pop();
                    Double b = value.pop();
                    value.push(b/a);
                }
            }
            else value.push(Double.parseDouble(s));
        }
        return value.pop();
    }
}
@34afbd670a3ff65abd4e23a08cb9009b@"
"r04546014","4","1.26","116048","@d9c01594d6e4a9525db670845bf0437b@
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;
import java.lang.NullPointerException;

/**
 *
 * @author Jayden
 */
public class Expression {

    private Node root;
    private List<Node> nodeList = new ArrayList<>();
    private String infixClone;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix)throws Exception {
        if(infix.isEmpty()) throw new NullPointerException();
        StringBuffer sb = new StringBuffer(infix);//由於近來的資料沒有空格，因此無法使用scanner直接做判斷，在這裡先把字串每一個不同的部分都加入空格，並且刪去左括號
        for (int i = 0; i < sb.length(); i++) {
            String kk = sb.substring(i, i + 1);
            if (sb.substring(i, i + 1).equals(""+"") || sb.substring(i, i + 1).equals(""-"") || sb.substring(i, i + 1).equals(""*"") || sb.substring(i, i + 1).equals(""/"")) {
                sb.insert(i, "" "");
                sb.insert(i + 2, "" "");
                i = i + 2;                
            }
            else if(sb.substring(i, i + 1).equals("")"")){
                sb.insert(i, "" "");
                i=i+1;
            }
            else if(sb.substring(i, i + 1).equals(""("") ){            
                sb.delete(i,i+1); 
                i--;
            }
            
        }
        infixClone = sb.toString();//複製一份infix
        Stack<Node> st = new Stack<Node>();

        Scanner sca = new Scanner(infixClone);
        String value;
        Node node;
        Node a, operator, b;//等一下pop出來的算式是a+-*/b
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {//如果下一個是數字，就轉成node在記錄
                value = String.valueOf(sca.nextDouble());
                node = new Node(null, null, value);
                st.push(node);
            } else {
                value = sca.next();
                if (value.equals("")"")) {
                    if(st.size()<3) break; //如果只有一個數字                   
                    b = st.pop();//第一個pop出來是後面的數字b
                    operator = st.pop();//第二個是運算式
                    a = st.pop();//第三個是前面的數字a
                    operator.setLeft(a);//運算式的左邊是前面的數字a
                    operator.setRight(b);//運算式的右邊是後面的數字b
                    st.push(operator);//回傳運算式

                } else if (value.equals(""("")) {//如果讀到的是左括號，就不做任何事情
                } else {
                    node = new Node(null, null, value);
                    st.push(node);
                }
            }
        }
        root = st.pop();
        return root;
    }

    public Node[] PrintPrefix() throws Exception {
        if(root!=null){
        nodeList.clear();//清除原本的nodeList
        prefixRecursive(root);//執行recursive
        Node[] prefix=new Node[nodeList.size()];
        nodeList.toArray(prefix);//將list轉成array
        return prefix;
        }
        else throw new NullPointerException();
    }

    public Node[] PrintPostfix()throws Exception {
        if(root!=null){
        
        nodeList.clear();//清除原本的nodeList
        postfixRecursive(root);//執行recursive
        Node[] postfix=new Node[nodeList.size()];
        nodeList.toArray(postfix);//將list轉成array
        return postfix;
        }
        else throw new NullPointerException();
    }

    public double Evaluation() throws Exception {
        if(root!=null){
        double answer = 0;
        Stack<String> str = new Stack<String>();
        Stack<Double> dou = new Stack<Double>();
        //兩個stack用來記錄兩種型態的資料
        double a, b;//ab是用來紀錄兩個pop出來的數字
        String c;//c則是用來記錄pop出來的運算符號

        Scanner sca = new Scanner(infixClone);
        String label;
        //scanner是讀取一個一個單字的用法，label則是存讀進來的是什麼東西
        while (sca.hasNext()) {
            if (sca.hasNextDouble()) {
                dou.push(sca.nextDouble());//如果下一個是數字，就記錄數字
            } else {//其餘的就是符號
                label = sca.next();
                if (label.equals(""+"") || label.equals(""-"") || label.equals(""*"") || label.equals(""/"")) {
                    str.push(label);
                } else if (label.equals("")"")) {
                    if(dou.size()<2){//處理如果只有一個數字的情況
                        answer=dou.pop();
                        break;
                    }
                    b = dou.pop();
                    a = dou.pop();
                    c = str.pop();
                    if (c.equals(""+"")) {
                        answer = a + b;
                    } else if (c.equals(""-"")) {
                        answer = a - b;
                    } else if (c.equals(""*"")) {
                        answer = a * b;
                    } else if (c.equals(""/"")) {
                        answer = a / b;
                    }
                    dou.push(answer);//再存入剛剛算出來的y
                }
            }
        }
        return answer;                  
        }
        else throw new NullPointerException();
    }

    private void prefixRecursive(Node n) {
        nodeList.add(n);//先儲存再往左往右
        if (n.getLeft() != null) {
            prefixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            prefixRecursive(n.getRight());
        }
        return;
    }

    private void postfixRecursive(Node n) {
        if (n.getLeft() != null) {
            postfixRecursive(n.getLeft());
        }
        if (n.getRight() != null) {
            postfixRecursive(n.getRight());
        }
        nodeList.add(n);//先往左往右再儲存
        return;
    }
}

@d9c01594d6e4a9525db670845bf0437b@"
"r03945012","5","0.96","105808","@67e30643f893ff7d895cefce0096a808@
import java.util.ArrayList;

/**
 * 1042 PDSA hw09_Expression
 *
 * @author Robert
 */
public class Expression {

    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;

    // DO NOT MODIFY THIS

    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        // initize root
        root = null;
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++) {
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++) {
                if (string.charAt(i) == operator.get(j)) {
                    isoperater = true;
                    if (n != 0) {
                        data.add(string.substring(i - n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i + 1));
                }
            }
            if (isoperater == false) {
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

//        for(String s : dataArr)
//            System.out.println(s);
        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");

        // Node 2 tmp: a, b

        Stack<String> s = new Stack<String>();
        Stack<Node> tmpStack = new Stack<Node>();

        for (int i = 0; i < dataArr.length; i++) {
            if ("")"".equals(dataArr[i])) {
                Node tmp1 = tmpStack.pop();
                Node tmp2 = tmpStack.pop();
                String operat = s.pop();
                Node tmp = new Node(tmp2, tmp1, operat);
                tmpStack.push(tmp);
                root = tmp;
            } else if (op.contains(dataArr[i])) {
                s.push(dataArr[i]);
            } else if (""("".equals(dataArr[i])) {
            } else {
                Node tmp = new Node(null, null, dataArr[i]);
                tmpStack.push(tmp);
            }
        }
        return (root);
    }

    public Node[] PrintPrefix() {
        prefix_answer = new ArrayList<>();
        preOrder(root);
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }

    private void preOrder(Node a) {
        if (a != null) {
            prefix_answer.add(a);
//            StdOut.println(a.getValue());
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }

    public Node[] PrintPostfix() {
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a) {
        if (a != null) {
            postfix_answer = new ArrayList<>();
            postfix_answer.add(a);
            postOrder(a.getLeft());
            postOrder(a.getRight());
        }
    }

    public double Evaluation() {
        double answer = 0;
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i = 0; i < data.length; i++) {
            s.push(data[i]);
            if ("")"".equals(s.peek())) {
                for (int j = 0; j < 5; j++) {
                    tmp[j] = s.pop();
                }
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]) {
                    case ""+"":
                        answer = num1 + num2;
                        break;
                    case ""-"":
                        answer = num1 - num2;
                        break;
                    case ""*"":
                        answer = num1 * num2;
                        break;
                    case ""/"":
                        answer = num1 / num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return (answer);
    }

    // testing
    public static void main(String[] args) {
//        String a = ""(4+(((4*2)/2)/3))"";
//        String b = ""(60*(((4*2)/2)*3))"";
        String a = ""(((0.235+0.88)*7.2)+(200+10))"";
//        String c = ""(((2*3)+(4+5))-((2/3)+(4+5)))"";
        Expression cct = new Expression();
        Node result = cct.Infix2BT(a);
//        result = cct.Infix2BT(c);
        Node[] test = cct.PrintPrefix();
//        StdOut.println(cct.Evaluation());
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
//        StdOut.println(test[2].getValue());
//        StdOut.println(test[3].getValue());
//        StdOut.println(test[4].getValue());
//        StdOut.println(test[5].getValue());
//        StdOut.println(test[6].getValue());
//        StdOut.println(test[7].getValue());

//        StdOut.println(result.getValue());
//        StdOut.println(result.getLeft().getValue());
//        StdOut.println(result.getRight().getValue());
//        StdOut.println(result.getLeft().getLeft().getValue());
//        StdOut.println(result.getRight().getRight().getValue());

    }

}

@67e30643f893ff7d895cefce0096a808@"
"r03945012","5","0.97","105872","@5ea277eacf40259b7012c1ae8e0d7645@
import java.util.ArrayList;

/**
 * 1042 PDSA hw09_Expression
 *
 * @author Robert
 */
public class Expression {

    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;

    // DO NOT MODIFY THIS

    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        // initize root
        root = null;
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++) {
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++) {
                if (string.charAt(i) == operator.get(j)) {
                    isoperater = true;
                    if (n != 0) {
                        data.add(string.substring(i - n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i + 1));
                }
            }
            if (isoperater == false) {
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

//        for(String s : dataArr)
//            System.out.println(s);
        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");

        // Node 2 tmp: a, b

        Stack<String> s = new Stack<String>();
        Stack<Node> tmpStack = new Stack<Node>();

        for (int i = 0; i < dataArr.length; i++) {
            if ("")"".equals(dataArr[i])) {
                Node tmp1 = tmpStack.pop();
                Node tmp2 = tmpStack.pop();
                String operat = s.pop();
                Node tmp = new Node(tmp2, tmp1, operat);
                tmpStack.push(tmp);
                root = tmp;
            } else if (op.contains(dataArr[i])) {
                s.push(dataArr[i]);
            } else if (""("".equals(dataArr[i])) {
            } else {
                Node tmp = new Node(null, null, dataArr[i]);
                tmpStack.push(tmp);
            }
        }
        return (root);
    }

    public Node[] PrintPrefix() {
        prefix_answer = new ArrayList<>();
        preOrder(root);
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }

    private void preOrder(Node a) {
        if (a != null) {
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }

    public Node[] PrintPostfix() {
        postfix_answer = new ArrayList<>();
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a) {
        if (a != null) {
            postfix_answer.add(a);
            postOrder(a.getLeft());
            postOrder(a.getRight());
        }
    }

    public double Evaluation() {
        double answer = 0;
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i = 0; i < data.length; i++) {
            s.push(data[i]);
            if ("")"".equals(s.peek())) {
                for (int j = 0; j < 5; j++) {
                    tmp[j] = s.pop();
                }
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]) {
                    case ""+"":
                        answer = num1 + num2;
                        break;
                    case ""-"":
                        answer = num1 - num2;
                        break;
                    case ""*"":
                        answer = num1 * num2;
                        break;
                    case ""/"":
                        answer = num1 / num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return (answer);
    }

    // testing
    public static void main(String[] args) {
//        String a = ""(4+(((4*2)/2)/3))"";
//        String b = ""(60*(((4*2)/2)*3))"";
        String a = ""(((0.235+0.88)*7.2)+(200+10))"";
//        String c = ""(((2*3)+(4+5))-((2/3)+(4+5)))"";
        Expression cct = new Expression();
        Node result = cct.Infix2BT(a);
//        result = cct.Infix2BT(c);
        Node[] test = cct.PrintPrefix();
//        StdOut.println(cct.Evaluation());
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
//        StdOut.println(test[2].getValue());
//        StdOut.println(test[3].getValue());
//        StdOut.println(test[4].getValue());
//        StdOut.println(test[5].getValue());
//        StdOut.println(test[6].getValue());
//        StdOut.println(test[7].getValue());

//        StdOut.println(result.getValue());
//        StdOut.println(result.getLeft().getValue());
//        StdOut.println(result.getRight().getValue());
//        StdOut.println(result.getLeft().getLeft().getValue());
//        StdOut.println(result.getRight().getRight().getValue());

    }

}

@5ea277eacf40259b7012c1ae8e0d7645@"
"b99611017","0","0.27","105248","@aacc22a466058831f90af0deac05c0e5@
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/**
 *
 * @author 許志鵬
 */
public class Expression {

    /**
     * @param args the command line arguments
     */
    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] to_do = infix.split("" "");

        Node[] arr = new Node[to_do.length];
        for (int i = 0; i < to_do.length; i++) {
            arr[i]=new Node(null,null,to_do[i]);
            

        }
        int breaker = to_do.length;
        while (breaker > 5) {
            int count = 0;
            //how_many_brackets
            for (int i = 0; i < to_do.length; i++) {
                if (arr[i].getValue() == ""("") {
                    count++;
                }
            }

            //remove_brackets
            int f_bott = 0;
            for (int i = 0; i < arr.length; i++) {
                if (arr[i].getValue() == ""("") {
                    count++;
                    if (count == f_bott) {
                        int j;
                        for(j=i;j<arr.length;j++)
                        {
                            if(arr[j].getValue()==""+""||arr[j].getValue()==""-""||arr[j].getValue()==""*""||arr[j].getValue()==""/"")
                            {
                                root=arr[j];
                                break;
                            }
                        }
                       // root=arr[i+2];
                        int n = j-1;
                        while (true) {
                            if (arr[n].getValue() == ""(""||arr[n].getValue() == null) {
                                arr[n]=null;
                                n--;
                            }
                            if (arr[n].getValue() != ""(""&&arr[n].getValue()!=null) {
                                root.setLeft(arr[n]);
                                
                                break;
                                
                            }
                        }
                        
                        int m = j+1;
                        while (true) {
                            if (arr[m].getValue() == "")""||arr[m].getValue()==null) {
                                arr[m]=null;
                                m++;
                            }
                            if (arr[m].getValue() != "")""&&arr[m].getValue()!=null) {
                                root.setRight(arr[m]);
                                
                                break;
                            }
                        }

                    }
                }
            }
            for(int i=0;i<arr.length;i++)
            {
                if(arr[i].getValue()!=""(""&&arr[i].getValue()!="")""&&arr[i].getValue()!=null)
                {
                    breaker++;
                }
            }
            
        }
        
        return root;
    }

    public Node[] PrintPrefix() {
        Node[] prefix = null;
        return prefix;
    }

    public Node[] PrintPostfix() {
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        return answer;
    }

    public static void main(String[] args) throws FileNotFoundException, IOException {
        // TODO code application logic here
        try (BufferedReader br = new BufferedReader(new FileReader(args[0]))) {
            String header = br.readLine();
            char[] cArray = header.toCharArray();

            String to_Split = """";

            for (int i = 0; i < cArray.length; i++) {
                if (cArray[i] == ')' || cArray[i] == '(' || cArray[i] == '+' || cArray[i] == '-' || cArray[i] == '*' || cArray[i] == '/') {
                    to_Split += String.valueOf(cArray[i]);
                    to_Split += "" "";
                }
                if (cArray[i] == '0' || cArray[i] == '1' || cArray[i] == '2' || cArray[i] == '3' || cArray[i] == '4' || cArray[i] == '5' || cArray[i] == '6'
                        || cArray[i] == '7' || cArray[i] == '8' || cArray[i] == '9' || cArray[i] == '.') {
                    to_Split += String.valueOf(cArray[i]);
                    if (cArray[i + 1] == '(' || cArray[i + 1] == ')' || cArray[i + 1] == '+' || cArray[i + 1] == '-' || cArray[i + 1] == '*' || cArray[i + 1] == '/') {
                        to_Split += "" "";
                    }
                }
            }
           
            
            
        }
    }

}

@aacc22a466058831f90af0deac05c0e5@"
"r04228002","1","1","105888","@f42cfaf3b8df21a1f5ebe87bd7e51728@
import java.util.Arrays;
import java.util.ArrayList;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
public class Expression{
  
    private Node root;
    private Node Rroot;
    private Node Newroot;
    //private Integer Rbracket = 0;
    //private Integer Lbracket = 0;
    
    private Queue<Node> PreNodeList = new Queue<Node>();
    //private ArrayList<Node> PreNodeList = new ArrayList<Node>();
    private Stack<Node> PostNodeList = new Stack<Node>();
    private Stack<Node> EVA =new Stack<Node>();
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        if (infix.equals("""")) {root=null; return root;}
        root = null;
        Rroot=null;
        
        Stack<String> S2 = new Stack<String>();
        
        String[] I = infix.split(""((?<=\\+|\\-|\\*|\\/|\\(|\\))|(?=\\+|\\-|\\*|\\/|\\(|\\)))"");
        Integer len = I.length-1;
        String[] S1 = new String[len];
        for (int i=0;i<len;i++){ 
            S1[i]=I[i+1];
        }
        
        if (len==3) {
            root=new Node(null,null,S1[1]);
            return root;
        }
        
        String Index2 = S1[2];
        String IndexLast2 = S1[len-3];
        if (Index2.equals(""+"")||Index2.equals(""-"")||Index2.equals(""*"")||Index2.equals(""/"")){
            root = new Node(null,null,Index2);
            root = BuildTree(root,0,2,len,S1);
        }
        else if (IndexLast2.equals(""+"")||IndexLast2.equals(""-"")||IndexLast2.equals(""*"")||IndexLast2.equals(""/"")){
            root = new Node(null,null,IndexLast2);
            root = BuildTree(root,0,len-3,len,S1);
        }
        else{
            Integer Rbracket = 0;
            Integer Lbracket = 0;
            for (int i=0;i<len;i++){
                String O = S1[i];
                if ((O.equals(""+"") || O.equals(""-"") || O.equals(""*"") || O.equals(""/"")) && Lbracket-Rbracket==1){
                    root = new Node(null,null,O);
                    root = BuildTree(root,0,i,len,S1);
                    break;
                }
                if (O.equals(""("")) Lbracket++;
                else if (O.equals("")"")) Rbracket++;
            }
        }
        return root;
    }
        ////////////////////////////////////////////////////////////////////////
        
            
           
            
            
////////////////////////////////////////////////////////////////////////////////
    public Node[] PrintPrefix(){
        if (root==null) throw new NullPointerException();
        root = getPrefix(root);
        //Node[] prefix = PreNodeList.toArray(new Node[PreNodeList.size()]);
        Integer size1 = PreNodeList.size();
        Node[] prefix = new Node[size1];
        for (int i=0;i<size1;i++){
            prefix[i]=PreNodeList.dequeue();
        }
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if (root==null) throw new NullPointerException();
        root = getPostfix(root);
        Integer size2 = PostNodeList.size();
        Node[] postfix = new Node[size2];
        for (int i=0;i<size2;i++){
            postfix[i]=PostNodeList.pop();
        }
        return postfix;
    }

    public double Evaluation(){
        if (root==null) throw new NullPointerException();
        Stack<Node> Temp = new Stack<Node>();
        root = getEVA(root);
        while (EVA.size() > 1){
            Node N1 = EVA.pop();
            Node N2 = EVA.pop();
            Node OP = EVA.pop();
            String OPV = OP.getValue();
            while (!OPV.equals(""+"") && !OPV.equals(""-"") && !OPV.equals(""*"") && !OPV.equals(""/"")){
                Temp.push(N1);
                N1=N2;
                N2=OP;
                OP=EVA.pop();
                OPV=OP.getValue();
            }
            Node TempNode = new Node(null,null,calValue(N1.getValue(),N2.getValue(),OP.getValue()));
            EVA.push(TempNode);
            while(Temp.size()!=0){
                EVA.push(Temp.pop());
            }
        }
        String a1 = EVA.pop().getValue();
        double answer = Double.parseDouble(a1);
        
        return answer;
    }
    ////////////////////////////////////////////////////////////////////////
    
    public Node getPrefix(Node n){
        if (n==null) return null;
        PreNodeList.enqueue(n);
        //PreNodeList.add(n);
        //if (n.getLeft()!=null) n.setLeft(getPrefix(n.getLeft()));
        //if (n.getRight()!=null) n.setRight(getPrefix(n.getRight()));
        n.setLeft(getPrefix(n.getLeft()));
        n.setRight(getPrefix(n.getRight()));
        return n;
    }
    
    
    public Node getPostfix(Node n){
        if (n==null) return null;
        PostNodeList.push(n);
        if (n.getRight()!=null) n.setRight(getPostfix(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getPostfix(n.getLeft()));
        return n;       
    }
    
    
    public Node getEVA(Node n){
        if (n==null) return null;
        EVA.push(n);
        if (n.getRight()!=null) n.setRight(getEVA(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getEVA(n.getLeft()));
        return n;
    }
    
    private String calValue(String n1,String n2, String op){
        double N1 = Double.parseDouble(n1);
        double N2 = Double.parseDouble(n2);
        if (op.equals(""+"")) return Double.toString(N1+N2);
        else if (op.equals(""-""))return Double.toString(N1-N2);
        else if (op.equals(""*""))return Double.toString(N1*N2);
        else return Double.toString(N1/N2);
    }
    
    public Node BuildTree(Node x,Integer LI,Integer Mid,Integer RI,String[] aList){
        String Temp = x.getValue();
        if (!Temp.equals(""+"") && !Temp.equals(""-"") && !Temp.equals(""*"") && !Temp.equals(""/"")) return x;
                
        if (!aList[Mid-1].equals("")"")){
            Node N = new Node(null,null,aList[Mid-1]);
            x.setLeft(BuildTree(N,LI,Mid-1,Mid,aList));
        }
        else if (aList[Mid-1].equals("")"")){
            Integer Rbracket = 0;
            Integer Lbracket = 0;
        
            for (int i=Mid-1;i>=LI;i--){
                String O =aList[i];
                if ((O.equals(""+"") || O.equals(""-"") || O.equals(""*"") || O.equals(""/"")) && Rbracket-Lbracket==1){
                    Node N =new Node(null,null,O);
                    x.setLeft(BuildTree(N,LI,i,Mid,aList));
                    break;
                }
                if (O.equals(""("")) Lbracket++;
                else if (O.equals("")"")) Rbracket++;
            }
        }
        
        if (!aList[Mid+1].equals(""("")){
            Node N = new Node(null,null,aList[Mid+1]);
            x.setRight(BuildTree(N,Mid,Mid+1,RI,aList));
        }
        else if (aList[Mid+1].equals(""("")){
            Integer Rbracket2 = 0;
            Integer Lbracket2 = 0;
        
            for (int i=Mid+1;i<=RI;i++){
                String O =aList[i];
                if ((O.equals(""+"") || O.equals(""-"") || O.equals(""*"") || O.equals(""/"")) && Lbracket2-Rbracket2==1){
                    Node N =new Node(null,null,O);
                    x.setRight(BuildTree(N,Mid,i,RI,aList));
                    break;
                }
                if (O.equals(""("")) Lbracket2++;
                else if (O.equals("")"")) Rbracket2++;
            }
        }
        return x;
    }
    /*
    public static void main(String[] args) {
        
    }
    */
}

    


@f42cfaf3b8df21a1f5ebe87bd7e51728@"
"r03945012","9","1","105824","@af211815415c93c31466f2b237cb4d62@
import java.util.ArrayList;

/**
 * 1042 PDSA hw09_Expression
 *
 * @author Robert
 */
public class Expression {

    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;

    // DO NOT MODIFY THIS

    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        // initize root
        root = null;
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++) {
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++) {
                if (string.charAt(i) == operator.get(j)) {
                    isoperater = true;
                    if (n != 0) {
                        data.add(string.substring(i - n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i + 1));
                }
            }
            if (isoperater == false) {
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

//        for(String s : dataArr)
//            System.out.println(s);
        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");

        // Node 2 tmp: a, b

        Stack<String> s = new Stack<String>();
        Stack<Node> tmpStack = new Stack<Node>();

        for (int i = 0; i < dataArr.length; i++) {
            if ("")"".equals(dataArr[i])) {
                Node tmp1 = tmpStack.pop();
                Node tmp2 = tmpStack.pop();
                String operat = s.pop();
                Node tmp = new Node(tmp2, tmp1, operat);
                tmpStack.push(tmp);
                root = tmp;
            } else if (op.contains(dataArr[i])) {
                s.push(dataArr[i]);
            } else if (""("".equals(dataArr[i])) {
            } else {
                Node tmp = new Node(null, null, dataArr[i]);
                tmpStack.push(tmp);
            }
        }
        return (root);
    }

    public Node[] PrintPrefix() {
        prefix_answer = new ArrayList<>();
        preOrder(root);
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }

    private void preOrder(Node a) {
        if (a != null) {
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }

    public Node[] PrintPostfix() {
        postfix_answer = new ArrayList<>();
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a) {
        if (a != null) {
            postOrder(a.getLeft());
            postOrder(a.getRight());
            postfix_answer.add(a);
        }
    }

    public double Evaluation() {
        double answer = 0;
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i = 0; i < data.length; i++) {
            s.push(data[i]);
            if ("")"".equals(s.peek())) {
                for (int j = 0; j < 5; j++) {
                    tmp[j] = s.pop();
                }
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]) {
                    case ""+"":
                        answer = num1 + num2;
                        break;
                    case ""-"":
                        answer = num1 - num2;
                        break;
                    case ""*"":
                        answer = num1 * num2;
                        break;
                    case ""/"":
                        answer = num1 / num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return (answer);
    }

    // testing
    public static void main(String[] args) {
//        String a = ""(4+(((4*2)/2)/3))"";
//        String b = ""(60*(((4*2)/2)*3))"";
        String a = ""(4+(((4*2)/2)/3))"";
        String c = ""(((2+3)/(4+5))+((2+3)+(4+5)))"";
        Expression cct = new Expression();
        Node result = cct.Infix2BT(a);
        Node[] test = cct.PrintPostfix();

        result = cct.Infix2BT(c);

        Node[] test2 = cct.PrintPostfix();
        StdOut.println(test[0].getValue());
        StdOut.println(test[1].getValue());
        StdOut.println(test[2].getValue());
        StdOut.println(test[3].getValue());
        StdOut.println(test[4].getValue());
        StdOut.println(test[5].getValue());
        StdOut.println(test[6].getValue());
        StdOut.println(test[7].getValue());

        
//        StdOut.println(test2[0].getValue());
//        StdOut.println(test2[1].getValue());
//        StdOut.println(test2[2].getValue());
//        StdOut.println(test2[3].getValue());
//        StdOut.println(test2[4].getValue());
//        StdOut.println(result.getValue());
//        StdOut.println(result.getLeft().getValue());
//        StdOut.println(result.getRight().getValue());
//        StdOut.println(result.getLeft().getLeft().getValue());
//        StdOut.println(result.getRight().getRight().getValue());

    }

}

@af211815415c93c31466f2b237cb4d62@"
"r04631025","10","0.096","105536","@cb8c302f1365b82cdcfb11d101a33e54@
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '-':
                case '+':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
            }
        }
         
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPrefixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    
    public void PrintPrefixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPrefixRecusive(p, root.getLeft());
        PrintPrefixRecusive(p, root.getRight());
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> postfix = new ArrayList<Node>();
        PrintPostfixRecusive(postfix, root);
        return postfix.toArray(new Node[postfix.size()]);
    }
    public void PrintPostfixRecusive(List<Node> p, Node root){
        if(root==null) return;
        
        PrintPostfixRecusive(p, root.getLeft());
        PrintPostfixRecusive(p, root.getRight());
        p.add(root);
//        p.add(root);
    }
    

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] eva = this.PrintPostfix();
        Stack<Double> evalue = new Stack<Double>();
        for(Node n:eva){
            String in = n.getValue();
            if(in.equals(""+"")){
                evalue.push(evalue.pop()+evalue.pop());
            } else if(in.equals(""-"")){
                evalue.push(-evalue.pop()+evalue.pop());
            } else if(in.equals(""*"")){
                evalue.push(evalue.pop()*evalue.pop());
            } else if(in.equals(""/"")){
                evalue.push(1/evalue.pop()*evalue.pop());
            } else {
                evalue.push(Double.parseDouble(in));
            }
            
        }
        return evalue.pop();
    }
}

@cb8c302f1365b82cdcfb11d101a33e54@"
"r03945012","9","0.96","105840","@2b26d048b5174a713ff1498fa4c974c6@
import java.util.ArrayList;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw09_Expression
 *
 * @author Robert
 */
public class Expression {

    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;

    // DO NOT MODIFY THIS

    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        // initize root
        root = null;
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++) {
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++) {
                if (string.charAt(i) == operator.get(j)) {
                    isoperater = true;
                    if (n != 0) {
                        data.add(string.substring(i - n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i + 1));
                }
            }
            if (isoperater == false) {
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

//        for(String s : dataArr)
//            System.out.println(s);
        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");

        // Node 2 tmp: a, b

        Stack<String> s = new Stack<String>();
        Stack<Node> tmpStack = new Stack<Node>();

        for (int i = 0; i < dataArr.length; i++) {
            if ("")"".equals(dataArr[i]) && ""("".equals(dataArr[i-1])){
                throw new NoSuchElementException();
            }
            else if ("")"".equals(dataArr[i])) {
                Node tmp1 = tmpStack.pop();
                Node tmp2 = tmpStack.pop();
                String operat = s.pop();
                Node tmp = new Node(tmp2, tmp1, operat);
                tmpStack.push(tmp);
                root = tmp;
            } else if (op.contains(dataArr[i])) {
                s.push(dataArr[i]);
            } else if (""("".equals(dataArr[i])) {
            } else {
                Node tmp = new Node(null, null, dataArr[i]);
                tmpStack.push(tmp);
            }
        }
        return (root);
    }

    public Node[] PrintPrefix() {
        prefix_answer = new ArrayList<>();
        preOrder(root);
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }

    private void preOrder(Node a) {
        if (a != null) {
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }

    public Node[] PrintPostfix() {
        postfix_answer = new ArrayList<>();
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a) {
        if (a != null) {
            postOrder(a.getLeft());
            postOrder(a.getRight());
            postfix_answer.add(a);
        }
    }

    public double Evaluation() {
        double answer = 0;
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i = 0; i < data.length; i++) {
            s.push(data[i]);
            if ("")"".equals(s.peek())) {
                for (int j = 0; j < 5; j++) {
                    tmp[j] = s.pop();
                }
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]) {
                    case ""+"":
                        answer = num1 + num2;
                        break;
                    case ""-"":
                        answer = num1 - num2;
                        break;
                    case ""*"":
                        answer = num1 * num2;
                        break;
                    case ""/"":
                        answer = num1 / num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return (answer);
    }

    // testing
    public static void main(String[] args) {
//        String a = ""(4+(((4*2)/2)/3))"";
//        String b = ""(60*(((4*2)/2)*3))"";
        String a = ""()"";
        String c = ""(((2+3)/(4+5))+((2+3)+(4+5)))"";
        Expression cct = new Expression();
        Node result = cct.Infix2BT(a);
        Node[] test = cct.PrintPostfix();

        result = cct.Infix2BT(c);

//        Node[] test2 = cct.PrintPostfix();
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
//        StdOut.println(test[2].getValue());
//        StdOut.println(test[3].getValue());
//        StdOut.println(test[4].getValue());
//        StdOut.println(test[5].getValue());
//        StdOut.println(test[6].getValue());
//        StdOut.println(test[7].getValue());

        
//        StdOut.println(test2[0].getValue());
//        StdOut.println(test2[1].getValue());
//        StdOut.println(test2[2].getValue());
//        StdOut.println(test2[3].getValue());
//        StdOut.println(test2[4].getValue());
//        StdOut.println(result.getValue());
//        StdOut.println(result.getLeft().getValue());
//        StdOut.println(result.getRight().getValue());
//        StdOut.println(result.getLeft().getLeft().getValue());
//        StdOut.println(result.getRight().getRight().getValue());

    }

}

@2b26d048b5174a713ff1498fa4c974c6@"
"r04631009","2","0.27","105040","@9e045ff43fe973381ed8dc5de7059fb3@
public class Expression {

    private Node root;
    private int num;

    // DO NOT MODIFY THIS

    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        String[] stringarray = infix.split("""");
        num = stringarray.length;
        Stack<Node> data = new Stack<Node>();
        for (int i = 0; i < num; i++) {
            if (stringarray[i].equals("")"")) {
                Node[] temp = new Node[4];
                int tempi = 0;
                while (tempi < 4) {
                    temp[tempi] = data.pop();
                    tempi++;
                }
                temp[1].setLeft(temp[2]);
                temp[1].setRight(temp[0]);
                root = temp[1];
                data.push(root);
            } else {
                Node temp = new Node(null, null, stringarray[i]);
                data.push(temp);
            }
        }
        return root;
    }

    public Node[] PrintPrefix() {
        Node[] prefix = new Node[num];
        int i = 0;
        PrintPrefix(prefix, root, i);
        return prefix;
    }

    private void PrintPrefix(Node[] prefix, Node root, int i) {
        Node x = root, L = x.getLeft(), R = x.getRight();
        prefix[i] = x;
        if (L != null) {
            PrintPrefix(prefix, root, i++);
        }
    }

    public Node[] PrintPostfix() {
        Node[] postfix = null;
        return postfix;
    }

    public double Evaluation() {
        double answer = 0;
        Node sign = root;
        answer = Evaluation(sign);
        return answer;
    }

    private double Evaluation(Node sign) {
        double ans = 0;
        Node x = sign;
        Node L = x.getLeft(), R = x.getRight();
        if (L.getValue().equals(""+"") || L.getValue().equals(""-"") || L.getValue().equals(""*"") || L.getValue().equals(""/"")) {
            L = new Node(null, null, String.valueOf(Evaluation(L)));
        }
        if (R.getValue().equals(""+"") || R.getValue().equals(""-"") || R.getValue().equals(""*"") || R.getValue().equals(""/"")) {
            R = new Node(null, null, String.valueOf(Evaluation(R)));
        }
        if (x.getValue().equals(""+"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l + r;
        } else if (x.getValue().equals(""-"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l - r;
        } else if (x.getValue().equals(""*"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l * r;
        } else if (x.getValue().equals(""/"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l / r;
        }
        return ans;
    }

    public static void main(String[] args) {
        String input=""(4+(((4*2)/2)/3))"";
        //String input = ""(((1+(12*5))-(3*4))+(4/5))"";
        //String input=""(((4/5)+3)+(1/2))"";
        String[] stringarray = input.split("" "");
    //     for (int i=0 ; i<stringarray.length ; i++)
        //         System.out.print(stringarray[i]+""\t"");
        //     System.out.println();
        //     System.out.println(input);
        Expression calculation = new Expression();
        calculation.Infix2BT(input);
        System.out.println(calculation.root.getValue());
        System.out.println(calculation.root.getLeft().getValue());
        System.out.println(calculation.root.getRight().getValue());
     //System.out.println(calculation.root.getRight().getLeft().getValue());
        //System.out.println(calculation.root.getRight().getLeft().getLeft().getValue());
        //System.out.println(calculation.root.getRight().getLeft().getLeft().getLeft().getValue());
        //Node[] prefix=calculation.PrintPrefix();
        //for (int i=0 ; i<prefix.length ; i++)
        //System.out.print(prefix[i].getValue()+""\t"");
        System.out.println("""");
        System.out.println(calculation.Evaluation());

    }
}

@9e045ff43fe973381ed8dc5de7059fb3@"
"r03945012","9","1","105920","@1f6e466b497a8894fdca0904e3cd877e@
import java.util.ArrayList;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw09_Expression
 *
 * @author Robert
 */
public class Expression {

    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;

    // DO NOT MODIFY THIS

    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        // initize root
        root = null;
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++) {
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++) {
                if (string.charAt(i) == operator.get(j)) {
                    isoperater = true;
                    if (n != 0) {
                        data.add(string.substring(i - n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i + 1));
                }
            }
            if (isoperater == false) {
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

//        for(String s : dataArr)
//            System.out.println(s);
        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");

        // Node 2 tmp: a, b

        Stack<String> s = new Stack<String>();
        Stack<Node> tmpStack = new Stack<Node>();

        for (int i = 0; i < dataArr.length; i++) {
            if ("")"".equals(dataArr[i]) && ""("".equals(dataArr[i-1])){
                throw new NullPointerException();
            }
            else if ("")"".equals(dataArr[i])) {
                Node tmp1 = tmpStack.pop();
                Node tmp2 = tmpStack.pop();
                String operat = s.pop();
                Node tmp = new Node(tmp2, tmp1, operat);
                tmpStack.push(tmp);
                root = tmp;
            } else if (op.contains(dataArr[i])) {
                s.push(dataArr[i]);
            } else if (""("".equals(dataArr[i])) {
            } else {
                Node tmp = new Node(null, null, dataArr[i]);
                tmpStack.push(tmp);
            }
        }
        return (root);
    }

    public Node[] PrintPrefix() {
        prefix_answer = new ArrayList<>();
        preOrder(root);
        Node[] prefix = new Node[prefix_answer.size()];
        prefix = prefix_answer.toArray(prefix);
        return prefix;
    }

    private void preOrder(Node a) {
        if (a != null) {
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }

    public Node[] PrintPostfix() {
        postfix_answer = new ArrayList<>();
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
    }

    private void postOrder(Node a) {
        if (a != null) {
            postOrder(a.getLeft());
            postOrder(a.getRight());
            postfix_answer.add(a);
        }
    }

    public double Evaluation() {
        double answer = 0;
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i = 0; i < data.length; i++) {
            s.push(data[i]);
            if ("")"".equals(s.peek())) {
                for (int j = 0; j < 5; j++) {
                    tmp[j] = s.pop();
                }
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]) {
                    case ""+"":
                        answer = num1 + num2;
                        break;
                    case ""-"":
                        answer = num1 - num2;
                        break;
                    case ""*"":
                        answer = num1 * num2;
                        break;
                    case ""/"":
                        answer = num1 / num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return (answer);
    }

    // testing
    public static void main(String[] args) {
//        String a = ""(4+(((4*2)/2)/3))"";
//        String b = ""(60*(((4*2)/2)*3))"";
        String a = ""()"";
        String c = ""(((2+3)/(4+5))+((2+3)+(4+5)))"";
        Expression cct = new Expression();
        Node result = cct.Infix2BT(a);
        Node[] test = cct.PrintPostfix();

        result = cct.Infix2BT(c);

//        Node[] test2 = cct.PrintPostfix();
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
//        StdOut.println(test[2].getValue());
//        StdOut.println(test[3].getValue());
//        StdOut.println(test[4].getValue());
//        StdOut.println(test[5].getValue());
//        StdOut.println(test[6].getValue());
//        StdOut.println(test[7].getValue());

        
//        StdOut.println(test2[0].getValue());
//        StdOut.println(test2[1].getValue());
//        StdOut.println(test2[2].getValue());
//        StdOut.println(test2[3].getValue());
//        StdOut.println(test2[4].getValue());
//        StdOut.println(result.getValue());
//        StdOut.println(result.getLeft().getValue());
//        StdOut.println(result.getRight().getValue());
//        StdOut.println(result.getLeft().getLeft().getValue());
//        StdOut.println(result.getRight().getRight().getValue());

    }

}

@1f6e466b497a8894fdca0904e3cd877e@"
"r03522809","10","0.098","105872","@448371d1cc2872082770acd5f0a0b07b@
import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */
public class Expression{
  
    private Node root;
    private int N;
    Queue<Node> findmidqueue =new Queue<Node>();
    Queue<Node> findleftqueue =new Queue<Node>();
    Stack<String> findans =new Stack<String>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] Num = infix.split("""");
        Queue<String> numberqueue =new Queue<String>();
        int count =0;

        for(int i=1;i<Num.length;i++){
            
            if(Num[i].equals(""("")){
            numberqueue.enqueue(Num[i]);
            count =i;
            
            }else if( Num[i].equals("")"") || Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"") ){

                String S1 =""""; 
                for(int j=count+1;j<i;j++){
                    S1 = (S1+Num[j]).replace(""null"","""");
                }
                String  S2 = S1.replace(""null"","""");
                  
                  if( !( S2=="""" )){
//                    System.out.println(S1);
                      numberqueue.enqueue(S2);
                  }
                numberqueue.enqueue(Num[i]);
                count =i;
                
            }else{

            }
        }
//        System.out.println( numberqueue.size());
        String[] Num2 =new String[numberqueue.size()];
        for(int i=0;i<Num2.length;i++){
            Num2[i]=numberqueue.dequeue();
        }

        Stack<Node>  numsta =new Stack<Node> ();
        Stack optsta =new Stack();
        Stack<Node> nodesta =new Stack<Node>();
        int N = Num2.length;
        this.N=N;
        Node[] Infnode =new Node[N/2+1];
        int nodenum=0;

          for(int i=0;i<N;i++){
              
//              System.out.println( Num2[i]);
//              System.out.println( Num2[i].equals(""*""));
              if( Num2[i].equals(""+"") || Num2[i].equals(""-"") || Num2[i].equals(""*"") || Num2[i].equals(""/"")){
                  optsta.push(Num2[i]);
                  
               }else if( Num2[i].equals(""("")){

               }else if( Num2[i].equals("")"")){
                  if(Num2[i-1].equals(""("") )
                    {
                       throw new NullPointerException(""NullPointerException"");
                    }
                   Infnode[0]=numsta.pop();
                   Infnode[1]=numsta.pop();
                   numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
               }else{

                  numsta.push(new Node(null,null,Num2[i]));
              }
          }
          
        root=numsta.peek();
        this.root=root;
        
//        System.out.println(root.getValue());
        
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findmid(rootnode[0]);
        Node[] prefix = new Node[findmidqueue.size()];
        int n=0;
        while(!findmidqueue.isEmpty()){
           prefix[n]=findmidqueue.dequeue();
           n=n+1;
       }
        return prefix;
    }
    
        public Node findmid(Node x){
            findmidqueue.enqueue(x);
//            System.out.println(findmidqueue.peek().getValue()); 
            if( !(x.getLeft()==null) ){
                    findmid(x.getLeft());
            }
            if( !(x.getRight()==null) ){
                    findmid(x.getRight());
            }
        return x;
    }
  
    public Node[] PrintPostfix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        while(!findleftqueue.isEmpty()){
           postfix[n]=findleftqueue.dequeue();
           n=n+1;
       }
          postfix[n]=rootnode[0];
        return postfix;
    }
    
    public Node findleft(Node x){
           
            if( !(x.getLeft()==null) ){
                    findleft(x.getLeft());
                     findleftqueue.enqueue(x.getLeft());
//                    System.out.println(x.getLeft().getValue()); 
            }
            if( !(x.getRight()==null) ){
                    findleft(x.getRight());
                    findleftqueue.enqueue(x.getRight());
//                    System.out.println(x.getRight().getValue()); 
            }
        return x;
    }
    
    public double Evaluation(){
        
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        findleftqueue.enqueue( rootnode[0] );
        
//        while(!findleftqueue.isEmpty()){
//           postfix[n]=findleftqueue.dequeue();
//           System.out.println(postfix[n].getValue());
//           n=n+1;
//       }

        while( !findleftqueue.isEmpty() ){

            findans.push(findleftqueue.dequeue().getValue());
            if( findans.peek().equals(""+"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=a+b;
                String stringc = Double.toString(c);
                findans.push(stringc);
                
            }else if( findans.peek().equals(""-"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b-a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""*"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b*a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""/"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b/a;
                String stringc = Double.toString(c);
                findans.push(stringc);
            }
        }

        double answer =Double.parseDouble( findans.peek());
        return answer;
    
    }

    /**
     * @param args the command line arguments
     */

     public static void main(String[] args)throws Exception {
        Node[] rootnode = new Node[1];
        String problem =""(((0.235+0.88)*7.2)+(200+10))"";
        Expression build = new Expression();
        rootnode[0]=build.Infix2BT(problem);
        System.out.println(build.Evaluation());
//
//        
        for(int i=0;i<build.PrintPostfix().length;i++ ){
        System.out.println(build.PrintPostfix()[i].getValue());
        }

//        System.out.println(rootnode[0].getRight().getValue());

    }
}

@448371d1cc2872082770acd5f0a0b07b@"
"r04228002","1","0.98","105904","@ad50337e7d8fc9ab9ea9286658ee918f@
import java.util.Arrays;
import java.util.ArrayList;
import java.util.NoSuchElementException;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */


/**
 *
 * @author Lenovo
 */
public class Expression{
  
    private Node root;
    //private Node Rroot;
    //private Node Newroot;
    //private Integer Rbracket = 0;
    //private Integer Lbracket = 0;
    
    private Queue<Node> PreNodeList = new Queue<Node>();
    //private ArrayList<Node> PreNodeList = new ArrayList<Node>();
    private Stack<Node> PostNodeList = new Stack<Node>();
    private Stack<Node> EVA =new Stack<Node>();
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        if (infix.equals("""")) {root=null; return root;}
        root = null;
        
        String[] I = infix.split(""((?<=\\+|\\-|\\*|\\/|\\(|\\))|(?=\\+|\\-|\\*|\\/|\\(|\\)))"");
        Integer len = I.length-1;
        String[] S1 = new String[len];
        for (int i=0;i<len;i++){ 
            S1[i]=I[i+1];
        }
        
        if (len==3) {
            root=new Node(null,null,S1[1]);
            return root;
        }
        
        String Index2 = S1[2];
        String IndexLast2 = S1[len-3];
        if (Index2.equals(""+"")||Index2.equals(""-"")||Index2.equals(""*"")||Index2.equals(""/"")){
            root = new Node(null,null,Index2);
            root = BuildTree(root,0,2,len,S1);
        }
        else if (IndexLast2.equals(""+"")||IndexLast2.equals(""-"")||IndexLast2.equals(""*"")||IndexLast2.equals(""/"")){
            root = new Node(null,null,IndexLast2);
            root = BuildTree(root,0,len-3,len,S1);
        }
        else{
            Integer Rbracket = 0;
            Integer Lbracket = 0;
            for (int i=0;i<len;i++){
                String O = S1[i];
                if ((O.equals(""+"") || O.equals(""-"") || O.equals(""*"") || O.equals(""/"")) && Lbracket-Rbracket==1){
                    root = new Node(null,null,O);
                    root = BuildTree(root,0,i,len,S1);
                    break;
                }
                if (O.equals(""("")) Lbracket++;
                else if (O.equals("")"")) Rbracket++;
            }
        }
        return root;
    }
        ////////////////////////////////////////////////////////////////////////
        
            
           
            
            
////////////////////////////////////////////////////////////////////////////////
    public Node[] PrintPrefix(){
        if (root==null) throw new NullPointerException();
        root = getPrefix(root);
        //Node[] prefix = PreNodeList.toArray(new Node[PreNodeList.size()]);
        Integer size1 = PreNodeList.size();
        Node[] prefix = new Node[size1];
        for (int i=0;i<size1;i++){
            prefix[i]=PreNodeList.dequeue();
        }
        
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if (root==null) throw new NullPointerException();
        root = getPostfix(root);
        Integer size2 = PostNodeList.size();
        Node[] postfix = new Node[size2];
        for (int i=0;i<size2;i++){
            postfix[i]=PostNodeList.pop();
        }
        return postfix;
    }

    public double Evaluation(){
        if (root==null) throw new NullPointerException();
        Stack<Node> Temp = new Stack<Node>();
        root = getEVA(root);
        while (EVA.size() > 1){
            Node N1 = EVA.pop();
            Node N2 = EVA.pop();
            Node OP = EVA.pop();
            String OPV = OP.getValue();
            while (!OPV.equals(""+"") && !OPV.equals(""-"") && !OPV.equals(""*"") && !OPV.equals(""/"")){
                Temp.push(N1);
                N1=N2;
                N2=OP;
                OP=EVA.pop();
                OPV=OP.getValue();
            }
            Node TempNode = new Node(null,null,calValue(N1.getValue(),N2.getValue(),OP.getValue()));
            EVA.push(TempNode);
            while(Temp.size()!=0){
                EVA.push(Temp.pop());
            }
        }
        String a1 = EVA.pop().getValue();
        double answer = Double.parseDouble(a1);
        
        return answer;
    }
    ////////////////////////////////////////////////////////////////////////
    
    private Node getPrefix(Node n){
        if (n==null) return null;
        PreNodeList.enqueue(n);
        //PreNodeList.add(n);
        //if (n.getLeft()!=null) n.setLeft(getPrefix(n.getLeft()));
        //if (n.getRight()!=null) n.setRight(getPrefix(n.getRight()));
        n.setLeft(getPrefix(n.getLeft()));
        n.setRight(getPrefix(n.getRight()));
        return n;
    }
    
    
    private Node getPostfix(Node n){
        if (n==null) return null;
        PostNodeList.push(n);
        if (n.getRight()!=null) n.setRight(getPostfix(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getPostfix(n.getLeft()));
        return n;       
    }
    
    
    private Node getEVA(Node n){
        if (n==null) return null;
        EVA.push(n);
        if (n.getRight()!=null) n.setRight(getEVA(n.getRight()));
        if (n.getLeft()!=null) n.setLeft(getEVA(n.getLeft()));
        return n;
    }
    
    private String calValue(String n1,String n2, String op){
        double N1 = Double.parseDouble(n1);
        double N2 = Double.parseDouble(n2);
        if (op.equals(""+"")) return Double.toString(N1+N2);
        else if (op.equals(""-""))return Double.toString(N1-N2);
        else if (op.equals(""*""))return Double.toString(N1*N2);
        else return Double.toString(N1/N2);
    }
    
    private Node BuildTree(Node x,Integer LI,Integer Mid,Integer RI,String[] aList){
        String Temp = x.getValue();
        if (!Temp.equals(""+"") && !Temp.equals(""-"") && !Temp.equals(""*"") && !Temp.equals(""/"")) return x;
                
        if (!aList[Mid-1].equals("")"")){
            Node N = new Node(null,null,aList[Mid-1]);
            x.setLeft(BuildTree(N,LI,Mid-1,Mid,aList));
        }
        else if (aList[Mid-1].equals("")"")){
            Integer Rbracket = 0;
            Integer Lbracket = 0;
        
            for (int i=Mid-1;i>=LI;i--){
                String O =aList[i];
                if ((O.equals(""+"") || O.equals(""-"") || O.equals(""*"") || O.equals(""/"")) && Rbracket-Lbracket==1){
                    Node N =new Node(null,null,O);
                    x.setLeft(BuildTree(N,LI,i,Mid,aList));
                    break;
                }
                if (O.equals(""("")) Lbracket++;
                else if (O.equals("")"")) Rbracket++;
            }
        }
        
        if (!aList[Mid+1].equals(""("")){
            Node N = new Node(null,null,aList[Mid+1]);
            x.setRight(BuildTree(N,Mid,Mid+1,RI,aList));
        }
        else if (aList[Mid+1].equals(""("")){
            Integer Rbracket2 = 0;
            Integer Lbracket2 = 0;
        
            for (int i=Mid+1;i<=RI;i++){
                String O =aList[i];
                if ((O.equals(""+"") || O.equals(""-"") || O.equals(""*"") || O.equals(""/"")) && Lbracket2-Rbracket2==1){
                    Node N =new Node(null,null,O);
                    x.setRight(BuildTree(N,Mid,i,RI,aList));
                    break;
                }
                if (O.equals(""("")) Lbracket2++;
                else if (O.equals("")"")) Rbracket2++;
            }
        }
        return x;
    }
    /*
    public static void main(String[] args) {
        
    }
    */
}

    


@ad50337e7d8fc9ab9ea9286658ee918f@"
"r03945012","10","0.095","105856","@a048288e78db98c1f41b4af2b3b7789c@
import java.util.ArrayList;
import java.util.NoSuchElementException;

/**
 * 1042 PDSA hw09_Expression
 *
 * @author Robert
 */
public class Expression {

    private Node root;
    private ArrayList<Node> prefix_answer = null;
    private ArrayList<Node> postfix_answer = null;
    private String[] dataArr;

    // DO NOT MODIFY THIS

    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        // initize root
        root = null;
        String string = infix;
        // operator as +-*/()
        ArrayList<Character> operator = new ArrayList<>();
        operator.add('+');
        operator.add('-');
        operator.add('*');
        operator.add('/');
        operator.add('(');
        operator.add(')');
        ArrayList<String> data = new ArrayList<>();
        int n = 0;
        for (int i = 0; i < string.length(); i++) {
            boolean isoperater = false;
            for (int j = 0; j < operator.size(); j++) {
                if (string.charAt(i) == operator.get(j)) {
                    isoperater = true;
                    if (n != 0) {
                        data.add(string.substring(i - n, i));
                        n = 0;
                    }
                    data.add(string.substring(i, i + 1));
                }
            }
            if (isoperater == false) {
                n++;
            }
        }
        // dataArr (infix)
        dataArr = new String[data.size()];
        dataArr = data.toArray(dataArr);

//        for(String s : dataArr)
//            System.out.println(s);
        // set op as operator
        ArrayList<String> op = new ArrayList<>();
        op.add(""+"");
        op.add(""-"");
        op.add(""*"");
        op.add(""/"");

        // Node 2 tmp: a, b

        Stack<String> s = new Stack<String>();
        Stack<Node> tmpStack = new Stack<Node>();

        for (int i = 0; i < dataArr.length; i++) {
            if ("")"".equals(dataArr[i]) && ""("".equals(dataArr[i-1])){
                throw new NullPointerException();
            }
            else if ("")"".equals(dataArr[i])) {
                Node tmp1 = tmpStack.pop();
                Node tmp2 = tmpStack.pop();
                String operat = s.pop();
                Node tmp = new Node(tmp2, tmp1, operat);
                tmpStack.push(tmp);
                root = tmp;
            } else if (op.contains(dataArr[i])) {
                s.push(dataArr[i]);
            } else if (""("".equals(dataArr[i])) {
            } else {
                Node tmp = new Node(null, null, dataArr[i]);
                tmpStack.push(tmp);
            }
        }
        return (root);
    }

    public Node[] PrintPrefix() {
        if (root == null){
            throw new NullPointerException();
        }
        else{
            prefix_answer = new ArrayList<>();
            preOrder(root);
            Node[] prefix = new Node[prefix_answer.size()];
            prefix = prefix_answer.toArray(prefix);
            return prefix;
        }
    }

    private void preOrder(Node a) {
        if (a != null) {
            prefix_answer.add(a);
            preOrder(a.getLeft());
            preOrder(a.getRight());
        }
    }

    public Node[] PrintPostfix() {
        if (root == null){
            throw new NullPointerException();
        }
        else{
        postfix_answer = new ArrayList<>();
        postOrder(root);
        Node[] postfix = new Node[postfix_answer.size()];
        postfix = postfix_answer.toArray(postfix);
        return postfix;
        }
    }

    private void postOrder(Node a) {
        if (a != null) {
            postOrder(a.getLeft());
            postOrder(a.getRight());
            postfix_answer.add(a);
        }
    }

    public double Evaluation() {
        double answer = 0;
        // hw03_Calculator
        // Calculator
        String[] data = dataArr;
        String[] tmp = new String[5];
        Stack<String> s = new Stack<String>();
        for (int i = 0; i < data.length; i++) {
            s.push(data[i]);
            if ("")"".equals(s.peek())) {
                for (int j = 0; j < 5; j++) {
                    tmp[j] = s.pop();
                }
                double num1 = Double.parseDouble(tmp[3]);
                double num2 = Double.parseDouble(tmp[1]);
                switch (tmp[2]) {
                    case ""+"":
                        answer = num1 + num2;
                        break;
                    case ""-"":
                        answer = num1 - num2;
                        break;
                    case ""*"":
                        answer = num1 * num2;
                        break;
                    case ""/"":
                        answer = num1 / num2;
                        break;
                }
                s.push(String.valueOf(answer));
            }
        }
        return (answer);
    }

    // testing
    public static void main(String[] args) {
//        String a = ""(4+(((4*2)/2)/3))"";
//        String b = ""(60*(((4*2)/2)*3))"";
        String a = ""()"";
        String c = ""(((2+3)/(4+5))+((2+3)+(4+5)))"";
        Expression cct = new Expression();
//        Node result = cct.Infix2BT(a);
        
        Node[] test = cct.PrintPrefix();
//        result = cct.Infix2BT(c);
//        StdOut.println(cct.root);
//        StdOut.println(cct.Evaluation());
//        Node[] test2 = cct.PrintPostfix();
//        StdOut.println(test[0].getValue());
//        StdOut.println(test[1].getValue());
//        StdOut.println(test[2].getValue());
//        StdOut.println(test[3].getValue());
//        StdOut.println(test[4].getValue());
//        StdOut.println(test[5].getValue());
//        StdOut.println(test[6].getValue());
//        StdOut.println(test[7].getValue());

        
//        StdOut.println(test2[0].getValue());
//        StdOut.println(test2[1].getValue());
//        StdOut.println(test2[2].getValue());
//        StdOut.println(test2[3].getValue());
//        StdOut.println(test2[4].getValue());
//        StdOut.println(result.getValue());
//        StdOut.println(result.getLeft().getValue());
//        StdOut.println(result.getRight().getValue());
//        StdOut.println(result.getLeft().getLeft().getValue());
//        StdOut.println(result.getRight().getRight().getValue());

    }

}

@a048288e78db98c1f41b4af2b3b7789c@"
"b03611038","0","0.098","105872","@d485ffe83c74468b7291af05624daab8@public class Expression{
  
    private Node root;
    private int size;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        
        int len = infix.length();
        Stack<String> ops = new Stack<>();
        Stack<String> val = new Stack<>();
        Stack<Node> im = new Stack<>();
        root = null;
        for(int i = 0;i<len;i++){
            
            String temp = infix.substring(i, i+1);
            if(temp.equals(""("")) ;
            else if(temp.equals(""+"")) ops.push(temp);
            else if(temp.equals(""-"")) ops.push(temp);
            else if(temp.equals(""*"")) ops.push(temp);
            else if(temp.equals(""/"")) ops.push(temp);
           
            else if(temp.equals("")"")) {
                if(ops.isEmpty()){
                    if(val.isEmpty()){
                        root = null;
                        break;
                    }
                 String cc = val.pop();
                 Node b = new Node(null,null, cc);
                 root = b;
                 size = 1;
                 break;        
                }
                String op = ops.pop();
                if(root==null){
                    Node c = new Node(null,null,val.pop()); size++;
                    Node a = new Node(null,null,val.pop()); size++;
                    Node b = new Node(a,c,op);  
                    size++;
                    root = b;
                    val.push(root.getValue());
                }
                else{
                    String cc = val.pop();
                    String aa = val.pop();
                    if(this.find(aa)==true && this.find(cc)==true){
                        root.setValue(op);
                        val.push(root.getValue());
                    }
                    else if(this.find(cc)){
                        Node a = new Node(null,null,aa); size++;
                        Node b = new Node(a,root,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else if(this.find(aa)){
                        Node c = new Node(null,null,cc); size++;
                        Node b = new Node(root,c,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else{
                       Node c = new Node(null,null,cc); size++;
                       Node a = new Node(null,null,aa); size++;
                       Node b = new Node(a,c,op); size++;
                       val.push(b.getValue());
                       Node d = new Node(root,b,null); size++;
                       root = d;
                    }
                }               
            }                
            else{
                  int j = i+1;
                  String wa = infix.substring(j, j+1);
                  while(this.find(wa)!=true){
                      j++;
                      wa = infix.substring(j, j+1);
                  }
                  wa = infix.substring(i, j);
                  i = j-1;
                  val.push(wa);
                    }
        }
       
        return root;
    }

    public Node[] PrintPrefix(){
         if(root ==null) throw new NullPointerException();
         
        Node[] prefix = new Node[size];
        this.pre(root, prefix, 0);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root ==null) throw new NullPointerException();
        
        Node[] postfix = new Node[size];
        this.post(root, postfix, 0);       
        return postfix;
    }
    
    public double Evaluation(){
         if(root ==null) throw new NullPointerException();
        double answer ;
        Node[] po = this.PrintPostfix();
        Stack<Double> ans = new Stack<>();
        for(int i = 0;i<size;i++){
            if(po[i].getValue().equals(""+"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a+b);
            }
            else  if(po[i].getValue().equals(""-"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a-b);
            }
            else  if(po[i].getValue().equals(""*"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a*b);
            }
            else  if(po[i].getValue().equals(""/"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a/b);
            }
            else{
                double a = Double.parseDouble(po[i].getValue());
                ans.push(a);
            }
        }
        answer = ans.pop();
        return answer;
    }
    
    public boolean find(String a){
        if(a.equals(""+"") || a.equals(""-"") || a.equals(""*"")
                || a.equals(""/"") || a.equals("")""))
        return true;
        else return false;
    }
    
   public int getsize(){
       return size;
   }
   public int pre(Node a, Node[] b, int i){
       b[i] = a;
       i++;
       if(a.getLeft()!=null)
           i = this.pre(a.getLeft(), b, i);
       if(a.getRight()!=null)
           i = this.pre(a.getRight(), b, i);
       return i;
   }
   public int post(Node a, Node[] b, int i){
        if(a.getLeft()!=null)
          i =this.post(a.getLeft(), b, i);          
        if(a.getRight()!=null)
          i =this.post(a.getRight(), b, i);           
       b[i] = a;
       i+;          
      return i;
   }
}

@d485ffe83c74468b7291af05624daab8@"
"b03611038","3","0.76","105248","@65f16c759c6264a3cfa7c7023f366ff3@public class Expression{
  
    private Node root;
    private int size;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        
        int len = infix.length();
        Stack<String> ops = new Stack<>();
        Stack<String> val = new Stack<>();
        Stack<Node> im = new Stack<>();
        root = null;
        for(int i = 0;i<len;i++){
            
            String temp = infix.substring(i, i+1);
            if(temp.equals(""("")) ;
            else if(temp.equals(""+"")) ops.push(temp);
            else if(temp.equals(""-"")) ops.push(temp);
            else if(temp.equals(""*"")) ops.push(temp);
            else if(temp.equals(""/"")) ops.push(temp);
           
            else if(temp.equals("")"")) {
                if(ops.isEmpty()){
                    if(val.isEmpty()){
                        root = null;
                        break;
                    }
                 String cc = val.pop();
                 Node b = new Node(null,null, cc);
                 root = b;
                 size = 1;
                 break;        
                }
                String op = ops.pop();
                if(root==null){
                    Node c = new Node(null,null,val.pop()); size++;
                    Node a = new Node(null,null,val.pop()); size++;
                    Node b = new Node(a,c,op);  
                    size++;
                    root = b;
                    val.push(root.getValue());
                }
                else{
                    String cc = val.pop();
                    String aa = val.pop();
                    if(this.find(aa)==true && this.find(cc)==true){
                        root.setValue(op);
                        val.push(root.getValue());
                    }
                    else if(this.find(cc)){
                        Node a = new Node(null,null,aa); size++;
                        Node b = new Node(a,root,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else if(this.find(aa)){
                        Node c = new Node(null,null,cc); size++;
                        Node b = new Node(root,c,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else{
                       Node c = new Node(null,null,cc); size++;
                       Node a = new Node(null,null,aa); size++;
                       Node b = new Node(a,c,op); size++;
                       val.push(b.getValue());
                       Node d = new Node(root,b,null); size++;
                       root = d;
                    }
                }               
            }                
            else{
                  int j = i+2;
                  String wa = infix.substring(j, j+1);
                  while(this.find(wa)!=true){
                      j++;
                      wa = infix.substring(j, j+1);
                  }
                  wa = infix.substring(i, j);
                  i = j-1;
                  val.push(wa);
                    }
        }
       
        return root;
    }

    public Node[] PrintPrefix(){
         if(root ==null) throw new NullPointerException();
         
        Node[] prefix = new Node[size];
        this.pre(root, prefix, 0);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root ==null) throw new NullPointerException();
        
        Node[] postfix = new Node[size];
        this.post(root, postfix, 0);       
        return postfix;
    }
    
    public double Evaluation(){
         if(root ==null) throw new NullPointerException();
        double answer ;
        Node[] po = this.PrintPostfix();
        Stack<Double> ans = new Stack<>();
        for(int i = 0;i<size;i++){
            if(po[i].getValue().equals(""+"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a+b);
            }
            else  if(po[i].getValue().equals(""-"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a-b);
            }
            else  if(po[i].getValue().equals(""*"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a*b);
            }
            else  if(po[i].getValue().equals(""/"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a/b);
            }
            else{
                double a = Double.parseDouble(po[i].getValue());
                ans.push(a);
            }
        }
        answer = ans.pop();
        return answer;
    }
    
    public boolean find(String a){
        if(a.equals(""+"") || a.equals(""-"") || a.equals(""*"")
                || a.equals(""/"") || a.equals("")""))
        return true;
        else return false;
    }
    
   public int getsize(){
       return size;
   }
   public int pre(Node a, Node[] b, int i){
       b[i] = a;
       i++;
       if(a.getLeft()!=null)
           i = this.pre(a.getLeft(), b, i);
       if(a.getRight()!=null)
           i = this.pre(a.getRight(), b, i);
       return i;
   }
   public int post(Node a, Node[] b, int i){
        if(a.getLeft()!=null)
          i =this.post(a.getLeft(), b, i);          
        if(a.getRight()!=null)
          i =this.post(a.getRight(), b, i);           
       b[i] = a;
       i++;          
      return i;
   }
}

@65f16c759c6264a3cfa7c7023f366ff3@"
"b03611038","10","0.098","105824","@1ff7397c528a41543fd476831ae21f2f@public class Expression{
  
    private Node root;
    private int size;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        
        int len = infix.length();
        Stack<String> ops = new Stack<>();
        Stack<String> val = new Stack<>();
        Stack<Node> im = new Stack<>();
        root = null;
        for(int i = 0;i<len;i++){
            
            String temp = infix.substring(i, i+1);
            if(temp.equals(""("")) ;
            else if(temp.equals(""+"")) ops.push(temp);
            else if(temp.equals(""-"")) ops.push(temp);
            else if(temp.equals(""*"")) ops.push(temp);
            else if(temp.equals(""/"")) ops.push(temp);
           
            else if(temp.equals("")"")) {
                if(ops.isEmpty()){
                    if(val.isEmpty()){
                        root = null;
                        break;
                    }
                 String cc = val.pop();
                 Node b = new Node(null,null, cc);
                 root = b;
                 size = 1;
                 break;        
                }
                String op = ops.pop();
                if(root==null){
                    Node c = new Node(null,null,val.pop()); size++;
                    Node a = new Node(null,null,val.pop()); size++;
                    Node b = new Node(a,c,op);  
                    size++;
                    root = b;
                    val.push(root.getValue());
                }
                else{
                    String cc = val.pop();
                    String aa = val.pop();
                    if(this.find(aa)==true && this.find(cc)==true){
                        root.setValue(op);
                        val.push(root.getValue());
                    }
                    else if(this.find(cc)){
                        Node a = new Node(null,null,aa); size++;
                        Node b = new Node(a,root,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else if(this.find(aa)){
                        Node c = new Node(null,null,cc); size++;
                        Node b = new Node(root,c,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else{
                       Node c = new Node(null,null,cc); size++;
                       Node a = new Node(null,null,aa); size++;
                       Node b = new Node(a,c,op); size++;
                       val.push(b.getValue());
                       Node d = new Node(root,b,null); size++;
                       root = d;
                    }
                }               
            }                
            else{
                  int j = i+1;
                  String wa = infix.substring(j, j+1);
                  while(this.find(wa)!=true){
                      j++;
                      wa = infix.substring(j, j+1);
                  }
                  wa = infix.substring(i, j);
                  i = j-1;
                  val.push(wa);
                    }
        }
       
        return root;
    }

    public Node[] PrintPrefix(){
         if(root ==null) throw new NullPointerException();
         
        Node[] prefix = new Node[size];
        this.pre(root, prefix, 0);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root ==null) throw new NullPointerException();
        
        Node[] postfix = new Node[size];
        this.post(root, postfix, 0);       
        return postfix;
    }
    
    public double Evaluation(){
         if(root ==null) throw new NullPointerException();
        double answer ;
        Node[] po = this.PrintPostfix();
        Stack<Double> ans = new Stack<>();
        for(int i = 0;i<size;i++){
            if(po[i].getValue().equals(""+"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a+b);
            }
            else  if(po[i].getValue().equals(""-"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a-b);
            }
            else  if(po[i].getValue().equals(""*"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a*b);
            }
            else  if(po[i].getValue().equals(""/"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a/b);
            }
            else{
                double a = Double.parseDouble(po[i].getValue());
                ans.push(a);
            }
        }
        answer = ans.pop();
        return answer;
    }
    
    public boolean find(String a){
        if(a.equals(""+"") || a.equals(""-"") || a.equals(""*"")
                || a.equals(""/"") || a.equals("")""))
        return true;
        else return false;
    }
    
   public int getsize(){
       return size;
   }
   public int pre(Node a, Node[] b, int i){
       b[i] = a;
       i++;
       if(a.getLeft()!=null)
           i = this.pre(a.getLeft(), b, i);
       if(a.getRight()!=null)
           i = this.pre(a.getRight(), b, i);
       return i;
   }
   public int post(Node a, Node[] b, int i){
        if(a.getLeft()!=null)
          i =this.post(a.getLeft(), b, i);          
        if(a.getRight()!=null)
          i =this.post(a.getRight(), b, i);           
       b[i] = a;
       i++;          
      return i;
   }
}

@1ff7397c528a41543fd476831ae21f2f@"
"r03522831","10","0.099","105920","@a45ed58f5f61fb85ea1bd5a065e98a3c@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */
public class Expression{
  
    private Node root;
    private int N;
    Queue<Node> findmidqueue =new Queue<Node>();
    Queue<Node> findleftqueue =new Queue<Node>();
    Stack<String> findans =new Stack<String>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] Num = infix.split("""");
        Queue<String> numberqueue =new Queue<String>();
        int count =0;

        for(int i=1;i<Num.length;i++){
            
            if(Num[i].equals(""("")){
            numberqueue.enqueue(Num[i]);
            count =i;
            
            }else if( Num[i].equals("")"") || Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"") ){

                String S1 =""""; 
                for(int j=count+1;j<i;j++){
                    S1 = (S1+Num[j]).replace(""null"","""");
                }
                String  S2 = S1.replace(""null"","""");
                  
                  if( !( S2=="""" )){
//                    System.out.println(S1);
                      numberqueue.enqueue(S2);
                  }
                numberqueue.enqueue(Num[i]);
                count =i;
                
            }else{

            }
        }
//        System.out.println( numberqueue.size());
        String[] Num2 =new String[numberqueue.size()];
        for(int i=0;i<Num2.length;i++){
            Num2[i]=numberqueue.dequeue();
        }

        Stack<Node>  numsta =new Stack<Node> ();
        Stack optsta =new Stack();
        Stack<Node> nodesta =new Stack<Node>();
        int N = Num2.length;
        this.N=N;
        Node[] Infnode =new Node[N/2+1];
        int nodenum=0;

          for(int i=0;i<N;i++){
              
//              System.out.println( Num2[i]);
//              System.out.println( Num2[i].equals(""*""));
              if( Num2[i].equals(""+"") || Num2[i].equals(""-"") || Num2[i].equals(""*"") || Num2[i].equals(""/"")){
                  optsta.push(Num2[i]);
                  
               }else if( Num2[i].equals(""("")){

               }else if( Num2[i].equals("")"")){
                  if(Num2[i-1].equals(""("") )
                    {
                       throw new NullPointerException(""NullPointerException"");
                    }
                   Infnode[0]=numsta.pop();
                   Infnode[1]=numsta.pop();
                   numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
               }else{

                  numsta.push(new Node(null,null,Num2[i]));
              }
          }
          
        root=numsta.peek();
        this.root=root;
        
//        System.out.println(root.getValue());
        
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findmid(rootnode[0]);
        Node[] prefix = new Node[findmidqueue.size()];
        int n=0;
        while(!findmidqueue.isEmpty()){
           prefix[n]=findmidqueue.dequeue();
           n=n+1;
       }
        return prefix;
    }
    
        public Node findmid(Node x){
            findmidqueue.enqueue(x);
//            System.out.println(findmidqueue.peek().getValue()); 
            if( !(x.getLeft()==null) ){
                    findmid(x.getLeft());
            }
            if( !(x.getRight()==null) ){
                    findmid(x.getRight());
            }
        return x;
    }
  
    public Node[] PrintPostfix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        while(!findleftqueue.isEmpty()){
           postfix[n]=findleftqueue.dequeue();
           n=n+1;
       }
          postfix[n]=rootnode[0];
        return postfix;
    }
    
    public Node findleft(Node x){
           
            if( !(x.getLeft()==null) ){
                    findleft(x.getLeft());
                     findleftqueue.enqueue(x.getLeft());
//                    System.out.println(x.getLeft().getValue()); 
            }
            if( !(x.getRight()==null) ){
                    findleft(x.getRight());
                    findleftqueue.enqueue(x.getRight());
//                    System.out.println(x.getRight().getValue()); 
            }
        return x;
    }
    
    public double Evaluation(){
        
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        findleftqueue.enqueue( rootnode[0] );
        
//        while(!findleftqueue.isEmpty()){
//           postfix[n]=findleftqueue.dequeue();
//           System.out.println(postfix[n].getValue());
//           n=n+1;
//       }

        while( !findleftqueue.isEmpty() ){

            findans.push(findleftqueue.dequeue().getValue());
            if( findans.peek().equals(""+"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=a+b;
                String stringc = Double.toString(c);
                findans.push(stringc);
                
            }else if( findans.peek().equals(""-"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b-a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""*"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b*a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""/"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b/a;
                String stringc = Double.toString(c);
                findans.push(stringc);
            }
        }

        double answer =Double.parseDouble( findans.peek());
        return answer;
    
    }

    /**
     * @param args the command line arguments
     */

     public static void main(String[] args)throws Exception {
        Node[] rootnode = new Node[1];
        String problem =""(((0.235+0.88)*7.2)+(200+10))"";
        Expression build = new Expression();
        rootnode[0]=build.Infix2BT(problem);
        System.out.println(build.Evaluation());
//
//        
        for(int i=0;i<build.PrintPostfix().length;i++ ){
        System.out.println(build.PrintPostfix()[i].getValue());
        }

//        System.out.println(rootnode[0].getRight().getValue());

    }
}
@a45ed58f5f61fb85ea1bd5a065e98a3c@"
"r03522826","10","0.099","105904","@a45ed58f5f61fb85ea1bd5a065e98a3c@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */
public class Expression{
  
    private Node root;
    private int N;
    Queue<Node> findmidqueue =new Queue<Node>();
    Queue<Node> findleftqueue =new Queue<Node>();
    Stack<String> findans =new Stack<String>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] Num = infix.split("""");
        Queue<String> numberqueue =new Queue<String>();
        int count =0;

        for(int i=1;i<Num.length;i++){
            
            if(Num[i].equals(""("")){
            numberqueue.enqueue(Num[i]);
            count =i;
            
            }else if( Num[i].equals("")"") || Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"") ){

                String S1 =""""; 
                for(int j=count+1;j<i;j++){
                    S1 = (S1+Num[j]).replace(""null"","""");
                }
                String  S2 = S1.replace(""null"","""");
                  
                  if( !( S2=="""" )){
//                    System.out.println(S1);
                      numberqueue.enqueue(S2);
                  }
                numberqueue.enqueue(Num[i]);
                count =i;
                
            }else{

            }
        }
//        System.out.println( numberqueue.size());
        String[] Num2 =new String[numberqueue.size()];
        for(int i=0;i<Num2.length;i++){
            Num2[i]=numberqueue.dequeue();
        }

        Stack<Node>  numsta =new Stack<Node> ();
        Stack optsta =new Stack();
        Stack<Node> nodesta =new Stack<Node>();
        int N = Num2.length;
        this.N=N;
        Node[] Infnode =new Node[N/2+1];
        int nodenum=0;

          for(int i=0;i<N;i++){
              
//              System.out.println( Num2[i]);
//              System.out.println( Num2[i].equals(""*""));
              if( Num2[i].equals(""+"") || Num2[i].equals(""-"") || Num2[i].equals(""*"") || Num2[i].equals(""/"")){
                  optsta.push(Num2[i]);
                  
               }else if( Num2[i].equals(""("")){

               }else if( Num2[i].equals("")"")){
                  if(Num2[i-1].equals(""("") )
                    {
                       throw new NullPointerException(""NullPointerException"");
                    }
                   Infnode[0]=numsta.pop();
                   Infnode[1]=numsta.pop();
                   numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
               }else{

                  numsta.push(new Node(null,null,Num2[i]));
              }
          }
          
        root=numsta.peek();
        this.root=root;
        
//        System.out.println(root.getValue());
        
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findmid(rootnode[0]);
        Node[] prefix = new Node[findmidqueue.size()];
        int n=0;
        while(!findmidqueue.isEmpty()){
           prefix[n]=findmidqueue.dequeue();
           n=n+1;
       }
        return prefix;
    }
    
        public Node findmid(Node x){
            findmidqueue.enqueue(x);
//            System.out.println(findmidqueue.peek().getValue()); 
            if( !(x.getLeft()==null) ){
                    findmid(x.getLeft());
            }
            if( !(x.getRight()==null) ){
                    findmid(x.getRight());
            }
        return x;
    }
  
    public Node[] PrintPostfix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        while(!findleftqueue.isEmpty()){
           postfix[n]=findleftqueue.dequeue();
           n=n+1;
       }
          postfix[n]=rootnode[0];
        return postfix;
    }
    
    public Node findleft(Node x){
           
            if( !(x.getLeft()==null) ){
                    findleft(x.getLeft());
                     findleftqueue.enqueue(x.getLeft());
//                    System.out.println(x.getLeft().getValue()); 
            }
            if( !(x.getRight()==null) ){
                    findleft(x.getRight());
                    findleftqueue.enqueue(x.getRight());
//                    System.out.println(x.getRight().getValue()); 
            }
        return x;
    }
    
    public double Evaluation(){
        
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        findleftqueue.enqueue( rootnode[0] );
        
//        while(!findleftqueue.isEmpty()){
//           postfix[n]=findleftqueue.dequeue();
//           System.out.println(postfix[n].getValue());
//           n=n+1;
//       }

        while( !findleftqueue.isEmpty() ){

            findans.push(findleftqueue.dequeue().getValue());
            if( findans.peek().equals(""+"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=a+b;
                String stringc = Double.toString(c);
                findans.push(stringc);
                
            }else if( findans.peek().equals(""-"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b-a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""*"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b*a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""/"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b/a;
                String stringc = Double.toString(c);
                findans.push(stringc);
            }
        }

        double answer =Double.parseDouble( findans.peek());
        return answer;
    
    }

    /**
     * @param args the command line arguments
     */

     public static void main(String[] args)throws Exception {
        Node[] rootnode = new Node[1];
        String problem =""(((0.235+0.88)*7.2)+(200+10))"";
        Expression build = new Expression();
        rootnode[0]=build.Infix2BT(problem);
        System.out.println(build.Evaluation());
//
//        
        for(int i=0;i<build.PrintPostfix().length;i++ ){
        System.out.println(build.PrintPostfix()[i].getValue());
        }

//        System.out.println(rootnode[0].getRight().getValue());

    }
}
@a45ed58f5f61fb85ea1bd5a065e98a3c@"
"r04522616","3","0.28","105616","@00a4e7d4d99c671f74d1fbcf19ec7abb@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        int countNull=0;
        String[] copyOutData=new String[outData.length];
        for(int i=0;i<outData.length;i++)
        {
            if(outData[i]==null)
            {
                countNull++;
            }            
        }
        for(int i=0;i<outData.length;i++)
        {
            copyOutData[i]=outData[countNull+i];
        }
        
        Node[] prefix  = new Node[outData.length];
        //String[] check=new String[outData.length];
        
        copyOutData=outData.clone();
        for(int i=0;i<outData.length;i++)
        {
            char isANumber=copyOutData[i].charAt(0);
            if(Character.isDigit(isANumber)!=true && copyOutData[i].equals(""("")!=true && copyOutData[i].equals("")"")!=true)
            {
                for(int j=i-1;j>=0;j--)
                {
                    if(copyOutData[j].equals(""(""))
                    {
                        copyOutData[j]=copyOutData[i];
                        copyOutData[i]="")"";
                        break;
                    }
                }
            }
        }
        String out = """";
        int a=0;
        for(int i=0;i<outData.length;i++)
        {
            if(copyOutData[i].equals("")"")!=true)
            {
                out = copyOutData[i];
                Node b=new Node(null,null,out);
                prefix[i-a]=b;
                //check[i-a]=out;
            }
            else if(copyOutData[i].equals("")"")==true)
            {
                a++;
            }
        }

//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
        

        return prefix;
    }
    

  
    public Node[] PrintPostfix(){
        
        Node[] postfix = new Node[outData.length];
        //String[] check=new String[outData.length];
        
        int countNull=0;
        String[] copyOutData=new String[outData.length];
        for(int i=0;i<outData.length;i++)
        {
            if(outData[i]==null)
            {
                countNull++;
            }            
        }
        for(int i=0;i<outData.length;i++)
        {
            copyOutData[i]=outData[countNull+i];
        }
        
        Stack<String> stk=new Stack<String>();
        int j=0;
        for(int i=0;i<outData.length;i++)
        {            
            char isANumber=copyOutData[i].charAt(0);
            if(copyOutData[i].equals(""(""))
            {
                j++;
            }
            else if(copyOutData[i].equals("")""))
            {
                String symbol=stk.pop();
                postfix[i-j]=new Node(null, null, symbol);
                //check[i-j]=symbol;
            }
            else if(Character.isDigit(isANumber)!=true && copyOutData[i].equals(""("")!=true && copyOutData[i].equals("")"")!=true)
            {
                j++;
                stk.push(copyOutData[i]);
            }
            else
            {
                Node a=new Node(null, null, copyOutData[i]);
                postfix[i-j]=a;
                //check[i-j]=copyOutData[i];
            }
        }
//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
//        System.out.print(""\n"");
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@00a4e7d4d99c671f74d1fbcf19ec7abb@"
"r04522616","4","0.99","105856","@11923dcdd52dcbd673207749007d0bd6@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        int countNull=0;
        int length=((outData.length+1)/2);
        String[] copyOutData=new String[outData.length];
        for(int i=0;i<outData.length;i++)
        {
            if(outData[i]==null)
            {
                countNull++;
            }            
        }
        for(int i=0;i<outData.length;i++)
        {
            copyOutData[i]=outData[countNull+i];
        }
        
        Node[] prefix  = new Node[length];
        //String[] check=new String[length];
        

        for(int i=0;i<outData.length;i++)
        {
            char isANumber=copyOutData[i].charAt(0);
            if(Character.isDigit(isANumber)!=true && copyOutData[i].equals(""("")!=true && copyOutData[i].equals("")"")!=true)
            {
                for(int j=i-1;j>=0;j--)
                {
                    if(copyOutData[j].equals(""(""))
                    {
                        copyOutData[j]=copyOutData[i];
                        copyOutData[i]="")"";
                        break;
                    }
                }
            }
        }
        String out = """";
        int a=0;
        for(int i=0;i<outData.length;i++)
        {
            if(copyOutData[i].equals("")"")!=true)
            {
                out = copyOutData[i];
                Node b=new Node(null,null,out);
                prefix[i-a]=b;
                //check[i-a]=out;
            }
            else if(copyOutData[i].equals("")"")==true)
            {
                a++;
            }
        }

//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
        

        return prefix;
    }
    

  
    public Node[] PrintPostfix(){
        
        int length=((outData.length+1)/2);
        Node[] postfix = new Node[length];
        //String[] check=new String[length];
        
        int countNull=0;
        String[] copyOutData=new String[outData.length];
        for(int i=0;i<outData.length;i++)
        {
            if(outData[i]==null)
            {
                countNull++;
            }            
        }
        for(int i=0;i<outData.length;i++)
        {
            copyOutData[i]=outData[countNull+i];
        }
        
        Stack<String> stk=new Stack<String>();
        int j=0;
        for(int i=0;i<outData.length;i++)
        {            
            char isANumber=copyOutData[i].charAt(0);
            if(copyOutData[i].equals(""(""))
            {
                j++;
            }
            else if(copyOutData[i].equals("")""))
            {
                String symbol=stk.pop();
                postfix[i-j]=new Node(null, null, symbol);
                //check[i-j]=symbol;
            }
            else if(Character.isDigit(isANumber)!=true && copyOutData[i].equals(""("")!=true && copyOutData[i].equals("")"")!=true)
            {
                j++;
                stk.push(copyOutData[i]);
            }
            else
            {
                Node a=new Node(null, null, copyOutData[i]);
                postfix[i-j]=a;
                //check[i-j]=copyOutData[i];
            }
        }
//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
//        System.out.print(""\n"");
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@11923dcdd52dcbd673207749007d0bd6@"
"r04631041","6","0.98","105904","@0f143314b8311237c41b289863f74def@public class Expression{
  
    private Node root;
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] stringarray=infix.split("""");
        Stack<Node> data=new Stack<Node>();
        for (int i=0 ; i<stringarray.length ; i++){
            if(stringarray[i].equals("")"")){
                Node[] temp=new Node[4];
                int tempi=0;
                while(tempi<4){
                 temp[tempi]=data.pop();
                 tempi++;
                }
                temp[1].setLeft(temp[2]);
                temp[1].setRight(temp[0]);
                root=temp[1];
                data.push(root);
            }
            else{
              Node temp=new Node(null,null,stringarray[i]);
              data.push(temp);
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Queue<Node> data=new Queue<Node>();
        Node x=root;
        PrintPrefix(data,x);
        int i=0,num=data.size();
        Node[] prefix = new Node[num];
        while(!data.isEmpty()){
           prefix[i]=data.dequeue();
        i++;
        }
        return prefix;
     }
    private void PrintPrefix(Queue<Node> data,Node root){
   Node x=root,L=root.getLeft(),R=root.getRight();
                 data.enqueue(x);
                 
    if (L!=null)PrintPrefix(data,L);
    if (R!=null) PrintPrefix(data,R);
    }
  public Node[] PrintPostfix(){
        Node x=root;
        Queue<Node> postdata=new Queue<Node>();
        PrintPostfix(postdata,x);
        int i=0,num=postdata.size();
        Node[] postfix=new Node[num];
        while(!postdata.isEmpty()){
            postfix[i]=postdata.dequeue();
            i++;
        }
        return postfix;
    }
     private void PrintPostfix(Queue<Node> postdata,Node root){
   Node x=root,L=root.getLeft(),R=root.getRight();
   
    if (L!=null)PrintPostfix(postdata,L);
    if (R!=null) PrintPostfix(postdata,R);
     postdata.enqueue(x);         
    }

    public double Evaluation(){
        double answer = 0;
        Node sign=root;
        answer=Evaluation(sign);
        return answer;
    }
    private double Evaluation(Node sign){
        double ans=0;
        Node x=sign;
        Node L=x.getLeft(),R=x.getRight();
        if (L.getValue().equals(""+"")||L.getValue().equals(""-"")||L.getValue().equals(""*"")||L.getValue().equals(""/"")) L=new Node(null,null, String.valueOf(Evaluation(L)));
        if (R.getValue().equals(""+"")||R.getValue().equals(""-"")||R.getValue().equals(""*"")||R.getValue().equals(""/"")) R=new Node(null,null, String.valueOf(Evaluation(R)));
        if (x.getValue().equals(""+"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l+r;
        }
        else if (x.getValue().equals(""-"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l-r;
        }
         else if (x.getValue().equals(""*"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l*r;
        }
         else if (x.getValue().equals(""/"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l/r;
        }
        return ans;
    }
     public static void main(String[] args) {
         String input=""(4+(((4*2)/2)/3))"";
         //String input=""(((1+(12*5))-(3*4))+(4/5))"";
         //String input=""(((4/5)+3)+(1/2))"";
         String[] stringarray=input.split("""");
    //     for (int i=0 ; i<stringarray.length ; i++)
    //         System.out.print(stringarray[i]+""\t"");
    //     System.out.println();
    //     System.out.println(input);
     Expression calculation=new Expression();
     calculation.Infix2BT(input);
     System.out.println(calculation.root.getValue());
     System.out.println(calculation.root.getLeft().getValue());
     System.out.println(calculation.root.getRight().getValue());
     //System.out.println(calculation.root.getLeft().getLeft().getValue());
     //System.out.println(calculation.root.getLeft().getLeft().getLeft().getValue());
     //System.out.println(calculation.root.getLeft().getLeft().getLeft().getLeft().getValue());
     //System.out.println(calculation.root.getRight().getLeft().getLeft().getLeft().getLeft());
     Node[] prefix=calculation.PrintPrefix();
     for (int i=0 ; i<prefix.length ; i++)
     System.out.print(prefix[i].getValue()+""\t"");
     System.out.println("""");
     Node[] postfix=calculation.PrintPostfix();
     for (int i=0 ; i<postfix.length ; i++)
     System.out.print(postfix[i].getValue()+""\t"");
     System.out.println("""");
     //System.out.println(calculation.Evaluation());
   
     }
}

@0f143314b8311237c41b289863f74def@"
"r04631009","6","1","105904","@7fd8af066930c21e03ba12110b2d656f@public class Expression{
  
    private Node root;
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] stringarray=infix.split("""");
        Stack<Node> data=new Stack<Node>();
        for (int i=0 ; i<stringarray.length ; i++){
            if(stringarray[i].equals("")"")){
                Node[] temp=new Node[4];
                int tempi=0;
                while(tempi<4){
                 temp[tempi]=data.pop();
                 tempi++;
                }
                temp[1].setLeft(temp[2]);
                temp[1].setRight(temp[0]);
                root=temp[1];
                data.push(root);
            }
            else{
              Node temp=new Node(null,null,stringarray[i]);
              data.push(temp);
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Queue<Node> data=new Queue<Node>();
        Node x=root;
        PrintPrefix(data,x);
        int i=0,num=data.size();
        Node[] prefix = new Node[num];
        while(!data.isEmpty()){
           prefix[i]=data.dequeue();
        i++;
        }
        return prefix;
     }
    private void PrintPrefix(Queue<Node> data,Node root){
   Node x=root,L=root.getLeft(),R=root.getRight();
                 data.enqueue(x);
                 
    if (L!=null)PrintPrefix(data,L);
    if (R!=null) PrintPrefix(data,R);
    }
  public Node[] PrintPostfix(){
        Node x=root;
        Queue<Node> postdata=new Queue<Node>();
        PrintPostfix(postdata,x);
        int i=0,num=postdata.size();
        Node[] postfix=new Node[num];
        while(!postdata.isEmpty()){
            postfix[i]=postdata.dequeue();
            i++;
        }
        return postfix;
    }
     private void PrintPostfix(Queue<Node> postdata,Node root){
   Node x=root,L=root.getLeft(),R=root.getRight();
   
    if (L!=null)PrintPostfix(postdata,L);
    if (R!=null) PrintPostfix(postdata,R);
     postdata.enqueue(x);         
    }

    public double Evaluation(){
        double answer = 0;
        Node sign=root;
        answer=Evaluation(sign);
        return answer;
    }
    private double Evaluation(Node sign){
        double ans=0;
        Node x=sign;
        Node L=x.getLeft(),R=x.getRight();
        if (L.getValue().equals(""+"")||L.getValue().equals(""-"")||L.getValue().equals(""*"")||L.getValue().equals(""/"")) L=new Node(null,null, String.valueOf(Evaluation(L)));
        if (R.getValue().equals(""+"")||R.getValue().equals(""-"")||R.getValue().equals(""*"")||R.getValue().equals(""/"")) R=new Node(null,null, String.valueOf(Evaluation(R)));
        if (x.getValue().equals(""+"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l+r;
        }
        else if (x.getValue().equals(""-"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l-r;
        }
         else if (x.getValue().equals(""*"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l*r;
        }
         else if (x.getValue().equals(""/"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l/r;
        }
        return ans;
    }
     public static void main(String[] args) {
         String input=""(4+(((4*2)/2)/3))"";
         //String input=""(((1+(12*5))-(3*4))+(4/5))"";
         //String input=""(((4/5)+3)+(1/2))"";
         String[] stringarray=input.split("""");
    //     for (int i=0 ; i<stringarray.length ; i++)
    //         System.out.print(stringarray[i]+""\t"");
    //     System.out.println();
    //     System.out.println(input);
     Expression calculation=new Expression();
     calculation.Infix2BT(input);
     System.out.println(calculation.root.getValue());
     System.out.println(calculation.root.getLeft().getValue());
     System.out.println(calculation.root.getRight().getValue());
     //System.out.println(calculation.root.getLeft().getLeft().getValue());
     //System.out.println(calculation.root.getLeft().getLeft().getLeft().getValue());
     //System.out.println(calculation.root.getLeft().getLeft().getLeft().getLeft().getValue());
     //System.out.println(calculation.root.getRight().getLeft().getLeft().getLeft().getLeft());
     Node[] prefix=calculation.PrintPrefix();
     for (int i=0 ; i<prefix.length ; i++)
     System.out.print(prefix[i].getValue()+""\t"");
     System.out.println("""");
     Node[] postfix=calculation.PrintPostfix();
     for (int i=0 ; i<postfix.length ; i++)
     System.out.print(postfix[i].getValue()+""\t"");
     System.out.println("""");
     //System.out.println(calculation.Evaluation());
   
     }
}
@7fd8af066930c21e03ba12110b2d656f@"
"b03704074","10","0.096","105600","@a14b5be92c95f2d3b56336d8bbc77ab9@
public class Expression {
    
    
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    private class littleNode{//設一個處理輸入字串的方向
        String item;
        littleNode pre;
    }
    private littleNode first = null;
    private Node[] array ;//要放每次產生的BTS
    public Node Infix2BT(String infix){
        int count = 0;//用來算array的數量
        int InfixCount = 0;
        String[] Infix1 = new String[1000];
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"")){
                break;
                
            }
            if(i == infix.length()-1){
            Node a = new Node(null,null,infix.substring(1, i));
            root = a;
            return root;}
        }
        for(int i = 0;i < infix.length();i++){
            if(infix.substring(i, i+1).equals(""(""))continue;
            if(infix.substring(i, i+1).equals(""+"") || infix.substring(i, i+1).equals(""-"") || infix.substring(i, i+1).equals(""*"") || infix.substring(i, i+1).equals(""/"") || infix.substring(i, i+1).equals("")"")){
                Infix1[InfixCount++] = infix.substring(i, i+1);
                
            }
            else {
                int temp = i;
                while(!infix.substring(i+1, i+2).equals(""("") &&!infix.substring(i+1, i+2).equals(""+"") &&! infix.substring(i+1, i+2).equals(""-"") &&! infix.substring(i+1, i+2).equals(""*"") &&! infix.substring(i+1, i+2).equals(""/"") &&! infix.substring(i+1, i+2).equals("")"") ){
                    i++;
                }
                Infix1[InfixCount++] = infix.substring(temp, i+1);
            }
        }
        String[] Infix = new String[InfixCount];
        for(int i = 0;i < InfixCount;i++){
            Infix[i] = Infix1[i];
        }
                
        
        Node[] array = new Node[infix.length()];//不影響
        
        int flag = 0;
        for(int i = 0;i < Infix.length;i++){//主要code 
            if(flag == 0){
            littleNode oldfirst = first;
            first = new littleNode();
            first.item = Infix[i];
            first.pre = oldfirst;}
            flag = 0;
            if(Infix[i].equals("")"")){
                flag = 1;
                //數字連數字
                if(!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/"")
                        && !first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/"")){
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(a,c,first.pre.pre.item);   
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count] = b;count++;
                }
                else if((first.pre.item.equals(""+"") || first.pre.item.equals(""-"") || first.pre.item.equals(""*"") || first.pre.item.equals(""/""))
                        && (!first.pre.pre.pre.item.equals(""+"") && !first.pre.pre.pre.item.equals(""-"") && !first.pre.pre.pre.item.equals(""*"")&& !first.pre.pre.pre.item.equals(""/""))){    
                    Node a = new Node(null,null,first.pre.pre.pre.item);
                    //c在array[count-1]
                    Node b = new Node(a,array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                    }
                else if((!first.pre.item.equals(""+"") && !first.pre.item.equals(""-"") && !first.pre.item.equals(""*"") && !first.pre.item.equals(""/""))
                        && (first.pre.pre.pre.item.equals(""+"") || first.pre.pre.pre.item.equals(""-"") || first.pre.pre.pre.item.equals(""*"")|| first.pre.pre.pre.item.equals(""/""))){
                    //a在array裡
                    Node c = new Node(null,null,first.pre.item);
                    Node b = new Node(array[count-1],c,first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-1] = b;//count不用加
                }
                else{
                    Node b = new Node(array[count-2],array[count-1],first.pre.pre.item);
                    //System.out.println(b.left.value+""  ""+b.value+""  ""+b.right.value);
                    array[count-2] = b; count--;
                }
                if(i+1!=Infix.length){
                littleNode A = first.pre.pre;
                littleNode B = first.pre.pre.pre.pre;
                //System.out.println("" 第一項   ""+B.item+"" 第二項  ""+A.item);
                
                first = new littleNode();
                
                first.item = Infix[++i];
                first.pre = A;
                A.pre = B;
                i--;}
                }}
        root = array[count-1];
        return root;
    }
    int count = 0;
    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();        
        Node[] prefix1 = new Node[1000];
        count = 0;
        preOrder(root,prefix1);
        int counta = 0;
        for(int i = 0;i < prefix1.length && prefix1[i]!=null;i++){
            //System.out.println(prefix1[i].getValue());
            counta++;
        } 
        Node[] prefix = new Node[counta];
        for(int i = 0;i < prefix.length;i++){
            prefix[i] = prefix1[i];
            //System.out.println(prefix[i].getValue());
        }         
        return prefix;
    }
    private void preOrder(Node x,Node[] y){
        y[count++] = x;
        if(x.getLeft()!=null)preOrder(x.getLeft(),y);
        if(x.getRight()!=null)preOrder(x.getRight(),y);
    }
    
    
    int countt = 0;
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        Node[] postfix1 = new Node[1000];
        countt = 0;
        postOrder(root,postfix1);
        int countb = 0;
        for(int i = 0;i < postfix1.length && postfix1[i]!=null;i++){
            countb++;
        }
        Node[] postfix = new Node[countb];
        for(int i = 0;i < postfix.length;i++){
            postfix[i] = postfix1[i];
            //System.out.println(postfix[i].getValue());
        }
        return postfix;
    }
    private void postOrder(Node x,Node[] y){
        if(x.getLeft()!=null) postOrder(x.getLeft(),y);
        if(x.getRight()!=null)postOrder(x.getRight(),y);
        y[countt++] = x;
    }
    private class EvaNode{
        Node item;
        EvaNode pre;
    }
    
    public double Evaluation(){
        EvaNode Evafirst = null;
        if(root == null) throw new NullPointerException();
        double[] valuearray = new double[100];
        Node[] A = PrintPostfix();
        for(int i = 0;i < A.length;i++){
            //System.out.println(A[i].getValue());
        }
        int countvalue = 0;
        for(int i = 0;i < A.length;i++){
            EvaNode oldfirst = Evafirst;
            Evafirst = new EvaNode();
            Evafirst.item = A[i];
            Evafirst.pre = oldfirst;
            if(Evafirst.item.getValue().equals(""+"")){
                if(!Evafirst.pre.pre.item.getValue().equals(""+"") && !Evafirst.pre.pre.item.getValue().equals(""-"")&& !Evafirst.pre.pre.item.getValue().equals(""*"")&& !Evafirst.pre.pre.item.getValue().equals(""/"")
                        && !Evafirst.pre.item.getValue().equals(""+"") && !Evafirst.pre.item.getValue().equals(""-"") && !Evafirst.pre.item.getValue().equals(""*"") && !Evafirst.pre.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a+b;
                valuearray[countvalue++] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((!Evafirst.pre.pre.item.getValue().equals(""+"") && !Evafirst.pre.pre.item.getValue().equals(""-"")&& !Evafirst.pre.pre.item.getValue().equals(""*"")&& !Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (Evafirst.pre.item.getValue().equals(""+"") || Evafirst.pre.item.getValue().equals(""-"") || Evafirst.pre.item.getValue().equals(""*"") || Evafirst.pre.item.getValue().equals(""/""))){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = valuearray[countvalue-1];
                double c = a+b;
                valuearray[countvalue-1] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((Evafirst.pre.pre.item.getValue().equals(""+"") || Evafirst.pre.pre.item.getValue().equals(""-"")|| Evafirst.pre.pre.item.getValue().equals(""*"") || Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (!Evafirst.pre.item.getValue().equals(""+"") && !Evafirst.pre.item.getValue().equals(""-"") && !Evafirst.pre.item.getValue().equals(""*"") && !Evafirst.pre.item.getValue().equals(""/""))){
                double a = valuearray[countvalue-1];
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a+b;
                valuearray[countvalue-1] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((Evafirst.pre.pre.item.getValue().equals(""+"") || Evafirst.pre.pre.item.getValue().equals(""-"")|| Evafirst.pre.pre.item.getValue().equals(""*"") || Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (Evafirst.pre.item.getValue().equals(""+"") || Evafirst.pre.item.getValue().equals(""-"") || Evafirst.pre.item.getValue().equals(""*"") || Evafirst.pre.item.getValue().equals(""/""))){
                double a = valuearray[countvalue-1];
                double b = valuearray[countvalue-2];
                double c = a+b;
                valuearray[countvalue-2] = c;countvalue--;
                Evafirst.pre = Evafirst.pre.pre.pre;}
            }
            else if(Evafirst.item.getValue().equals(""-"")){
                if(!Evafirst.pre.pre.item.getValue().equals(""+"") && !Evafirst.pre.pre.item.getValue().equals(""-"")&& !Evafirst.pre.pre.item.getValue().equals(""*"")&& !Evafirst.pre.pre.item.getValue().equals(""/"")
                        && !Evafirst.pre.item.getValue().equals(""+"") && !Evafirst.pre.item.getValue().equals(""-"") && !Evafirst.pre.item.getValue().equals(""*"") && !Evafirst.pre.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a-b;
                valuearray[countvalue++] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((!Evafirst.pre.pre.item.getValue().equals(""+"") && !Evafirst.pre.pre.item.getValue().equals(""-"")&& !Evafirst.pre.pre.item.getValue().equals(""*"")&& !Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (Evafirst.pre.item.getValue().equals(""+"") || Evafirst.pre.item.getValue().equals(""-"") || Evafirst.pre.item.getValue().equals(""*"") || Evafirst.pre.item.getValue().equals(""/""))){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = valuearray[countvalue-1];
                double c = a-b;
                valuearray[countvalue-1] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((Evafirst.pre.pre.item.getValue().equals(""+"") || Evafirst.pre.pre.item.getValue().equals(""-"")|| Evafirst.pre.pre.item.getValue().equals(""*"") || Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (!Evafirst.pre.item.getValue().equals(""+"") && !Evafirst.pre.item.getValue().equals(""-"") && !Evafirst.pre.item.getValue().equals(""*"") && !Evafirst.pre.item.getValue().equals(""/""))){
                double a = valuearray[countvalue-1];
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a-b;
                valuearray[countvalue-1] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((Evafirst.pre.pre.item.getValue().equals(""+"") || Evafirst.pre.pre.item.getValue().equals(""-"")|| Evafirst.pre.pre.item.getValue().equals(""*"") || Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (Evafirst.pre.item.getValue().equals(""+"") || Evafirst.pre.item.getValue().equals(""-"") || Evafirst.pre.item.getValue().equals(""*"") || Evafirst.pre.item.getValue().equals(""/""))){
                double a = valuearray[countvalue-1];
                double b = valuearray[countvalue-2];
                double c = a-b;
                valuearray[countvalue-2] = c;countvalue--;
                Evafirst.pre = Evafirst.pre.pre.pre;}
            }
            else if(Evafirst.item.getValue().equals(""*"")){
                if(!Evafirst.pre.pre.item.getValue().equals(""+"") && !Evafirst.pre.pre.item.getValue().equals(""-"")&& !Evafirst.pre.pre.item.getValue().equals(""*"")&& !Evafirst.pre.pre.item.getValue().equals(""/"")
                        && !Evafirst.pre.item.getValue().equals(""+"") && !Evafirst.pre.item.getValue().equals(""-"") && !Evafirst.pre.item.getValue().equals(""*"") && !Evafirst.pre.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a*b;
                valuearray[countvalue++] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((!Evafirst.pre.pre.item.getValue().equals(""+"") && !Evafirst.pre.pre.item.getValue().equals(""-"")&& !Evafirst.pre.pre.item.getValue().equals(""*"")&& !Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (Evafirst.pre.item.getValue().equals(""+"") || Evafirst.pre.item.getValue().equals(""-"") || Evafirst.pre.item.getValue().equals(""*"") || Evafirst.pre.item.getValue().equals(""/""))){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = valuearray[countvalue-1];
                double c = a*b;
                valuearray[countvalue-1] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((Evafirst.pre.pre.item.getValue().equals(""+"") || Evafirst.pre.pre.item.getValue().equals(""-"")|| Evafirst.pre.pre.item.getValue().equals(""*"") || Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (!Evafirst.pre.item.getValue().equals(""+"") && !Evafirst.pre.item.getValue().equals(""-"") && !Evafirst.pre.item.getValue().equals(""*"") && !Evafirst.pre.item.getValue().equals(""/""))){
                double a = valuearray[countvalue-1];
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a*b;
                valuearray[countvalue-1] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((Evafirst.pre.pre.item.getValue().equals(""+"") || Evafirst.pre.pre.item.getValue().equals(""-"")|| Evafirst.pre.pre.item.getValue().equals(""*"") || Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (Evafirst.pre.item.getValue().equals(""+"") || Evafirst.pre.item.getValue().equals(""-"") || Evafirst.pre.item.getValue().equals(""*"") || Evafirst.pre.item.getValue().equals(""/""))){
                double a = valuearray[countvalue-1];
                double b = valuearray[countvalue-2];
                double c = a*b;
                valuearray[countvalue-2] = c;countvalue--;
                Evafirst.pre = Evafirst.pre.pre.pre;}
            }
            else if(Evafirst.item.getValue().equals(""/"")){
                if(!Evafirst.pre.pre.item.getValue().equals(""+"") && !Evafirst.pre.pre.item.getValue().equals(""-"")&& !Evafirst.pre.pre.item.getValue().equals(""*"")&& !Evafirst.pre.pre.item.getValue().equals(""/"")
                        && !Evafirst.pre.item.getValue().equals(""+"") && !Evafirst.pre.item.getValue().equals(""-"") && !Evafirst.pre.item.getValue().equals(""*"") && !Evafirst.pre.item.getValue().equals(""/"")){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a/b;
                valuearray[countvalue++] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((!Evafirst.pre.pre.item.getValue().equals(""+"") && !Evafirst.pre.pre.item.getValue().equals(""-"")&& !Evafirst.pre.pre.item.getValue().equals(""*"")&& !Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (Evafirst.pre.item.getValue().equals(""+"") || Evafirst.pre.item.getValue().equals(""-"") || Evafirst.pre.item.getValue().equals(""*"") || Evafirst.pre.item.getValue().equals(""/""))){
                double a = Double.parseDouble(Evafirst.pre.pre.item.getValue());
                double b = valuearray[countvalue-1];
                double c = a/b;
                valuearray[countvalue-1] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((Evafirst.pre.pre.item.getValue().equals(""+"") || Evafirst.pre.pre.item.getValue().equals(""-"")|| Evafirst.pre.pre.item.getValue().equals(""*"") || Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (!Evafirst.pre.item.getValue().equals(""+"") && !Evafirst.pre.item.getValue().equals(""-"") && !Evafirst.pre.item.getValue().equals(""*"") && !Evafirst.pre.item.getValue().equals(""/""))){
                double a = valuearray[countvalue-1];
                double b = Double.parseDouble(Evafirst.pre.item.getValue());
                double c = a/b;
                valuearray[countvalue-1] = c;
                Evafirst.pre = Evafirst.pre.pre.pre;}
                else if((Evafirst.pre.pre.item.getValue().equals(""+"") || Evafirst.pre.pre.item.getValue().equals(""-"")|| Evafirst.pre.pre.item.getValue().equals(""*"") || Evafirst.pre.pre.item.getValue().equals(""/""))
                        && (Evafirst.pre.item.getValue().equals(""+"") || Evafirst.pre.item.getValue().equals(""-"") || Evafirst.pre.item.getValue().equals(""*"") || Evafirst.pre.item.getValue().equals(""/""))){
                double a = valuearray[countvalue-1];
                double b = valuearray[countvalue-2];
                double c = a/b;
                valuearray[countvalue-2] = c;countvalue--;
                Evafirst.pre = Evafirst.pre.pre.pre;}
            }
        }
        double answer = valuearray[countvalue-1];
        //System.out.println(answer);
        return answer;
    }
    public static void main(String[] args) {
        // TODO code application logic here
        Expression exp = new Expression();
        Node test = exp.Infix2BT(""(4-2)"");       
        Node[] pre = exp.PrintPrefix();
        Node[] post = exp.PrintPostfix();
       double answer = exp.Evaluation();
        for(int i = 0 ; i<pre.length;i++){
             System.out.println(pre[i].getValue()); }
        System.out.println(answer);
        
        
    }
    
}

@a14b5be92c95f2d3b56336d8bbc77ab9@"
"b03611038","3","0.77","105824","@65f16c759c6264a3cfa7c7023f366ff3@public class Expression{
  
    private Node root;
    private int size;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        
        int len = infix.length();
        Stack<String> ops = new Stack<>();
        Stack<String> val = new Stack<>();
        Stack<Node> im = new Stack<>();
        root = null;
        for(int i = 0;i<len;i++){
            
            String temp = infix.substring(i, i+1);
            if(temp.equals(""("")) ;
            else if(temp.equals(""+"")) ops.push(temp);
            else if(temp.equals(""-"")) ops.push(temp);
            else if(temp.equals(""*"")) ops.push(temp);
            else if(temp.equals(""/"")) ops.push(temp);
           
            else if(temp.equals("")"")) {
                if(ops.isEmpty()){
                    if(val.isEmpty()){
                        root = null;
                        break;
                    }
                 String cc = val.pop();
                 Node b = new Node(null,null, cc);
                 root = b;
                 size = 1;
                 break;        
                }
                String op = ops.pop();
                if(root==null){
                    Node c = new Node(null,null,val.pop()); size++;
                    Node a = new Node(null,null,val.pop()); size++;
                    Node b = new Node(a,c,op);  
                    size++;
                    root = b;
                    val.push(root.getValue());
                }
                else{
                    String cc = val.pop();
                    String aa = val.pop();
                    if(this.find(aa)==true && this.find(cc)==true){
                        root.setValue(op);
                        val.push(root.getValue());
                    }
                    else if(this.find(cc)){
                        Node a = new Node(null,null,aa); size++;
                        Node b = new Node(a,root,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else if(this.find(aa)){
                        Node c = new Node(null,null,cc); size++;
                        Node b = new Node(root,c,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else{
                       Node c = new Node(null,null,cc); size++;
                       Node a = new Node(null,null,aa); size++;
                       Node b = new Node(a,c,op); size++;
                       val.push(b.getValue());
                       Node d = new Node(root,b,null); size++;
                       root = d;
                    }
                }               
            }                
            else{
                  int j = i+2;
                  String wa = infix.substring(j, j+1);
                  while(this.find(wa)!=true){
                      j++;
                      wa = infix.substring(j, j+1);
                  }
                  wa = infix.substring(i, j);
                  i = j-1;
                  val.push(wa);
                    }
        }
       
        return root;
    }

    public Node[] PrintPrefix(){
         if(root ==null) throw new NullPointerException();
         
        Node[] prefix = new Node[size];
        this.pre(root, prefix, 0);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root ==null) throw new NullPointerException();
        
        Node[] postfix = new Node[size];
        this.post(root, postfix, 0);       
        return postfix;
    }
    
    public double Evaluation(){
         if(root ==null) throw new NullPointerException();
        double answer ;
        Node[] po = this.PrintPostfix();
        Stack<Double> ans = new Stack<>();
        for(int i = 0;i<size;i++){
            if(po[i].getValue().equals(""+"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a+b);
            }
            else  if(po[i].getValue().equals(""-"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a-b);
            }
            else  if(po[i].getValue().equals(""*"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a*b);
            }
            else  if(po[i].getValue().equals(""/"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a/b);
            }
            else{
                double a = Double.parseDouble(po[i].getValue());
                ans.push(a);
            }
        }
        answer = ans.pop();
        return answer;
    }
    
    public boolean find(String a){
        if(a.equals(""+"") || a.equals(""-"") || a.equals(""*"")
                || a.equals(""/"") || a.equals("")""))
        return true;
        else return false;
    }
    
   public int getsize(){
       return size;
   }
   public int pre(Node a, Node[] b, int i){
       b[i] = a;
       i++;
       if(a.getLeft()!=null)
           i = this.pre(a.getLeft(), b, i);
       if(a.getRight()!=null)
           i = this.pre(a.getRight(), b, i);
       return i;
   }
   public int post(Node a, Node[] b, int i){
        if(a.getLeft()!=null)
          i =this.post(a.getLeft(), b, i);          
        if(a.getRight()!=null)
          i =this.post(a.getRight(), b, i);           
       b[i] = a;
       i++;          
      return i;
   }
}

@65f16c759c6264a3cfa7c7023f366ff3@"
"b03611038","10","0.096","105872","@1ff7397c528a41543fd476831ae21f2f@public class Expression{
  
    private Node root;
    private int size;
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        
        int len = infix.length();
        Stack<String> ops = new Stack<>();
        Stack<String> val = new Stack<>();
        Stack<Node> im = new Stack<>();
        root = null;
        for(int i = 0;i<len;i++){
            
            String temp = infix.substring(i, i+1);
            if(temp.equals(""("")) ;
            else if(temp.equals(""+"")) ops.push(temp);
            else if(temp.equals(""-"")) ops.push(temp);
            else if(temp.equals(""*"")) ops.push(temp);
            else if(temp.equals(""/"")) ops.push(temp);
           
            else if(temp.equals("")"")) {
                if(ops.isEmpty()){
                    if(val.isEmpty()){
                        root = null;
                        break;
                    }
                 String cc = val.pop();
                 Node b = new Node(null,null, cc);
                 root = b;
                 size = 1;
                 break;        
                }
                String op = ops.pop();
                if(root==null){
                    Node c = new Node(null,null,val.pop()); size++;
                    Node a = new Node(null,null,val.pop()); size++;
                    Node b = new Node(a,c,op);  
                    size++;
                    root = b;
                    val.push(root.getValue());
                }
                else{
                    String cc = val.pop();
                    String aa = val.pop();
                    if(this.find(aa)==true && this.find(cc)==true){
                        root.setValue(op);
                        val.push(root.getValue());
                    }
                    else if(this.find(cc)){
                        Node a = new Node(null,null,aa); size++;
                        Node b = new Node(a,root,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else if(this.find(aa)){
                        Node c = new Node(null,null,cc); size++;
                        Node b = new Node(root,c,op); size++;
                         root = b;
                    val.push(root.getValue());
                    }
                    else{
                       Node c = new Node(null,null,cc); size++;
                       Node a = new Node(null,null,aa); size++;
                       Node b = new Node(a,c,op); size++;
                       val.push(b.getValue());
                       Node d = new Node(root,b,null); size++;
                       root = d;
                    }
                }               
            }                
            else{
                  int j = i+1;
                  String wa = infix.substring(j, j+1);
                  while(this.find(wa)!=true){
                      j++;
                      wa = infix.substring(j, j+1);
                  }
                  wa = infix.substring(i, j);
                  i = j-1;
                  val.push(wa);
                    }
        }
       
        return root;
    }

    public Node[] PrintPrefix(){
         if(root ==null) throw new NullPointerException();
         
        Node[] prefix = new Node[size];
        this.pre(root, prefix, 0);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root ==null) throw new NullPointerException();
        
        Node[] postfix = new Node[size];
        this.post(root, postfix, 0);       
        return postfix;
    }
    
    public double Evaluation(){
         if(root ==null) throw new NullPointerException();
        double answer ;
        Node[] po = this.PrintPostfix();
        Stack<Double> ans = new Stack<>();
        for(int i = 0;i<size;i++){
            if(po[i].getValue().equals(""+"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a+b);
            }
            else  if(po[i].getValue().equals(""-"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a-b);
            }
            else  if(po[i].getValue().equals(""*"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a*b);
            }
            else  if(po[i].getValue().equals(""/"")){
                double a,b;
                b = ans.pop();
                a = ans.pop();
                ans.push(a/b);
            }
            else{
                double a = Double.parseDouble(po[i].getValue());
                ans.push(a);
            }
        }
        answer = ans.pop();
        return answer;
    }
    
    public boolean find(String a){
        if(a.equals(""+"") || a.equals(""-"") || a.equals(""*"")
                || a.equals(""/"") || a.equals("")""))
        return true;
        else return false;
    }
    
   public int getsize(){
       return size;
   }
   public int pre(Node a, Node[] b, int i){
       b[i] = a;
       i++;
       if(a.getLeft()!=null)
           i = this.pre(a.getLeft(), b, i);
       if(a.getRight()!=null)
           i = this.pre(a.getRight(), b, i);
       return i;
   }
   public int post(Node a, Node[] b, int i){
        if(a.getLeft()!=null)
          i =this.post(a.getLeft(), b, i);          
        if(a.getRight()!=null)
          i =this.post(a.getRight(), b, i);           
       b[i] = a;
       i++;          
      return i;
   }
}

@1ff7397c528a41543fd476831ae21f2f@"
"r04945008","6","1.01","105872","@28c289dcced77ca297bcc3b28eb51870@public class Expression{
  
    private Node root;
    final static Queue<Node> prefix = new Queue<Node>();
    final static Queue<Node> postfix = new Queue<Node>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        final Stack<Node> nodes = new Stack<Node>();
        String[] str = mod(infix);
        for (int i = 0; i < str.length; i++) {
            String temp  = str[i];
            if(temp.equals(""("")){
            }
            else if(temp.equals("")"")){
                Node rightNode = nodes.pop();
                String op = nodes.pop().getValue();
                Node leftNode = nodes.pop();
                nodes.push(new Node(leftNode, rightNode, op));
            }
            else{
                nodes.push(new Node(null, null, temp));
            }
        }
        root = nodes.pop();
        return root;
    }

    public String[] mod(String str){
        String[] output = new String[str.length()];
        String value = """";
        int k = 0;
        for (int i = 0; i < str.length(); i++) {
            char temp  = str.charAt(i);
            if(!notOperand(temp)){
                value += temp;
            }
            else{
                if(value != """"){
                    output[k++] = value;
                    value = """";
                }
                output[k++] = String.valueOf(temp);
            }
        }
        for(int i = 0; i < output.length; i++)
            if(output[i] == null)
                output[i] = """";
        return output;
    }
    
    private static void PrefixTree(Node root) {
        if (isLeaf(root))
            prefix.enqueue(root);
        else {
            prefix.enqueue(root);
            PrefixTree(root.getLeft());
            PrefixTree(root.getRight());
        }
    }

    public Node[] PrintPrefix(){
        int i = 0;
        PrefixTree(root);
        Node[] output = new Node[prefix.size()];
        while(!prefix.isEmpty()){
            output[i++] = prefix.dequeue();
        }
        return output;
    }
    
    private static void PostfixTree(Node root) {
        if (isLeaf(root))
            postfix.enqueue(root);
        else{
            PostfixTree(root.getLeft());
            PostfixTree(root.getRight());
            postfix.enqueue(root);
        }
    }
  
    public Node[] PrintPostfix(){
        int i = 0;
        PostfixTree(root);
        Node[] output = new Node[postfix.size()];
        while(!postfix.isEmpty()){
            output[i++] = postfix.dequeue();
        }
        return output;
    }
    private double eval(Node root){
        if (isLeaf(root)){
            return Double.parseDouble(root.getValue());
        } else if(root.getValue().equals(""*"")){
            return eval(root.getLeft()) * eval(root.getRight());
        } else if (root.getValue().equals( ""+"" )) {
            return eval(root.getLeft()) + eval(root.getRight());
        } else if (root.getValue().equals( ""-"" )) {
            return eval(root.getLeft()) - eval(root.getRight());
        } else if (root.getValue().equals( ""/"" )) {
            return eval(root.getLeft()) / eval(root.getRight());
        }
        return Double.parseDouble(root.getValue());
  }
    

    public double Evaluation(){
        double answer = eval(root);
        return answer;
    }

    private boolean notOperand(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')';
    }
    
    private static boolean isLeaf(Node n) {
        return (n.getLeft() == null && n.getRight() == null);
    }
    
    public static void main(String[] args) {
         Expression s = new Expression();
         String test = ""(4+(((4*2)/2)/3))"";
         String[] output = s.mod(test);
         Node a = s.Infix2BT(test);
         Node[] b = s.PrintPostfix();
         System.out.println(a.getValue());
         System.out.println(s.Evaluation());
//         for(int i = 0; i < output.length; i++)
//         System.out.print(output[i].toString() + ""\n"");
    }
}

@28c289dcced77ca297bcc3b28eb51870@"
"r04522616","3","0.96","105856","@c034dd4c0ee7138f1bc5f851bc248a8a@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;

    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] prefix;
        if(root==null)
        {
            prefix=null;
        }
        else
        {
            int countNull=0;
            int length=((outData.length+1)/2);
            prefix = new Node[length];
            String[] copyOutData=new String[outData.length];
            for(int i=0;i<outData.length;i++)
            {
                if(outData[i]==null)
                {
                    countNull++;
                }            
            }
            for(int i=0;i<outData.length;i++)
            {
                copyOutData[i]=outData[countNull+i];
            }

            //String[] check=new String[length];
            for(int i=0;i<outData.length;i++)
            {
                char isANumber=copyOutData[i].charAt(0);
                if(Character.isDigit(isANumber)!=true && copyOutData[i].equals(""("")!=true && copyOutData[i].equals("")"")!=true)
                {
                    for(int j=i-1;j>=0;j--)
                    {
                        if(copyOutData[j].equals(""(""))
                        {
                            copyOutData[j]=copyOutData[i];
                            copyOutData[i]="")"";
                            break;
                        }
                    }
                }
            }
            String out = """";
            int a=0;
            for(int i=0;i<outData.length;i++)
            {
                if(copyOutData[i].equals("")"")!=true)
                {
                    out = copyOutData[i];
                    Node b=new Node(null,null,out);
                    prefix[i-a]=b;
                    //check[i-a]=out;
                }
                else if(copyOutData[i].equals("")"")==true)
                {
                    a++;
                }
            }

    //        int i=0;
    //        do
    //        {
    //            System.out.print(check[i]);
    //            i++;
    //        }
    //        while(i!=((outData.length+1)/2));
        }
        
        return prefix;
    }
    

  
    public Node[] PrintPostfix(){
        Node[] postfix;
        if(root==null)
        {
            postfix=null;
        }
        else
        {
            int length=((outData.length+1)/2);
            postfix = new Node[length];
            //String[] check=new String[length];

            int countNull=0;
            String[] copyOutData=new String[outData.length];
            for(int i=0;i<outData.length;i++)
            {
                if(outData[i]==null)
                {
                    countNull++;
                }
            }
            for(int i=0;i<outData.length;i++)
            {
                copyOutData[i]=outData[countNull+i];
            }

            Stack<String> stk=new Stack<String>();
            int j=0;
            for(int i=0;i<outData.length;i++)
            {            
                char isANumber=copyOutData[i].charAt(0);
                if(copyOutData[i].equals(""(""))
                {
                    j++;
                }
                else if(copyOutData[i].equals("")""))
                {
                    String symbol=stk.pop();
                    postfix[i-j]=new Node(null, null, symbol);
                    //check[i-j]=symbol;
                }
                else if(Character.isDigit(isANumber)!=true && copyOutData[i].equals(""("")!=true && copyOutData[i].equals("")"")!=true)
                {
                    j++;
                    stk.push(copyOutData[i]);
                }
                else
                {
                    Node a=new Node(null, null, copyOutData[i]);
                    postfix[i-j]=a;
                    //check[i-j]=copyOutData[i];
                }
            }
//        int i=0;
//        do
//        {
//            System.out.print(check[i]);
//            i++;
//        }
//        while(i!=((outData.length+1)/2));
//        System.out.print(""\n"");
        }
        
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@c034dd4c0ee7138f1bc5f851bc248a8a@"
"r03849033","5","0.49","105536","@d4e6ab3f82c83fdaf7a63c9f8fdc4dbf@public class Expression{
public Node root;
private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{	index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)	{	stack[++index] = a;	}
	public Node pop(){	return stack[index--];	}
	public Node now(){	return stack[index];	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        size=0;
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(""+"") || data[dd].equals(""-"") || data[dd].equals(""*"") || data[dd].equals(""/"")) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(""("")) {
            } else if (data[dd].equals("")"")) {
                if(s.index>1){
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
                }
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(""+"") ||prefix[i].getValue().equals(""-"") ||prefix[i].getValue().equals(""*"") ||prefix[i].getValue().equals(""/"")){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(""+"")){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""-"")){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""*"")){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""/"")){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }
}

@d4e6ab3f82c83fdaf7a63c9f8fdc4dbf@"
"r04631026","10","0.099","104304","@380eced3c5ad63b8b2332f4e4c8784cd@import java.io.BufferedReader;
import java.io.FileReader;

/*
* To change this license header, choose License Headers in Project Properties.
* To change this template file, choose Tools | Templates
* and open the template in the editor.
*/

/**
*
* @author Dennis
*/
public class Expression{

private Node root;
private int N;
Queue<Node> findmidqueue =new Queue<Node>();
Queue<Node> findleftqueue =new Queue<Node>();
Stack<String> findans =new Stack<String>();
// DO NOT MODIFY THIS
public Expression(){}

// Build a Binary and Return the Root
public Node Infix2BT(String infix){
String[] Num = infix.split("""");
Queue<String> numberqueue =new Queue<String>();
int count =0;

for(int i=1;i<Num.length;i++){

if(Num[i].equals(""("")){
numberqueue.enqueue(Num[i]);
count =i;

}else if( Num[i].equals("")"") || Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"") ){

String S1 =""""; 
for(int j=count+1;j<i;j++){
S1 = (S1+Num[j]).replace(""null"","""");
}
String S2 = S1.replace(""null"","""");

if( !( S2=="""" )){
// System.out.println(S1);
numberqueue.enqueue(S2);
}
numberqueue.enqueue(Num[i]);
count =i;

}else{

}
}
// System.out.println( numberqueue.size());
String[] Num2 =new String[numberqueue.size()];
for(int i=0;i<Num2.length;i++){
Num2[i]=numberqueue.dequeue();
}

Stack<Node> numsta =new Stack<Node> ();
Stack optsta =new Stack();
Stack<Node> nodesta =new Stack<Node>();
int N = Num2.length;
this.N=N;
Node[] Infnode =new Node[N/2+1];
int nodenum=0;

for(int i=0;i<N;i++){

// System.out.println( Num2[i]);
// System.out.println( Num2[i].equals(""*""));
if( Num2[i].equals(""+"") || Num2[i].equals(""-"") || Num2[i].equals(""*"") || Num2[i].equals(""/"")){
optsta.push(Num2[i]);

}else if( Num2[i].equals(""("")){

}else if( Num2[i].equals("")"")){
if(Num2[i-1].equals(""("") )
{
throw new NullPointerException(""NullPointerException"");
}
Infnode[0]=numsta.pop();
Infnode[1]=numsta.pop();
numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
}else{

numsta.push(new Node(null,null,Num2[i]));
}
}

root=numsta.peek();
this.root=root;

// System.out.println(root.getValue());

return root;
}

public Node[] PrintPrefix(){
Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findmid(rootnode[0]);
Node[] prefix = new Node[findmidqueue.size()];
int n=0;
while(!findmidqueue.isEmpty()){
prefix[n]=findmidqueue.dequeue();
n=n+1;
}
return prefix;
}

public Node findmid(Node x){
findmidqueue.enqueue(x);
// System.out.println(findmidqueue.peek().getValue()); 
if( !(x.getLeft()==null) ){
findmid(x.getLeft());
}
if( !(x.getRight()==null) ){
findmid(x.getRight());
}
return x;
}

public Node[] PrintPostfix(){
Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findleft(rootnode[0]);
Node[] postfix = new Node[findleftqueue.size()+1];
int n=0;
while(!findleftqueue.isEmpty()){
postfix[n]=findleftqueue.dequeue();
n=n+1;
}
postfix[n]=rootnode[0];
return postfix;
}

public Node findleft(Node x){

if( !(x.getLeft()==null) ){
findleft(x.getLeft());
findleftqueue.enqueue(x.getLeft());
// System.out.println(x.getLeft().getValue()); 
}
if( !(x.getRight()==null) ){
findleft(x.getRight());
findleftqueue.enqueue(x.getRight());
// System.out.println(x.getRight().getValue()); 
}
return x;
}

public double Evaluation(){

Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findleft(rootnode[0]);
Node[] postfix = new Node[findleftqueue.size()+1];
int n=0;
findleftqueue.enqueue( rootnode[0] );

// while(!findleftqueue.isEmpty()){
// postfix[n]=findleftqueue.dequeue();
// System.out.println(postfix[n].getValue());
// n=n+1;
// }

while( !findleftqueue.isEmpty() ){

findans.push(findleftqueue.dequeue().getValue());
if( findans.peek().equals(""+"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=a+b;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""-"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b-a;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""*"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b*a;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""/"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b/a;
String stringc = Double.toString(c);
findans.push(stringc);
}
}

double answer =Double.parseDouble( findans.peek());
return answer;

}

/**
* @param args the command line arguments
*/

public static void main(String[] args)throws Exception {
Node[] rootnode = new Node[1];
String problem =""(((0.235+0.88)*7.2)+(200+10))"";
Expression build = new Expression();
rootnode[0]=build.Infix2BT(problem);
System.out.println(build.Evaluation());
//
// 
for(int i=0;i<build.PrintPostfix().length;i++ ){
System.out.println(build.PrintPostfix()[i].getValue());
}

// System.out.println(rootnode[0].getRight().getValue());

}
}
@380eced3c5ad63b8b2332f4e4c8784cd@"
"r03849033","0","0.26","105504","@1c433121bf53ca76ff71a7783db96d97@public class Expression{
public Node root;
    public Expression(){}

    public Node Infix2BT(String infix){
    return root;
    }
 
    public Node[] PrintPrefix(){
    Node[] p =new Node[1];
    return p;
    }
  
    public Node[] PrintPostfix(){
    Node[] p =new Node[1];
    return p;
    }

    public double Evaluation(){
    return 1.0;

    }
}


@1c433121bf53ca76ff71a7783db96d97@"
"r04525016","9","0.86","105584","@a36d96f5d23cf8c221ffa5cca865a4a0@import java.util.ArrayList;
import java.util.Stack;
import java.util.stream.Collector;

/**
 * Created by cavitation on 2016/5/20.
 */
public class Expression {
    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        Stack<Node> symbol = new Stack<>();
        Stack<Node> values = new Stack<>();
        String vals = """";

        for (int i = 0; i < infix.length(); i++) {
            char temp = infix.charAt(i);
            if ((temp == '+') || (temp == '-') || (temp == '*') || (temp == '/')) {
                if (!vals.equals("""")) {
                    Node n = new Node(null, null, vals);
//                    System.out.println(n.getValue());
                    values.push(n);
                    vals = """";
                }
                String ops = temp + """";
                Node n2 = new Node(null, null, ops);
//                    System.out.println(n2.getValue());
                symbol.push(n2);

            } else if (temp == ')') {
                if (!vals.equals("""")) {

                    Node n = new Node(null, null, vals);
//                    System.out.println(n.getValue());
                    values.push(n);
                    vals = """";
                }
                Node rootTemp = symbol.pop();
//                    System.out.println(rootTemp.getValue());
                Node rightTemp = values.pop();
//                    System.out.println(rightTemp.getValue());
                rootTemp.setRight(rightTemp);
                Node leftTemp = values.pop();
//                    System.out.println(leftTemp.getValue());
                rootTemp.setLeft(leftTemp);
                values.push(rootTemp);
                root = rootTemp;
            } else if (temp != '(') {
                vals = vals + """" + temp;
            }
        }
        return root;
    }

    public Node[] PrintPrefix() {
        Node point = root;
        Stack<Node> rightVal = new Stack<>();
        ArrayList<Node> prefixTemp = new ArrayList<>();

        while (true) {
            prefixTemp.add(point);
            if (point.getLeft() != null) {
                if (point.getRight() != null) {
                    rightVal.push(point.getRight());
                }
                point = point.getLeft();
            } else {
                if (rightVal.isEmpty()) {
                    break;
                }
                point = rightVal.pop();
            }
        }
        Node[] prefix = new Node[prefixTemp.size()];
        for (int i = 0; i < prefixTemp.size(); i++) {
            prefix[i] = prefixTemp.get(i);
        }
        return prefix;
    }


    public Node[] PrintPostfix() {

        Node point = root;
        Node lastStop = null;
        Node peek;
        Stack<Node> pos = new Stack<>();
        ArrayList<Node> postfixTemp = new ArrayList<>();

        while (!pos.isEmpty() || point != null) {

            if (point != null) {
                pos.push(point);
                point = point.getLeft();

            } else {
                peek = pos.peek();
                if (peek.getRight() == null || peek.getRight() == lastStop) {
                    postfixTemp.add(peek);
                    lastStop = pos.pop();
                } else {
                    point = peek.getRight();
                }
            }
        }

//        for (Node e : postfixTemp) {
//            System.out.print(e.getValue() + "" "");
//        }


        Node[] postfix = new Node[postfixTemp.size()];

        for (int i = 0; i < postfixTemp.size(); i++) {
            postfix[i] = postfixTemp.get(i);
        }

        return postfix;
    }


    public double Evaluation() {

        Node[] postStr = PrintPostfix();
        Stack<Double> vals = new Stack<>();
        double vals1, vals2;

        for (int i = 0; i < postStr.length; i++) {
            String n = postStr[i].getValue();
            if (n.equals(""+"")) {
                vals1 = vals.pop();
                vals2 = vals.pop();
                vals.push(vals2 + vals1);

            } else if (n.equals(""-"")) {
                vals1 = vals.pop();
                vals2 = vals.pop();
                vals.push(vals2 - vals1);

            } else if (n.equals(""*"")) {
                vals1 = vals.pop();
                vals2 = vals.pop();
                vals.push(vals2 * vals1);

            } else if (n.equals(""/"")) {
                vals1 = vals.pop();
                vals2 = vals.pop();
                vals.push(vals2 / vals1);

            } else {
                vals.push(Double.parseDouble(n));
            }
        }


        double answer = vals.pop();
        return answer;
    }
}

@a36d96f5d23cf8c221ffa5cca865a4a0@"
"r03849033","0","0.09","98624","@4830f74bc097227a0cb401da9eabfe1d@public class Expression{
public Node root;
    public Expression(){}

    public Node Infix2BT(String infix){
    root.setValue(infix);
    return root;
    }
 
    public Node[] PrintPrefix(){
    Node[] p =new Node[1];
    return p;
    }
  
    public Node[] PrintPostfix(){
    Node[] p =new Node[1];
    return p;
    }

    public double Evaluation(){
    return Double.parseDouble(root.getValue());

    }
}

@4830f74bc097227a0cb401da9eabfe1d@"
"r04631046","10","0.1","105904","@380eced3c5ad63b8b2332f4e4c8784cd@import java.io.BufferedReader;
import java.io.FileReader;

/*
* To change this license header, choose License Headers in Project Properties.
* To change this template file, choose Tools | Templates
* and open the template in the editor.
*/

/**
*
* @author Dennis
*/
public class Expression{

private Node root;
private int N;
Queue<Node> findmidqueue =new Queue<Node>();
Queue<Node> findleftqueue =new Queue<Node>();
Stack<String> findans =new Stack<String>();
// DO NOT MODIFY THIS
public Expression(){}

// Build a Binary and Return the Root
public Node Infix2BT(String infix){
String[] Num = infix.split("""");
Queue<String> numberqueue =new Queue<String>();
int count =0;

for(int i=1;i<Num.length;i++){

if(Num[i].equals(""("")){
numberqueue.enqueue(Num[i]);
count =i;

}else if( Num[i].equals("")"") || Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"") ){

String S1 =""""; 
for(int j=count+1;j<i;j++){
S1 = (S1+Num[j]).replace(""null"","""");
}
String S2 = S1.replace(""null"","""");

if( !( S2=="""" )){
// System.out.println(S1);
numberqueue.enqueue(S2);
}
numberqueue.enqueue(Num[i]);
count =i;

}else{

}
}
// System.out.println( numberqueue.size());
String[] Num2 =new String[numberqueue.size()];
for(int i=0;i<Num2.length;i++){
Num2[i]=numberqueue.dequeue();
}

Stack<Node> numsta =new Stack<Node> ();
Stack optsta =new Stack();
Stack<Node> nodesta =new Stack<Node>();
int N = Num2.length;
this.N=N;
Node[] Infnode =new Node[N/2+1];
int nodenum=0;

for(int i=0;i<N;i++){

// System.out.println( Num2[i]);
// System.out.println( Num2[i].equals(""*""));
if( Num2[i].equals(""+"") || Num2[i].equals(""-"") || Num2[i].equals(""*"") || Num2[i].equals(""/"")){
optsta.push(Num2[i]);

}else if( Num2[i].equals(""("")){

}else if( Num2[i].equals("")"")){
if(Num2[i-1].equals(""("") )
{
throw new NullPointerException(""NullPointerException"");
}
Infnode[0]=numsta.pop();
Infnode[1]=numsta.pop();
numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
}else{

numsta.push(new Node(null,null,Num2[i]));
}
}

root=numsta.peek();
this.root=root;

// System.out.println(root.getValue());

return root;
}

public Node[] PrintPrefix(){
Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findmid(rootnode[0]);
Node[] prefix = new Node[findmidqueue.size()];
int n=0;
while(!findmidqueue.isEmpty()){
prefix[n]=findmidqueue.dequeue();
n=n+1;
}
return prefix;
}

public Node findmid(Node x){
findmidqueue.enqueue(x);
// System.out.println(findmidqueue.peek().getValue()); 
if( !(x.getLeft()==null) ){
findmid(x.getLeft());
}
if( !(x.getRight()==null) ){
findmid(x.getRight());
}
return x;
}

public Node[] PrintPostfix(){
Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findleft(rootnode[0]);
Node[] postfix = new Node[findleftqueue.size()+1];
int n=0;
while(!findleftqueue.isEmpty()){
postfix[n]=findleftqueue.dequeue();
n=n+1;
}
postfix[n]=rootnode[0];
return postfix;
}

public Node findleft(Node x){

if( !(x.getLeft()==null) ){
findleft(x.getLeft());
findleftqueue.enqueue(x.getLeft());
// System.out.println(x.getLeft().getValue()); 
}
if( !(x.getRight()==null) ){
findleft(x.getRight());
findleftqueue.enqueue(x.getRight());
// System.out.println(x.getRight().getValue()); 
}
return x;
}

public double Evaluation(){

Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findleft(rootnode[0]);
Node[] postfix = new Node[findleftqueue.size()+1];
int n=0;
findleftqueue.enqueue( rootnode[0] );

// while(!findleftqueue.isEmpty()){
// postfix[n]=findleftqueue.dequeue();
// System.out.println(postfix[n].getValue());
// n=n+1;
// }

while( !findleftqueue.isEmpty() ){

findans.push(findleftqueue.dequeue().getValue());
if( findans.peek().equals(""+"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=a+b;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""-"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b-a;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""*"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b*a;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""/"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b/a;
String stringc = Double.toString(c);
findans.push(stringc);
}
}

double answer =Double.parseDouble( findans.peek());
return answer;

}

/**
* @param args the command line arguments
*/

public static void main(String[] args)throws Exception {
Node[] rootnode = new Node[1];
String problem =""(((0.235+0.88)*7.2)+(200+10))"";
Expression build = new Expression();
rootnode[0]=build.Infix2BT(problem);
System.out.println(build.Evaluation());
//
// 
for(int i=0;i<build.PrintPostfix().length;i++ ){
System.out.println(build.PrintPostfix()[i].getValue());
}

// System.out.println(rootnode[0].getRight().getValue());

}
}
@380eced3c5ad63b8b2332f4e4c8784cd@"
"r04631031","10","0.097","105968","@380eced3c5ad63b8b2332f4e4c8784cd@import java.io.BufferedReader;
import java.io.FileReader;

/*
* To change this license header, choose License Headers in Project Properties.
* To change this template file, choose Tools | Templates
* and open the template in the editor.
*/

/**
*
* @author Dennis
*/
public class Expression{

private Node root;
private int N;
Queue<Node> findmidqueue =new Queue<Node>();
Queue<Node> findleftqueue =new Queue<Node>();
Stack<String> findans =new Stack<String>();
// DO NOT MODIFY THIS
public Expression(){}

// Build a Binary and Return the Root
public Node Infix2BT(String infix){
String[] Num = infix.split("""");
Queue<String> numberqueue =new Queue<String>();
int count =0;

for(int i=1;i<Num.length;i++){

if(Num[i].equals(""("")){
numberqueue.enqueue(Num[i]);
count =i;

}else if( Num[i].equals("")"") || Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"") ){

String S1 =""""; 
for(int j=count+1;j<i;j++){
S1 = (S1+Num[j]).replace(""null"","""");
}
String S2 = S1.replace(""null"","""");

if( !( S2=="""" )){
// System.out.println(S1);
numberqueue.enqueue(S2);
}
numberqueue.enqueue(Num[i]);
count =i;

}else{

}
}
// System.out.println( numberqueue.size());
String[] Num2 =new String[numberqueue.size()];
for(int i=0;i<Num2.length;i++){
Num2[i]=numberqueue.dequeue();
}

Stack<Node> numsta =new Stack<Node> ();
Stack optsta =new Stack();
Stack<Node> nodesta =new Stack<Node>();
int N = Num2.length;
this.N=N;
Node[] Infnode =new Node[N/2+1];
int nodenum=0;

for(int i=0;i<N;i++){

// System.out.println( Num2[i]);
// System.out.println( Num2[i].equals(""*""));
if( Num2[i].equals(""+"") || Num2[i].equals(""-"") || Num2[i].equals(""*"") || Num2[i].equals(""/"")){
optsta.push(Num2[i]);

}else if( Num2[i].equals(""("")){

}else if( Num2[i].equals("")"")){
if(Num2[i-1].equals(""("") )
{
throw new NullPointerException(""NullPointerException"");
}
Infnode[0]=numsta.pop();
Infnode[1]=numsta.pop();
numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
}else{

numsta.push(new Node(null,null,Num2[i]));
}
}

root=numsta.peek();
this.root=root;

// System.out.println(root.getValue());

return root;
}

public Node[] PrintPrefix(){
Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findmid(rootnode[0]);
Node[] prefix = new Node[findmidqueue.size()];
int n=0;
while(!findmidqueue.isEmpty()){
prefix[n]=findmidqueue.dequeue();
n=n+1;
}
return prefix;
}

public Node findmid(Node x){
findmidqueue.enqueue(x);
// System.out.println(findmidqueue.peek().getValue()); 
if( !(x.getLeft()==null) ){
findmid(x.getLeft());
}
if( !(x.getRight()==null) ){
findmid(x.getRight());
}
return x;
}

public Node[] PrintPostfix(){
Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findleft(rootnode[0]);
Node[] postfix = new Node[findleftqueue.size()+1];
int n=0;
while(!findleftqueue.isEmpty()){
postfix[n]=findleftqueue.dequeue();
n=n+1;
}
postfix[n]=rootnode[0];
return postfix;
}

public Node findleft(Node x){

if( !(x.getLeft()==null) ){
findleft(x.getLeft());
findleftqueue.enqueue(x.getLeft());
// System.out.println(x.getLeft().getValue()); 
}
if( !(x.getRight()==null) ){
findleft(x.getRight());
findleftqueue.enqueue(x.getRight());
// System.out.println(x.getRight().getValue()); 
}
return x;
}

public double Evaluation(){

Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findleft(rootnode[0]);
Node[] postfix = new Node[findleftqueue.size()+1];
int n=0;
findleftqueue.enqueue( rootnode[0] );

// while(!findleftqueue.isEmpty()){
// postfix[n]=findleftqueue.dequeue();
// System.out.println(postfix[n].getValue());
// n=n+1;
// }

while( !findleftqueue.isEmpty() ){

findans.push(findleftqueue.dequeue().getValue());
if( findans.peek().equals(""+"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=a+b;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""-"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b-a;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""*"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b*a;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""/"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b/a;
String stringc = Double.toString(c);
findans.push(stringc);
}
}

double answer =Double.parseDouble( findans.peek());
return answer;

}

/**
* @param args the command line arguments
*/

public static void main(String[] args)throws Exception {
Node[] rootnode = new Node[1];
String problem =""(((0.235+0.88)*7.2)+(200+10))"";
Expression build = new Expression();
rootnode[0]=build.Infix2BT(problem);
System.out.println(build.Evaluation());
//
// 
for(int i=0;i<build.PrintPostfix().length;i++ ){
System.out.println(build.PrintPostfix()[i].getValue());
}

// System.out.println(rootnode[0].getRight().getValue());

}
}
@380eced3c5ad63b8b2332f4e4c8784cd@"
"r04525016","10","0.096","105536","@8681d018fd9a7e250b0bafdf73b1f1bc@import java.util.ArrayList;
import java.util.Stack;
import java.util.stream.Collector;

/**
 * Created by cavitation on 2016/5/20.
 */
public class Expression {
    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        Stack<Node> symbol = new Stack<>();
        Stack<Node> values = new Stack<>();
        String vals = """";

        for (int i = 0; i < infix.length(); i++) {
            char temp = infix.charAt(i);
            if ((temp == '+') || (temp == '-') || (temp == '*') || (temp == '/')) {
                if (!vals.equals("""")) {
                    Node n = new Node(null, null, vals);
//                    System.out.println(n.getValue());
                    values.push(n);
                    vals = """";
                }
                String ops = temp + """";
                Node n2 = new Node(null, null, ops);
//                    System.out.println(n2.getValue());
                symbol.push(n2);

            } else if (temp == ')') {
                if (!vals.equals("""")) {

                    Node n = new Node(null, null, vals);
//                    System.out.println(n.getValue());
                    values.push(n);
                    vals = """";
                }
                Node rootTemp = symbol.pop();
//                    System.out.println(rootTemp.getValue());
                Node rightTemp = values.pop();
//                    System.out.println(rightTemp.getValue());
                rootTemp.setRight(rightTemp);
                Node leftTemp = values.pop();
//                    System.out.println(leftTemp.getValue());
                rootTemp.setLeft(leftTemp);
                values.push(rootTemp);
                root = rootTemp;
            } else if (temp != '(') {
                vals = vals + """" + temp;
            }
        }
        return root;
    }

    public Node[] PrintPrefix() {
        if (root == null) {
            throw new NullPointerException();
        }
        Node point = root;
        Stack<Node> rightVal = new Stack<>();
        ArrayList<Node> prefixTemp = new ArrayList<>();

        while (true) {
            prefixTemp.add(point);
            if (point.getLeft() != null) {
                if (point.getRight() != null) {
                    rightVal.push(point.getRight());
                }
                point = point.getLeft();
            } else {
                if (rightVal.isEmpty()) {
                    break;
                }
                point = rightVal.pop();
            }
        }
        Node[] prefix = new Node[prefixTemp.size()];
        for (int i = 0; i < prefixTemp.size(); i++) {
            prefix[i] = prefixTemp.get(i);
        }
        return prefix;
    }


    public Node[] PrintPostfix() {
        if (root == null) {
            throw new NullPointerException();
        }
        Node point = root;
        Node lastStop = null;
        Node peek;
        Stack<Node> pos = new Stack<>();
        ArrayList<Node> postfixTemp = new ArrayList<>();

        while (!pos.isEmpty() || point != null) {

            if (point != null) {
                pos.push(point);
                point = point.getLeft();

            } else {
                peek = pos.peek();
                if (peek.getRight() == null || peek.getRight() == lastStop) {
                    postfixTemp.add(peek);
                    lastStop = pos.pop();
                } else {
                    point = peek.getRight();
                }
            }
        }

//        for (Node e : postfixTemp) {
//            System.out.print(e.getValue() + "" "");
//        }


        Node[] postfix = new Node[postfixTemp.size()];

        for (int i = 0; i < postfixTemp.size(); i++) {
            postfix[i] = postfixTemp.get(i);
        }

        return postfix;
    }


    public double Evaluation() {
        if (root == null) {
            throw new NullPointerException();
        }
        Node[] postStr = PrintPostfix();
        Stack<Double> vals = new Stack<>();
        double vals1, vals2;

        for (int i = 0; i < postStr.length; i++) {
            String n = postStr[i].getValue();
            if (n.equals(""+"")) {
                vals1 = vals.pop();
                vals2 = vals.pop();
                vals.push(vals2 + vals1);

            } else if (n.equals(""-"")) {
                vals1 = vals.pop();
                vals2 = vals.pop();
                vals.push(vals2 - vals1);

            } else if (n.equals(""*"")) {
                vals1 = vals.pop();
                vals2 = vals.pop();
                vals.push(vals2 * vals1);

            } else if (n.equals(""/"")) {
                vals1 = vals.pop();
                vals2 = vals.pop();
                vals.push(vals2 / vals1);

            } else {
                vals.push(Double.parseDouble(n));
            }
        }


        double answer = vals.pop();
        return answer;
    }
}

@8681d018fd9a7e250b0bafdf73b1f1bc@"
"f02631008","10","0.096","105488","@cb8c302f1365b82cdcfb11d101a33e54@
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class Expression{
  
    private Node root;

    // DO NOT MODIFY THIS
    public Expression(){}
    
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        Stack<Node> ops = new Stack<Node>();
        Stack<Node> vals = new Stack<Node>();
        String tot = """";
        for(int i = 0 ; i < infix.length() ; i++){
            char j = infix.charAt(i);
            switch (j){
                case '(':
                    tot = """";
                    break;
                case '-':
                case '+':
                case '*':
                case '/':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    ops.push(new Node(null , null , j + """"));
                    break;
                case ')':
                    if(!tot.equals("""")){
                    vals.push(new Node(null , null , tot));
                    }
                    tot = """";
                    Node num01 = vals.pop();
                    Node num02 = vals.pop();
                    Node cal = ops.pop();
                    cal.setLeft(num02);
                    cal.setRight(num01);
                    root = cal;
                    vals.push(cal);
                    break;
                    
                default:
                    tot +=j;
            }
        }
         
        return root;
    }

    public Node[] PrintPrefix(){
        if(root == null) throw new NullPointerException();
        List<Node> prefix = new ArrayList<Node>();
        PrintPrefixRecusive(prefix, root);
        return prefix.toArray(new Node[prefix.size()]);
    }
    
    public void PrintPrefixRecusive(List<Node> p, Node root){
        if(root==null) return;
        p.add(root);
        PrintPrefixRecusive(p, root.getLeft());
        PrintPrefixRecusive(p, root.getRight());
    }
  
    public Node[] PrintPostfix(){
        if(root == null) throw new NullPointerException();
        List<Node> postfix = new ArrayList<Node>();
        PrintPostfixRecusive(postfix, root);
        return postfix.toArray(new Node[postfix.size()]);
    }
    public void PrintPostfixRecusive(List<Node> p, Node root){
        if(root==null) return;
        
        PrintPostfixRecusive(p, root.getLeft());
        PrintPostfixRecusive(p, root.getRight());
        p.add(root);
//        p.add(root);
    }
    

    public double Evaluation(){
        if(root == null) throw new NullPointerException();
        Node[] eva = this.PrintPostfix();
        Stack<Double> evalue = new Stack<Double>();
        for(Node n:eva){
            String in = n.getValue();
            if(in.equals(""+"")){
                evalue.push(evalue.pop()+evalue.pop());
            } else if(in.equals(""-"")){
                evalue.push(-evalue.pop()+evalue.pop());
            } else if(in.equals(""*"")){
                evalue.push(evalue.pop()*evalue.pop());
            } else if(in.equals(""/"")){
                evalue.push(1/evalue.pop()*evalue.pop());
            } else {
                evalue.push(Double.parseDouble(in));
            }
            
        }
        return evalue.pop();
    }
}

@cb8c302f1365b82cdcfb11d101a33e54@"
"b02611028","6","1.04","105680","@b1894211b837cb908023f721ba8e2778@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Collections;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        Stack<String> s = new Stack<String>();
        Stack<Node> node = new Stack<Node>();
        for (int i = 0; i < infix.split("""").length; i++) {
            String c = infix.split("""")[i];
            s.push(c);
            if (s.iterator().next().equals("")"")) {
                s.pop();
                ArrayList<String> ccc = new ArrayList<String>();
                int j = 0;
                while (true) {
                    String n = s.pop();
                    //System.out.print(n);
                    ccc.add(n);
                    if (ccc.get(j).equals(""+"") || ccc.get(j).equals(""-"") || ccc.get(j).equals(""*"") || ccc.get(j).equals(""/"")) {
                        //System.out.print(ccc.get(j));
                        break;
                    }
                    j = j + 1;
                }
                String ope = ccc.remove(j);

                String listString = """";
                Collections.reverse(ccc);

                StringBuilder sb = new StringBuilder();
                for (String buffer : ccc) {
                    sb.append(buffer);
                    //sb.append(""\t"");
                }
                listString=sb.toString();
                 
                //System.out.print(listString);
                Node right = new Node(null, null, listString);

                ArrayList<String> bbb = new ArrayList<String>();
                j = 0;
                while (true) {
                    String ssss = s.pop();

                    bbb.add(ssss);
                    if (bbb.get(j).equals(""("")) {

                        break;
                    }
                    j = j + 1;
                }
                bbb.remove(j);
                listString = """";
                Collections.reverse(bbb);
                
                StringBuilder ssb = new StringBuilder();
                for (String buffer : bbb) {
                    ssb.append(buffer);
                    //sb.append(""\t"");
                }
                listString=ssb.toString();
                
                

                Node left = new Node(null, null, listString);
                Node top = new Node(left, right, ope);

                s.push(""00"");
                node.push(top);
            }
        }
        Node n = node.pop();
        root = n;

        while (!node.isEmpty()) {
            Node nn = node.pop();
            if (n.getLeft().getValue().equals(""00"")) {

                n.setLeft(nn);

            } else if (n.getRight().getValue().equals(""00"")) {

                n.setRight(nn);
                //System.out.print(n.getRight().getValue());
                //System.out.print(nn.getValue());
            }

            n = nn;
            
        }

        return root;
    }

    public Node[] PrintPrefix() {
        Node n=root;
        Stack<Node> s=new Stack<Node>();
        LinkedQueue<Node> q = new LinkedQueue<Node>();
        
        while(true){
            if(n.getLeft()!=null){
                s.push(n);
                q.enqueue(n);
                Node nn=n.getLeft();
                n=nn;
            }else{
                q.enqueue(n);
                if(s.isEmpty())break;
                n=s.pop();
                n=n.getRight();
            }
        }
        
        Node[] prefix = new Node[q.size()];
        int len=q.size();
        for(int i=0;i<len;i++){
            prefix[i]=q.dequeue();
        }
        return prefix;
    }

    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[PrintPrefix().length];
//        Queue<Node> q = new LinkedList<>();
        LinkedQueue<Node> q=new LinkedQueue<>();
        post(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            postfix[i]=q.dequeue();
        }
        return postfix;
    }

    private void post(Node node, LinkedQueue<Node> q){
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        post(node.getLeft(), q);
        post(node.getRight(), q);
        q.enqueue(node);
        return;
    }
    
    
    
    public double Evaluation() {
        Node[] n=PrintPostfix();
        ArrayList<String> calarray=new ArrayList<String>();
        for(int i=0;i<n.length;i++){
            calarray.add(n[i].getValue());
        }
        int i=0;
        while(calarray.size()!=1){
            if(calarray.get(i).equals(""+"")||calarray.get(i).equals(""-"")||calarray.get(i).equals(""*"")||calarray.get(i).equals(""/"")){
                Double d1= Double.parseDouble(calarray.get(i-1));
                Double d2= Double.parseDouble(calarray.get(i-2));
                Double ans=0.0;
                if(""+"".equals(calarray.get(i))){
                    ans=d2+d1;
                }
                if(""-"".equals(calarray.get(i))){
                    ans=d2-d1;
                }
                if(""*"".equals(calarray.get(i))){
                    ans=d2*d1;
                }
                if(""/"".equals(calarray.get(i))){
                    ans=d2/d1;
                }
                String aa=String.valueOf(ans);
                calarray.remove(i-2);
                calarray.remove(i-2);
                calarray.remove(i-2);
                calarray.add(i-2, aa);
                i=i-2;
            }
            i=i+1;
        }
        
        
        double answer = Double.parseDouble(calarray.get(0));
        return answer;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            Expression expression = new Expression();
            String infix = br.readLine();
            expression.Infix2BT(infix);
            Node n1[] = expression.PrintPostfix();
            Node n2[] = expression.PrintPrefix();
            
             for (int i = 0; i < n1.length; i++) {
             System.out.print(n1[i].getValue()+"" "");
             }
             System.out.println(""\n"");
             for (int i = 0; i < n2.length; i++) {
             System.out.print(n2[i].getValue()+"" "");
             }
             System.out.println(""\n"");
             System.out.println(expression.Evaluation());

//            expression.Infix2BT(infix);
//            Expression expression2= new Expression();
//            expression2.Infix2BT(""(4+(((4*2)/2)/3))"");
//            Node n3[]=expression2.PrintPostfix();
//            for (int i = 0; i < n3.length; i++) {
//                System.out.print(n3[i].getValue()+"" "");
//            }
        }
    }
}

@b1894211b837cb908023f721ba8e2778@"
"b02611028","6","1","109056","@1b5ade7a8bfaabb4340edd810be86fcc@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Collections;

public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {
        Stack<String> s = new Stack<String>();
        Stack<Node> node = new Stack<Node>();
        for (int i = 0; i < infix.split("""").length; i++) {
            String c = infix.split("""")[i];
            s.push(c);
            if (s.iterator().next().equals("")"")) {
                s.pop();
                ArrayList<String> ccc = new ArrayList<String>();
                int j = 0;
                while (true) {
                    String n = s.pop();
                    //System.out.print(n);
                    ccc.add(n);
                    if (ccc.get(j).equals(""+"") || ccc.get(j).equals(""-"") || ccc.get(j).equals(""*"") || ccc.get(j).equals(""/"")) {
                        //System.out.print(ccc.get(j));
                        break;
                    }
                    j = j + 1;
                }
                String ope = ccc.remove(j);

                String listString = """";
                Collections.reverse(ccc);

                StringBuilder sb = new StringBuilder();
                for (String buffer : ccc) {
                    sb.append(buffer);
                    //sb.append(""\t"");
                }
                listString=sb.toString();
                 
                //System.out.print(listString);
                Node right = new Node(null, null, listString);

                ArrayList<String> bbb = new ArrayList<String>();
                j = 0;
                while (true) {
                    String ssss = s.pop();

                    bbb.add(ssss);
                    if (bbb.get(j).equals(""("")) {

                        break;
                    }
                    j = j + 1;
                }
                bbb.remove(j);
                listString = """";
                Collections.reverse(bbb);
                
                StringBuilder ssb = new StringBuilder();
                for (String buffer : bbb) {
                    ssb.append(buffer);
                    //sb.append(""\t"");
                }
                listString=ssb.toString();
                
                

                Node left = new Node(null, null, listString);
                Node top = new Node(left, right, ope);

                s.push(""00"");
                node.push(top);
            }
        }
        Node n = node.pop();
        root = n;

        while (!node.isEmpty()) {
            Node nn = node.pop();
            if (n.getLeft().getValue().equals(""00"")) {

                n.setLeft(nn);

            } else if (n.getRight().getValue().equals(""00"")) {

                n.setRight(nn);
                //System.out.print(n.getRight().getValue());
                //System.out.print(nn.getValue());
            }

            n = nn;
            
        }

        return root;
    }

    public Node[] PrintPrefix() {
        if(root==null) throw new NullPointerException();
        Node n=root;
        Stack<Node> s=new Stack<Node>();
        LinkedQueue<Node> q = new LinkedQueue<Node>();
        
        while(true){
            if(n.getLeft()!=null){
                s.push(n);
                q.enqueue(n);
                Node nn=n.getLeft();
                n=nn;
            }else{
                q.enqueue(n);
                if(s.isEmpty())break;
                n=s.pop();
                n=n.getRight();
            }
        }
        
        Node[] prefix = new Node[q.size()];
        int len=q.size();
        for(int i=0;i<len;i++){
            prefix[i]=q.dequeue();
        }
        return prefix;
    }

    public Node[] PrintPostfix(){
        if(root==null) throw new NullPointerException();
        Node[] postfix = new Node[PrintPrefix().length];
//        Queue<Node> q = new LinkedList<>();
        LinkedQueue<Node> q=new LinkedQueue<>();
        post(root,q);
        int n=q.size();
        for (int i = 0; i < n; i++) {
            postfix[i]=q.dequeue();
        }
        return postfix;
    }

    private void post(Node node, LinkedQueue<Node> q){
        if(node.getLeft()==null && node.getRight()==null){
            q.enqueue(node);
            return;
        }
        post(node.getLeft(), q);
        post(node.getRight(), q);
        q.enqueue(node);
        return;
    }
    
    
    
    public double Evaluation() {
        if(root==null) throw new NullPointerException();
        Node[] n=PrintPostfix();
        ArrayList<String> calarray=new ArrayList<String>();
        for(int i=0;i<n.length;i++){
            calarray.add(n[i].getValue());
        }
        int i=0;
        while(calarray.size()!=1){
            if(calarray.get(i).equals(""+"")||calarray.get(i).equals(""-"")||calarray.get(i).equals(""*"")||calarray.get(i).equals(""/"")){
                Double d1= Double.parseDouble(calarray.get(i-1));
                Double d2= Double.parseDouble(calarray.get(i-2));
                Double ans=0.0;
                if(""+"".equals(calarray.get(i))){
                    ans=d2+d1;
                }
                if(""-"".equals(calarray.get(i))){
                    ans=d2-d1;
                }
                if(""*"".equals(calarray.get(i))){
                    ans=d2*d1;
                }
                if(""/"".equals(calarray.get(i))){
                    ans=d2/d1;
                }
                String aa=String.valueOf(ans);
                calarray.remove(i-2);
                calarray.remove(i-2);
                calarray.remove(i-2);
                calarray.add(i-2, aa);
                i=i-2;
            }
            i=i+1;
        }
        
        
        double answer = Double.parseDouble(calarray.get(0));
        return answer;
    }

    public static void main(String[] args) throws Exception {
        try (BufferedReader br = new BufferedReader(new FileReader(""input.txt""))) {
            Expression expression = new Expression();
            String infix = br.readLine();
            expression.Infix2BT(infix);
            Node n1[] = expression.PrintPostfix();
            Node n2[] = expression.PrintPrefix();
            
             for (int i = 0; i < n1.length; i++) {
             System.out.print(n1[i].getValue()+"" "");
             }
             System.out.println(""\n"");
             for (int i = 0; i < n2.length; i++) {
             System.out.print(n2[i].getValue()+"" "");
             }
             System.out.println(""\n"");
             System.out.println(expression.Evaluation());

//            expression.Infix2BT(infix);
//            Expression expression2= new Expression();
//            expression2.Infix2BT(""(4+(((4*2)/2)/3))"");
//            Node n3[]=expression2.PrintPostfix();
//            for (int i = 0; i < n3.length; i++) {
//                System.out.print(n3[i].getValue()+"" "");
//            }
        }
    }
}

@1b5ade7a8bfaabb4340edd810be86fcc@"
"r04945008","10","0.098","105904","@8250701817cee82e011ec741660865ed@public class Expression{
  
    private Node root;
    final static Queue<Node> prefix = new Queue<Node>();
    final static Queue<Node> postfix = new Queue<Node>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        final Stack<Node> nodes = new Stack<Node>();
        String[] str = mod(infix);
        for (int i = 0; i < str.length; i++) {
            String temp  = str[i];
            if(temp.equals(""("")){
            }
            else if(temp.equals("")"")){
                Node rightNode = nodes.pop();
                String op = nodes.pop().getValue();
                Node leftNode = nodes.pop();
                nodes.push(new Node(leftNode, rightNode, op));
            }
            else{
                nodes.push(new Node(null, null, temp));
            }
        }
        root = nodes.pop();
        return root;
    }

    public String[] mod(String str){
        String[] output = new String[str.length()];
        String value = """";
        int k = 0;
        int size = 0;
        for (int i = 0; i < str.length(); i++) {
            char temp  = str.charAt(i);
            if(!notOperand(temp)){
                value += temp;
            }
            else{
                if(value != """"){
                    output[k++] = value;
                    value = """";
                }
                output[k++] = String.valueOf(temp);
            }
        }
        for(int i = 0; i < output.length; i++)
            if(output[i] != null)
                size++;
        String[] finaloutput = new String[size];
        k = 0;
        for(int i = 0; i < output.length; i++)
            if(output[i] != null)
                finaloutput[k++] = output[i];
        return finaloutput;
    }
    
    private static void PrefixTree(Node root) {
        if (isLeaf(root))
            prefix.enqueue(root);
        else {
            prefix.enqueue(root);
            PrefixTree(root.getLeft());
            PrefixTree(root.getRight());
        }
    }

    public Node[] PrintPrefix(){
        int i = 0;
        PrefixTree(root);
        Node[] output = new Node[prefix.size()];
        while(!prefix.isEmpty()){
            output[i++] = prefix.dequeue();
        }
        return output;
    }
    
    private static void PostfixTree(Node root) {
        if (isLeaf(root))
            postfix.enqueue(root);
        else{
            PostfixTree(root.getLeft());
            PostfixTree(root.getRight());
            postfix.enqueue(root);
        }
    }
  
    public Node[] PrintPostfix(){
        int i = 0;
        PostfixTree(root);
        Node[] output = new Node[postfix.size()];
        while(!postfix.isEmpty()){
            output[i++] = postfix.dequeue();
        }
        return output;
    }
    private double eval(Node root){
        if (isLeaf(root)){
            return Double.parseDouble(root.getValue());
        } else if(root.getValue().equals(""*"")){
            return eval(root.getLeft()) * eval(root.getRight());
        } else if (root.getValue().equals( ""+"" )) {
            return eval(root.getLeft()) + eval(root.getRight());
        } else if (root.getValue().equals( ""-"" )) {
            return eval(root.getLeft()) - eval(root.getRight());
        } else if (root.getValue().equals( ""/"" )) {
            return eval(root.getLeft()) / eval(root.getRight());
        }
        return Double.parseDouble(root.getValue());
  }
    

    public double Evaluation(){
        double answer = eval(root);
        return answer;
    }

    private boolean notOperand(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/' || c == '(' || c == ')';
    }
    
    private static boolean isLeaf(Node n) {
        return (n.getLeft() == null && n.getRight() == null);
    }
    
    public static void main(String[] args) {
         Expression s = new Expression();
         String test = ""(4+(((4*2)/2)/3))"";
         String[] output = s.mod(test);
         Node a = s.Infix2BT(test);
         Node[] b = s.PrintPostfix();
         System.out.println(a.getValue());
         System.out.println(s.Evaluation());
//         for(int i = 0; i < output.length; i++)
//         System.out.print(output[i].toString() + ""\n"");
    }
}

@8250701817cee82e011ec741660865ed@"
"r04631041","10","0.098","105904","@a45ed58f5f61fb85ea1bd5a065e98a3c@import java.io.BufferedReader;
import java.io.FileReader;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Dennis
 */
public class Expression{
  
    private Node root;
    private int N;
    Queue<Node> findmidqueue =new Queue<Node>();
    Queue<Node> findleftqueue =new Queue<Node>();
    Stack<String> findans =new Stack<String>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String[] Num = infix.split("""");
        Queue<String> numberqueue =new Queue<String>();
        int count =0;

        for(int i=1;i<Num.length;i++){
            
            if(Num[i].equals(""("")){
            numberqueue.enqueue(Num[i]);
            count =i;
            
            }else if( Num[i].equals("")"") || Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"") ){

                String S1 =""""; 
                for(int j=count+1;j<i;j++){
                    S1 = (S1+Num[j]).replace(""null"","""");
                }
                String  S2 = S1.replace(""null"","""");
                  
                  if( !( S2=="""" )){
//                    System.out.println(S1);
                      numberqueue.enqueue(S2);
                  }
                numberqueue.enqueue(Num[i]);
                count =i;
                
            }else{

            }
        }
//        System.out.println( numberqueue.size());
        String[] Num2 =new String[numberqueue.size()];
        for(int i=0;i<Num2.length;i++){
            Num2[i]=numberqueue.dequeue();
        }

        Stack<Node>  numsta =new Stack<Node> ();
        Stack optsta =new Stack();
        Stack<Node> nodesta =new Stack<Node>();
        int N = Num2.length;
        this.N=N;
        Node[] Infnode =new Node[N/2+1];
        int nodenum=0;

          for(int i=0;i<N;i++){
              
//              System.out.println( Num2[i]);
//              System.out.println( Num2[i].equals(""*""));
              if( Num2[i].equals(""+"") || Num2[i].equals(""-"") || Num2[i].equals(""*"") || Num2[i].equals(""/"")){
                  optsta.push(Num2[i]);
                  
               }else if( Num2[i].equals(""("")){

               }else if( Num2[i].equals("")"")){
                  if(Num2[i-1].equals(""("") )
                    {
                       throw new NullPointerException(""NullPointerException"");
                    }
                   Infnode[0]=numsta.pop();
                   Infnode[1]=numsta.pop();
                   numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
               }else{

                  numsta.push(new Node(null,null,Num2[i]));
              }
          }
          
        root=numsta.peek();
        this.root=root;
        
//        System.out.println(root.getValue());
        
        return root;
    }

    public Node[] PrintPrefix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findmid(rootnode[0]);
        Node[] prefix = new Node[findmidqueue.size()];
        int n=0;
        while(!findmidqueue.isEmpty()){
           prefix[n]=findmidqueue.dequeue();
           n=n+1;
       }
        return prefix;
    }
    
        public Node findmid(Node x){
            findmidqueue.enqueue(x);
//            System.out.println(findmidqueue.peek().getValue()); 
            if( !(x.getLeft()==null) ){
                    findmid(x.getLeft());
            }
            if( !(x.getRight()==null) ){
                    findmid(x.getRight());
            }
        return x;
    }
  
    public Node[] PrintPostfix(){
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        while(!findleftqueue.isEmpty()){
           postfix[n]=findleftqueue.dequeue();
           n=n+1;
       }
          postfix[n]=rootnode[0];
        return postfix;
    }
    
    public Node findleft(Node x){
           
            if( !(x.getLeft()==null) ){
                    findleft(x.getLeft());
                     findleftqueue.enqueue(x.getLeft());
//                    System.out.println(x.getLeft().getValue()); 
            }
            if( !(x.getRight()==null) ){
                    findleft(x.getRight());
                    findleftqueue.enqueue(x.getRight());
//                    System.out.println(x.getRight().getValue()); 
            }
        return x;
    }
    
    public double Evaluation(){
        
        Node[] rootnode = new Node[1];
        rootnode[0]=this.root;
        findleft(rootnode[0]);
        Node[] postfix = new Node[findleftqueue.size()+1];
        int n=0;
        findleftqueue.enqueue( rootnode[0] );
        
//        while(!findleftqueue.isEmpty()){
//           postfix[n]=findleftqueue.dequeue();
//           System.out.println(postfix[n].getValue());
//           n=n+1;
//       }

        while( !findleftqueue.isEmpty() ){

            findans.push(findleftqueue.dequeue().getValue());
            if( findans.peek().equals(""+"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=a+b;
                String stringc = Double.toString(c);
                findans.push(stringc);
                
            }else if( findans.peek().equals(""-"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b-a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""*"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b*a;
                String stringc = Double.toString(c);
                findans.push(stringc);
           
            }else if( findans.peek().equals(""/"") ){
                findans.pop();
                double a =Double.parseDouble(findans.pop());
                double b =Double.parseDouble(findans.pop());
                double c=b/a;
                String stringc = Double.toString(c);
                findans.push(stringc);
            }
        }

        double answer =Double.parseDouble( findans.peek());
        return answer;
    
    }

    /**
     * @param args the command line arguments
     */

     public static void main(String[] args)throws Exception {
        Node[] rootnode = new Node[1];
        String problem =""(((0.235+0.88)*7.2)+(200+10))"";
        Expression build = new Expression();
        rootnode[0]=build.Infix2BT(problem);
        System.out.println(build.Evaluation());
//
//        
        for(int i=0;i<build.PrintPostfix().length;i++ ){
        System.out.println(build.PrintPostfix()[i].getValue());
        }

//        System.out.println(rootnode[0].getRight().getValue());

    }
}
@a45ed58f5f61fb85ea1bd5a065e98a3c@"
"r03849033","5","0.48","105216","@8a2495650843e598986a4a1b3b7f705c@public class Expression{
public Node root;
private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{	index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)	{	stack[++index] = a;	}
	public Node pop(){	return stack[index--];	}
	public Node now(){	return stack[index];	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        size=0;
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(""+"") || data[dd].equals(""-"") || data[dd].equals(""*"") || data[dd].equals(""/"")) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(""("")) {
            } else if (data[dd].equals("")"")) {

                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 

            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size/2);
        Stack stemp2 = new Stack(size/2);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(""+"") ||prefix[i].getValue().equals(""-"") ||prefix[i].getValue().equals(""*"") ||prefix[i].getValue().equals(""/"")){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(""+"")){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""-"")){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""*"")){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""/"")){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }

}

@8a2495650843e598986a4a1b3b7f705c@"
"r03849033","5","0.49","105520","@d645a693a48ec8e5d7bfbdbe5368c679@public class Expression{
public Node root;
private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{	index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)	{	stack[++index] = a;	}
	public Node pop(){	return stack[index--];	}
	public Node now(){	return stack[index];	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        size=0;
        String[] da = infix.split("""");
        String[] data = new  String[da.length];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(""+"") || data[dd].equals(""-"") || data[dd].equals(""*"") || data[dd].equals(""/"")) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(""("")) {
            } else if (data[dd].equals("")"")) {
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size);
        Stack stemp2 = new Stack(size);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(""+"") ||prefix[i].getValue().equals(""-"") ||prefix[i].getValue().equals(""*"") ||prefix[i].getValue().equals(""/"")){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(""+"")){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""-"")){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""*"")){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""/"")){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }

}

@d645a693a48ec8e5d7bfbdbe5368c679@"
"r03849033","10","0.099","105536","@f413d1f00e3ade14ad61d7815cbb98d8@public class Expression{
public Node root;
private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{	index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)	{	stack[++index] = a;	}
	public Node pop(){	return stack[index--];	}
	public Node now(){	return stack[index];	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        size=0;
        String[] da = infix.split("""");
        String[] data = new  String[100000];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(""+"") || data[dd].equals(""-"") || data[dd].equals(""*"") || data[dd].equals(""/"")) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(""("")) {
            } else if (data[dd].equals("")"")) {
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size);
        Stack stemp2 = new Stack(size);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(""+"") ||prefix[i].getValue().equals(""-"") ||prefix[i].getValue().equals(""*"") ||prefix[i].getValue().equals(""/"")){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(""+"")){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""-"")){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""*"")){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""/"")){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }
 
}

@f413d1f00e3ade14ad61d7815cbb98d8@"
"r03849033","10","0.099","105536","@7e95717660dd01129fa8b9d9dcd8edef@public class Expression{
public Node root;
private static class Stack
{
	Node[] stack;
	public int index;
	Stack(int max)
	{	index = -1; 
		stack = new Node[max];
	}
	public void push(Node a)	{	stack[++index] = a;	}
	public Node pop(){	return stack[index--];	}
	public Node now(){	return stack[index];	}        
}      

    public Expression(){}
    public int size=0;
    public Node Infix2BT(String infix){
        size=0;
        String[] da = infix.split("""");
        String[] data = new  String[1000];
        int d = 0;
        String tempstring="""";
        for(int i=0;i<da.length;i++){
            if (da[i].equals(""+"") || da[i].equals(""-"") || da[i].equals(""*"") || da[i].equals(""/"") || da[i].equals(""("") || da[i].equals("")"")) {
                if(!tempstring.equals("""")){data[d++]=tempstring;  tempstring="""";}
                data[d++]=da[i];
            }
            else if(!da[i].equals("""")){
                    tempstring=tempstring+da[i];
            }
        }
   	Stack s = new Stack(data.length);
        int dd = 0;
        while(data[dd]!=null){
            if (data[dd].equals(""+"") || data[dd].equals(""-"") || data[dd].equals(""*"") || data[dd].equals(""/"")) {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp); 
            } else if (data[dd].equals(""("")) {
            } else if (data[dd].equals("")"")) {
                    Node b1 = s.pop();
                    Node b2 = s.pop();
                    Node b3 = s.pop();
                    b2.setLeft(b3);
                    b2.setRight(b1);
                    s.push(b2); 
            } else {
                size++;
                Node temp = new Node(null,null,data[dd]);
                s.push(temp);               
            }
        dd++;    
        }
        root=s.pop();
        return root;
    }
    public Node[] Prefixpath(Node a){
        if(a==null){ throw new NullPointerException();}
        int x=0;
        Node[] prefix = new Node[size];
        Stack stemp = new Stack(size); 
        Node temproot=a;
        stemp.push(temproot);
        while(stemp.index!=-1){
            temproot=stemp.pop();
            prefix[x++]=temproot;
            if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }
            while(temproot.getLeft()!=null){
                temproot=temproot.getLeft();
                prefix[x++]=temproot;
                if(temproot.getRight()!=null){  stemp.push(temproot.getRight()); }                
            }
        }
        return prefix;        
    }
    
    public Node[] PrintPrefix(){
        Node[] prefix = Prefixpath(root);
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){ throw new NullPointerException();}
        int stat=0;
        int x=-1;
        Node[] postfix1 = new Node[size];
        Stack stemp = new Stack(size);
        Stack stemp2 = new Stack(size);         
        Node temproot=root;  
        postfix1[size-1]=root;
        for(int i=0;i<size-1;i++){
            if(stat==0){
            while(temproot.getLeft()!=null){
                stemp.push(temproot);
                stemp2.push(temproot.getRight());          
                temproot=temproot.getLeft();
            }}       
            postfix1[++x]=temproot;
            stat=0;
            if(stemp2.index==-1){temproot=stemp.pop(); stat=1;}
            else if(stemp.now().getRight().equals(stemp2.now())){    temproot=stemp2.pop();  }
            else{ temproot=stemp.pop(); stat=1;}
            }   
        return postfix1;
    }

    public double Evaluation(){
        Node[] prefix = Prefixpath(root);     
        Stack s = new Stack(prefix.length); 
        for(int i=prefix.length-1;i>-1;i--){
            if(prefix[i].getValue().equals(""+"") ||prefix[i].getValue().equals(""-"") ||prefix[i].getValue().equals(""*"") ||prefix[i].getValue().equals(""/"")){
                Double b2 = Double.parseDouble(s.pop().getValue());
                Double b1 = Double.parseDouble(s.pop().getValue());
                if(prefix[i].getValue().equals(""+"")){ Node temp = new Node(null,null,""""+(b2+b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""-"")){ Node temp = new Node(null,null,""""+(b2-b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""*"")){ Node temp = new Node(null,null,""""+(b2*b1)); s.push(temp);}
                if(prefix[i].getValue().equals(""/"")){ Node temp = new Node(null,null,""""+(b2/b1)); s.push(temp);}                  
            }
            else{ s.push(prefix[i]);}
        }        
        double answer = Double.parseDouble(s.pop().getValue());
        return answer;  
    }
     
}

@7e95717660dd01129fa8b9d9dcd8edef@"
"r03631015","10","0.098","105888","@380eced3c5ad63b8b2332f4e4c8784cd@import java.io.BufferedReader;
import java.io.FileReader;

/*
* To change this license header, choose License Headers in Project Properties.
* To change this template file, choose Tools | Templates
* and open the template in the editor.
*/

/**
*
* @author Dennis
*/
public class Expression{

private Node root;
private int N;
Queue<Node> findmidqueue =new Queue<Node>();
Queue<Node> findleftqueue =new Queue<Node>();
Stack<String> findans =new Stack<String>();
// DO NOT MODIFY THIS
public Expression(){}

// Build a Binary and Return the Root
public Node Infix2BT(String infix){
String[] Num = infix.split("""");
Queue<String> numberqueue =new Queue<String>();
int count =0;

for(int i=1;i<Num.length;i++){

if(Num[i].equals(""("")){
numberqueue.enqueue(Num[i]);
count =i;

}else if( Num[i].equals("")"") || Num[i].equals(""+"") || Num[i].equals(""-"") || Num[i].equals(""*"") || Num[i].equals(""/"") ){

String S1 =""""; 
for(int j=count+1;j<i;j++){
S1 = (S1+Num[j]).replace(""null"","""");
}
String S2 = S1.replace(""null"","""");

if( !( S2=="""" )){
// System.out.println(S1);
numberqueue.enqueue(S2);
}
numberqueue.enqueue(Num[i]);
count =i;

}else{

}
}
// System.out.println( numberqueue.size());
String[] Num2 =new String[numberqueue.size()];
for(int i=0;i<Num2.length;i++){
Num2[i]=numberqueue.dequeue();
}

Stack<Node> numsta =new Stack<Node> ();
Stack optsta =new Stack();
Stack<Node> nodesta =new Stack<Node>();
int N = Num2.length;
this.N=N;
Node[] Infnode =new Node[N/2+1];
int nodenum=0;

for(int i=0;i<N;i++){

// System.out.println( Num2[i]);
// System.out.println( Num2[i].equals(""*""));
if( Num2[i].equals(""+"") || Num2[i].equals(""-"") || Num2[i].equals(""*"") || Num2[i].equals(""/"")){
optsta.push(Num2[i]);

}else if( Num2[i].equals(""("")){

}else if( Num2[i].equals("")"")){
if(Num2[i-1].equals(""("") )
{
throw new NullPointerException(""NullPointerException"");
}
Infnode[0]=numsta.pop();
Infnode[1]=numsta.pop();
numsta.push(new Node( Infnode[1],Infnode[0],optsta.pop().toString()));
}else{

numsta.push(new Node(null,null,Num2[i]));
}
}

root=numsta.peek();
this.root=root;

// System.out.println(root.getValue());

return root;
}

public Node[] PrintPrefix(){
Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findmid(rootnode[0]);
Node[] prefix = new Node[findmidqueue.size()];
int n=0;
while(!findmidqueue.isEmpty()){
prefix[n]=findmidqueue.dequeue();
n=n+1;
}
return prefix;
}

public Node findmid(Node x){
findmidqueue.enqueue(x);
// System.out.println(findmidqueue.peek().getValue()); 
if( !(x.getLeft()==null) ){
findmid(x.getLeft());
}
if( !(x.getRight()==null) ){
findmid(x.getRight());
}
return x;
}

public Node[] PrintPostfix(){
Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findleft(rootnode[0]);
Node[] postfix = new Node[findleftqueue.size()+1];
int n=0;
while(!findleftqueue.isEmpty()){
postfix[n]=findleftqueue.dequeue();
n=n+1;
}
postfix[n]=rootnode[0];
return postfix;
}

public Node findleft(Node x){

if( !(x.getLeft()==null) ){
findleft(x.getLeft());
findleftqueue.enqueue(x.getLeft());
// System.out.println(x.getLeft().getValue()); 
}
if( !(x.getRight()==null) ){
findleft(x.getRight());
findleftqueue.enqueue(x.getRight());
// System.out.println(x.getRight().getValue()); 
}
return x;
}

public double Evaluation(){

Node[] rootnode = new Node[1];
rootnode[0]=this.root;
findleft(rootnode[0]);
Node[] postfix = new Node[findleftqueue.size()+1];
int n=0;
findleftqueue.enqueue( rootnode[0] );

// while(!findleftqueue.isEmpty()){
// postfix[n]=findleftqueue.dequeue();
// System.out.println(postfix[n].getValue());
// n=n+1;
// }

while( !findleftqueue.isEmpty() ){

findans.push(findleftqueue.dequeue().getValue());
if( findans.peek().equals(""+"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=a+b;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""-"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b-a;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""*"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b*a;
String stringc = Double.toString(c);
findans.push(stringc);

}else if( findans.peek().equals(""/"") ){
findans.pop();
double a =Double.parseDouble(findans.pop());
double b =Double.parseDouble(findans.pop());
double c=b/a;
String stringc = Double.toString(c);
findans.push(stringc);
}
}

double answer =Double.parseDouble( findans.peek());
return answer;

}

/**
* @param args the command line arguments
*/

public static void main(String[] args)throws Exception {
Node[] rootnode = new Node[1];
String problem =""(((0.235+0.88)*7.2)+(200+10))"";
Expression build = new Expression();
rootnode[0]=build.Infix2BT(problem);
System.out.println(build.Evaluation());
//
// 
for(int i=0;i<build.PrintPostfix().length;i++ ){
System.out.println(build.PrintPostfix()[i].getValue());
}

// System.out.println(rootnode[0].getRight().getValue());

}
}
@380eced3c5ad63b8b2332f4e4c8784cd@"
"r04631021","1","0.09","105232","@51fdb5a58f4eff2513902e63b361da02@import java.io.*;
import java.util.*;
public class Expression{
  
    private Node root ;
    int treesize = 0 ;
    public int i = 0 ;
    // DO NOT MODIFY THIS
    public Expression(){}

    public boolean isOperator(String judge){
if(judge.equals(""+"")||judge.equals(""-"")||judge.equals(""*"")||judge.equals(""/""))
    return true ;
else 
    return false ;
//if(judge.equals(""+""))
//    return 1 ;
//else if(judge.equals(""-""))
//    return 2 ;
//else if(judge.equals(""*""))
//    return 3 ;
//else if(judge.equals(""/""))
//    return 4 ;
//else
//    return 5 ;        
    }
    
    
private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //new two stacks one for values , the other is for operators
    Stack<Node> operator = new Stack() ;
    int count = 1 ;
    String[] op = infix.split("""") ;
    int stringlen = op . length - 1 ;
    Node[] oldy = new Node[stringlen] ;
    while(count != infix.length()+1 ){
        switch (op[count]){
            case ""("" :                
                break;
            case ""+"" :  
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""+"");
                treesize++ ;
                break ;
            case ""-"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""-"") ;
                treesize++ ;
               break;
            case ""*"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""*"");
                treesize++ ;
                break ;
            case ""/"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""/"");
                treesize++ ;
                break;
            case "")"" :
                Node a = operator.pop() ;
                Node b = operator.pop() ;
                Node c = operator.pop() ;
                if(operator.isEmpty()){
                root = new Node(null,null,null);
                root.setLeft(c);
                root.setRight(a);
                root.setValue(b.getValue());
                operator.push(root);

                }
                else{
                b.setLeft(c) ;
                b.setRight(a) ;                
                operator.push(b) ;

                }
                break;
                
            default :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]) ;
                oldy[count].setValue(op[count]);
                treesize++ ;

                break ;
                       
        }
        count++ ;
    }   
        return root;
    }
    
          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }


private void postfix(ArrayList list , Node node){
    
    if(node.getLeft() != null){
        postfix(list , node.getLeft()) ;
    }
    if(node.getRight()!=null){
        postfix(list , node.getRight()) ;
        }
    list.add(node) ;
    }

    public Node[] PrintPrefix(){
        
        if(root == null)
            throw new java.lang.NullPointerException();
               
        ArrayList<Node> array = new ArrayList<Node>() ;
        prefix(array,root) ;
        Node[] prefix = new Node[array.size()] ;
        
        for (int count = 0; count < array.size(); count++) {
           prefix[count] = array.get(count);
           System.out.print(prefix[count].getValue());
           }
        
        return prefix;
        
    }
  
    public Node[] PrintPostfix(){
        
        if(root == null)
            throw new java.lang.NullPointerException() ;
        
        ArrayList<Node> array = new ArrayList<Node>() ;
        postfix(array,root) ;
        Node[] postfix = new Node[array.size()] ;
        
        for(int j = 0 ; j < array.size() ; j ++){
            postfix[j] = array.get(j) ;
            System.out.print(postfix[j].getValue());
            
        }        
        return postfix;
    }

//    public double Evaluation(){
//        
//        if(root == null)
//            throw new java.lang.NullPointerException();
//        
//        double answer = 0 ;
//        
//        ArrayList<Node> cal = new ArrayList<Node>() ;
//        postfix(cal,root) ;
//        Stack<Double> eva = new Stack<Double>() ;
//        for(int k = 0 ; k < cal.size() ; k++){
//            String a = cal.get(k).getValue() ;
//            Double number1 ;
//            Double number2 ;
//            if(isOperator(a) != 5)
//                number1 = eva.pop() ;
//                number2 = eva.pop() ;
//                if(isOperator(a) == 1)
//                     answer = number1 + number2 ;
//                if(isOperator)
//                
//        }
//        
//        
//        
//        
//        
//        return answer;
//    }
    
          public double Evaluation() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              postfix(array, this.root);
                              Stack<Double> storge = new Stack<Double>();
                              for (int count = 0; count < array.size(); count++) {
                                        if (isOperator(array.get(count).getValue())) {

                                                  Calculate(storge, array.get(count).getValue());
                                        } else {
                                                  storge.push(Double.parseDouble(array.get(count).getValue()));
                                        }
                              }

                              return storge.pop();
                    }
          }

}

@51fdb5a58f4eff2513902e63b361da02@"
"r02b48003","9","0.88","105520","@f7458aa72c357f7feaf845500beb8e79@/**
 * Class Expression 
 * You are asked to implement a class named Expression.java, which can read in a math expression in infix form, and store the expression in a binary tree.
 * With the data structure of binary trees (BT), the math expression can be easily evaluated (i.e., calculating the value) or converted into different expression forms such prefix, infix, and postfix.
 * To achieve this goal, you will learn how to construct a binary tree from scratch and how to traverse the tree in different ways, including preorder, inorder, or postorder traversal.
 * Please complete this homework by implementing the following API. Please note that your main function will not be executed.
 * Replace the content of the binary tree if a new expression is specified through functions Infix2BT.
 * Throw NullPointerException if the root is null when calling printPreOrder, printInOrder, printPostOrder, or evaluation.
 * @author Clintko, r02b48003
 */
public class Expression{
  
    private Node root;
    private int index;
    private int size;
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        index = 1;
        size = 0;
        root = null;
        root = Infix2BT(root, infix);
        return root;
    }
    
    private Node Infix2BT(Node x, String infix) {
        // initialization
        if (x == null) {
            x = new Node(null, null, """");
            this.size += 1;
        } // end if
        String val = """";
        boolean isLeft = true;
        
        //
        while (true) {
            char c = infix.charAt(this.index++);
            if (c == '('){ 
                if (isLeft) x.setLeft (Infix2BT(x.getLeft(),  infix));
                else        x.setRight(Infix2BT(x.getRight(), infix));
                continue;
            } // end if
            
            if (c == ')'){ 
                if (!val.equals("""")) {
                    //System.out.println(val);
                    x.setRight(new Node(null, null, val));
                    // update size
                    this.size += 1;
                } // end if
                break;
            } // end if
            
            // deal with operators
            if (c == '+' || c == '-' || c == '*' || c == '/'){
                if (!val.equals("""")) {
                    //System.out.print(val);
                    x.setLeft(new Node(null, null, val));
                    // update size & reset value
                    this.size += 1;
                    val = """";
                } // end if
                
                // node value = operator
                x.setValue(c+"""");
                
                //System.out.print(x.getValue());
                isLeft = false;
                continue;
            } // end if
            
            // collect char if not special char
            val += c;
        } // end while
        
        return x;
    } // end private class infix2BT 
    
    
    public int size() {
        return size;
    } // end public method size
    
    public Node[] PrintPrefix(){
        Node[] prefix = new Node[size];
        index = 0;
        PrintPrefix(root, prefix);
        return prefix;
    }
    
    private void PrintPrefix(Node x, Node[] nodes){
        nodes[index++] = x;
        
        if (x.getLeft() != null)
            PrintPrefix(x.getLeft(), nodes);
        
        if (x.getRight() != null)
            PrintPrefix(x.getRight(), nodes);
    } // end private method PrintPrefix
    
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[size];
        index = 0;
        PrintPostfix(root, postfix);
        return postfix;
    }
    
    private void PrintPostfix(Node x, Node[] nodes){
        if (x.getLeft() != null)
            PrintPostfix(x.getLeft(), nodes);
        
        if (x.getRight() != null)
            PrintPostfix(x.getRight(), nodes);
        
        nodes[index++] = x;
    } // end private method PrintPrefix

    public double Evaluation(){
        double answer = Evaluation(root);
        return answer;
    }
    
    private Double Evaluation(Node x){
        if (x.getLeft() == null) return Double.parseDouble(x.getValue());
        
        Double val1 = Evaluation(x.getLeft());
        Double val2 = Evaluation(x.getRight());
        
        if (x.getValue().equals(""+"")) return val1 + val2;
        if (x.getValue().equals(""-"")) return val1 - val2;
        if (x.getValue().equals(""*"")) return val1 * val2;
        if (x.getValue().equals(""/"")) return val1 / val2; 
        
        return null;
    } // end private method Evaluation
    
    public static void main(String[] args) {
        Expression exp = new Expression();
        String expStr0 = ""(4+(((4*2)/2)/3))"";
        String expStr1 = ""(10+25)"";
        String expStr2 = ""(1.5+2.6)"";
        String expStr3 = ""((1*2)+(1/2))"";
        
        Node root;
        Node[] nodes;
        
        System.out.println(""---------Expression 00---------"");
        root = exp.Infix2BT(expStr0);
        System.out.println(""Expression: "" + expStr0);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
        System.out.println(""---------Expression 02---------"");
        root = exp.Infix2BT(expStr2);
        System.out.println(""Expression: "" + expStr2);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
        System.out.println(""---------Expression 03---------"");
        root = exp.Infix2BT(expStr3);
        System.out.println(""Expression: "" + expStr3);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
    } // end main
} // end class Expression
@f7458aa72c357f7feaf845500beb8e79@"
"r04631021","1","0.09","104352","@d18e65bc4db3c37a044a84ba8a105c4c@import java.io.*;
import java.util.*;
public class Expression{
  
    private Node root ;
    int treesize = 0 ;
    public int i = 0 ;
    // DO NOT MODIFY THIS
    public Expression(){}

    public boolean isOperator(String judge){
if(judge.equals(""+"")||judge.equals(""-"")||judge.equals(""*"")||judge.equals(""/""))
    return true ;
else 
    return false ;
//if(judge.equals(""+""))
//    return 1 ;
//else if(judge.equals(""-""))
//    return 2 ;
//else if(judge.equals(""*""))
//    return 3 ;
//else if(judge.equals(""/""))
//    return 4 ;
//else
//    return 5 ;        
    }
    
    
private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //new two stacks one for values , the other is for operators
    Stack<Node> operator = new Stack() ;
    int count = 1 ;
    String[] op = infix.split("""") ;
    int stringlen = op . length - 1 ;
    Node[] oldy = new Node[stringlen] ;
    while(count != infix.length()+1 ){
        switch (op[count]){
            case ""("" :                
                break;
            case ""+"" :  
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""+"");
                treesize++ ;
                break ;
            case ""-"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""-"") ;
                treesize++ ;
               break;
            case ""*"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""*"");
                treesize++ ;
                break ;
            case ""/"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""/"");
                treesize++ ;
                break;
            case "")"" :
                Node a = operator.pop() ;
                Node b = operator.pop() ;
                Node c = operator.pop() ;
                if(operator.isEmpty()){
                root = new Node(null,null,null);
                root.setLeft(c);
                root.setRight(a);
                root.setValue(b.getValue());
                operator.push(root);

                }
                else{
                b.setLeft(c) ;
                b.setRight(a) ;                
                operator.push(b) ;

                }
                break;
                
            default :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]) ;
                oldy[count].setValue(op[count]);
                treesize++ ;

                break ;
                       
        }
        count++ ;
    }   
        return root;
    }
    
          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }


private void postfix(ArrayList list , Node node){
    
    if(node.getLeft() != null){
        postfix(list , node.getLeft()) ;
    }
    if(node.getRight()!=null){
        postfix(list , node.getRight()) ;
        }
    list.add(node) ;
    }

    public Node[] PrintPrefix(){
        
        if(root == null)
            throw new java.lang.NullPointerException();
               
        ArrayList<Node> array = new ArrayList<Node>() ;
        prefix(array,root) ;
        Node[] prefix = new Node[array.size()] ;
        
        for (int count = 0; count < array.size(); count++) {
           prefix[count] = array.get(count);
//           System.out.print(prefix[count].getValue());
           }
        
        return prefix;
        
    }
  
    public Node[] PrintPostfix(){
        
        if(root == null)
            throw new java.lang.NullPointerException() ;
        
        ArrayList<Node> array = new ArrayList<Node>() ;
        postfix(array,root) ;
        Node[] postfix = new Node[array.size()] ;
        
        for(int j = 0 ; j < array.size() ; j ++){
            postfix[j] = array.get(j) ;
//            System.out.print(postfix[j].getValue());
            
        }        
        return postfix;
    }

//    public double Evaluation(){
//        
//        if(root == null)
//            throw new java.lang.NullPointerException();
//        
//        double answer = 0 ;
//        
//        ArrayList<Node> cal = new ArrayList<Node>() ;
//        postfix(cal,root) ;
//        Stack<Double> eva = new Stack<Double>() ;
//        for(int k = 0 ; k < cal.size() ; k++){
//            String a = cal.get(k).getValue() ;
//            Double number1 ;
//            Double number2 ;
//            if(isOperator(a) != 5)
//                number1 = eva.pop() ;
//                number2 = eva.pop() ;
//                if(isOperator(a) == 1)
//                     answer = number1 + number2 ;
//                if(isOperator)
//                
//        }
//        
//        
//        
//        
//        
//        return answer;
//    }
    
          public double Evaluation() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              postfix(array, this.root);
                              Stack<Double> storge = new Stack<Double>();
                              for (int count = 0; count < array.size(); count++) {
                                        if (isOperator(array.get(count).getValue())) {

                                                  Calculate(storge, array.get(count).getValue());
                                        } else {
                                                  storge.push(Double.parseDouble(array.get(count).getValue()));
                                        }
                              }

                              return storge.pop();
                    }
          }

}

@d18e65bc4db3c37a044a84ba8a105c4c@"
"r04631021","1","0.09","101264","@c9790af0acccb239e8bb06fe6899d59a@import java.io.*;
import java.util.*;
public class Expression{
  
    private Node root ;
    int treesize = 0 ;
    public int i = 0 ;
    // DO NOT MODIFY THIS
    public Expression(){}

    public boolean isOperator(String judge){
if(judge.equals(""+"")||judge.equals(""-"")||judge.equals(""*"")||judge.equals(""/""))
    return true ;
else 
    return false ;
//if(judge.equals(""+""))
//    return 1 ;
//else if(judge.equals(""-""))
//    return 2 ;
//else if(judge.equals(""*""))
//    return 3 ;
//else if(judge.equals(""/""))
//    return 4 ;
//else
//    return 5 ;        
    }
    
    
private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //new two stacks one for values , the other is for operators
    Stack<Node> operator = new Stack() ;
    int count = 1 ;
    String[] op = infix.split("""") ;
    int stringlen = op . length - 1 ;
    Node[] oldy = new Node[stringlen] ;
    while(count != infix.length()+1 ){
        switch (op[count]){
            case ""("" :                
                break;
            case ""+"" :  
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""+"");
                treesize++ ;
                break ;
            case ""-"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""-"") ;
                treesize++ ;
               break;
            case ""*"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""*"");
                treesize++ ;
                break ;
            case ""/"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""/"");
                treesize++ ;
                break;
            case "")"" :
                Node a = operator.pop() ;
                Node b = operator.pop() ;
                Node c = operator.pop() ;
                if(operator.isEmpty()){
                root = new Node(null,null,null);
                root.setLeft(c);
                root.setRight(a);
                root.setValue(b.getValue());
                operator.push(root);

                }
                else{
                b.setLeft(c) ;
                b.setRight(a) ;                
                operator.push(b) ;

                }
                break;
                
            default :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]) ;
                oldy[count].setValue(op[count]);
                treesize++ ;

                break ;
                       
        }
        count++ ;
    }   
        return root;
    }
    
          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }


private void postfix(ArrayList list , Node node){
    
    if(node.getLeft() != null){
        postfix(list , node.getLeft()) ;
    }
    if(node.getRight()!=null){
        postfix(list , node.getRight()) ;
        }
    list.add(node) ;
    }

    public Node[] PrintPrefix(){
        
        if(root == null)
            throw new java.lang.NullPointerException();
               
        ArrayList<Node> array = new ArrayList<Node>() ;
        prefix(array,root) ;
        Node[] prefix = new Node[array.size()] ;
        
        for (int count = 0; count < array.size(); count++) {
           prefix[count] = array.get(count);
//           System.out.print(prefix[count].getValue());
           }
        
        return prefix;
        
    }
  
    public Node[] PrintPostfix(){
        
        if(root == null)
            throw new java.lang.NullPointerException() ;
        
        ArrayList<Node> array = new ArrayList<Node>() ;
        postfix(array,root) ;
        Node[] postfix = new Node[array.size()] ;
        
        for(int j = 0 ; j < array.size() ; j ++){
            postfix[j] = array.get(j) ;
//            System.out.print(postfix[j].getValue());
            
        }        
        return postfix;
    }

//    public double Evaluation(){
//        
//        if(root == null)
//            throw new java.lang.NullPointerException();
//        
//        double answer = 0 ;
//        
//        ArrayList<Node> cal = new ArrayList<Node>() ;
//        postfix(cal,root) ;
//        Stack<Double> eva = new Stack<Double>() ;
//        for(int k = 0 ; k < cal.size() ; k++){
//            String a = cal.get(k).getValue() ;
//            Double number1 ;
//            Double number2 ;
//            if(isOperator(a) != 5)
//                number1 = eva.pop() ;
//                number2 = eva.pop() ;
//                if(isOperator(a) == 1)
//                     answer = number1 + number2 ;
//                if(isOperator)
//                
//        }
//        
//        
//        
//        
//        
//        return answer;
//    }
    
          public double Evaluation() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                   } else {
ArrayList<Node> array = new ArrayList<Node>();
postfix(array, this.root);
Stack<Double> storge = new Stack<Double>();
for (int count = 0; count < array.size(); count++) {
if (isOperator(array.get(count).getValue())) {

  Calculate(storge, array.get(count).getValue());
                                        } else {
 storge.push(Double.parseDouble(array.get(count).getValue()));
                                        }
                              }

                              return storge.pop();
                    }
          }

}

@c9790af0acccb239e8bb06fe6899d59a@"
"r04631021","10","0.098","105264","@7b33dc9d01795b9c08f290e1c6b19875@
import java.util.*;

public class Expression {

          private Node root;

          // DO NOT MODIFY THIS
          public Expression() {
          }

          private boolean isCalculator(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else if (java.lang.Character.isDigit(c.charAt(0))) {
                              return true;
                    }
                    return false;
          }

          private boolean isOperation(String c) {
                    if (c.equals(""+"") || c.equals(""-"") || c.equals(""*"") || c.equals(""/"")) {
                              return true;
                    } else {
                              return false;
                    }
          }

          private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }

          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }

          private void posfix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    list.add(node);
          }

                    private void infix(ArrayList list, Node node) {

                    if (node.getLeft() != null) {
                              posfix(list, node.getLeft());
                    }
                    list.add(node);
                    if (node.getRight() != null) {
                              posfix(list, node.getRight());
                    }
                    
          }
// Build a Binary and Return the Root
          public Node Infix2BT(String infix) {
                    String[] charater = infix.split("""");
                    charater = Arrays.copyOfRange(charater, 1, charater.length);
                    Stack<Node> treeNode = new Stack<Node>();
          for (int counter = 0; counter < charater.length; counter++) {
               if (charater[counter].equals(""("")) {
                    continue;
               } else if (charater[counter].equals("")"")) {
                    Node right = treeNode.pop();
                    Node mid = treeNode.pop();
                    Node left = treeNode.pop();
                    mid.setLeft(left);
                    mid.setRight(right);
                    treeNode.push(mid);
               } else if (isOperation(charater[counter])) {
                    treeNode.push(new Node(null, null, charater[counter]));
               } else {
                    if (treeNode.isEmpty()) {
                         treeNode.push(new Node(null, null, charater[counter]));
                    } else {
                         Node temp = treeNode.pop();
                         if (isOperation(temp.getValue())) {
                              treeNode.push(temp);
                              treeNode.push(new Node(null, null, charater[counter]));
                         } else {
                              temp.setValue(temp.getValue() + charater[counter]);
                              treeNode.push(temp);
                         }
                    }
               }

          }
                    
                    this.root = treeNode.pop();
                    return this.root;
          }

          public Node[] PrintPrefix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              prefix(array, this.root);
                              Node[] prefix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        prefix[count] = array.get(count);
                              }
                              return prefix;
                    }
          }
          
          public Node[] PrintInfix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              infix(array, this.root);
                              Node[] infix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        infix[count] = array.get(count);
                              }
                              return infix;
                    }
          }
          
          public Node[] PrintPostfix() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Node[] posfix = new Node[array.size()];

                              for (int count = 0; count < array.size(); count++) {
                                        posfix[count] = array.get(count);
                              }
                              return posfix;
                    }
          }

          public double Evaluation() {
                    if (this.root == null) {
                              throw new java.lang.NullPointerException();
                    } else {
                              ArrayList<Node> array = new ArrayList<Node>();
                              posfix(array, this.root);
                              Stack<Double> storge = new Stack<Double>();
                              for (int count = 0; count < array.size(); count++) {
                                        if (isOperation(array.get(count).getValue())) {

                                                  Calculate(storge, array.get(count).getValue());
                                        } else {
                                                  storge.push(Double.parseDouble(array.get(count).getValue()));
                                        }
                              }

                              return storge.pop();
                    }
          }
}


@7b33dc9d01795b9c08f290e1c6b19875@"
"r02b48003","10","0.095","105536","@fa57ed3ace97530f99abd21ad1ef06b0@import java.lang.NullPointerException;

/**
 * Class Expression 
 * You are asked to implement a class named Expression.java, which can read in a math expression in infix form, and store the expression in a binary tree.
 * With the data structure of binary trees (BT), the math expression can be easily evaluated (i.e., calculating the value) or converted into different expression forms such prefix, infix, and postfix.
 * To achieve this goal, you will learn how to construct a binary tree from scratch and how to traverse the tree in different ways, including preorder, inorder, or postorder traversal.
 * Please complete this homework by implementing the following API. Please note that your main function will not be executed.
 * Replace the content of the binary tree if a new expression is specified through functions Infix2BT.
 * Throw NullPointerException if the root is null when calling printPreOrder, printInOrder, printPostOrder, or evaluation.
 * @author Clintko, r02b48003
 */
public class Expression{
  
    private Node root;
    private int index;
    private int size;
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        index = 1;
        size = 0;
        root = null;
        root = Infix2BT(root, infix);
        return root;
    }
    
    private Node Infix2BT(Node x, String infix) {
        // initialization
        if (x == null) {
            x = new Node(null, null, """");
            this.size += 1;
        } // end if
        String val = """";
        boolean isLeft = true;
        
        //
        while (true) {
            char c = infix.charAt(this.index++);
            if (c == '('){ 
                if (isLeft) x.setLeft (Infix2BT(x.getLeft(),  infix));
                else        x.setRight(Infix2BT(x.getRight(), infix));
                continue;
            } // end if
            
            if (c == ')'){ 
                if (!val.equals("""")) {
                    //System.out.println(val);
                    x.setRight(new Node(null, null, val));
                    // update size
                    this.size += 1;
                } // end if
                break;
            } // end if
            
            // deal with operators
            if (c == '+' || c == '-' || c == '*' || c == '/'){
                if (!val.equals("""")) {
                    //System.out.print(val);
                    x.setLeft(new Node(null, null, val));
                    // update size & reset value
                    this.size += 1;
                    val = """";
                } // end if
                
                // node value = operator
                x.setValue(c+"""");
                
                //System.out.print(x.getValue());
                isLeft = false;
                continue;
            } // end if
            
            // collect char if not special char
            val += c;
        } // end while
        
        return x;
    } // end private class infix2BT 
    
    
    public int size() {
        return size;
    } // end public method size
    
    public Node[] PrintPrefix(){
        if (root == null) throw new NullPointerException();
        Node[] prefix = new Node[size];
        index = 0;
        PrintPrefix(root, prefix);
        return prefix;
    }
    
    private void PrintPrefix(Node x, Node[] nodes){
        nodes[index++] = x;
        
        if (x.getLeft() != null)
            PrintPrefix(x.getLeft(), nodes);
        
        if (x.getRight() != null)
            PrintPrefix(x.getRight(), nodes);
    } // end private method PrintPrefix
    
    public Node[] PrintPostfix(){
        if (root == null) throw new NullPointerException();
        Node[] postfix = new Node[size];
        index = 0;
        PrintPostfix(root, postfix);
        return postfix;
    }
    
    private void PrintPostfix(Node x, Node[] nodes){
        if (x.getLeft() != null)
            PrintPostfix(x.getLeft(), nodes);
        
        if (x.getRight() != null)
            PrintPostfix(x.getRight(), nodes);
        
        nodes[index++] = x;
    } // end private method PrintPrefix

    public double Evaluation(){
        double answer = Evaluation(root);
        return answer;
    }
    
    private Double Evaluation(Node x){
        if (x.getLeft() == null) return Double.parseDouble(x.getValue());
        
        Double val1 = Evaluation(x.getLeft());
        Double val2 = Evaluation(x.getRight());
        
        if (x.getValue().equals(""+"")) return val1 + val2;
        if (x.getValue().equals(""-"")) return val1 - val2;
        if (x.getValue().equals(""*"")) return val1 * val2;
        if (x.getValue().equals(""/"")) return val1 / val2; 
        
        return null;
    } // end private method Evaluation
    
    public static void main(String[] args) {
        Expression exp = new Expression();
        String expStr0 = ""(4+(((4*2)/2)/3))"";
        String expStr1 = ""(10+25)"";
        String expStr2 = ""(1.5+2.6)"";
        String expStr3 = ""((1*2)+(1/2))"";
        
        Node root;
        Node[] nodes;
        
        System.out.println(""---------Expression 00---------"");
        root = exp.Infix2BT(expStr0);
        System.out.println(""Expression: "" + expStr0);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
        System.out.println(""---------Expression 02---------"");
        root = exp.Infix2BT(expStr2);
        System.out.println(""Expression: "" + expStr2);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
        System.out.println(""---------Expression 03---------"");
        root = exp.Infix2BT(expStr3);
        System.out.println(""Expression: "" + expStr3);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
    } // end main
} // end class Expression

@fa57ed3ace97530f99abd21ad1ef06b0@"
"r03228006","1","0.22","104384","@48e4aa87254ecafea1b8b519e63d2d6a@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
    private Node root    // DO NOT MODIFY THIS
;
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        int key=1;
        size=0;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(Parts[i]!=""(""&Parts[i]!="")""){size++;}
        }
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){;root=all[i-1];key=i-1;i--;}
        else{
          while(root==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root = all[i];key=i;
                 //System.out.println(all[key].getValue());
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        Node[] prefix = new Node[size];
        Node x = root;
        prefix[0]=x;
        int i=1;
        int key=0;
        int p=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             key=i;i++;
          }
          else if ((prefix[key].getRight()!=null)&& (i>=4+key)){//root right
             prefix[i]=prefix[key].getRight();
             key=i;i++;p=1;
          }
          else{key=key-1;}//1 3
          if(p==1&key==0){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        Node x =root;
        int i=0;
        int key=0;
        int p=0;
        while(true){
          while(x.getLeft()!=null){x=x.getLeft();}
          postfix[i]=x;i++;
          
          if (postfix[key].getRight()!=null&(i-key)==2){
             postfix[i]=postfix[key].getRight();
             key=i;i++;
          }
          else if (postfix[key].getRight()!=null&key==0){//root right
             postfix[i]=postfix[key].getRight();
             key=i;i++;p=1;
          }
          else{key=key-1;}//1 3
          if(p==1&key==0){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
       Expression x1 = new Expression();
       String infix = ""(4+(((4*2)/2)/3))"";
       String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
       //Node[] all = new Node[Parts.length];

       Node r = x1.Infix2BT(infix); 
       //System.out.println(r.getValue());
       Node[] pre = x1.PrintPrefix();
       for(int i = 0; i < pre.length ; i++){
         System.out.println(pre[i].getValue());
        }

        }
}


@48e4aa87254ecafea1b8b519e63d2d6a@"
"r04631009","10","0.098","105824","@b746772d494011967650e459213d2464@
public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        String a = infix.replace(""+"","" + "");
        String b = a.replace(""-"","" - "");
        String c = b.replace(""*"","" * "");
        String d = c.replace(""/"","" / "");
        String e = d.replace(""("","" ( "");
        String f = e.replace("")"","" ) "");
        String g = f.replace(""  "","" "");
        String h = g.replaceFirst("" "", """");

        String[] stringarray = h.split("" "");

        Stack<Node> data = new Stack<Node>();
        for (int i = 0; i < stringarray.length; i++) {
            if (stringarray[i].equals("")"")) {
                Node[] temp = new Node[4];
                int tempi = 0;
                while (tempi < 4) {
                    temp[tempi] = data.pop();
                    tempi++;
                }
                temp[1].setLeft(temp[2]);
                temp[1].setRight(temp[0]);
                root = temp[1];
                data.push(root);
            } else {
                Node temp = new Node(null, null, stringarray[i]);
                data.push(temp);
            }
        }
        return root;
    }

    public Node[] PrintPrefix() {
        Queue<Node> data = new Queue<Node>();
        Node x = root;
        PrintPrefix(data, x);
        int i = 0, num = data.size();
        Node[] prefix = new Node[num];
        while (!data.isEmpty()) {
            prefix[i] = data.dequeue();
            i++;
        }
        return prefix;
    }

    private void PrintPrefix(Queue<Node> data, Node root) {
        Node x = root, L = root.getLeft(), R = root.getRight();
        data.enqueue(x);

        if (L != null) {
            PrintPrefix(data, L);
        }
        if (R != null) {
            PrintPrefix(data, R);
        }
    }

    public Node[] PrintPostfix() {
        Node x = root;
        Queue<Node> postdata = new Queue<Node>();
        PrintPostfix(postdata, x);
        int i = 0, num = postdata.size();
        Node[] postfix = new Node[num];
        while (!postdata.isEmpty()) {
            postfix[i] = postdata.dequeue();
            i++;
        }
        return postfix;
    }

    private void PrintPostfix(Queue<Node> postdata, Node root) {
        Node x = root, L = root.getLeft(), R = root.getRight();

        if (L != null) {
            PrintPostfix(postdata, L);
        }
        if (R != null) {
            PrintPostfix(postdata, R);
        }
        postdata.enqueue(x);
    }

    public double Evaluation() {
        double answer = 0;
        Node sign = root;
        answer = Evaluation(sign);
        return answer;
    }

    private double Evaluation(Node sign) {
        double ans = 0;
        Node x = sign;
        Node L = x.getLeft(), R = x.getRight();
        if (L.getValue().equals(""+"") || L.getValue().equals(""-"") || L.getValue().equals(""*"") || L.getValue().equals(""/"")) {
            L = new Node(null, null, String.valueOf(Evaluation(L)));
        }
        if (R.getValue().equals(""+"") || R.getValue().equals(""-"") || R.getValue().equals(""*"") || R.getValue().equals(""/"")) {
            R = new Node(null, null, String.valueOf(Evaluation(R)));
        }
        if (x.getValue().equals(""+"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l + r;
        } else if (x.getValue().equals(""-"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l - r;
        } else if (x.getValue().equals(""*"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l * r;
        } else if (x.getValue().equals(""/"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l / r;
        }
        return ans;
    }

    public static void main(String[] args) {
        String input = ""(4+(((4*2.2)/2)/3))"";
        //String input=""(((1+(12*5))-(3*4))+(4/5))"";
        //String input=""(((4/5)+3)+(1/2))"";
        String[] stringarray = input.split("""");
        //     for (int i=0 ; i<stringarray.length ; i++)
        //         System.out.print(stringarray[i]+""\t"");
        //     System.out.println();
        //     System.out.println(input);
        Expression calculation = new Expression();
        calculation.Infix2BT(input);
        System.out.println(calculation.root.getValue());
        System.out.println(calculation.root.getLeft().getValue());
        System.out.println(calculation.root.getRight().getValue());
        //System.out.println(calculation.root.getLeft().getLeft().getValue());
        //System.out.println(calculation.root.getLeft().getLeft().getLeft().getValue());
        //System.out.println(calculation.root.getLeft().getLeft().getLeft().getLeft().getValue());
        //System.out.println(calculation.root.getRight().getLeft().getLeft().getLeft().getLeft());
        Node[] prefix = calculation.PrintPrefix();
        for (int i = 0; i < prefix.length; i++) {
            System.out.print(prefix[i].getValue() + ""\t"");
        }
        System.out.println("""");
        Node[] postfix = calculation.PrintPostfix();
        for (int i = 0; i < postfix.length; i++) {
            System.out.print(postfix[i].getValue() + ""\t"");
        }
        System.out.println("""");
        //System.out.println(calculation.Evaluation());

    }
}

@b746772d494011967650e459213d2464@"
"r04631041","10","0.1","105920","@97fb4938db7902a7de0ea1d92377f9ef@public class Expression{
  
    private Node root;
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
  public Node Infix2BT(String infix) {

        String a = infix.replace(""+"","" + "");
        String b = a.replace(""-"","" - "");
        String c = b.replace(""*"","" * "");
        String d = c.replace(""/"","" / "");
        String e = d.replace(""("","" ( "");
        String f = e.replace("")"","" ) "");
        String g = f.replace(""  "","" "");
        String h = g.replaceFirst("" "", """");

        String[] stringarray = h.split("" "");

        Stack<Node> data = new Stack<Node>();
        for (int i = 0; i < stringarray.length; i++) {
            if (stringarray[i].equals("")"")) {
                Node[] temp = new Node[4];
                int tempi = 0;
                while (tempi < 4) {
                    temp[tempi] = data.pop();
                    tempi++;
                }
                temp[1].setLeft(temp[2]);
                temp[1].setRight(temp[0]);
                root = temp[1];
                data.push(root);
            } else {
                Node temp = new Node(null, null, stringarray[i]);
                data.push(temp);
            }
        }
        return root;
    }

    public Node[] PrintPrefix(){
        Queue<Node> data=new Queue<Node>();
        Node x=root;
        PrintPrefix(data,x);
        int i=0,num=data.size();
        Node[] prefix = new Node[num];
        while(!data.isEmpty()){
           prefix[i]=data.dequeue();
        i++;
        }
        return prefix;
     }
    private void PrintPrefix(Queue<Node> data,Node root){
   Node x=root,L=root.getLeft(),R=root.getRight();
                 data.enqueue(x);
                 
    if (L!=null)PrintPrefix(data,L);
    if (R!=null) PrintPrefix(data,R);
    }
  public Node[] PrintPostfix(){
        Node x=root;
        Queue<Node> postdata=new Queue<Node>();
        PrintPostfix(postdata,x);
        int i=0,num=postdata.size();
        Node[] postfix=new Node[num];
        while(!postdata.isEmpty()){
            postfix[i]=postdata.dequeue();
            i++;
        }
        return postfix;
    }
     private void PrintPostfix(Queue<Node> postdata,Node root){
   Node x=root,L=root.getLeft(),R=root.getRight();
   
    if (L!=null)PrintPostfix(postdata,L);
    if (R!=null) PrintPostfix(postdata,R);
     postdata.enqueue(x);         
    }

    public double Evaluation(){
        double answer = 0;
        Node sign=root;
        answer=Evaluation(sign);
        return answer;
    }
    private double Evaluation(Node sign){
        double ans=0;
        Node x=sign;
        Node L=x.getLeft(),R=x.getRight();
        if (L.getValue().equals(""+"")||L.getValue().equals(""-"")||L.getValue().equals(""*"")||L.getValue().equals(""/"")) L=new Node(null,null, String.valueOf(Evaluation(L)));
        if (R.getValue().equals(""+"")||R.getValue().equals(""-"")||R.getValue().equals(""*"")||R.getValue().equals(""/"")) R=new Node(null,null, String.valueOf(Evaluation(R)));
        if (x.getValue().equals(""+"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l+r;
        }
        else if (x.getValue().equals(""-"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l-r;
        }
         else if (x.getValue().equals(""*"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l*r;
        }
         else if (x.getValue().equals(""/"")){
           double l=Double.parseDouble(L.getValue()),r=Double.parseDouble(R.getValue());
           ans=l/r;
        }
        return ans;
    }
     public static void main(String[] args) {
         //String input=""(4+(((4*2)/2)/3))"";
         String input=""(((1+(12*5))-(3*4))+(4/5))"";
         //String input=""(((4/5)+3)+(1/2))"";
         String[] stringarray=input.split("""");
    //     for (int i=0 ; i<stringarray.length ; i++)
    //         System.out.print(stringarray[i]+""\t"");
    //     System.out.println();
    //     System.out.println(input);
     Expression calculation=new Expression();
     calculation.Infix2BT(input);
     System.out.println(calculation.root.getValue());
     System.out.println(calculation.root.getLeft().getValue());
     System.out.println(calculation.root.getRight().getValue());
     System.out.println(calculation.root.getLeft().getLeft().getValue());
     System.out.println(calculation.root.getLeft().getLeft().getLeft().getValue());
     //System.out.println(calculation.root.getLeft().getLeft().getLeft().getLeft().getValue());
     //System.out.println(calculation.root.getRight().getLeft().getLeft().getLeft().getLeft());
     Node[] prefix=calculation.PrintPrefix();
     for (int i=0 ; i<prefix.length ; i++)
     System.out.print(prefix[i].getValue()+""\t"");
     System.out.println("""");
     Node[] postfix=calculation.PrintPostfix();
     for (int i=0 ; i<postfix.length ; i++)
     System.out.print(postfix[i].getValue()+""\t"");
     System.out.println("""");
     //System.out.println(calculation.Evaluation());
   
     }
}

@97fb4938db7902a7de0ea1d92377f9ef@"
"r04631009","10","0.097","105920","@df7ba5607b7b81930044a3544422ce57@
public class Expression {

    private Node root;

    // DO NOT MODIFY THIS
    public Expression() {
    }

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix) {

        String a = infix.replace(""+"", "" + "");
        String b = a.replace(""-"", "" - "");
        String c = b.replace(""*"", "" * "");
        String d = c.replace(""/"", "" / "");
        String e = d.replace(""("", "" ( "");
        String f = e.replace("")"", "" ) "");
        String g = f.replace(""  "", "" "");
        String h = g.replaceFirst("" "", """");

        String[] stringarray = h.split("" "");

        Stack<Node> data = new Stack<Node>();
        for (int i = 0; i < stringarray.length; i++) {
            if (stringarray[i].equals("")"")) {
                Node[] temp = new Node[4];
                int tempi = 0;
                while (tempi < 4) {
                    temp[tempi] = data.pop();
                    tempi++;
                }
                temp[1].setLeft(temp[2]);
                temp[1].setRight(temp[0]);
                root = temp[1];
                data.push(root);
            } else {
                Node temp = new Node(null, null, stringarray[i]);
                data.push(temp);
            }
        }
        return root;
    }

    public Node[] PrintPrefix() {
        Queue<Node> data = new Queue<Node>();
        Node x = root;
        PrintPrefix(data, x);
        int i = 0, num = data.size();
        Node[] prefix = new Node[num];
        while (!data.isEmpty()) {
            prefix[i] = data.dequeue();
            i++;
        }
        return prefix;
    }

    private void PrintPrefix(Queue<Node> data, Node root) {
        Node x = root, L = root.getLeft(), R = root.getRight();
        data.enqueue(x);

        if (L != null) {
            PrintPrefix(data, L);
        }
        if (R != null) {
            PrintPrefix(data, R);
        }
    }

    public Node[] PrintPostfix() {
        Node x = root;
        Queue<Node> postdata = new Queue<Node>();
        PrintPostfix(postdata, x);
        int i = 0, num = postdata.size();
        Node[] postfix = new Node[num];
        while (!postdata.isEmpty()) {
            postfix[i] = postdata.dequeue();
            i++;
        }
        return postfix;
    }

    private void PrintPostfix(Queue<Node> postdata, Node root) {
        Node x = root, L = root.getLeft(), R = root.getRight();

        if (L != null) {
            PrintPostfix(postdata, L);
        }
        if (R != null) {
            PrintPostfix(postdata, R);
        }
        postdata.enqueue(x);
    }

    public double Evaluation() {
        double answer = 0;
        Node sign = root;
        answer = Evaluation(sign);
        return answer;
    }

    private double Evaluation(Node sign) {
        double ans = 0;
        Node x = sign;
        Node L = x.getLeft(), R = x.getRight();
        if (L.getValue().equals(""+"") || L.getValue().equals(""-"") || L.getValue().equals(""*"") || L.getValue().equals(""/"")) {
            L = new Node(null, null, String.valueOf(Evaluation(L)));
        }
        if (R.getValue().equals(""+"") || R.getValue().equals(""-"") || R.getValue().equals(""*"") || R.getValue().equals(""/"")) {
            R = new Node(null, null, String.valueOf(Evaluation(R)));
        }
        if (x.getValue().equals(""+"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l + r;
        } else if (x.getValue().equals(""-"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l - r;
        } else if (x.getValue().equals(""*"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l * r;
        } else if (x.getValue().equals(""/"")) {
            double l = Double.parseDouble(L.getValue()), r = Double.parseDouble(R.getValue());
            ans = l / r;
        }
        return ans;
    }

}

@df7ba5607b7b81930044a3544422ce57@"
"r04631021","1","0.09","98656","@96485a7c6788e703013451e20ec554f7@import java.io.*;
import java.util.*;
public class Expression{
  
    private Node root ;
    int treesize = 0 ;
    public int i = 0 ;
    // DO NOT MODIFY THIS
    public Expression(){}

    public int isOperator(String judge){
//if(judge.equals(""+"")||judge.equals(""-"")||judge.equals(""*"")||judge.equals(""/""))
//    return true ;
//else 
//    return false ;
if(judge.equals(""+""))
    return 1 ;
else if(judge.equals(""-""))
    return 2 ;
else if(judge.equals(""*""))
    return 3 ;
else if(judge.equals(""/""))
    return 4 ;
else
    return 5 ;        
}
    
    
private void Calculate(Stack<Double> stack, String operation) {
                    double sce = stack.pop();
                    double fir = stack.pop();

                    if (operation.equals(""+"")) {
                              stack.push(fir + sce);
                    } else if (operation.equals(""-"")) {
                              stack.push(fir - sce);
                    } else if (operation.equals(""*"")) {
                              stack.push(fir * sce);
                    } else if (operation.equals(""/"")) {
                              stack.push(fir / sce);
                    }

          }
    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        //new two stacks one for values , the other is for operators
    Stack<Node> operator = new Stack() ;
    int count = 1 ;
    String[] op = infix.split("""") ;
    int stringlen = op . length - 1 ;
    Node[] oldy = new Node[stringlen] ;
    while(count != infix.length()+1 ){
        switch (op[count]){
            case ""("" :                
                break;
            case ""+"" :  
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""+"");
                treesize++ ;
                break ;
            case ""-"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""-"") ;
                treesize++ ;
               break;
            case ""*"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""*"");
                treesize++ ;
                break ;
            case ""/"" :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]);
                oldy[count].setValue(""/"");
                treesize++ ;
                break;
            case "")"" :
                Node a = operator.pop() ;
                Node b = operator.pop() ;
                Node c = operator.pop() ;
                if(operator.isEmpty()){
                root = new Node(null,null,null);
                root.setLeft(c);
                root.setRight(a);
                root.setValue(b.getValue());
                operator.push(root);

                }
                else{
                b.setLeft(c) ;
                b.setRight(a) ;                
                operator.push(b) ;

                }
                break;
                
            default :
                oldy[count] = new Node (null,null,null);
                operator.push(oldy[count]) ;
                oldy[count].setValue(op[count]);
                treesize++ ;

                break ;
                       
        }
        count++ ;
    }   
        return root;
    }
    
          private void prefix(ArrayList list, Node node) {
                    list.add(node);
                    if (node.getLeft() != null) {
                              prefix(list, node.getLeft());
                    }
                    if (node.getRight() != null) {
                              prefix(list, node.getRight());
                    }
          }


private void postfix(ArrayList list , Node node){
    
    if(node.getLeft() != null){
        postfix(list , node.getLeft()) ;
    }
    if(node.getRight()!=null){
        postfix(list , node.getRight()) ;
        }
    list.add(node) ;
    }

    public Node[] PrintPrefix(){
        
        if(root == null)
            throw new java.lang.NullPointerException();
               
        ArrayList<Node> array = new ArrayList<Node>() ;
        prefix(array,root) ;
        Node[] prefix = new Node[array.size()] ;
        
        for (int count = 0; count < array.size(); count++) {
           prefix[count] = array.get(count);
//           System.out.print(prefix[count].getValue());
           }
        
        return prefix;
        
    }
  
    public Node[] PrintPostfix(){
        
        if(root == null)
            throw new java.lang.NullPointerException() ;
        
        ArrayList<Node> array = new ArrayList<Node>() ;
        postfix(array,root) ;
        Node[] postfix = new Node[array.size()] ;
        
        for(int j = 0 ; j < array.size() ; j ++){
            postfix[j] = array.get(j) ;
//            System.out.print(postfix[j].getValue());
            
        }        
        return postfix;
    }

    public double Evaluation(){
        
        if(root == null)
            throw new java.lang.NullPointerException();
        
        double answer = 0 ;
        double number1 = 0 ;
        
        ArrayList<Node> cal = new ArrayList<Node>() ;
        postfix(cal,root) ;
        Stack<Double> eva = new Stack<Double>() ;
        for(int k = 0 ; k < cal.size() ; k++){
            String a = cal.get(k).getValue() ;
                
                if(isOperator(a) == 1){
                    number1 = eva.pop() ;
                    answer = eva.pop() ;
                     answer += number1;
                    eva.push(answer);
                }
                else if(isOperator(a) == 2){
                    number1 = eva.pop() ;
                    answer = eva.pop() ;
                    answer -= number1 ;
                    eva.push(answer);
                }
                else if(isOperator(a) == 3){
                    number1 = eva.pop() ;
                    answer = eva.pop() ;
                    answer *= number1 ;
                    eva.push(answer);
                }
                else if(isOperator(a) == 4){
                    number1 = eva.pop() ;
                    answer = eva.pop() ;
                    answer = answer / number1 ;
                    eva.push(answer);
                }                
                else
                eva.push(Double.parseDouble(a));
                
        }
        
        
        
        
        
        return answer;
    }

}

@96485a7c6788e703013451e20ec554f7@"
"r03228006","2","0.29","105536","@0d43bea0b28056a2b7a37529c538cd21@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
    private Node root    // DO NOT MODIFY THIS
;
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        int key=1;
        size=0;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){;root=all[i-1];key=i-1;i--;}
        else{
          while(root==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root = all[i];key=i;
                 //System.out.println(all[key].getValue());
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        Node[] prefix = new Node[size];
        int[] check = new int[size];
        Node x = root;
        prefix[0]=x;
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = null;
        Node x =root;
        int i=0;
        int key=0;
        int p=0;
        while(true){
          while(x.getLeft()!=null){x=x.getLeft();}
          postfix[i]=x;i++;
          
          if (postfix[key].getRight()!=null&(i-key)==2){
             postfix[i]=postfix[key].getRight();
             key=i;i++;
          }
          else if (postfix[key].getRight()!=null&key==0){//root right
             postfix[i]=postfix[key].getRight();
             key=i;i++;p=1;
          }
          else{key=key-1;}//1 3
          if(p==1&key==0){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
       Expression x1 = new Expression();
       String infix = ""(4+(((4*2)/2)/3))"";
       String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
       //Node[] all = new Node[Parts.length];

       Node r = x1.Infix2BT(infix); 
       //System.out.println(r.getValue());
       Node[] pre = x1.PrintPrefix();
       for(int i = 0; i < pre.length ; i++){
         System.out.println(pre[i].getValue());
        }

        }
}



@0d43bea0b28056a2b7a37529c538cd21@"
"r02b48003","10","0.097","105552","@a3006c26ed087a700f5ffa57cbc26091@import java.lang.NullPointerException;

/**
 * Class Expression 
 * You are asked to implement a class named Expression.java, which can read in a math expression in infix form, and store the expression in a binary tree.
 * With the data structure of binary trees (BT), the math expression can be easily evaluated (i.e., calculating the value) or converted into different expression forms such prefix, infix, and postfix.
 * To achieve this goal, you will learn how to construct a binary tree from scratch and how to traverse the tree in different ways, including preorder, inorder, or postorder traversal.
 * Please complete this homework by implementing the following API. Please note that your main function will not be executed.
 * Replace the content of the binary tree if a new expression is specified through functions Infix2BT.
 * Throw NullPointerException if the root is null when calling printPreOrder, printInOrder, printPostOrder, or evaluation.
 * @author Clintko, r02b48003
 */
public class Expression{
  
    private Node root;
    private int index;
    private int size;
    
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        index = 1;
        size = 0;
        root = null;
        root = Infix2BT(root, infix);
        return root;
    }
    
    /* Recursive call for Method Infix2BT */
    private Node Infix2BT(Node x, String infix) {
        // initialization
        if (x == null) {
            // since '(' is a recursive call, 
            // for such case ""(((1+2)....."", we need to prevent null Node
            x = new Node(null, null, """");
            this.size += 1; // update size
        } // end if
        String val = """";
        boolean isLeft = true;
        
        // iterate through the expression
        while (true) {
            // read an character
            char c = infix.charAt(this.index++);
            
            // case01: '(': recursive call to the next level
            if (c == '('){ 
                if (isLeft) x.setLeft (Infix2BT(x.getLeft(),  infix));
                else        x.setRight(Infix2BT(x.getRight(), infix));
                continue;
            } // end if
            
            // case02: ')': finish a subtree and break,return
            if (c == ')'){ 
                if (!val.equals("""")) {
                    // if value exist, add to the right link 
                    x.setRight(new Node(null, null, val));
                    // update size
                    this.size += 1;
                } // end if
                break;
            } // end if
            
            // case03: deal with operators
            if (c == '+' || c == '-' || c == '*' || c == '/'){
                if (!val.equals("""")) {
                    // if value exist, add to the left link
                    x.setLeft(new Node(null, null, val));
                    // update size & reset value
                    this.size += 1;
                    val = """";
                } // end if
                
                // node value = operator
                x.setValue(c+"""");
                
                // set isLeft to false and continue
                isLeft = false;
                continue;
            } // end if
            
            // case04: collect char if not special char
            val += c;
        } // end while
        
        return x;
    } // end private class infix2BT 
    
    /**
     * Method: size
     * return the number of nodes in the tree
     * @return integer
     */
    public int size() {
        return size;
    } // end public method size
    
    /**
     * Method: PrintPrefix
     * return Node array in Prefix order by calling a recursive function
     * @return Node[]
     */
    public Node[] PrintPrefix(){
        if (root == null) throw new NullPointerException();
        // initialization
        Node[] prefix = new Node[size];
        index = 0;
        // get Prefix of the expression and return
        PrintPrefix(root, prefix);
        return prefix;
    } // end public method PrintPrefix
    
    /* Recursive call for Method PrintPrefix */
    /* Postfix: (1) print itself (2) print left (3) print right */
    private void PrintPrefix(Node x, Node[] nodes){
        nodes[index++] = x;
        
        if (x.getLeft() != null)
            PrintPrefix(x.getLeft(), nodes);
        
        if (x.getRight() != null)
            PrintPrefix(x.getRight(), nodes);
    } // end private method PrintPrefix
    
    /**
     * Method: PrintPostfix
     * return Node array in Postfix order by calling a recursive function
     * @return Node[]
     */
    public Node[] PrintPostfix(){
        if (root == null) throw new NullPointerException();
        // initialization
        Node[] postfix = new Node[size];
        index = 0;
        // get Postfix of the expression and return
        PrintPostfix(root, postfix);
        return postfix;
    } // end public method PrintPostfix
    
    /* Recursive call for Method PrintPostfix */
    /* Postfix: (1) print left (2) print right (3) print itself */
    private void PrintPostfix(Node x, Node[] nodes){
        if (x.getLeft() != null)
            PrintPostfix(x.getLeft(), nodes);
        
        if (x.getRight() != null)
            PrintPostfix(x.getRight(), nodes);
        
        nodes[index++] = x;
    } // end private method PrintPrefix

    /**
     * Method: Evaluation
     * calculate the result of expression by calling a recursive function
     * @return Node[]
     */
    public double Evaluation(){
        double answer = Evaluation(root);
        return answer;
    } // end public method Evaluation
    
    /* Recursive call for Method Evaluation */
    private Double Evaluation(Node x){
        if (x.getLeft() == null) return Double.parseDouble(x.getValue());
        
        // first evaluation left and right subtree
        Double val1 = Evaluation(x.getLeft());
        Double val2 = Evaluation(x.getRight());
        
        // return the result
        if (x.getValue().equals(""+"")) return val1 + val2;
        if (x.getValue().equals(""-"")) return val1 - val2;
        if (x.getValue().equals(""*"")) return val1 * val2;
        if (x.getValue().equals(""/"")) return val1 / val2; 
        
        // impossible to be executed, unless other operators exist
        return null; 
    } // end private method Evaluation
    
    public static void main(String[] args) {
        Expression exp = new Expression();
        String expStr0 = ""(4+(((4*2)/2)/3))"";
        String expStr1 = ""(10+25)"";
        String expStr2 = ""(1.5+2.6)"";
        String expStr3 = ""((1*2)+(1/2))"";
        String expStr4 = ""(((2/1)+(3+4))+(10/5))"";
        String expStr5 = ""((1.1122+10.3344)+100.5511)"";
        
        Node root;
        Node[] nodes;
        
        System.out.println(""---------Expression 00---------"");
        root = exp.Infix2BT(expStr0);
        System.out.println(""Expression: "" + expStr0);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
        System.out.println(""---------Expression 02---------"");
        root = exp.Infix2BT(expStr2);
        System.out.println(""Expression: "" + expStr2);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
        System.out.println(""---------Expression 03---------"");
        root = exp.Infix2BT(expStr3);
        System.out.println(""Expression: "" + expStr3);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
        System.out.println(""---------Expression 04---------"");
        root = exp.Infix2BT(expStr4);
        System.out.println(""Expression: "" + expStr4);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
        
        System.out.println(""---------Expression 05---------"");
        root = exp.Infix2BT(expStr5);
        System.out.println(""Expression: "" + expStr5);
        System.out.println(""Size: "" + exp.size());
        System.out.println(root.getValue());
        System.out.println(root.getLeft().getValue());
        System.out.println(root.getRight().getValue());
        
        System.out.print(""PrintPrefix: "");
        nodes = exp.PrintPrefix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""PrintPostfix: "");
        nodes = exp.PrintPostfix();
        for (Node x : nodes) System.out.print(x.getValue() + "" "");
        System.out.println();
        
        System.out.print(""Evaluation: "");
        System.out.print(exp.Evaluation());
        System.out.println();
    } // end main
} // end class Expression

@a3006c26ed087a700f5ffa57cbc26091@"
"r03228006","3","0.49","104384","@022f82779b57663732b33fecc3cc8d7c@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
    private Node root    // DO NOT MODIFY THIS
;
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        int key=1;
        size=0;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){;root=all[i-1];key=i-1;i--;}
        else{
          while(root==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root = all[i];key=i;
                 //System.out.println(all[key].getValue());
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        Node[] prefix = new Node[size];
        int[] check = new int[size];
        Node x = root;
        prefix[0]=x;
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix = new Node[size];
        postfix[size-1]=root;
        int[] check = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&(key-i)==2){
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else if (postfix[key].getLeft()!=null&(key-i)>=3&&check[key]==1){//root right
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        double answer = 0;
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
       Expression x1 = new Expression();
       String infix = ""(4+(((4*2)/2)/3))"";
       String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
       //Node[] all = new Node[Parts.length];

       Node r = x1.Infix2BT(infix); 
       //System.out.println(r.getValue());
       Node[] pre = x1.PrintPrefix();
       for(int i = 0; i < pre.length ; i++){
         System.out.println(pre[i].getValue());
        }
       Node[] pos = x1.PrintPostfix();
       for(int i = 0; i < pos.length ; i++){
         System.out.println(pos[i].getValue());
        }

        }
}


@022f82779b57663732b33fecc3cc8d7c@"
"r04522616","10","0.098","103888","@6b8f3f252447c15f11d6346d5f531731@//import edu.princeton.cs.algs4.Stack;
public class Expression{
  
    private Node root;
    String[] outData;
    Queue<Node> qPreNode=new Queue<Node>();
    Queue<Node> qPostNode=new Queue<Node>();
    // DO NOT MODIFY THIS
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
        String str=infix;
        outData=str.split(""(?<=[-+*/\\(\\)])|(?=[-+*/\\(\\)])"");
        Stack<String> stk=new Stack<String>();
        Node tempRoot=null;
        Node tempRoot2=null;
        
        int i=0;
        int j=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  if(j==0)
                  {
                      String rightString = stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      
                      Node b = new Node(null, null, rightString); 
                      Node a = new Node(null, null, leftString);
                      
                      tempRoot=new Node(a, b, midString);
                      stk.pop();                     
                      
                      j++;
                  }
                  else
                  {
                      String rightString=stk.pop();
                      String midString = stk.pop();
                      String leftString = stk.pop();
                      char rightIsANumber=rightString.charAt(0);
                      char midIsANumber=midString.charAt(0);
                      char leftIsANumber=leftString.charAt(0);
                      if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          tempRoot=new Node(tempRoot, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)==true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          Node a = new Node(null, null, midString);
                          tempRoot=new Node(a, tempRoot, rightString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)==true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)==true)
                      {
                          stk.push(leftString);
                          Node b = new Node(null, null, rightString);
                          Node a = new Node(null, null, leftString);
                          tempRoot2=new Node(a, b, midString);
                          stk.pop();
                      }
                      else if(Character.isDigit(rightIsANumber)!=true && Character.isDigit(midIsANumber)!=true && Character.isDigit(leftIsANumber)!=true)
                      {
                          stk.push(leftString);
                          tempRoot=new Node(tempRoot, tempRoot2, midString);
                          stk.pop();
                      }
                  }
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
          
          root=tempRoot;
        return root;
    }

    public Node[] PrintPrefix(){
        int length=((outData.length+1)/2);

        Node[] prefix=new Node[length];
//            int countNull=0;
//            int length=((outData.length+1)/2);
//            prefix = new Node[length];
//            String[] copyOutData=new String[outData.length];
//            for(int i=0;i<outData.length;i++)
//            {
//                if(outData[i]==null)
//                {
//                    countNull++;
//                }            
//            }
//            for(int i=0;i<outData.length;i++)
//            {
//                copyOutData[i]=outData[countNull+i];
//            }
//  
//            for(int i=0;i<outData.length;i++)
//            {
//                char isANumber=copyOutData[i].charAt(0);
//                if(Character.isDigit(isANumber)!=true && copyOutData[i].equals(""("")!=true && copyOutData[i].equals("")"")!=true)
//                {
//                    for(int j=i-1;j>=0;j--)
//                    {
//                        if(copyOutData[j].equals(""(""))
//                        {
//                            copyOutData[j]=copyOutData[i];
//                            copyOutData[i]="")"";
//                            break;
//                        }
//                    }
//                }
//            }
//            String out = """";
//            int a=0;
//            for(int i=0;i<outData.length;i++)
//            {
//                if(copyOutData[i].equals("")"")!=true)
//                {
//                    out = copyOutData[i];
//                    Node b=new Node(null,null,out);
//                    prefix[i-a]=b;
//                    //check[i-a]=out;
//                }
//                else if(copyOutData[i].equals("")"")==true)
//                {
//                    a++;
//                }
//            }

        preorderPrintTree(root);
        for(int i=0;i<((outData.length+1)/2);i++)
        {
            prefix[i]=qPreNode.dequeue();
        }
        return prefix;
    }
    
    private void preorderPrintTree(Node root) {

        if (root.getLeft()==null&&root.getRight()==null)
        {
            qPreNode.enqueue(root);
            //System.out.print(root.getValue());
        }            
        else{
            qPreNode.enqueue(root);
            //System.out.print(root.getValue());

            preorderPrintTree(root.getLeft());
            preorderPrintTree(root.getRight());

        }
    }

  
    public Node[] PrintPostfix(){
        int length=((outData.length+1)/2);

        Node[] postfix=new Node[length];

//            int length=((outData.length+1)/2);
//            postfix = new Node[length];
//
//            int countNull=0;
//            String[] copyOutData=new String[outData.length];
//            for(int i=0;i<outData.length;i++)
//            {
//                if(outData[i]==null)
//                {
//                    countNull++;
//                }
//            }
//            for(int i=0;i<outData.length;i++)
//            {
//                copyOutData[i]=outData[countNull+i];
//            }
//
//            Stack<String> stk=new Stack<String>();
//            int j=0;
//            for(int i=0;i<outData.length;i++)
//            {            
//                char isANumber=copyOutData[i].charAt(0);
//                if(copyOutData[i].equals(""(""))
//                {
//                    j++;
//                }
//                else if(copyOutData[i].equals("")""))
//                {
//                    String symbol=stk.pop();
//                    postfix[i-j]=new Node(null, null, symbol);
//                }
//                else if(Character.isDigit(isANumber)!=true && copyOutData[i].equals(""("")!=true && copyOutData[i].equals("")"")!=true)
//                {
//                    j++;
//                    stk.push(copyOutData[i]);
//                }
//                else
//                {
//                    Node a=new Node(null, null, copyOutData[i]);
//                    postfix[i-j]=a;
//                }
//            }

        postorderPrintTree(root);
        for(int i=0;i<((outData.length+1)/2);i++)
        {
            postfix[i]=qPostNode.dequeue();
        }
        return postfix;
    }
    
    private void postorderPrintTree(Node root) {
        if (root.getLeft()==null&&root.getRight()==null) {
            qPostNode.enqueue(root);
            //System.out.print(root.getValue());
        } else {
            postorderPrintTree(root.getLeft());
            postorderPrintTree(root.getRight());
            qPostNode.enqueue(root);
            //System.out.print(root.getValue());            
        }
    }

    public double Evaluation(){
        double answer = 0;
        Stack<String> stk=new Stack<String>();
        int i=0;
          do
          {
              if(outData[i].equals("")""))
              {
                  String num2 = stk.pop();
                  double numTwo=Double.parseDouble(num2);

                  String label = stk.pop();             

                  String num1 = stk.pop();
                  double numOne=Double.parseDouble(num1);
                  if(label.equals(""+""))
                  {
                      answer = numOne+numTwo;
                  }
                  if(label.equals(""-""))
                  {
                      answer = numOne-numTwo;
                  }
                  if(label.equals(""*""))
                  {
                      answer = numOne*numTwo;
                  }
                  if(label.equals(""/""))
                  {
                      answer = numOne/numTwo;
                  }
                  stk.pop();
                  stk.push(String.valueOf(answer));
              }
              else
              {
                  stk.push(outData[i]);
              }
              i++;
          }
          while(i!=outData.length);
        return answer;
    }
}

@6b8f3f252447c15f11d6346d5f531731@"
"r03228006","4","0.49","105536","@68df91148d26a1ef3f2df1c40fb6340c@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
   private Node root;    // DO NOT MODIFY THIS
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        int key=1;
        size=0;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){root=all[i-1];key=i-1;i--;}
        else{
          while(root==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root = all[i];key=i;
                 //System.out.println(all[key].getValue());
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        Node[] prefix=new Node[size];;
        int[] check = new int[size];
        prefix[0]=new Node(root.getLeft(),root.getRight(),root.getValue());
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix=new Node[size];
        postfix[size-1]=root;
        int[] check = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&(key-i)==2){
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else if (postfix[key].getLeft()!=null&(key-i)>=3&&check[key]==1){//root right
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        Node[] prefix= PrintPrefix();
        Node[] postfix= PrintPostfix();
        for (int i =0;i<(postfix.length);i++){
            if(postfix[i].getValue().equals(""+"")|postfix[i].getValue().equals(""-"")|postfix[i].getValue().equals(""*"")|postfix[i].getValue().equals(""/"")){
                int j = i-1;
                while(postfix[j]==null){j--;}
                Double a = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
                j--;
                while(postfix[j]==null){j--;}
                Double b = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
               if(postfix[i].getValue().equals(""+"")){postfix[i].setValue(Double.toString(b+a)); }
               if(postfix[i].getValue().equals(""-"")){postfix[i].setValue(Double.toString(b-a)); }
               if(postfix[i].getValue().equals(""*"")){postfix[i].setValue(Double.toString(b*a)); }
               if(postfix[i].getValue().equals(""/"")){postfix[i].setValue(Double.toString(b/a)); }
            }}
        double answer = Double.parseDouble(postfix[postfix.length-1].getValue());
       
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
       Expression x1 = new Expression();
       String infix = ""(4+(((4*2)/2)/3))"";
       String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
       //Node[] all = new Node[Parts.length];

       Node r = x1.Infix2BT(infix); 
       //System.out.println(r.getValue());
       Node[] pre = x1.PrintPrefix();
       for(int i = 0; i < pre.length ; i++){
         System.out.println(pre[i].getValue());
        }
       Node[] pos = x1.PrintPostfix();
       for(int i = 0; i < pos.length ; i++){
         System.out.println(pos[i].getValue());
        }
       System.out.println(x1.Evaluation());

        }
}


@68df91148d26a1ef3f2df1c40fb6340c@"
"r03228006","4","0.48","105552","@598303faa94145ff4c903313fe5f88db@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
   private Node root;    // DO NOT MODIFY THIS
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        if(Parts.length<3){throw new NullPointerException();}
        int key=1;
        size=0;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        if (Parts.length==3){root=new Node(null,null,Parts[1]);return root;}
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){root=all[i-1];key=i-1;i--;}
        else{
          while(root==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root = all[i];key=i;
                 //System.out.println(all[key].getValue());
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        //System.out.println(size);
        //if(size==1) {
        //Node[] prefix=new Node[1];
        //prefix[0]= root;
        //return prefix;}
        
        Node[] prefix=new Node[size];
        int[] check = new int[size];
        prefix[0]=root;
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        Node[] postfix=new Node[size];
        postfix[size-1]=root;
        int[] check = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&(key-i)==2){
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else if (postfix[key].getLeft()!=null&(key-i)>=3&&check[key]==1){//root right
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        Node[] prefix= PrintPrefix();
        Node[] postfix= PrintPostfix();
        for (int i =0;i<(postfix.length);i++){
            if(postfix[i].getValue().equals(""+"")|postfix[i].getValue().equals(""-"")|postfix[i].getValue().equals(""*"")|postfix[i].getValue().equals(""/"")){
                int j = i-1;
                while(postfix[j]==null){j--;}
                Double a = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
                j--;
                while(postfix[j]==null){j--;}
                Double b = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
               if(postfix[i].getValue().equals(""+"")){postfix[i].setValue(Double.toString(b+a)); }
               if(postfix[i].getValue().equals(""-"")){postfix[i].setValue(Double.toString(b-a)); }
               if(postfix[i].getValue().equals(""*"")){postfix[i].setValue(Double.toString(b*a)); }
               if(postfix[i].getValue().equals(""/"")){postfix[i].setValue(Double.toString(b/a)); }
            }}
        double answer = Double.parseDouble(postfix[postfix.length-1].getValue());
       
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
       Expression x1 = new Expression();
       String infix = ""(((0.235+0.88)*7.2)+(200+10))"";
       //String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
       //Node[] all = new Node[Parts.length];

       Node r = x1.Infix2BT(infix); 
       System.out.println(r.getValue());
       //System.out.println(r.getValue());
       Node[] pre = x1.PrintPrefix();
       for(int i = 0; i < pre.length ; i++){
         System.out.println(pre[i].getValue());
        }
       Node[] pos = x1.PrintPostfix();
       for(int i = 0; i < pos.length ; i++){
         System.out.println(pos[i].getValue());
        }
       System.out.println(x1.Evaluation());

        }
}


@598303faa94145ff4c903313fe5f88db@"
"r03228006","5","0.6","104640","@ef95c75a09200d64a66bb7e22fdd5dfb@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
   private Node root;    // DO NOT MODIFY THIS
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        if(Parts.length<3){throw new NullPointerException();}
        int key=1;
        size=0;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        if (Parts.length==3){root=new Node(null,null,Parts[1]);return root;}
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){root=all[i-1];key=i-1;i--;}
        else{
          while(root==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root = all[i];key=i;
                 //System.out.println(all[key].getValue());
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        //System.out.println(size);
        //if(size==1) {
        //Node[] prefix=new Node[1];
        //prefix[0]= root;
        //return prefix;}
        if(root==null){throw new NullPointerException();}
        Node[] prefix=new Node[size];
        int[] check = new int[size];
        prefix[0]=root;
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){throw new NullPointerException();}
        Node[] postfix=new Node[size];
        postfix[size-1]=root;
        int[] check = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&(key-i)==2){
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else if (postfix[key].getLeft()!=null&(key-i)>=3&&check[key]==1){//root right
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        if(root==null){throw new NullPointerException();}
        Node[] prefix= PrintPrefix();
        Node[] postfix= PrintPostfix();
        for (int i =0;i<(postfix.length);i++){
            if(postfix[i].getValue().equals(""+"")|postfix[i].getValue().equals(""-"")|postfix[i].getValue().equals(""*"")|postfix[i].getValue().equals(""/"")){
                int j = i-1;
                while(postfix[j]==null){j--;}
                Double a = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
                j--;
                while(postfix[j]==null){j--;}
                Double b = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
               if(postfix[i].getValue().equals(""+"")){postfix[i].setValue(Double.toString(b+a)); }
               if(postfix[i].getValue().equals(""-"")){postfix[i].setValue(Double.toString(b-a)); }
               if(postfix[i].getValue().equals(""*"")){postfix[i].setValue(Double.toString(b*a)); }
               if(postfix[i].getValue().equals(""/"")){postfix[i].setValue(Double.toString(b/a)); }
            }}
        double answer = Double.parseDouble(postfix[postfix.length-1].getValue());
       
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
       Expression x1 = new Expression();
       String infix = ""(((0.235+0.88)*7.2)+(200+10))"";
       //String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
       //Node[] all = new Node[Parts.length];

       Node r = x1.Infix2BT(infix); 
       System.out.println(r.getValue());
       //System.out.println(r.getValue());
       Node[] pre = x1.PrintPrefix();
       for(int i = 0; i < pre.length ; i++){
         System.out.println(pre[i].getValue());
        }
       Node[] pos = x1.PrintPostfix();
       for(int i = 0; i < pos.length ; i++){
         System.out.println(pos[i].getValue());
        }
       System.out.println(x1.Evaluation());

        }
}


@ef95c75a09200d64a66bb7e22fdd5dfb@"
"r03228006","4","0.58","105632","@231a9805a0cb52948054a62053d77931@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
   private Node root;    // DO NOT MODIFY THIS
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        root=new Node(null,null,null);
        //System.out.println(root.getValue()==null);     
        size=0;
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        if(Parts.length<3){throw new NullPointerException();}
        int key=1;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        if (Parts.length==3){root=new Node(null,null,Parts[1]);return root;}
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){root=all[i-1];key=i-1;i--;}
        //if(ri==1){root.setValue(all[i-1].getValue());key=i-1;i--;}
        else{
          while(root.getValue()==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root=all[i];key=i;
                 //root.setValue(all[i].getValue());key=i;
                // break;
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        //System.out.println(size);
        
        if(root==null){throw new NullPointerException();}
        //ArrayList<Node> pre = new ArrayList<Node>();
       // size=1;
       // Node test = root;
       // while(test.getLeft()!=null|test.getRight()!=null){
       //    while(test.getLeft().getLeft()!=null){test=test.getLeft(); size++;}
       //   size++;//the depest left
       //    while(test.getRight().getRight()!=null){test=test.getRight(); size++;}
       //    size++;
       // }
        Node[] prefix=new Node[size];
        int[] check = new int[size];
        //pre.add(root);
        prefix[0]=root;
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root==null){throw new NullPointerException();}
        Node[] postfix=new Node[size];
        postfix[size-1]=root;
        int[] check = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&(key-i)==2){
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else if (postfix[key].getLeft()!=null&(key-i)>=3&&check[key]==1){//root right
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        if(root==null){throw new NullPointerException();}
        Node[] prefix= PrintPrefix();
        Node[] postfix= PrintPostfix();
        System.out.println(postfix.length);//to find +-*/
        for (int i =0;i<(postfix.length);i++){
            if(postfix[i].getValue().equals(""+"")|postfix[i].getValue().equals(""-"")|postfix[i].getValue().equals(""*"")|postfix[i].getValue().equals(""/"")){
                int j = i-1;
                while(postfix[j]==null){j--;}
                Double a = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
                j--;
                while(postfix[j]==null){j--;}
                Double b = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
               if(postfix[i].getValue().equals(""+"")){postfix[i].setValue(Double.toString(b+a)); }
               if(postfix[i].getValue().equals(""-"")){postfix[i].setValue(Double.toString(b-a)); }
               if(postfix[i].getValue().equals(""*"")){postfix[i].setValue(Double.toString(b*a)); }
               if(postfix[i].getValue().equals(""/"")){postfix[i].setValue(Double.toString(b/a)); }
            }}
        double answer = Double.parseDouble(postfix[postfix.length-1].getValue());
       
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
       Expression x1 = new Expression();
       //String infix = ""((20120224791*(121259+797912))+(211544771212/2))"";
       //String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
       //Node[] all = new Node[Parts.length];
       String[] infix = new String[]{""((20120224791*(121259+797912))+(211544771212/2))"",""(((1.23-(121259+797912))*(21212+213135498))/32349)"",""((1312.1+((5.132*323.13)/(131313.12+464588)))""};
       String infix2 = ""((20120224791*(121259+797912))+(211544771212/2))"";
 for (int j =0;j<3;j++){
       Node r = x1.Infix2BT(infix[j]); 
       System.out.println(r.getValue());
       //System.out.println(r.getValue());
       Node[] pre = x1.PrintPrefix();
       for(int i = 0; i < pre.length ; i++){
         System.out.println(pre[i].getValue());
        }
       Node[] pos = x1.PrintPostfix();
       for(int i = 0; i < pos.length ; i++){
         System.out.println(pos[i].getValue());
        }
       System.out.println(x1.Evaluation());
       
   }
        }
}


@231a9805a0cb52948054a62053d77931@"
"r03228006","5","0.59","105552","@9d45f97a22e7f1eb2121a9c1b1aa551d@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
   private Node root;    // DO NOT MODIFY THIS
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        root=new Node(null,null,null);
        //System.out.println(root.getValue()==null);     
        size=0;
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        if(Parts.length<3){throw new NullPointerException();}
        int key=1;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        if (Parts.length==3){root.setValue(Parts[1]);return root;}
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){root=all[i-1];key=i-1;i--;}
        //if(ri==1){root.setValue(all[i-1].getValue());key=i-1;i--;}
        else{
          while(root.getValue()==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root=all[i];key=i;
                 //root.setValue(all[i].getValue());key=i;
                // break;
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        //System.out.println(size);
        
        if(root.getValue()==null){throw new NullPointerException();}
        //ArrayList<Node> pre = new ArrayList<Node>();
       // size=1;
       // Node test = root;
       // while(test.getLeft()!=null|test.getRight()!=null){
       //    while(test.getLeft().getLeft()!=null){test=test.getLeft(); size++;}
       //   size++;//the depest left
       //    while(test.getRight().getRight()!=null){test=test.getRight(); size++;}
       //    size++;
       // }
        Node[] prefix=new Node[size];
        int[] check = new int[size];
        //pre.add(root);
        prefix[0]=root;
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root.getValue()==null){throw new NullPointerException();}
        Node[] postfix=new Node[size];
        postfix[size-1]=root;
        int[] check = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&(key-i)==2){
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else if (postfix[key].getLeft()!=null&(key-i)>=3&&check[key]==1){//root right
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        if(root.getValue()==null){throw new NullPointerException();}
        Node[] prefix= PrintPrefix();
        Node[] postfix= PrintPostfix();
        //System.out.println(postfix.length);//to find +-*/
        for (int i =0;i<(postfix.length);i++){
            if(postfix[i].getValue().equals(""+"")|postfix[i].getValue().equals(""-"")|postfix[i].getValue().equals(""*"")|postfix[i].getValue().equals(""/"")){
                int j = i-1;
                while(postfix[j]==null){j--;}
                Double a = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
                j--;
                while(postfix[j]==null){j--;}
                Double b = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
               if(postfix[i].getValue().equals(""+"")){postfix[i].setValue(Double.toString(b+a)); }
               if(postfix[i].getValue().equals(""-"")){postfix[i].setValue(Double.toString(b-a)); }
               if(postfix[i].getValue().equals(""*"")){postfix[i].setValue(Double.toString(b*a)); }
               if(postfix[i].getValue().equals(""/"")){postfix[i].setValue(Double.toString(b/a)); }
            }}
        double answer = Double.parseDouble(postfix[postfix.length-1].getValue());
       
        return answer;
    }
    
    public static void main(String[] args) throws Exception {
       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
       Expression x1 = new Expression();
       //String infix = ""((20120224791*(121259+797912))+(211544771212/2))"";
       //String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
       //Node[] all = new Node[Parts.length];
       String[] infix = new String[]{""((20120224791*(121259+797912))+(211544771212/2))"",""(((1.23-(121259+797912))*(21212+213135498))/32349)"",""((1312.1+((5.132*323.13)/(131313.12+464588)))""};
       String infix2 = ""(2)"";
 //for (int j =0;j<3;j++){
       Node r = x1.Infix2BT(infix2); 
       System.out.println(r.getValue());
       Node[] pre = x1.PrintPrefix();
       for(int i = 0; i < pre.length ; i++){
         System.out.println(pre[i].getValue());
        }
       Node[] pos = x1.PrintPostfix();
       for(int i = 0; i < pos.length ; i++){
         System.out.println(pos[i].getValue());
        }
      System.out.println(x1.Evaluation());
       
   //}
        }
}


@9d45f97a22e7f1eb2121a9c1b1aa551d@"
"r03228006","5","0.58","105552","@6b1b54ca8a5ac34bb7ca6e3999829043@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
   private Node root;    // DO NOT MODIFY THIS
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        root=new Node(null,null,null);
        //System.out.println(root.getValue()==null);     
        size=0;
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        if(Parts.length<3){throw new NullPointerException();}
        int key=1;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        if (Parts.length==3){root.setValue(Parts[1]);return root;}
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){root=all[i-1];key=i-1;i--;}
        //if(ri==1){root.setValue(all[i-1].getValue());key=i-1;i--;}
        else{
          while(root.getValue()==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root=all[i];key=i;
                 //root.setValue(all[i].getValue());key=i;
                // break;
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        //System.out.println(size);
        
        if(root.getValue()==null){throw new NullPointerException();}
        //ArrayList<Node> pre = new ArrayList<Node>();
       // size=1;
       // Node test = root;
       // while(test.getLeft()!=null|test.getRight()!=null){
       //    while(test.getLeft().getLeft()!=null){test=test.getLeft(); size++;}
       //   size++;//the depest left
       //    while(test.getRight().getRight()!=null){test=test.getRight(); size++;}
       //    size++;
       // }
        Node[] prefix=new Node[size];
        int[] check = new int[size];
        //pre.add(root);
        prefix[0]=root;
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root.getValue()==null){throw new NullPointerException();}
        Node[] postfix=new Node[size];
        postfix[size-1]=root;
        int[] check = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&(key-i)==2){
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else if (postfix[key].getLeft()!=null&(key-i)>=3&&check[key]==1){//root right
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        if(root.getValue()==null){throw new NullPointerException();}
        Node[] prefix= PrintPrefix();
        Node[] postfix= PrintPostfix();
        //System.out.println(postfix.length);//to find +-*/
        for (int i =0;i<(postfix.length);i++){
            if(postfix[i].getValue().equals(""+"")|postfix[i].getValue().equals(""-"")|postfix[i].getValue().equals(""*"")|postfix[i].getValue().equals(""/"")){
                int j = i-1;
                while(postfix[j]==null){j--;}
                Double a = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
                j--;
                while(postfix[j]==null){j--;}
                Double b = Double.parseDouble(postfix[j].getValue());
                postfix[j]=null;
               if(postfix[i].getValue().equals(""+"")){postfix[i].setValue(Double.toString(b+a)); }
               if(postfix[i].getValue().equals(""-"")){postfix[i].setValue(Double.toString(b-a)); }
               if(postfix[i].getValue().equals(""*"")){postfix[i].setValue(Double.toString(b*a)); }
               if(postfix[i].getValue().equals(""/"")){postfix[i].setValue(Double.toString(b/a)); }
            }}
        double answer = Double.parseDouble(postfix[postfix.length-1].getValue());
       
        return answer;
    }
    
    
    	public static void main(String[] args) throws Exception{
		 try(BufferedReader br = new BufferedReader(new FileReader(""input9.txt""))){
			 String temp;
			 while((temp = br.readLine())!=null){
				 String[] split_temp=temp.split("" "");
				 for(String input:split_temp){
					 Expression e = new Expression();
					 Node n = e.Infix2BT(input);			 
					 Node[] pre = e.PrintPrefix();
					 Node[] post = e.PrintPostfix();
					 double answer = e.Evaluation();
					 System.out.println(""PrintPrefix: "");
					 for(int i = 0 ; i<pre.length;i++){
						 System.out.println(pre[i].getValue());
					 }
					 System.out.println("""");
					 System.out.println(""PrintPostfix: "");
					 for(int i = 0 ; i<post.length;i++){
						 System.out.println(post[i].getValue());
					 }
					 System.out.println("""");
					 System.out.println(""Evaluation(): "");
					 System.out.println(answer);
					 System.out.println("""");
				 }
			 }
		 }	
	}
    
    
//    public static void main(String[] args) throws Exception {
//       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
//       Expression x1 = new Expression();
//       //String infix = ""((20120224791*(121259+797912))+(211544771212/2))"";
//       //String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
//       //Node[] all = new Node[Parts.length];
//       String[] infix = new String[]{""((20120224791*(121259+797912))+(211544771212/2))"",""(((1.23-(121259+797912))*(21212+213135498))/32349)"",""((1312.1+((5.132*323.13)/(131313.12+464588)))""};
//       String infix2 = ""(2)"";
// for (int j =0;j<3;j++){
//       Node r = x1.Infix2BT(infix[j]); 
//       System.out.println(r.getValue());
//       Node[] pre = x1.PrintPrefix();
//       for(int i = 0; i < pre.length ; i++){
//         System.out.println(pre[i].getValue());
//        }
//       Node[] pos = x1.PrintPostfix();
//       for(int i = 0; i < pos.length ; i++){
//         System.out.println(pos[i].getValue());
//        }
//      System.out.println(x1.Evaluation());
//       
//   //}
//        }
//}

}


@6b1b54ca8a5ac34bb7ca6e3999829043@"
"r03228006","6","0.58","105584","@c5c44ec29779a838b6bd4cdc251992ee@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
   private Node root;    // DO NOT MODIFY THIS
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        root=new Node(null,null,null);
        //System.out.println(root.getValue()==null);     
        size=0;
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        if(Parts.length<3){throw new NullPointerException();}
        int key=1;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        if (Parts.length==3){root.setValue(Parts[1]);return root;}
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){root=all[i-1];key=i-1;i--;}
        //if(ri==1){root.setValue(all[i-1].getValue());key=i-1;i--;}
        else{
          while(root.getValue()==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root=all[i];key=i;
                 //root.setValue(all[i].getValue());key=i;
                // break;
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        //System.out.println(size);
        
        if(root.getValue()==null){throw new NullPointerException();}
        //ArrayList<Node> pre = new ArrayList<Node>();
       // size=1;
       // Node test = root;
       // while(test.getLeft()!=null|test.getRight()!=null){
       //    while(test.getLeft().getLeft()!=null){test=test.getLeft(); size++;}
       //   size++;//the depest left
       //    while(test.getRight().getRight()!=null){test=test.getRight(); size++;}
       //    size++;
       // }
        Node[] prefix=new Node[size];
        int[] check = new int[size];
        //pre.add(root);
        prefix[0]=root;
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root.getValue()==null){throw new NullPointerException();}
        Node[] postfix=new Node[size];
        postfix[size-1]=root;
        int[] check = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&(key-i)==2){
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else if (postfix[key].getLeft()!=null&(key-i)>=3&&check[key]==1){//root right
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        if(root.getValue()==null){throw new NullPointerException();}
        Node[] postf= new Node[PrintPostfix().length];
        for (int i=0;i<postf.length;i++){postf[i]=new Node(null,null,PrintPostfix()[i].getValue());}
        //System.out.println(postfix.length);//to find +-*/
        for (int i =0;i<(postf.length);i++){
            if(postf[i].getValue().equals(""+"")|postf[i].getValue().equals(""-"")|postf[i].getValue().equals(""*"")|postf[i].getValue().equals(""/"")){
                int j = i-1;
                while(postf[j]==null){j--;}
                Double a = Double.parseDouble(postf[j].getValue());
                postf[j]=null;
                j--;
                while(postf[j]==null){j--;}
                Double b = Double.parseDouble(postf[j].getValue());
                postf[j]=null;
               if(postf[i].getValue().equals(""+"")){postf[i].setValue(Double.toString(b+a)); }
               if(postf[i].getValue().equals(""-"")){postf[i].setValue(Double.toString(b-a)); }
               if(postf[i].getValue().equals(""*"")){postf[i].setValue(Double.toString(b*a)); }
               if(postf[i].getValue().equals(""/"")){postf[i].setValue(Double.toString(b/a)); }
            }}
        double answer = Double.parseDouble(postf[postf.length-1].getValue());
       
        return answer;
    }
    
    
//    	public static void main(String[] args) throws Exception{
//		 try(BufferedReader br = new BufferedReader(new FileReader(""input9.txt""))){
//			 String temp;
//			 while((temp = br.readLine())!=null){
//				 String[] split_temp=temp.split("" "");
//				 for(String input:split_temp){
////                                         String[] Parts = input.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
////                                         System.out.println(""Input: "");
////					 for(int i = 0 ; i<Parts.length;i++){
////						 System.out.println(Parts[i]);
////					 }
//					 Expression e = new Expression();
//					 Node n = e.Infix2BT(input);			 
//					 Node[] pre = e.PrintPrefix();
//					 Node[] post = e.PrintPostfix();
//					 double answer = e.Evaluation();
//					 System.out.println(""PrintPrefix: "");
//					 for(int i = 0 ; i<pre.length;i++){
//						 System.out.println(pre[i].getValue());
//					 }
//					 System.out.println("""");
//					 System.out.println(""PrintPostfix: "");
//					 for(int i = 0 ; i<post.length;i++){
//						 System.out.println(post[i].getValue());
//					 }
//					 System.out.println("""");
//					 System.out.println(""Evaluation(): "");
//					 System.out.println(answer);
//					 System.out.println("""");
//				 }
//			 }
//		 }	
//	}
    
    
    public static void main(String[] args) throws Exception {
       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
       
       //String infix = ""((20120224791*(121259+797912))+(211544771212/2))"";
       //String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
       //Node[] all = new Node[Parts.length];
       String[] infix = new String[]{""((20120224791*(121259+797912))+(211544771212/2))"",""(((1.23-(121259+797912))*(21212+213135498))/32349)"",""((1312.1+((5.132*323.13)/(131313.12+464588)))""};
       String infix2 = ""(4+(((4*2)/2)/3))"";
// for (int j =0;j<3;j++){
       Expression e = new Expression();
       Node n = e.Infix2BT(infix2);			 
       Node[] pre = e.PrintPrefix();
       Node[] post = e.PrintPostfix();
					 double answer = e.Evaluation();
					 System.out.println(""PrintPrefix: "");
					 for(int i = 0 ; i<pre.length;i++){
						 System.out.println(pre[i].getValue());
					 }
					 System.out.println("""");
					 System.out.println(""PrintPostfix: "");
					 for(int i = 0 ; i<post.length;i++){
						 System.out.println(post[i].getValue());
					 }



//       Expression x1 = new Expression();  
//       Node r = x1.Infix2BT(infix2); 
//       Node[] pre = x1.PrintPrefix();
//       Node[] pos = x1.PrintPostfix();
//       for(int i = 0; i < pre.length ; i++){
//         System.out.println(pre[i].getValue());
//        }
//       
//       for(int i = 0; i < pos.length ; i++){
//         System.out.println(pos[i].getValue());
//        }
//      System.out.println(x1.Evaluation());
       
      //  }
}

}


@c5c44ec29779a838b6bd4cdc251992ee@"
"r03228006","6","0.59","105616","@b4324ce2714126b9f4db1665726becdd@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
   private Node root;    // DO NOT MODIFY THIS
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        root=new Node(null,null,null);
        //System.out.println(root.getValue()==null);     
        size=0;
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        if(Parts.length<3){throw new NullPointerException();}
        int key=1;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        if (Parts.length==3){root.setValue(Parts[1]);return root;}
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){root=all[i-1];key=i-1;i--;}
        //if(ri==1){root.setValue(all[i-1].getValue());key=i-1;i--;}
        else{
          while(root.getValue()==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root=all[i];key=i;
                 //root.setValue(all[i].getValue());key=i;
                // break;
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        //System.out.println(size);
        
        if(root.getValue()==null){throw new NullPointerException();}
        //ArrayList<Node> pre = new ArrayList<Node>();
       // size=1;
       // Node test = root;
       // while(test.getLeft()!=null|test.getRight()!=null){
       //    while(test.getLeft().getLeft()!=null){test=test.getLeft(); size++;}
       //   size++;//the depest left
       //    while(test.getRight().getRight()!=null){test=test.getRight(); size++;}
       //    size++;
       // }
        Node[] prefix=new Node[size];
        int[] check = new int[size];
        //pre.add(root);
        prefix[0]=new Node(root.getLeft(),root.getRight(),root.getValue());
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)==2){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root.getValue()==null){throw new NullPointerException();}
        Node[] postfix=new Node[size];
        postfix[size-1]=new Node(root.getLeft(),root.getRight(),root.getValue());
        int[] check = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&(key-i)==2){
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else if (postfix[key].getLeft()!=null&(key-i)>=3&&check[key]==1){//root right
             postfix[i]=postfix[key].getLeft();
             check[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        if(root.getValue()==null){throw new NullPointerException();}
        Node[] postf= new Node[PrintPostfix().length];
        for (int i=0;i<postf.length;i++){postf[i]=new Node(null,null,PrintPostfix()[i].getValue());}
        //System.out.println(postfix.length);//to find +-*/
        for (int i =0;i<(postf.length);i++){
            if(postf[i].getValue().equals(""+"")|postf[i].getValue().equals(""-"")|postf[i].getValue().equals(""*"")|postf[i].getValue().equals(""/"")){
                int j = i-1;
                while(postf[j]==null){j--;}
                Double a = Double.parseDouble(postf[j].getValue());
                postf[j]=null;
                j--;
                while(postf[j]==null){j--;}
                Double b = Double.parseDouble(postf[j].getValue());
                postf[j]=null;
               if(postf[i].getValue().equals(""+"")){postf[i].setValue(Double.toString(b+a)); }
               if(postf[i].getValue().equals(""-"")){postf[i].setValue(Double.toString(b-a)); }
               if(postf[i].getValue().equals(""*"")){postf[i].setValue(Double.toString(b*a)); }
               if(postf[i].getValue().equals(""/"")){postf[i].setValue(Double.toString(b/a)); }
            }}
        double answer = Double.parseDouble(postf[postf.length-1].getValue());
       
        return answer;
    }
    
    
    	public static void main(String[] args) throws Exception{
		 try(BufferedReader br = new BufferedReader(new FileReader(""input9.txt""))){
			 String temp;
			 while((temp = br.readLine())!=null){
				 String[] split_temp=temp.split("" "");
				 for(String input:split_temp){
//                                         String[] Parts = input.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
//                                         System.out.println(""Input: "");
//					 for(int i = 0 ; i<Parts.length;i++){
//						 System.out.println(Parts[i]);
//					 }
					 Expression e = new Expression();
					 Node n = e.Infix2BT(input);			 
					 Node[] pre = e.PrintPrefix();
					 Node[] post = e.PrintPostfix();
					 double answer = e.Evaluation();
					 System.out.println(""PrintPrefix: "");
					 for(int i = 0 ; i<pre.length;i++){
						 System.out.println(pre[i].getValue());
					 }
					 System.out.println("""");
					 System.out.println(""PrintPostfix: "");
					 for(int i = 0 ; i<post.length;i++){
						 System.out.println(post[i].getValue());
					 }
					 System.out.println("""");
					 System.out.println(""Evaluation(): "");
					 System.out.println(answer);
					 System.out.println("""");
				 }
			 }
		 }	
	}
    
    
//    public static void main(String[] args) throws Exception {
//       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
//       
//       //String infix = ""((20120224791*(121259+797912))+(211544771212/2))"";
//       //String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
//       //Node[] all = new Node[Parts.length];
//       String[] infix = new String[]{""((20120224791*(121259+797912))+(211544771212/2))"",""(((1.23-(121259+797912))*(21212+213135498))/32349)"",""((1312.1+((5.132*323.13)/(131313.12+464588)))""};
//       String infix2 = ""(4+(((4*2)/2)/3))"";
//// for (int j =0;j<3;j++){
//       Expression e = new Expression();
//       Node n = e.Infix2BT(infix2);			 
//       Node[] pre = e.PrintPrefix();
//       Node[] post = e.PrintPostfix();
//					 double answer = e.Evaluation();
//					 System.out.println(""PrintPrefix: "");
//					 for(int i = 0 ; i<pre.length;i++){
//						 System.out.println(pre[i].getValue());
//					 }
//					 System.out.println("""");
//					 System.out.println(""PrintPostfix: "");
//					 for(int i = 0 ; i<post.length;i++){
//						 System.out.println(post[i].getValue());
//					 }
//


//       Expression x1 = new Expression();  
//       Node r = x1.Infix2BT(infix2); 
//       Node[] pre = x1.PrintPrefix();
//       Node[] pos = x1.PrintPostfix();
//       for(int i = 0; i < pre.length ; i++){
//         System.out.println(pre[i].getValue());
//        }
//       
//       for(int i = 0; i < pos.length ; i++){
//         System.out.println(pos[i].getValue());
//        }
//      System.out.println(x1.Evaluation());
       
      //  }
}




@b4324ce2714126b9f4db1665726becdd@"
"r03228006","6","0.58","104096","@326a022f92e4c0a6c13c99b8b671c77f@import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Arrays;

public class Expression{
  
   private Node root;    // DO NOT MODIFY THIS
   private int size;
   
    public Expression(){}

    // Build a Binary and Return the Root
    public Node Infix2BT(String infix){
    //public String[] Infix2BT(String infix){
        root=new Node(null,null,null);
        //System.out.println(root.getValue()==null);     
        size=0;
        String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
        int N = Parts.length;
        if(Parts.length<3){throw new NullPointerException();}
        int key=1;
        Node[] all = new Node[N];
        for(int i = 0; i<N; i++){
            all[i]=new Node(null,null,Parts[i]);
            if(!Parts[i].equals(""("")&!Parts[i].equals("")"")){size++;}
        }
        if (Parts.length==3){root.setValue(Parts[1]);return root;}
        int i = N-2; // N<2
        int ri = 1;//right
        int le = 0;
        while(Parts[i].equals("")"")){ // to find how many right )
             ri++;i--;}
        //System.out.println(ri);
        //System.out.println(root==null);
        if(ri==1){root=all[i-1];key=i-1;i--;}
        //if(ri==1){root.setValue(all[i-1].getValue());key=i-1;i--;}
        else{
          while(root.getValue()==null){//to find root
              if(Parts[i].equals(""("")){le++;}
              i--;
              if(le==(ri-1)){
                 while(Parts[i].equals(""("")){i--;}
                 //System.out.println(i);
                 root=all[i];key=i;
                 //root.setValue(all[i].getValue());key=i;
                // break;
              }
          }}
        
        while(true){
            //System.out.println(all[key].getLeft()==null);
            //System.out.println(key);
            //System.out.println(all[key].getRight()==null);
            if(all[key].getLeft()==null){//i=key-1
               //System.out.println(all[i].getValue());
               ri=0;
               le=0;
               i=key-1;
               while(all[i].getValue().equals("")"")){ri++;i--;}//end i at ) -1 or key-1
               //System.out.println(ri==0);
               if(ri==0){all[key].setLeft(all[i]);}//end i at the key-1(left hand)
                 else if(ri==1){all[key].setLeft(all[i-1]);i--;}//end i at left hand
                 else if(ri>1){
                   while(ri>le+1){
                     if(all[i].getValue().equals(""("")){
                         le++;i--;}
                     else {i--;}//end i at the left)
                   }
                   all[key].setLeft(all[i]);//end i at the left hand
                 }
               String xl =all[key].getLeft().getValue();
               if(xl.equals(""+"")|xl.equals(""*"")|xl.equals(""-"")|xl.equals(""/"")){key=i;}
               //System.out.println(key);
            }
            
            else if(all[key].getRight()==null){//after having left but no right(左樹優先)
                ri=0;le=0;i=key+1;//i is the right position
                while(all[i].getValue().equals(""("")){le++;i++;}//end i at ( +1 or key+1
                //System.out.println(le);
                if(le==0){all[key].setRight(all[i]);}//end i at the key-1(R hand)
                 else if(le==1){all[key].setRight(all[i+1]);key=i+1;i++;}//end i at R hand
                 else if(le>1){
                   while(le>ri+1){
                     if(all[i].getValue().equals("")"")){ri++;i++;}//end i at the R h)
                     else{i++;} // go right
                   }
                   all[key].setRight(all[i]);
                   key=i;//end i at the R hand
                 }
            }
            else {
                //System.out.println(all[key].getValue());
                //System.out.println(all[key].getRight().getValue());
                //System.out.println(""else"");
                key=key+1;
                //System.out.println((!(xv.equals(""+"")|xv.equals(""*"")|xv.equals(""-"")|xv.equals(""/"")))&(i<(N-1)));
                while((!(all[key].getValue().equals(""+"")|all[key].getValue().equals(""*"")|all[key].getValue().equals(""-"")|all[key].getValue().equals(""/"")))&(key<(N-1)))
                {key=key+1;}
                //System.out.println(key);}//to find +-*/
            if(key>=(N-1)){break;}
            //System.out.println(key);
            }}
        return root;
      }

    public Node[] PrintPrefix(){
        //System.out.println(size);
        
        if(root.getValue()==null|root==null){throw new NullPointerException();}
        //ArrayList<Node> pre = new ArrayList<Node>();
       // size=1;
       // Node test = root;
       // while(test.getLeft()!=null|test.getRight()!=null){
       //    while(test.getLeft().getLeft()!=null){test=test.getLeft(); size++;}
       //   size++;//the depest left
       //    while(test.getRight().getRight()!=null){test=test.getRight(); size++;}
       //    size++;
       // }
        Node[] prefix=new Node[size];
        int[] check = new int[size];
        //pre.add(root);
        prefix[0]=root;
        int i=1;
        int key=0;
        while(true){
          if(prefix[key].getLeft()!=null&(i-key)==1){
             prefix[i]=prefix[key].getLeft();
             if(prefix[key].getRight()!=null){check[key]=1;}
             key=i;i++;//2 3
          }//no left
          else if (prefix[key].getRight()!=null&&(i-key)>=2&&check[key]==1){
             prefix[i]=prefix[key].getRight();
             check[key]=0;
             key=i;i++;
          }
//          else if (prefix[key].getRight()!=null&&(i-key)>=3&&check[key]==1){
//             prefix[i]=prefix[key].getRight();
//             check[key]=0;
//             key=i;i++;
//          }
          else{key=key-1;}//1 3
          if(i==size){break;}
        }
        return prefix;
    }
  
    public Node[] PrintPostfix(){
        if(root.getValue()==null|root==null){throw new NullPointerException();}
        Node[] postfix=new Node[size];
        postfix[size-1]=root;
        int[] check2 = new int[size];
        int i=size-2;
        int key=size-1;
        while(true){
            
          if(postfix[key].getRight()!=null&(key-i)==1){
             postfix[i]=postfix[key].getRight();
             if(postfix[key].getLeft()!=null){check2[key]=1;}
             key=i;i--;}//no left
  
          else if (postfix[key].getLeft()!=null&&(key-i)>=2&&check2[key]==1){
             postfix[i]=postfix[key].getLeft();
             check2[key]=0;
             key=i;i--;
          }
          else{key=key+1;}//1 3
          if(i==-1){break;}
        }
        return postfix;
    }

    public double Evaluation(){
        if(root.getValue()==null|root==null){throw new NullPointerException();}
        Node[] postf= new Node[PrintPostfix().length];
        for (int i=0;i<postf.length;i++){postf[i]=new Node(null,null,PrintPostfix()[i].getValue());}
        //System.out.println(postfix.length);//to find +-*/
        for (int i =0;i<(postf.length);i++){
            if(postf[i].getValue().equals(""+"")|postf[i].getValue().equals(""-"")|postf[i].getValue().equals(""*"")|postf[i].getValue().equals(""/"")){
                int j = i-1;
                while(postf[j]==null&j>0){j--;}
                Double a = Double.parseDouble(postf[j].getValue());
                postf[j]=null;
                j--;
                while(postf[j]==null&j>0){j--;}
                Double b = Double.parseDouble(postf[j].getValue());
                postf[j]=null;
               if(postf[i].getValue().equals(""+"")){postf[i].setValue(Double.toString(b+a)); }
               if(postf[i].getValue().equals(""-"")){postf[i].setValue(Double.toString(b-a)); }
               if(postf[i].getValue().equals(""*"")){postf[i].setValue(Double.toString(b*a)); }
               if(postf[i].getValue().equals(""/"")){postf[i].setValue(Double.toString(b/a)); }
            }}
        double answer = Double.parseDouble(postf[postf.length-1].getValue());
       
        return answer;
    }
    
    
    	public static void main(String[] args) throws Exception{
		 try(BufferedReader br = new BufferedReader(new FileReader(""input9.txt""))){
			 String temp;
			 while((temp = br.readLine())!=null){
				 String[] split_temp=temp.split("" "");
				 for(String input:split_temp){
//                                         String[] Parts = input.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
//                                         System.out.println(""Input: "");
//					 for(int i = 0 ; i<Parts.length;i++){
//						 System.out.println(Parts[i]);
//					 }
					 Expression e = new Expression();
					 Node n = e.Infix2BT(input);			 
					 Node[] pre = e.PrintPrefix();
					 Node[] post = e.PrintPostfix();
					 double answer = e.Evaluation();
					 System.out.println(""PrintPrefix: "");
					 for(int i = 0 ; i<pre.length;i++){
						 System.out.println(pre[i].getValue());
					 }
					 System.out.println("""");
					 System.out.println(""PrintPostfix: "");
					 for(int i = 0 ; i<post.length;i++){
						 System.out.println(post[i].getValue());
					 }
					 System.out.println("""");
					 System.out.println(""Evaluation(): "");
					 System.out.println(answer);
					 System.out.println("""");
                                         System.out.println(Double.parseDouble(""8210000000000000000""));
                                         
				 }
			 }
		 }	
	}
    
    
//    public static void main(String[] args) throws Exception {
//       //System.out.println(Arrays.toString(""(4+(((4*2)/2)/3))"".split(""[+\\*\\-\\/\\(\\})]"")));
//       
//       //String infix = ""((20120224791*(121259+797912))+(211544771212/2))"";
//       //String[] Parts = infix.split(""((?<=[+\\*\\-\\/\\(\\})])|(?=[+\\*\\-\\/\\(\\})]))"");
//       //Node[] all = new Node[Parts.length];
//       String[] infix = new String[]{""((20120224791*(121259+797912))+(211544771212/2))"",""(((1.23-(121259+797912))*(21212+213135498))/32349)"",""((1312.1+((5.132*323.13)/(131313.12+464588)))""};
//       String infix2 = ""(4+(((4*2)/2)/3))"";
//// for (int j =0;j<3;j++){
//       Expression e = new Expression();
//       Node n = e.Infix2BT(infix2);			 
//       Node[] pre = e.PrintPrefix();
//       Node[] post = e.PrintPostfix();
//					 double answer = e.Evaluation();
//					 System.out.println(""PrintPrefix: "");
//					 for(int i = 0 ; i<pre.length;i++){
//						 System.out.println(pre[i].getValue());
//					 }
//					 System.out.println("""");
//					 System.out.println(""PrintPostfix: "");
//					 for(int i = 0 ; i<post.length;i++){
//						 System.out.println(post[i].getValue());
//					 }
//


//       Expression x1 = new Expression();  
//       Node r = x1.Infix2BT(infix2); 
//       Node[] pre = x1.PrintPrefix();
//       Node[] pos = x1.PrintPostfix();
//       for(int i = 0; i < pre.length ; i++){
//         System.out.println(pre[i].getValue());
//        }
//       
//       for(int i = 0; i < pos.length ; i++){
//         System.out.println(pos[i].getValue());
//        }
//      System.out.println(x1.Evaluation());
       
      //  }
}




@326a022f92e4c0a6c13c99b8b671c77f@"
